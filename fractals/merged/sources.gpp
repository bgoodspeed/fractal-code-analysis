// -*- mode: c++ -*-
// $Id: ackermann.gpp,v 1.1 2004-11-07 22:41:41 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/

#include <iostream>
#include <stdlib.h>

using namespace std;

int Ack(int M, int N) { return(M ? (Ack(M-1,N ? Ack(M,(N-1)) : 1)) : N+1); }

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    cout << "Ack(3," << n << "): " << Ack(3, n) << endl;
    return(0);
}
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Fredrik Fornwall
*/
#include <cstdlib>
#include <iostream>
using namespace std;

template <int M> int Ack(int N) { return Ack<M-1>(N ? Ack<M>(N-1) : 1); }
template<> int Ack<0>(int N) { return N + 1; }

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    cout << "Ack(3," << n << "): " << Ack<3>(n) << endl;
    return 0;
}
// -*- mode: c++ -*-
// $Id: ary.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    typedef vector<int> ARY;
    ARY x(n);
    ARY y(n);

    for (int i=0; i<n; i++) {
	x[i] = i + 1;
    }
    for (int k=0; k<1000; k++) {
	for (int i = n - 1; i >= 0; --i) {
	    y[i] += x[i];
	}
    }

    cout << y[0] << " " << y.back() << endl;
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Jon Harrop
 * Modified by Alex Mizrahi
 */

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

struct Node {
  Node *l, *r;
  int i;
  Node(int i2) : l(0), r(0), i(i2) {}
  Node(Node *l2, int i2, Node *r2) : l(l2), r(r2), i(i2) {}
  ~Node() { delete l; delete r; }
  int check() const {
	  if (l)
		return l->check() + i - r->check(); 
	  else return i;
  }
};

Node *make(int i, int d) {
  if (d == 0) return new Node(i);
  return new Node(make(2*i-1, d-1), i, make(2*i, d-1));
}

int main(int argc, char *argv[]) {
  int min_depth = 4,
    max_depth = std::max(min_depth+2,
			 (argc == 2 ? atoi(argv[1]) : 10)),
    stretch_depth = max_depth+1;

  {
    Node *c = make(0, stretch_depth);
    std::cout << "stretch tree of depth " << stretch_depth << "\t "
      << "check: " << c->check() << std::endl;
    delete c;
  }

  Node *long_lived_tree=make(0, max_depth);

  for (int d=min_depth; d<=max_depth; d+=2) {
    int iterations = 1 << (max_depth - d + min_depth), c=0;
    for (int i=1; i<=iterations; ++i) {
      Node *a = make(i, d), *b = make(-i, d);
      c += a->check() + b->check();
      delete a;
      delete b;
    }
    std::cout << (2*iterations) << "\t trees of depth " << d << "\t "
	      << "check: " << c << std::endl;
  }

  std::cout << "long lived tree of depth " << max_depth << "\t "
	    << "check: " << (long_lived_tree->check()) << "\n";

  delete long_lived_tree;

  return 0;
}

/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Jon Harrop
 * modified by Alex Mizrahi
 * modified by Andreas SchÃ¤fer
 * very minor omp tweak by The Anh Tran
 */

#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <omp.h>

#include <boost/pool/object_pool.hpp>


const size_t	LINE_SIZE = 64;


struct Node 
{
    Node *l, *r;
    int i;
    
    Node(int i2) : l(0), r(0), i(i2) 
    {}
    Node(Node *l2, int i2, Node *r2) : l(l2), r(r2), i(i2) 
    {}

    int check() const 
    {
        if (l)
            return l->check() + i - r->check();
        else return i;
    }
};

typedef boost::object_pool<Node> NodePool;


Node *make(int i, int d, NodePool &store) 
{
    if (d > 0) 
	    return store.construct(	make(2*i-1, d-1, store), 
	    						i, 
	    						make(2*i, d-1, store)	);
   	return store.construct(i);
}

int GetThreadCount()
{
	cpu_set_t cs;
	CPU_ZERO(&cs);
	sched_getaffinity(0, sizeof(cs), &cs);

	int count = 0;
	for (int i = 0; i < 8; i++)
	{
		if (CPU_ISSET(i, &cs))
			count++;
	}
	return count;
}

int main(int argc, char *argv[]) 
{
    int min_depth = 4;
    int max_depth = std::max(min_depth+2,
                             (argc == 2 ? atoi(argv[1]) : 10));
    int stretch_depth = max_depth+1;

	// Alloc then dealloc stretchdepth tree
    {
        NodePool store;
        Node *c = make(0, stretch_depth, store);
        std::cout << "stretch tree of depth " << stretch_depth << "\t "
                  << "check: " << c->check() << std::endl;
    }

    NodePool long_lived_store;
    Node *long_lived_tree = make(0, max_depth, long_lived_store);

	// buffer to store output of each thread
	char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));

	#pragma omp parallel for default(shared) num_threads(GetThreadCount()) schedule(dynamic, 1)
    for (int d = min_depth; d <= max_depth; d += 2) 
    {
        int iterations = 1 << (max_depth - d + min_depth);
        int c = 0;

        for (int i = 1; i <= iterations; ++i) 
        {
            NodePool store;
            Node *a = make(i, d, store), *b = make(-i, d, store);
            c += a->check() + b->check();
        }

		// each thread write to separate location
		sprintf(outputstr + LINE_SIZE * d, "%d\t trees of depth %d\t check: %d\n", (2 * iterations), d, c);
	}

	// print all results
	for (int d = min_depth; d <= max_depth; d += 2) 
		printf("%s", outputstr + (d * LINE_SIZE) );
	free(outputstr);

    std::cout << "long lived tree of depth " << max_depth << "\t "
              << "check: " << (long_lived_tree->check()) << "\n";

    return 0;
}

/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * Contributed by Branimir Maksimovic
 * should be linked with -lpthread
 */

#include <pthread.h>
#include <iostream>
#include <ostream>
using namespace std;

#define arrLen(arr) (sizeof arr / sizeof arr[0])

enum Colour { blue, red, yellow, faded };

class MeetingPlace
{
private:
 Colour first, second;
 bool firstCall;
 bool mustWait;
 int n;
 pthread_cond_t monitor;
 pthread_mutex_t mlock;

public:
MeetingPlace(int maxMeetings)
: firstCall(true),mustWait(false),n(maxMeetings)
{
  pthread_cond_init(&monitor,0);
  pthread_mutex_init(&mlock,0);
}

Colour OtherCreaturesColour(Colour me)
{
    pthread_mutex_lock(&mlock);
    Colour other;

    while (mustWait)
    {
      pthread_cond_wait(&monitor,&mlock);
    }

    if (firstCall)
    {
      if (n-- > 0)
      {
        first = me;
        firstCall = false;

        while (!firstCall)
        {
          pthread_cond_wait(&monitor,&mlock);
        }
        mustWait = false;
        other = second;
      }
      else
      {
        other = faded;
      }
    }
    else
    {
      second = me;
      other = first;
      firstCall = true;
      mustWait = true;
    }

    pthread_cond_broadcast(&monitor);
    pthread_mutex_unlock(&mlock);
    return other;
}
~MeetingPlace()
{
  pthread_cond_destroy(&monitor);
  pthread_mutex_destroy(&mlock);
}
private:
MeetingPlace(const MeetingPlace&);
MeetingPlace& operator=(const MeetingPlace&);
};

class Creature
{
private:
  MeetingPlace* m;
  int creaturesMet_;
  Colour me;

public:
  Creature(MeetingPlace* m_, Colour c)
  :m(m_),creaturesMet_(0),me(c)
  {
  }

  void Be()
  {
    while(me != faded){ MeetOtherCreature(); }
  }

  void MeetOtherCreature()
  {
    Colour other = m->OtherCreaturesColour(me);
    if (other == faded)
    {
      me = other;
    }
    else
    {
      creaturesMet_++;
      me = Complement(other);
    }
  }
  Colour Complement(Colour other)
  {
    if (me == other) return me;
    switch(me)
    {
      case blue:
            return other == red ? yellow : red;
      case red:
            return other == blue ? yellow : blue;
      case yellow:
            return other == blue ? red : blue;
      default: return me;
    }
   }
   int creaturesMet()const { return creaturesMet_; }
};

static Colour colours []= { blue, red, yellow, blue };
static Creature* creatures[arrLen(colours)];
static pthread_t threads[arrLen(colours)];

extern "C" void* thread_run(void* c)
{
  ((Creature*)c)->Be();
  return 0;
}

int main(int argc,char*argv[])
{
  if(argc<2)return 0;
  int n = atoi(argv[1]);
  MeetingPlace m(n);

  for (unsigned i=0; i<arrLen(colours); i++)
  {
    creatures[i] = new Creature(&m,colours[i]);
    pthread_create(&threads[i],0,thread_run,creatures[i]);
  }

  for(unsigned i =0; i<arrLen(colours); i++)
    pthread_join(threads[i],0);

  int meetings = 0;
  for(unsigned i=0;i<arrLen(colours);i++)
  {
    meetings += creatures[i]->creaturesMet();
    delete creatures[i];
  }

  cout<<meetings<<'\n';
  return 0;
}
/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/

Based on original C contribution by Alex Burlyga.
Based on thread pool + request queue in Java contribution by Michael Barker.
Based on single atomic ops, and pthread affinity in C contribution by Dmitry Vyukov.
Based on C++ contribution by Andrew Moon.
Contributed by The Anh Tran.

This entry creates N kernel threads. All threads will wait inside 
boost::asio::io_service queue object. If there is a request posted to io_service 
queue, a thread will be dispatched to handle it.

Each creature will submit "i want to go to meeting place" request to io_service.
Atomic compare-and-set is used to change meeting place state.
*/

#include <fstream>
#include <iostream>
#include <string>
#include <map>
#include <sstream>

#include <cstdlib>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <memory.h>

#include <pthread.h>
#include <sched.h>

#include <boost/xpressive/xpressive_static.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/bind.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/foreach.hpp>

#define foreach BOOST_FOREACH



typedef unsigned int uint;
typedef boost::asio::io_service QUEUE_T;


#define CPU_INFO_STR   "/proc/cpuinfo"
#define L2_ALIGN      __attribute__((aligned(16)))

enum COLOR {   BLUE = 0,   RED = 1,   YELLOW = 2   };
COLOR 
operator ^ (COLOR c1, COLOR c2)
{
   switch (c1)   // game rule
   {
   case BLUE:   switch (c2)
            {
            case BLUE:      return BLUE;
            case RED:      return YELLOW;
            case YELLOW:   return RED;
            }

   case RED:   switch (c2)
            {
            case BLUE:      return YELLOW;
            case RED:      return RED;
            case YELLOW:   return BLUE;
            }

   case YELLOW:   switch (c2)
            {
            case BLUE:      return RED;
            case RED:      return BLUE;
            case YELLOW:   return YELLOW;
            }
   }

   assert(false);
   return BLUE;
}


std::ostream& 
operator << (std::ostream &os, COLOR c) 
{   
   static char const * ColorName[3]   = {"blue", "red", "yellow"};
   os << ColorName[c];
   return os;
}


std::string
SpellNumber(uint n)
{
   static char const* NumberStr[] = 
   {
      "zero ", "one ", "two ", "three ", "four ",
      "five ", "six ", "seven ", "eight ", "nine "
   };
   
   std::string num;
   
   while ( n >= 10 )
   {
      uint m = n % 10;
      n /= 10;

      num.insert(0, NumberStr[m]);
   }

   num.insert(0, NumberStr[n]);
   return num;
}

/*   Place where a creature meet another.
   stage_exchange stores 2 informations:
   _ how many meeting times to go. 28 bit from bit 0 -> 27.
   _ is there any creature waiting. 4 highest bit, 28 -> 31
*/
struct MeetingPlace
{
private:
   L2_ALIGN
   uint volatile   state_exchange_;

public:
   MeetingPlace(uint N) :   state_exchange_(N)   {   }

/*
   State_exchange = 32 bit
   4 bit MSB: id of creature which is waiting. Can support up to 15 creatures.
   28 bit: counter of how many meeting times that needs to run
*/
   int EnterMeetingRoom( uint cr_id )   // id starts from 1.
   {
      while (true)
      {
         uint old_state = state_exchange_;
         uint meeting_left = old_state & 0x0FFFFFFF;

         if (meeting_left > 0)
         {
            uint cr_waiting = old_state >> 28;
            uint new_state;

            if (cr_waiting == 0)   // no one inside, me is 1st
               new_state = meeting_left | (cr_id << 28);
            else   // there is a creature waiting
               new_state = meeting_left -1;

            if (__sync_bool_compare_and_swap(&state_exchange_, old_state, new_state))
               return cr_waiting;
         }
         else
            return -1;
      }
   }
};


struct Creature
{
   QUEUE_T*            p_queue_;
   MeetingPlace*         p_meetingplace_;
   Creature*            p_cr_list_;

   COLOR               color_;
   uint               count_;
   uint               id_;      // creature id start from 1
   uint               same_count_;

   Creature() : color_(BLUE), count_(0), id_(0), same_count_(0)   {}

   void 
   Start(   MeetingPlace* mp, COLOR color , uint id, 
         QUEUE_T* queue,  Creature* pcrl)
   {
      color_   = color;
      id_      = id +1;

      p_queue_      = queue;
      p_meetingplace_   = mp;
      p_cr_list_      = pcrl;

      // post "go to meeting place" request
      p_queue_->post(boost::bind(&Creature::PlayGame, this));
   }

   // request granted, meeting action executes here
   void 
   PlayGame()   
   {   
      int other_cr_id = p_meetingplace_->EnterMeetingRoom(id_);

      // meeting_place returns other creature?
      if (other_cr_id > 0)
         SayHello( p_cr_list_[other_cr_id -1] );

      // if me is the 1st one entering meeting_place, do nothing. 
      // 2nd arrival creature will submit next meeting request for me.
   }

   void 
   SayHello(Creature &other)
   {
      if (__builtin_expect(id_ == other.id_, false))
      {
         ++same_count_;
         ++other.same_count_;
      }
      
      ++count_;
      ++other.count_;

      COLOR new_color   = this->color_ ^ other.color_;
      other.color_   = color_   = new_color;

      // submit another meeting request, for current creature + other creature.
      p_queue_->post(boost::bind(&Creature::PlayGame, this));
      p_queue_->post(boost::bind(&Creature::PlayGame, &other));
   }
} L2_ALIGN;



template <int ncolor>
struct Game
{
   MeetingPlace   mplace;
   QUEUE_T         queue;
   Creature      cr_list[ncolor];   // list of all creatures

   std::ostringstream   game_output;
   boost::thread_group   cr_thread_group;         // 1 standard OS thread for each creature

   Game(uint n, COLOR const (&color)[ncolor], cpu_set_t * aff = 0)   
      :   mplace(n)   
   {
      boost::format fmt("%1% ");
      
      // print initial color of each creature
      for (int i = 0; i < ncolor; ++i)
      {
         game_output << (fmt % (color[i]) );
         cr_list[i].Start( &mplace, color[i], i, &queue, cr_list );
      }
      game_output << std::endl;

      // Create N kernel threads. All threads will wait inside boost::asio::io_service
      // queue object. If there is a request posted to io_service queue, a thread
      // will be dispatched to handle it.
      for (int i = 0; i < ncolor; ++i)
      {
         boost::thread* t = cr_thread_group.create_thread(boost::bind(&QUEUE_T::run, &queue));
      
         if(aff != 0)
            pthread_setaffinity_np(t->native_handle(), sizeof(cpu_set_t), aff);
      }
   }

   std::string
   WaitAndGetResult()
   {
      // wait until meeting times = 0
      cr_thread_group.join_all();

      uint total = 0;
      boost::format fmt("%1% %2%\n");

      // print meeting times of each creature
      for (int i = 0; i < ncolor; i++)
      {
         total += cr_list[i].count_;
         game_output << (fmt 
                     % cr_list[i].count_ 
                     % SpellNumber(cr_list[i].same_count_)   );
      }

      // print total meeting times
      fmt = boost::format(" %1%\n\n");
      game_output << (fmt % SpellNumber(total));

      return game_output.str();
   }
};

void 
PrintColors()
{
   boost::format fmt("%1% + %2% -> %3%\n");
   
   for (int c1 = BLUE; c1 <= YELLOW; ++c1)
   {
      for (int c2 = BLUE; c2 <= YELLOW; ++c2)
         std::cout << (fmt % (COLOR)c1 % (COLOR)c2 % ((COLOR)c1 ^ (COLOR)c2));
   }

   std::cout << std::endl;
}

// Detect multi / single thread benchmark
int 
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < 16; ++i)
   {
      if (CPU_ISSET(i, &cs))
         ++count;
   }
   return count;
}

// Parse /proc/cpuinfo
// Return a list of cpu cores sharing 1 L2 cache
std::auto_ptr<std::vector<cpu_set_t> >
GetAffinityList()
{
   std::ifstream file(CPU_INFO_STR);
   std::istreambuf_iterator<char> is(file), ise;

   // load file to vector<char>
   std::vector<char> buf;
   std::copy(is, ise, std::back_inserter(buf));
   file.close();
   

   // map processors to L2 cache unit
   typedef std::map<int, cpu_set_t> MAP_T;
   MAP_T l2_set;

   {
      using namespace boost::xpressive;
      namespace bx = boost::xpressive;

      typedef std::vector<char>::iterator      VI_T;
      typedef bx::basic_regex<VI_T>         RE_T;
      typedef bx::regex_iterator<VI_T>      IRE_T;

      RE_T re(
         as_xpr("processor") >> +(_s|':') >> (s1 = +_d)
         >> -+(~_n|_n)
         >> "apicid" >> +(_s|':') >> (s2 = +_d) );

      IRE_T it(buf.begin(), buf.end(), re), it_end;

      for (; it != it_end; ++it)
      {
         int core = boost::lexical_cast<int>( (*it)[1].str() );
         int apic = boost::lexical_cast<int>( (*it)[2].str() );
         
         // q6600 has 4 cores, 2 cores share 1 L2 cache
         // 2 cores + 1 L2 = 1 package
         int package = apic >> 1;

         CPU_SET(core, &(l2_set[package]));
      }
   }

   std::auto_ptr<std::vector<cpu_set_t> > aff(new std::vector<cpu_set_t>);
   typedef MAP_T::value_type VT;

   foreach ( VT &i, l2_set )
      aff->push_back(i.second);

   return aff;
}


int 
main(int argc, char** argv)
{
   PrintColors();

   COLOR const r1[] = {   BLUE, RED, YELLOW   };
   COLOR const r2[] = {   BLUE, RED, YELLOW, RED, YELLOW, BLUE, RED, YELLOW, RED, BLUE   };
   
   int n = (argc >= 2) ? boost::lexical_cast<int>(argv[1]) : 600;
   
   if (GetThreadCount() > 1)
   {
      std::auto_ptr<std::vector<cpu_set_t> > affset( GetAffinityList() );

      Game<3> cg1( n, r1, &((*affset)[0]) );
      Game<10> cg2( n, r2, &((*affset)[1]) );
      
      std::cout << cg1.WaitAndGetResult();
      std::cout << cg2.WaitAndGetResult();
   }
   else
   {
      Game<3> cg1( n, r1 );
      std::cout << cg1.WaitAndGetResult();

      Game<10> cg2( n, r2 );
      std::cout << cg2.WaitAndGetResult();
   }

   return 0;
}
/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/

Based on C contribution by Alex Burlyga
Based on Java contribution by Michael Barker
Based on the original C++ contribution by The Anh Tran 
Based on the #5 C contribution by Dmitry Vyukov 
Contributed & Modified by Andrew Moon

Each chameneous creature is a standard OS thread.
Data exchange mechanism is gcc built-in atomic ops.
*/


#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

struct CPUs {
   enum { perslot = 2 };
   CPUs() {
      for ( int i = 0; i < 33; i++ )
         CPU_ZERO( &affinities[i] );
      cpu_set_t &cs = affinities[0];
      sched_getaffinity( 0, sizeof(cs), &cs );

      count = 0;
      for ( int i = 0; i < CPU_SETSIZE; i++ ) {
         if ( CPU_ISSET( i, &cs ) ) {
            CPU_SET( i, &affinities[(count / perslot) + 1] );
            count++;
         }
      }
      mod = ( count > 2 ) ? count >> 1 : 1;
   }
   
   cpu_set_t *getaffinity( int slot ) { 
      return &affinities[ slot ? ( slot % mod ) + 1 : 0 ]; 
   }

   int count, mod;
   cpu_set_t affinities[33]; // up to 64 cores!
} cpus;

// kludge to make running on a single core at least SOMEWHAT performant
struct SingleCoreYield {
   SingleCoreYield() : counter(0) {}
   void Run() {
      if ( cpus.count <= 1 || counter++ > 20000 ) {
         sched_yield();
         counter = 0;
      }
   }

protected:
   int counter;
};

enum Color { blue = 0, red, yellow, Invalid };

// stream operator to write a color
ostream &operator<< ( ostream &s, const Color &c ) {
   static const char *names[] = { "blue", "red", "yellow", "Invalid" };
   s << names[c];
   return s;
}

// +operator to add colors
Color operator+( const Color &c1, const Color &c2 ) {
   switch ( c1 ) {
      case blue: switch ( c2 ) {
         case blue:   return blue;
         case red:    return yellow;
         case yellow: return red;
         default:;
      }
      case red: switch ( c2 ) {
         case blue:   return yellow;
         case red:    return red;
         case yellow: return blue;
         default:;
      }
      case yellow: switch ( c2 ) {
         case blue:   return red;
         case red:    return blue;
         case yellow: return yellow;
         default:;
      }
      default:;
   }
   return Invalid;
}


// spells out a number as named digits
string SpellNumber( int n ) {
   static const char *numbers[] = {
      " zero", " one", " two",
      " three", " four", " five",
      " six", " seven", " eight",
      " nine"
   };

   string str;
   do {
      str.insert( 0, numbers[n % 10] );
      n /= 10;
   } while ( n );

   return str;
}

struct MeetingPlace;

struct Creature {
   Creature() : id(0), count(0), sameCount(0), met(false) {}

   // output our total visits and self visits, returning total visits
   int Display() const {
      cout << count << SpellNumber(sameCount) << endl;
      return count;
   }

   void Meet( Creature *other ) {
      if ( id == other->id ) {
         sameCount++;
         other->sameCount++;
      }

      count++;
      other->count++;

      Color newcolor = color + other->color;
      other->color = color = newcolor;
      other->met = true;
   }

   void Init( MeetingPlace *mp, Color c );
   void Run();

   void Start( int affinity = 0 ) {
      pthread_attr_init( &threadAttr );
      if ( cpus.count >= 4 ) {
         cpu_set_t *cores = cpus.getaffinity( affinity );
         pthread_attr_setaffinity_np( &threadAttr, sizeof(cpu_set_t), cores );
      }
      pthread_create( &threadHandle, &threadAttr, &Creature::ThreadRun, this );
   }

   static void *ThreadRun( void *param ) {
      ((Creature*)param)->Run();
      return 0;
   }

   void Wait() const {
      pthread_join( threadHandle, NULL );
   }

   void WaitUntilMet() {
      SingleCoreYield yield;
      while ( !met )
         yield.Run();
      met = false;
   }

   int id, count, sameCount;
   volatile bool met; // met is set from other threads, don't cache in a register
   Color initialColor, color;

protected:
   pthread_t threadHandle;
   pthread_attr_t threadAttr;
   MeetingPlace *place;
};

struct MeetingPlace {
   // max # of creatures is ( 1 << S ) - 1, max # of meetings is ( 1 << ( 32 - S ) ) - 1
   enum { S = 4, creatureMask = (1 << S) - 1 };
   MeetingPlace( int N ) : state(N << S), idGenerator(1) { creatures = new Creature *[N]; }
   ~MeetingPlace() { delete[] creatures; }
   
   void Register( Creature &creature ) {
      creature.id = idGenerator++;
      creatures[creature.id] = &creature;
   }

   void MeetUp( Creature *creature ) {
      int useState = state;
      while ( true ) {
         int waiting = useState & creatureMask, tryState = 0;
         if ( waiting )
            // there's a waiting creature, set the new state to meetingCount - 1
            tryState = ( ( useState & ~creatureMask ) - ( 1 << S ) );
         else if ( useState )
            // nobody waiting and meetings left, set ourselves to the waiting creature
            tryState = useState | creature->id;
         else
            // nobody waiting and no meetings left, we're done
            return;

         int oldState = __sync_val_compare_and_swap( &state, useState, tryState );
         if ( oldState == useState ) {
            if ( waiting )
               creature->Meet( creatures[waiting] );
            else
               creature->WaitUntilMet();
            useState = state;
         } else {
            useState = oldState;
         }
      }
   }

protected:
   volatile int state; // state is read & set from other threads, don't cache in a register
   int idGenerator;
   Creature **creatures;
};



void Creature::Init( MeetingPlace *mp, Color c ) {
   place = mp;
   initialColor = color = c;
   place->Register( *this );
}

void Creature::Run() {
   place->MeetUp( this );
}


template< int ncolor >
struct Game {
   Game( int meetings, const Color (&color)[ncolor] ) : meetingPlace(meetings) {
      for ( int i = 0; i < ncolor; i++ )
         creatures[i].Init( &meetingPlace, color[i] );
   }
   
   void Start(  int affinity = 0 ) {
      for ( int i = 0; i < ncolor; i++ )
         creatures[i].Start( affinity );
   }

   void Wait() {
      for ( int i = 0; i < ncolor; i++ )
         creatures[i].Wait();
   }

   void Display() {
      // display the initial color list
      for ( int i = 0; i < ncolor; i++ )
         cout << " " << creatures[i].initialColor;
      cout << endl;

      // output each creature and sum up the total visits
      int total = 0;
      for ( int i = 0; i < ncolor; i++ )
         total += creatures[i].Display();
      cout << SpellNumber(total) << endl << endl;
   }

protected:
   MeetingPlace meetingPlace;
   Creature creatures[ncolor];
};


int main( int argc, const char *argv[] ) {
   const Color r1[] = {
      blue, red, yellow
   };

   const Color r2[] = {
      blue, red, yellow,
      red, yellow, blue,
      red, yellow, red,
      blue
   };

   for ( int c1 = blue; c1 <= yellow; c1++ )
      for ( int c2 = blue; c2 <= yellow; c2++ )
         cout << r1[c1] << " + " << r1[c2] << " -> " << ( r1[c1] + r1[c2] ) << endl;
   cout << endl;

   int n = ( argc >= 2 ) ? atoi( argv[1] ) : 6000000;

   Game< 3> g1( n, r1 ); 
   Game<10> g2( n, r2 );
   if ( cpus.count < 4 ) {
      g1.Start(); g1.Wait();
      g2.Start(); g2.Wait();
   } else {
      g1.Start(1); g2.Start(2);
      g1.Wait(); g2.Wait();
   }
   g1.Display();
   g2.Display();
}
// -*- mode: c++ -*-
// $Id: echo.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>

using namespace std;

#define DATA "Hello there sailor\n"

void myabort (char *m) { fprintf(stderr, "%s\n", m); exit(1); }
void sysabort (char *m) { perror(m); exit(1); }

int sigchld = 0;
void reaper (int sig) { sigchld = 1; }

int server_sock ()
{
    int ss, optval = 1;
    struct sockaddr_in sin;
    if ((ss = socket(PF_INET, SOCK_STREAM, 0)) == -1)
	sysabort("server/socket");
    if (setsockopt(ss, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1)
	sysabort("server/setsockopt");
    memset(&sin,0,sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sin.sin_port = 0;
    if (bind(ss, (sockaddr *)&sin, sizeof(sin)) == -1)
	sysabort("server/bind");
    listen(ss, 2);
    return(ss);
}


int get_port (int sock)
{
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    if (getsockname(sock, (sockaddr *)&sin, &slen) == -1)
	sysabort("server/getsockname");
    return(sin.sin_port);
}    


int client_sock (int port)
{
    struct sockaddr_in sin;
    int sock;
    if ((sock = socket(PF_INET, SOCK_STREAM, 0)) == -1)
	sysabort("client/socket");
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sin.sin_port = port;
    if (connect(sock, (sockaddr *)&sin, sizeof(sin)) == -1)
	sysabort("client/connect");
    return(sock);
}


void echo_client (int n, int port)
{
    int len, nwritten, nread;
    char *offset, obuf[64], ibuf[64];
    char *end = ibuf + sizeof(ibuf);

    int sock = client_sock(port);
    strcpy(obuf, DATA);
    int olen = strlen(obuf);
    for (int i=0; i<n; i++) {
	len = olen;
	offset = obuf;
	while (len > 0) {
	    if ((nwritten = write(sock, offset, len)) == -1)
		sysabort("client/write");
	    offset += nwritten;
	    len -= nwritten;
	}
	offset = ibuf;
	while ((nread = read(sock, offset, (end - offset))) > 0) {
	    offset += nread;
	    if (*(offset-1) == '\n') break;
	}
	if (nread == -1)
	    sysabort("client/read");
	*offset = 0;
	if ((strcmp(obuf, ibuf)) != 0) {
	    char mbuf[128];
	    sprintf(mbuf, "client: \"%s\" ne \"%s\"", obuf, ibuf);
	    myabort(mbuf);
	}
    }
    close(sock);
}


void echo_server (int n)
{
    int csock, len, nwritten, total_bytes;
    pid_t pid;
    char buf[64], *offset;
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    int status;

    int ssock = server_sock();
    signal(SIGCHLD, reaper);
    if ((pid = fork()) == -1)
	sysabort("server/fork");
    if (pid) {
	/* parent is server */
	if ((csock = accept(ssock, (sockaddr *)&sin, &slen)) == -1)
	    sysabort("server/accept");
	total_bytes = 0;
	while ((len = read(csock, buf, sizeof(buf))) > 0) {
	    if (sigchld) myabort("server/sigchld");
	    offset = buf;
	    total_bytes += len;
	    while (len > 0) {
		if ((nwritten = write(csock, offset, len)) == -1)
		    sysabort("server/write");
		offset += nwritten;
		len -= nwritten;
	    }
	}
	if (len == -1)
	    sysabort("server/read");
	close(csock);
	fprintf(stdout, "server processed %d bytes\n", total_bytes);
    } else {
	/* child is client */
	echo_client(n, get_port(ssock));
    }
    wait(&status);
}


int main(int argc, char *argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    echo_server(n);
    return(0);
}
// -*- mode: c++ -*-
// $Id: except.gpp,v 1.1 2004-11-10 06:26:50 bfulgham Exp $
// http://shootout.alioth.debian.org/
// from Bill Lear

#include <iostream>
#include <cstdlib>
#include <cstdio>

using namespace std;

size_t HI = 0;
size_t LO = 0;

class Hi_exception {
public:
    explicit Hi_exception(size_t _n) : n(_n) {}
    const char* what() { sprintf(N, "%d", n); return N; }
private:
    size_t n; char N[8];
};

class Lo_exception {
public:
    explicit Lo_exception(size_t _n) : n(_n) {}
    const char* what() { sprintf(N, "%d", n); return N; }
private:
    size_t n; char N[8];
};

void blowup(size_t num) {
    if (num % 2) {
        throw Lo_exception(num);
    }
    throw Hi_exception(num);
}

void lo_function(size_t num) {
    try {
        blowup(num);
    } catch(const Lo_exception& ex) {
        ++LO;
    }
}

void hi_function(size_t num) {
    try {
        lo_function(num);
    } catch(const Hi_exception& ex) {
        ++HI;
    }
}

void some_function(size_t num) {
    try {
        hi_function(num);
    } catch (...) {
        cerr << "We shouldn't get here\n"; exit(1);
    }
}

int
main(int argc, char* argv[]) {
    size_t NUM = (argc == 2 ? (atoi(argv[1]) < 1 ? 1 : atoi(argv[1])): 1);
    while (NUM--) {
        some_function(NUM);
    }
    cout << "Exceptions: HI=" << HI << " / " << "LO=" << LO << endl;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Andrew Moon
 * Based on the C++ code by The Anh Tran
 * Based on the C code by Eckehard Berns
*/

#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <algorithm>
#include <pthread.h>

struct worker {
   worker( int ndigits, int pos, worker *head = NULL ) :
      digits(ndigits), pos_right(pos), next(head) {}
   
   inline int countflips() {
      if ( !p[0] )
         return 0;
      if ( !p[p[0]] )
         return 1;

      int tmp[16], flips = 0, last = p[0];
      memcpy( tmp, p, digits * sizeof( int ) );
      do {
         if ( !tmp[last] )
            return flips + 1;
         for ( int lo = 1, hi = last - 1; lo < hi; lo++, hi-- )
            std::swap( tmp[lo], tmp[hi] );
         std::swap( tmp[last], last );
         flips++;
      } while ( last );
      return flips;
   }

   inline void permute() {
      int tmp = p[0];
      for ( int i = 0; i < pos_left; i++ )
         p[i] = p[i + 1];
      p[pos_left] = tmp;
   }
   
   bool print( int &left ) {
      if ( left-- > 0 ) {
         for ( int i = 0; i < digits; i++ )
            printf( "%d", p[i] + 1 );
         printf( "\n" );
      }
      return ( left > 0 );
   }

   int fannkuch( int toprint = -1 ) {
      bool printing = ( toprint >= 0 );
      int left_limit = printing ? digits : digits - 1;
      pos_left = printing ? 1 : digits - 2;
      for ( int i = 0; i < digits; i++ ) {
         p[i] = i;
         count[i] = i + 1;
      }
      if ( printing )
         print( toprint );
      p[pos_right] = digits - 1;
      p[digits - 1] = pos_right;

      int maxflips = ( digits > 1 ) ? 1 : 0;
      while ( pos_left < left_limit ) {
         permute();
         if ( --count[pos_left] > 0 ) {
            if ( printing && !print( toprint ) )
               return maxflips;

            for ( ; pos_left != 1; pos_left-- )
               count[pos_left - 1] = pos_left;
            maxflips = std::max( maxflips, countflips() );
         } else {
            pos_left++;
         }
      }
      return maxflips;
   }

   void launch() { pthread_create( &id, NULL, threadrun, this ); }
   int finish() { int t; pthread_join( id, (void **)&t ); return t; }
   static void *threadrun( void *args ) { return (void *)((worker *)args)->fannkuch(); }

protected:
   int p[16], count[16];
   int digits, pos_right, pos_left;
   pthread_t id;

public:
   worker *next;
};


int fannkuch( int n ) {
   // create the workers
   int count = n - 1;
   worker *head = NULL;
   if ( n > 0 ) {
      for ( int i = 0; i < count; i++ ) {
         head = new worker( n, i, head );
         head->launch();
      }

      // print the first 30
      worker(n,n-1).fannkuch( 30 );
   }

   // gather the results
   int maxflips = 0;
   while ( head ) {
      maxflips = std::max( head->finish(), maxflips );
      worker *tmp = head->next;
      delete head;
      head = tmp;
   }

   return maxflips;
}

int main( int argc, const char *argv[] ) {
   int n = ( argc > 1 ) ? atoi( argv[1] ) : 0;
   printf( "Pfannkuchen(%d) = %d\n", n, fannkuch( n ) );
   return 0;
}
/*
 * The Computer Lannguage Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Originial c version contributed by Heiner Marxen
 * slightly adapted by Marc Halbruegge
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int fannkuch(int n, ostream &o) {
    if (n < 1) return 0;

    int flipsMax=0;
    int	r=n;
    int	numPermutationsPrinted=0;

    vector<int> permutation(n);
    vector<int> permForFlipping(n);
    vector<int> count(n);
    
    /* initial (trivial) permu */
    for (int i=0; i<n; ++i) permutation[i] = i;

    for (;;) {
        if (numPermutationsPrinted++ < 30) {
            for (int i=0; i<n; ++i) {
                o << (1+permutation[i]);
            }
            o << endl;
	}
	for ( ; r!=1; --r) {
	    count[r-1] = r;
	}

	if (!(permutation[0]==0 || permutation[n-1]==n-1)) {
	    int flips = 0;
	    for (int i=1; i<n; ++i) permForFlipping[i] = permutation[i];

            /* cache perm[0] in k */
	    int k = permutation[0];

	    do {
		int i,j;
		for (i=1, j=k-1; i<j; ++i, --j) {
                    swap(permForFlipping[i], permForFlipping[j]);
		}
                swap(permForFlipping[k], k);

		++flips;
	    } while (k);

	    if (flipsMax < flips) {
		flipsMax = flips;
	    }
	}

	for (;;) {
	    if (r == n) {
		return flipsMax;
	    }

	    /* rotate down perm[0..r] by one */
            int perm0 = permutation[0];
            for (int i=0; i<r; ++i) {
                permutation[i] = permutation[i+1];
            }
            permutation[r] = perm0;

	    if (--count[r] > 0) break;

	    ++r;
	}
    }
}


int main(int argc, const char **argv) {

    int	n = (argc>1) ? atoi(argv[1]) : 0;

    cout << "Pfannkuchen(" << n << ") = "
	 << fannkuch(n, cout) << endl;

    return 0;
}
/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
*
* Based on code by Eckehard Berns
* Based on code by Heiner Marxen
* and the ATS version by Hongwei Xi
* convert to C++ by The Anh Tran
*/


#include <omp.h>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <memory.h>
#include <sched.h>
#include <boost/lexical_cast.hpp>

// Take a permut array, continuously flipping until first element is '1'
// Return flipping times
template <typename VT, int n>
static
int count_flip(VT (&perm_flip)[n])
{
   // cache first element, avoid swapping perm[0] and perm[k]
   VT v0 = perm_flip[0];
   VT tmp;

   int flip_count = 0;
   do
   {
      for ( int i = 1, j = v0 -1; i < j; ++i, --j )
      {
         tmp = perm_flip[i];
         perm_flip[i] = perm_flip[j];
         perm_flip[j] = tmp;
      }

      tmp = perm_flip[v0];
      perm_flip[v0] = v0;
      v0 = tmp;

      flip_count++;
   } while (v0 != 0); // stop when first element == '1' (no more flip)

   return flip_count;
}

// Return next permut, by rotating elements [0 - position] one 'step'
// next_perm('12345', 2) -> '23145'
template <typename VT, int n>
static
void next_permutation(VT (&permutation)[n], int position)
{
   VT perm0 = permutation[0];

   for (int i = 0; i < position; ++i)
      permutation[i] = permutation[i +1];
   permutation[position] = perm0;
}

// To divide tasks 'equally' for many threads, 
// permut generation strategy is different than that of original single thread.
// this function will 'correctly' print first 30 permutations
template <typename VT, int n>
static
void print_30_permutation()
{
   // declare and initialize
   // print original perm '123456...'
   VT permutation[n];
   for ( int i = 0; i < n; i++ )
   {
      permutation[i] = (VT)i;
      printf("%d", (1 + i));
   }

   printf("\n");
   int numPermutationsPrinted = 1;

   // initialize counter
   VT perm_remain[n];
   for ( int i = 1; i <= n; i++ )
      perm_remain[i -1] = (VT)i;

   for ( int pos_right = 2; pos_right <= n; pos_right++ )
   {
      int pos_left = pos_right -1;
      while (pos_left < pos_right)
      {
         // rotate down perm[0..prev] by one
         next_permutation(permutation, pos_left);

         if (--perm_remain[pos_left] > 0)
         {
            if (numPermutationsPrinted++ < 30)
            {
               for (int i = 0; i < n; ++i)
                  printf("%d", int(1 + permutation[i]));
               printf("\n");
            }
            else
               return;

            for ( ; pos_left != 1; --pos_left)
               perm_remain[pos_left -1] = pos_left;
         }
         else
            ++pos_left;
      }
   }
}

// Detect single/multithread benchmark
static
int GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < 16; i++)
   {
      if (CPU_ISSET(i, &cs))
         count++;
   }
   return count;
}


template <int n>
static
int fannkuch(int n_perm)
{
   if (n_perm < n)
      return fannkuch<n -1>(n_perm);

   typedef int VT;
   int flip_max_arr[n] = {0}; // hold flip_count result for each swapping index

   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      #pragma omp single nowait
      print_30_permutation<VT, n>();

      VT   permutation   [n];   // main array
      VT   perm_flip   [n];   // 2nd array, for counting flip times
      int   perm_remain   [n];   // 3rd array, holding permut counter

      // element at the last index take most of the time
      // -> task division: each swap(element i, last element) is a flipping run sub-task
      #pragma omp for schedule(dynamic, 1) nowait
      for ( int pos_right = 0; pos_right < n -1; pos_right++ )
      {
         int flip_max = 0; // flip count of this sub-task

         // value init
         for ( int i = 0; i < n -1; i++ )
            permutation[i] = VT(i);

         // manually swap element i and last element 
         permutation[pos_right] = VT(n -1);
         permutation[n -1] = VT(pos_right);

         // counter init
         for ( int i = 1; i <= n; i++ )
            perm_remain[i -1] = i;

         int pos_left = n -2;
         while (pos_left < n -1) // manually swap(i, last_element) => exclude last element
         {
            // rotate down perm[0..r] by one
            next_permutation(permutation, pos_left);

            if (--perm_remain[pos_left] > 0)
            {
               for ( ; pos_left != 1; --pos_left)
                  perm_remain[pos_left -1] = pos_left;

               if ((permutation[0] != 0) && (permutation[n-1] != VT(n-1)))
               {
                  memcpy(perm_flip, permutation, sizeof(perm_flip));
                  flip_max = std::max(flip_max, count_flip(perm_flip));
               }
            }
            else
               pos_left++;
         }

         // update max_flip counter for each flipping sub-task
         flip_max_arr[pos_right] = flip_max;
      } // end parallel foreach position
   } // end parallel region

   return *(std::max_element(&flip_max_arr[0], &flip_max_arr[n]));
}


// Specialized to stop compilation
template <>
int fannkuch<2>(int)
{
   print_30_permutation<int, 2>();
   return 1;
}


int main(int argc, const char **argv)
{
   int n = (argc >= 2) ? boost::lexical_cast<int>(argv[1]) : 7;

   printf("Pfannkuchen(%d) = %d\n", n, fannkuch<32>(n));
   return 0;
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

contributed by Miroslav Rubanets
based on Java 6 source code by Oleg Mazurov.

License full text is here: http://shootout.alioth.debian.org/license.php

Building checked in Ubuntu 10.4 with g++ (Ubuntu 4.4.3-4ubuntu5) 4.4.3
   one needs to install libboost-thread-dev package to get this working 
   g++ -c -O3 -pthread -flax-vector-conversions -march=native fannkuchredux_optimized.cpp
   g++ -O3 -lpthread -lboost_thread fannkuchredux_optimized.o
*/
//std stuff
#include <algorithm>
#include <cstdio>
using std::copy;using std::max;using std::min; using std::atoi;
using std::printf;using std::swap;
//threads stuff
#include <boost/thread.hpp>
using boost::thread;using boost::thread_group;using boost::ref;
//platform specific
//vector stuff
#ifdef __SSE__
#   include <xmmintrin.h>
#endif //sse
#ifdef __SSSE3__
#   include <tmmintrin.h>
#endif // sse3
#ifdef __SSE4_1__
#   include <smmintrin.h>
#endif // sse4.1
typedef char v16si __attribute__ ((vector_size (16)));
typedef v16si P;
#define INLINE __attribute__ ((__always_inline__))
//static data
//0  1  2  3  4  5  6  7  8  9   a   b   c   d   e  f 
const P reverse_data[16]={
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 2, 1, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 3, 2, 1, 0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 4, 3, 2, 1, 0, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 5, 4, 3, 2, 1, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 6, 5, 4, 3, 2, 1, 0, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 11, 12, 13, 14, 15},
{ 8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 10, 11, 12, 13, 14, 15},
{ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 10, 11, 12, 13, 14, 15},
{10, 9, 8, 7, 6, 5, 4, 3, 2, 1,  0, 11, 12, 13, 14, 15},
{11,10, 9, 8, 7, 6, 5, 4, 3, 2,  1,  0, 12, 13, 14, 15},
{12,11,10, 9, 8, 7, 6, 5, 4, 3,  2,  1,  0, 13, 14, 15}, 
{13,12,11,10, 9, 8, 7, 6, 5, 4,  3,  2,  1,  0, 14, 15},
{14,13,12,11,10, 9, 8, 7, 6, 5,  4,  3,  2,  1,  0, 15},
{15,14,13,12,11,10, 9, 8, 7, 6,  5,  4,  3,  2,  1,  0},
};
const P rotate_data[16] = {
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 0, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 0, 7, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 0, 8, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 0, 9, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10,  0, 11, 12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 0,  12, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12,  0, 13, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13,  0, 14, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14,  0, 15},
{ 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15,  0},
};
//fwd
int p0(P p) INLINE;
P assign(const char d[16])INLINE;
P reverse(P p, int first)INLINE;
P rotate1(P p) INLINE;
P rotate(P p, int f)INLINE;
//fallback 
char& access(P const& p, int i) INLINE;
P& reverse_slow(P& p, int first)INLINE;
P& rotate1_slow(P& p, int f)INLINE;
P& rotate_slow(P& p, int f)INLINE;
int p0(P p) 
{ 
#ifdef __SSE4_1__
    return _mm_extract_epi8(p, 0);
#else
    return static_cast<int>( reinterpret_cast<const char*>(&p)[0] );
#endif
}
P assign(const char d[16])
{
    P ld = {
        d[0], d[1], d[ 2], d[ 3],     d[ 4], d[ 5], d[ 6], d[ 7], 
        d[8], d[9], d[10], d[11],     d[12], d[13], d[14], d[15]
    };
    return ld;
}
P reverse(P p, int first)
{
#ifdef __SSSE3__
    register P mask = reverse_data[first];
    return _mm_shuffle_epi8( p, mask);
#else
    return reverse_slow( p, first );
#endif
}
P rotate1(P p) 
{
#ifdef __SSSE3__
    register P mask = rotate_data[1];
    return _mm_shuffle_epi8( p, mask );
#else
    return rotate_slow( p, 1 );
#endif
}
P rotate(P p, int f)
{
#ifdef __SSSE3__
    register P mask = rotate_data[f];
    return _mm_shuffle_epi8( p, mask);
#else
    return rotate_slow( p, f );
#endif
}
// this functions really should not be called unless its very old march=native
char& access(P & p, int i) 
{
    return reinterpret_cast<char*>(&p)[i];
}
P& reverse_slow(P& p, int n)
{
    for ( int lo = 0, hi = n ; lo < hi; ++lo, --hi ) 
    {
        swap( access(p, lo), access( p, hi) );
    }
    return p;
}
P& rotate1_slow(P&p)
{
    swap( access( p, 0), access( p, 1 ) );
    return p;
}
P& rotate_slow(P&p, int i)
{
    int first = access( p, 0 );
    for ( int j=0; j<i; ++j ) 
    {
        access( p, j) = access( p, j+1);
    }
    access( p, i ) = first;
    return p;
}
struct G
{// permutation generator
    P p;
    int count[16];
    int fact[16];
    int len;
    int padding[3];
    void init(int n)
    {
        len = n;
        std::fill( &count[0], &count[16], 0);
        fact[0] = 1;
        for(int i = 1; i<len+1; ++i)
        {
            fact[i] = fact[i-1]*i;
        }
        first_permutation(0);
    }
    void first_permutation(int idx)
    {
        char p[16]={};
        char pp[16]={};
        for ( int i=0; i<len; ++i ) 
           p[i] = i;
        for ( int i=len-1; i>0; --i ) 
        {
            int d = idx / fact[i];
            count[i] = d;
            idx = idx % fact[i];
            copy( &p[0], &p[i+1], &pp[0] );
            for ( int j=0; j<=i; ++j ) 
            {
                p[j] = j+d <= i ? pp[j+d] : pp[j+d-i-1];
            }
        }
        this->p = assign( p );
    }
    void next_permutation()
    {
        p = rotate1( p );
        int i=1;
        while ( ++count[i] > i ) 
        {
            count[i++] = 0;
            p = rotate( p, i );
        }
    }
};
struct Fannkuchredux
{
    G g;
    struct R{ int maxflips, checksum; };
    void init(int len)
    {
        g.init( len );
    }
    void count_flips(R&r, int i)
    {//performance magic happen here. 
        register int flips = 0;
        register P p = g.p;
        register int f = p0( p );
        if( f )
        {
            do{
                ++flips;
                p = reverse( p, f);
            }while( f = p0(p) );
        }
        int total_flips = flips;
        r.maxflips = max( r.maxflips, total_flips );
        r.checksum += i%2 ==0 ? total_flips : -total_flips;
    }
    R run(int i, int N)
    {
        R r = { 0, 0};
        g.first_permutation( i );
        for(;;)
        { 
            count_flips( r, i );
            ++i;
            if( i >= N )
                break;
            g.next_permutation();
        }
        return r;
    }
};
struct Part
{
    Fannkuchredux f;
    Fannkuchredux::R r;
    int first_index, last_index;
    void operator()()
    {
        r = f.run( first_index, last_index );
    }
};
const char* usage = "usage fannkuchredux number\n\
number has to be in range [3-12]\n";
int main(int argc, char* argv[])
{
    if( argc < 2 )
    {
        printf("%s", usage);
        return 1;
    }
    int len = atoi(argv[1] ); 
    if( len < 3 || len > 12 )
    {
        printf("%s", usage);
        return 2;
    }
    unsigned n_cpu = thread::hardware_concurrency();
    Fannkuchredux::R r= { 0, 0};
    Fannkuchredux f;
    f.init(len);
    if( n_cpu == 1 )
    {
        r = f.run(0, f.g.fact[len]);
    }else
    {   // hack to use 4 cpus.
        // used here to avoid bringing in alignment machinery.
        const unsigned max_cpu_limit = 4;
        Part parts[max_cpu_limit];
        thread_group tg;
        unsigned n = min(n_cpu, max_cpu_limit);
        int index = 0; 
        int index_max = f.g.fact[len]; 
        int index_step = (index_max + n-1 )/ n;
        for(unsigned i = 0; i<n; ++i, index += index_step )
        {            
            Part& p = parts[i];
            p.f = f;
            p.first_index = index;
            p.last_index = min( index + index_step, index_max );
            p.r.checksum = 0; 
            p.r.maxflips = 0;                        
            tg.create_thread( ref( p ) );
        }
        tg.join_all();
        for(unsigned i = 0; i<n; ++i )
        {
            Part const& p = parts[i];
            r.maxflips = max( p.r.maxflips, r.maxflips );
            r.checksum += p.r.checksum;
        }
    }
    printf("%d\nPfannkuchen(%d) = %d\n", r.checksum, len, r.maxflips);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

contributed by Miroslav Rubanets
based on Java 6 source code by Oleg Mazurov.

License full text is here: http://shootout.alioth.debian.org/license.php

Building checked in Ubuntu 10.4 with g++ 4.4 (both x86 and amd64).
   one needs to install libboost-thread-dev package to get this working 
   g++ -c -O3 -pipe -pthread -fomit-frame-pointer -march=native f.cpp
   g++ -lpthread -lboost_thread f.o
*/
//std stuff
#include <cassert>
#include <algorithm>
#include <cstdio>
using std::copy;using std::max;using std::min; using std::atoi;
using std::printf;using std::swap;
//threads stuff
#include <boost/thread.hpp>
using boost::thread;using boost::thread_group;using boost::ref;

struct P{//permutation
    char data[16];
    char& operator[](int i){ return data[i]; }
    const char& operator[](int i)const{ return data[i]; }
    void assign( const char* p, int len){ copy(p, p+len, &data[0] ); }
    void rotate(int i){
        int first = data[0];
        for (int j=0; j<i; ++j)
            data[j] = data[j+1];
        data[i] = first;
    }
    void reverse(int n){
        // following lines are very carefully written to meet both test 
        // conditions and reasonable timings. 
        char * lo = &data[0], * hi = &data[n];
        for (; lo < hi; ++lo, --hi) 
            swap( *lo, *hi );
    }
};
class G{// permutation generator
    P p;
    int count[16];
    union{//for alignment
        struct{
            const int * fact;
            int len;
        };
        int padding[4];
    };
public:
    G():fact(), len(){}
    void init(const int*p, int n){
        fact = p;
        len = n;
        std::fill(&count[0], &count[16], 0);
    }
    bool constructed()const{ return fact != 0;}
    void first_permutation(int idx){
        char p[16]={};
        char pp[16]={};
        for ( int i=0; i<len; ++i ) 
           p[i] = i;
        for ( int i=len-1; i>0; --i ) {
            int d = idx / fact[i];
            count[i] = d;
            idx = idx % fact[i];
            copy( &p[0], &p[i+1], &pp[0] );
            for ( int j=0; j<=i; ++j ){
                p[j] = j+d <= i ? pp[j+d] : pp[j+d-i-1];
            }
        }
        this->p.assign(p, 16);
    }
    void next_permutation(){
        p.rotate(1);
        int i=1;
        while (++count[i] > i){
            count[i++] = 0;
            p.rotate( i );
        }
    }
    char get_first_item()const{ return p[0];}
    void get_permutation( P & out ){ out = p;}
};
struct Fannkuchredux{
    struct R{ int maxflips, checksum; };
    R run(G* g, int i, int N){
        R r = { 0, 0 };
        g->first_permutation(i);
        for(; i < N; ++i, g->next_permutation()){
            //count flips
            register int flips = 0;
            char f = g->get_first_item();
            if(f){
                P p;
                g->get_permutation(p);
                do{
                    ++flips;
                    p.reverse(f);
                }while(f = p[0]);
            }
            int total_flips = flips;
            r.maxflips = max(r.maxflips, total_flips);
            r.checksum += i%2 ==0 ? total_flips : -total_flips;
        }
        return r;
    }
};
//two phase construction to be default constructible
class Task : public Fannkuchredux {
    G g;
    int first_index, last_index;
    int padding[14];
public:
    Fannkuchredux::R r;
    void init(const int *p, int n, int b, int e){
        g.init( p, n );
        first_index = b;
        last_index = e;
        r.checksum = r.maxflips = 0;
    }
    void operator()()
    {
        assert( g.constructed() );
        r = run( &g, first_index, last_index );
    }
};
const char* usage = "usage fannkuchredux number\n\
number has to be in range [3-12]\n";
int main(int argc, char* argv[])
{
    if( argc < 2 ){
        printf("%s", usage);
        return 1;
    }
    int len = atoi(argv[1] ); 
    if( len < 3 || len > 12 ){
        printf("%s", usage);
        return 2;
    }
    int fact[16];
    fact[0] = 1;
    for(int i = 1; i<len+1; ++i)
        fact[i] = fact[i-1]*i;
    unsigned n_cpu = thread::hardware_concurrency();
    Fannkuchredux::R r= { 0, 0};
    const unsigned max_cpu_limit = 4;
    Task parts[max_cpu_limit];
    unsigned n = min(n_cpu, max_cpu_limit);
    thread_group tg;
    int index = 0;
    int index_max = fact[len]; 
    int index_step = (index_max + n-1)/n;
    for(unsigned i = 0; i<n; ++i, index += index_step){
        Task& p = parts[i];
        p.init(fact, len, index, index + index_step);
        tg.create_thread(ref(p));
    }
    tg.join_all();
    for(unsigned i = 0; i<n; ++i){
        Task const& p = parts[i];
        r.maxflips = max( p.r.maxflips, r.maxflips );
        r.checksum += p.r.checksum;
    }
    printf("%d\nPfannkuchen(%d) = %d\n", r.checksum, len, r.maxflips);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Andrew Moon
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>

struct Random {
   enum { IM = 139968, IA = 3877, IC = 29573 };
   Random() : last(42) {}
   float get( float max = 1.0f ) { 
      last = ( last * IA + IC ) % IM;
      return max * last / IM;
   }
protected:
   unsigned int last;
} rng;

struct IUB {
   int c;
   double p;
   unsigned int pi;
};

struct Cumulative {
   enum { slots = 512, };

   Cumulative( IUB *start ) {
      double p = 0;
      for ( IUB *iter = start; iter->c; ++iter ) {
         p += iter->p;
         iter->p = std::min( p, 1.0 );
         iter->pi = (unsigned int )( iter->p * slots );
      }

      for ( unsigned int i = 0; i <= slots; i++ ) {
         while ( i > start->pi )
            ++start;
         table[i] = start;
      }
   }

   const char operator[] ( float pct ) const {
      IUB *iter = table[(unsigned int )( pct * slots )];
      while ( iter->p < pct )
         ++iter;
      return iter->c;
   }

protected:
   IUB *table[slots + 1];
};

static const size_t lineLength = 60;

struct LineBuffer {
   LineBuffer() : lastN(0) {}
   LineBuffer &genrand( Cumulative &table, size_t N ) {
      for ( size_t i = 0; i < N; i++ )
         buffer[i] = table[rng.get()];
      buffer[N] = '\n';
      lastN = N + 1;
      return *this;
   }
   void writeline() const { fwrite_unlocked( buffer, 1, lastN, stdout ); }
protected:
   char buffer[lineLength + 1];
   size_t lastN;
};

struct RotatingString {
   RotatingString( const char *in ) : pos(0) {
      size = strlen( in );
      buffer = new char[size + lineLength];
      memcpy( buffer, in, size );
      memcpy( buffer + size, in, lineLength );
   }
   ~RotatingString() { delete[] buffer; }
   void write( size_t bytes ) {
      fwrite_unlocked( buffer + pos, 1, bytes, stdout );
      fputc_unlocked( '\n', stdout );
      pos += bytes;
      if ( pos > size )
         pos -= size;
   }
protected:
   char *buffer;
   size_t size, pos;
};

template< class Output >
void makeFasta( const char *id, const char *desc, size_t N, Output &output ) {
   fprintf( stdout, ">%s %s\n", id, desc );

   while ( N ) {
      const size_t bytes = std::min( N, lineLength );
      output.writeline( bytes );
      N -= bytes;
   }
}

struct Repeater {
   Repeater( const char *alu ) : rot(alu) {}
   void writeline( size_t bytes ) { rot.write( bytes ); }
   void run( const char *id, const char *desc, size_t N ) {
      makeFasta( id, desc, N, *this );
   }
protected:
   RotatingString rot;
};

struct Randomized {
   Randomized( IUB *start ) : table(start) {}
   void writeline( size_t bytes ) { line.genrand(table, bytes).writeline(); }
   void run( const char *id, const char *desc, size_t N ) {
      makeFasta( id, desc, N, *this );
   }
protected:
   Cumulative table;
   LineBuffer line;
};

IUB iub[] = {
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 },
   {   0,    0 },
};

IUB homosapiens[] = {
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 },
   {   0,               0 },
};

static const char alu[] =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
   "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
   "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
   "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
   "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
   "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
   "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int main( int argc, const char *argv[] ) {
   const size_t n = ( argc > 1 ) ? atoi( argv[1] ) : 512;

   Repeater(alu)
      .run( "ONE", "Homo sapiens alu", n*2 );
   Randomized(iub)
      .run( "TWO", "IUB ambiguity codes", n*3 );
   Randomized(homosapiens)
      .run( "THREE", "Homo sapiens frequency", n*5 );

   return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Andrew Moon
   slightly modified by Krzysztof Jakubowski
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>

struct Random {
   enum { IM = 139968, IA = 3877, IC = 29573 };
   Random() : last(42) {}
   float get( float max = 1.0f ) {
      last = ( last * IA + IC ) % IM;
      return max * last * (512.0f / IM);
   }
protected:
   unsigned int last;
} rng;

struct IUB {
   int c;
   double p;
   unsigned int pi;
};

struct Cumulative {
   enum { slots = 512, };

   Cumulative( IUB *start ) {
      double p = 0;
      for ( IUB *iter = start; iter->c; ++iter ) {
         p += iter->p;
         iter->p = std::min( p, 1.0 ) * slots;
         iter->pi = (unsigned int )(iter->p);
      }

      for ( unsigned int i = 0; i <= slots; i++ ) {
         while ( i > start->pi )
            ++start;
         table[i] = start;
      }
   }

   const char operator[] ( float pct ) const {
      IUB *iter = table[(unsigned)pct];
      while ( iter->p < pct )
         ++iter;
      return iter->c;
   }

protected:
   IUB *table[slots + 1];
};

static const size_t lineLength = 60;

struct LineBuffer {
   LineBuffer() : lastN(0) {}
   LineBuffer &genrand( Cumulative &table, size_t N ) {
      for ( size_t i = 0; i < N; i++ )
         buffer[i] = table[rng.get()];
      buffer[N] = '\n';
      lastN = N + 1;
      return *this;
   }
   void writeline() const { fwrite_unlocked( buffer, 1, lastN, stdout ); }
protected:
   char buffer[lineLength + 1];
   size_t lastN;
};

struct RotatingString {
   RotatingString( const char *in ) : pos(0) {
      size = strlen( in );
      buffer = new char[size + lineLength];
      memcpy( buffer, in, size );
      memcpy( buffer + size, in, lineLength );
   }
   ~RotatingString() { delete[] buffer; }
   void write( size_t bytes ) {
      fwrite_unlocked( buffer + pos, 1, bytes, stdout );
      fputc_unlocked( '\n', stdout );
      pos += bytes;
      if ( pos > size )
         pos -= size;
   }
protected:
   char *buffer;
   size_t size, pos;
};

template< class Output >
void makeFasta( const char *id, const char *desc, size_t N, Output &output ) {
   fprintf( stdout, ">%s %s\n", id, desc );

   while ( N ) {
      const size_t bytes = std::min( N, lineLength );
      output.writeline( bytes );
      N -= bytes;
   }
}

struct Repeater {
   Repeater( const char *alu ) : rot(alu) {}
   void writeline( size_t bytes ) { rot.write( bytes ); }
   void run( const char *id, const char *desc, size_t N ) {
      makeFasta( id, desc, N, *this );
   }
protected:
   RotatingString rot;
};

struct Randomized {
   Randomized( IUB *start ) : table(start) {}
   void writeline( size_t bytes ) { line.genrand(table, bytes).writeline(); }
   void run( const char *id, const char *desc, size_t N ) {
      makeFasta( id, desc, N, *this );
   }
protected:
   Cumulative table;
   LineBuffer line;
};

IUB iub[] = {
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 },
   {   0,    0 },
};

IUB homosapiens[] = {
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 },
   {   0,               0 },
};

static const char alu[] =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
   "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
   "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
   "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
   "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
   "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
   "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int main( int argc, const char *argv[] ) {
   const size_t n = ( argc > 1 ) ? atoi( argv[1] ) : 512;

   Repeater(alu)
      .run( "ONE", "Homo sapiens alu", n*2 );
   Randomized(iub)
      .run( "TWO", "IUB ambiguity codes", n*3 );
   Randomized(homosapiens)
      .run( "THREE", "Homo sapiens frequency", n*5 );

   return 0;
}

/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/

converted to C++ from D by Rafal Rusin
modified by Vaclav Haisman
modified by The Anh to compile with g++ 4.3.2

compile: g++ -O3 -Wall -march=native -msse2 -o fasta fasta.cpp
*/

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <memory>
#include <vector>
#include <numeric>
#include <functional>

using namespace std;

static int const IM = 139968, IA = 3877, IC = 29573;
static int last = 42;

static inline
double
genRandom(double max)
{
   return(max * (last = (last * IA + IC) % IM) / IM);
}

struct IUB
{
   char c;
   double p;
};

struct IUB_accum : public std::binary_function<IUB const &, IUB, IUB>
{
   result_type
      operator () (first_argument_type a, second_argument_type b) const
   {
      b.p += a.p;
      return b;
   }
};

template <typename Iter>
static inline
void
makeCumulative(Iter const start, Iter const end)
{
   partial_sum (start, end, start, IUB_accum ());
}

static const char alu[] =
"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

static const unsigned length = 60, alu_size = sizeof(alu) - 1;

static inline
void
makeRepeatFasta(char const * const id, char const * const desc, unsigned n)
{
   printf(">%s %s\n", id, desc);
   char line[length+1];
   unsigned alu_index = 0;
   while(n > 0)
   {
      unsigned const m = min (n, length);
      line[m] = '\n';
      n -= m;
      unsigned line_index = 0;
      while (m - line_index != 0)
      {
         unsigned const copy_count = min (m - line_index, alu_size - alu_index);
         copy (alu + alu_index, alu + alu_index + copy_count, line + line_index);
         alu_index += copy_count;
         line_index += copy_count;
         if (alu_index == alu_size)
            alu_index = 0;
      }
      fwrite_unlocked (line, 1, m + 1, stdout);
   }
}

template <typename Iter>
static inline
void
makeRandomFasta(char const * const id, char const * const desc, unsigned n, Iter start, Iter end)
{
   printf(">%s %s\n", id, desc);
   makeCumulative(start, end);
   char line[length + 1];
   while(n > 0)
   {
      unsigned const m = min (n, length);
      n -= m;
      for(size_t j = 0; j < m; ++j)
      {
         double const rval = genRandom(1);
         Iter it;
         for (it = start; it != end; ++it)
         {
            if (rval < it->p)
               break;
         }
         line[j] = it->c;
      }
      line[m] = '\n';
      fwrite_unlocked (line, 1, m + 1, stdout);
   }
}

static IUB iub[] =
{
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 }
};

static IUB homosapiens[] =
{
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 }
};

int main(int argc, char *argv[])
{
   unsigned const n = argc > 1 ? atoi(argv[1]) : 1;

   makeRepeatFasta("ONE", "Homo sapiens alu", n*2);
   makeRandomFasta("TWO", "IUB ambiguity codes", n*3, iub,
      iub + sizeof (iub) / sizeof (IUB));
   makeRandomFasta("THREE", "Homo sapiens frequency", n*5, homosapiens,
      homosapiens + sizeof (homosapiens) / sizeof (IUB));
}


/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Andrew Moon
   modified by Krzysztof Jakubowski
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>

struct Random {
   enum { IM = 139968, IA = 3877, IC = 29573 };
   Random() : last(42) {}
   float get( float max = 1.0f ) {
      last = ( last * IA + IC ) % IM;
      return max * last / IM;
   }
   
   unsigned int last;
} rng;

struct IUB {
   int c;
   double p;
   unsigned int pi;
};

struct Cumulative {
   enum { slots = 512 };

   Cumulative( IUB *start ) {
      double p = 0;
      for ( IUB *iter = start; iter->c; ++iter ) {
         p += iter->p;
         iter->p = std::min( p, 1.0 );
         iter->pi = (unsigned int )( iter->p * slots );
      }

      for ( unsigned int i = 0; i <= slots; i++ ) {
         while ( i > start->pi )
            ++start;
         table[i] = start;
      }
   }

   const char operator[] ( float pct ) const {
      IUB *iter = table[(unsigned int )( pct * slots )];
      while ( iter->p < pct )
         ++iter;
      return iter->c;
   }

protected:
   IUB *table[slots + 1];
};

enum { lineLength = 60 };

struct LineBuffer {
   LineBuffer() : lastN(0) {}
   LineBuffer &genrand( Cumulative &table, size_t N ) {
      for ( size_t i = 0; i < N; i++ )
         buffer[i] = table[rng.get()];
      buffer[N] = '\n';
      lastN = N + 1;
      return *this;
   }
   void writeline() const {
	   fwrite_unlocked( buffer, 1, lastN, stdout );
   }
protected:
   char buffer[lineLength + 1];
   size_t lastN;
};

struct RotatingString {
   RotatingString( const char *in ) : pos(0) {
      size = strlen( in );
      buffer = new char[size + lineLength];
      memcpy( buffer, in, size );
      memcpy( buffer + size, in, lineLength );
   }
   ~RotatingString() { delete[] buffer; }
   void write( size_t bytes ) {
      fwrite_unlocked( buffer + pos, 1, bytes, stdout );
      fputc_unlocked( '\n', stdout );
      pos += bytes;
      if ( pos > size )
         pos -= size;
   }
protected:
   char *buffer;
   size_t size, pos;
};

template< class Output >
void makeFasta( const char *id, const char *desc, size_t N, Output &output ) {
   fprintf( stdout, ">%s %s\n", id, desc );

   while ( N ) {
      const size_t bytes = std::min( N, size_t(lineLength));
      output.writeline( bytes );
      N -= bytes;
   }
}

struct Repeater {
   Repeater( const char *alu ) : rot(alu) {}
	void writeline( size_t bytes ) { rot.write( bytes ); }
	void run(const char *id, const char *desc, size_t N) {
		makeFasta(id, desc, N, *this);
	}

protected:
   RotatingString rot;
};
   

struct Randomized {
	Randomized( IUB *start ) : table(start) {}
	void writeline(size_t bytes) {
		line.genrand(table, bytes).writeline();
	}

	void run(const char *id, const char *desc, size_t N) {
	//	makeFasta(id, desc, N, *this);
		fprintf(stdout, ">%s %s\n", id, desc);

		char buffer[140000 + lineLength];

		unsigned int rStart = rng.last;
		buffer[0] = table[rng.get()];
		size_t count = 1;
		for(;rng.last != rStart && count < N; count++)
			buffer[count] = table[rng.get()];
		std::copy(buffer, buffer + lineLength, buffer + count);

		int lines = N / lineLength;
		char line[lineLength + 1];
		line[lineLength] = '\n';

		for(int l = 0; l < lines; l++) {
			char *src = buffer + (l * lineLength) % count;
			char tmp = src[lineLength];
			src[lineLength] = '\n';
			fwrite_unlocked(src, 1, 61, stdout);
			src[lineLength] = tmp;
		}
		if(N % lineLength) {
			fwrite_unlocked(buffer + (N - N % lineLength) % count, 1,
					N % lineLength, stdout);
			fwrite_unlocked("\n", 1, 1, stdout);
		}

		if(N > count) {
			int riters = N % count;
			for(int i = 0; i < riters; i++) rng.get();
		}
	}

protected:
   Cumulative table;
   LineBuffer line;
};
   
IUB iub[] = {
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 },
   {   0,    0 },
};

IUB homosapiens[] = {
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 },
   {   0,               0 },
};

static const char alu[] =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
   "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
   "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
   "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
   "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
   "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
   "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int main( int argc, const char *argv[] ) {
   const size_t n = ( argc > 1 ) ? atoi( argv[1] ) : 512;

   Repeater(alu)
     .run( "ONE", "Homo sapiens alu", n*2 );
   Randomized(iub)
      .run( "TWO", "IUB ambiguity codes", n*3 );
   Randomized(homosapiens)
      .run( "THREE", "Homo sapiens frequency", n*5 );

   return 0;
}

// -*- mode: c++ -*-
// $Id: fibo.gpp,v 1.3 2005-04-25 19:01:38 igouy-guest Exp $
// http://shootout.alioth.debian.org/

#include <iostream>
#include <stdlib.h>

using namespace std;

unsigned long fib(unsigned long n) {
    if (n < 2)
	return(1);
    else
	return(fib(n-2) + fib(n-1));
}

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    cout << fib(n) << endl;
    return(0);
}
/*
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Daniel Skiles
*/

#include <cstdlib>
#include <iostream>
#include <iomanip>

using namespace std;

int main(int argc, char *argv[])
{
    double n;
    double partialSum = 0;
    n = (argc == 2) ? atof(argv[1]) : 10000000;
    cout << setiosflags(ios::fixed) << setprecision(9);
    
    for(double i=1; i<=n; i++)
            partialSum += 1.0/i;
    cout << partialSum << endl;
    return EXIT_SUCCESS;
}

// -*- mode: c++ -*-
// $Id: hash.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org
//
// Improved by Brad Knotwell to use memory constraints

#include <stdio.h>
#include <iostream>
#include <memory>
#include <ext/hash_map>

using namespace std;
#if (! defined(__INTEL_COMPILER))
using namespace __gnu_cxx;
#endif

struct eqstr {
    bool operator()(const char* s1, const char* s2) const {
	return strcmp(s1, s2) == 0;
    }
};

#if defined(__INTEL_COMPILER)
struct str_hash_compare
{
    enum { bucket_size = 4, min_buckets = 8 };
	
    bool operator()(char const *s1, char const *s2) const
    {return strcmp(s1, s2) < 0;}

    size_t operator() (const char* s) const
    {
        size_t h = 0;
        for (; *s; ++s)
            h = 5 * h + *s;
        return h;
    }
};
#endif

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[16];
#if defined(__INTEL_COMPILER)
    typedef hash_map<const char*, int, str_hash_compare> HM;
#else
    typedef hash_map<const char*, int, hash<const char*>, eqstr, __single_client_alloc> HM;
#endif
    HM X;

    for (int i=1; i<=n; i++) {
	sprintf(buf, "%x", i);
	X[strdup(buf)] = i;
    }

    int c = 0;
    for (int i=n; i>0; i--) {
	sprintf(buf, "%d", i);
	if (X.find(buf) != X.end()) c++;
    }

    cout << c << endl;
}
// -*- mode: c++ -*-
// $Id: hash2.gpp-2.gpp,v 1.1 2004-11-10 07:07:16 bfulgham Exp $
// http://shootout.alioth.debian.org/
// from David Hedbor

// this version uses a custom string and hash function

#include <stdio.h>
#include <hash_map.h>
#include <string.h>
using namespace std;

// Simple hashing function
struct sstr {
    int refs;
    size_t len;
    size_t strhash;
    char *data;
    static size_t strhasher(const char *name, size_t mlen) {
	size_t seed = (9248339*mlen);
	for(size_t i = 4; i < mlen; i++) {
	    seed ^= (seed <<8) + name[i];
	}
	seed  %= 0xefffff;
	return seed;
    }

    sstr (const char *str) :
	refs(1), len(strlen(str)), strhash(strhasher(str, len)),
	data(strdup(str)) {
    }
    void free() { refs--; }
    sstr *copy() { refs++; return this; }  
};

struct mystr {
    sstr *data;
    mystr() : data(0) { }
    mystr(const char * dt) : data(new sstr(dt))
	{   
	}
    ~mystr() {
	if(data) {
	    data->free();
	    if(!data->refs) delete data;
	}
    }
    bool operator==(const mystr &other) const {
	return other.data->len == data->len &&
	    !memcmp(other.data->data, data->data, data->len);
    }
    mystr &operator=(const mystr &other)  {
	if(*this == other) return *this;
	data = other.data->copy();
	return *this;
    }
    mystr &operator=(const char *other)  {
	data = new sstr(other);
	return *this;
    }
    mystr(const mystr &other) : data(other.data->copy()) { }
};

struct mysthash {
    size_t operator()(const mystr &str) const { return str.data->strhash; }
};

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[16];
    typedef hash_map<const mystr, int, mysthash> HM;
    HM hash1, hash2;

    for (int i=0; i<10000; i++) {
	sprintf(buf, "foo_%d", i);
	hash1[buf] = i; 
    }

    for (int i=0; i<n; i++) {
	for (HM::iterator k = hash1.begin(); k != hash1.end(); ++k) {
	    hash2[(*k).first] += hash1[(*k).first];
	}
    }

    printf("%d %d %d %d\n", hash1["foo_1"],  hash1["foo_9999"], 
	   hash2["foo_1"], hash2["foo_9999"]);
}
// -*- mode: c++ -*-
// $Id: hash2.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <stdio.h>
#include <iostream>
#include <ext/hash_map>

using namespace std;
#if (! defined(__INTEL_COMPILER))
using namespace __gnu_cxx;
#endif

struct eqstr {
   bool operator()(const char* s1, const char* s2) const {
      if (s1 == s2) return true;
      if (!s1 || !s2) return false;
      while (*s1 != '\0' && *s1 == *s2)
         s1++, s2++;
      return *s1 == *s2;
   }
};

struct strhash {
#if defined(__INTEL_COMPILER)
   enum { bucket_size = 4, min_buckets = 8 };

   bool operator()(char const *s1, char const *s2) const
        {return strcmp(s1, s2) < 0;}
#endif
   size_t operator()(const char* s) const {
      size_t i;
      for (i = 0; *s; s++)
         i = 31 * i + *s;
      return i;
   }
};

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[16];
#if defined(__INTEL_COMPILER)
    typedef hash_map<const char*, int, strhash> HM;
#else
    typedef hash_map<const char*, int, strhash, eqstr> HM;
#endif
    HM hash1, hash2;

    for (int i=0; i<10000; i++) {
        sprintf(buf, "foo_%d", i);
        hash1[strdup(buf)] = i;
    }
    for (int i=0; i<n; i++) {
        for (HM::iterator k = hash1.begin(); k != hash1.end(); ++k) {
            hash2[(*k).first] += k->second;
        }
    }
    cout << hash1["foo_1"] << " " << hash1["foo_9999"] << " "
         << hash2["foo_1"] << " " << hash2["foo_9999"] << endl;
}
// -*- mode: c++ -*-
// $Id: heapsort.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org/
// C++-ified by Brent Fulgham

#include <iomanip>
#include <iostream>
#include <stdlib.h>
#include <math.h>

using namespace std;

#define IM 139968
#define IA   3877
#define IC  29573

double gen_random(double max) {
    static long last = 42;
    return( max * (last = (last * IA + IC) % IM) / IM );
}

void heapsort(int n, double *ra) {
    int i, j;
    int ir = n;
    int l = (n >> 1) + 1;
    double rra;

    for (;;) {
	if (l > 1) {
	    rra = ra[--l];
	} else {
	    rra = ra[ir];
	    ra[ir] = ra[1];
	    if (--ir == 1) {
		ra[1] = rra;
		return;
	    }
	}
	i = l;
	j = l << 1;
	while (j <= ir) {
	    if (j < ir && ra[j] < ra[j+1]) { ++j; }
	    if (rra < ra[j]) {
		ra[i] = ra[j];
		j += (i = j);
	    } else {
		j = ir + 1;
	    }
	}
	ra[i] = rra;
    }
}

int main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    
    /* create an array of N random doubles */
    double *ary = new double[ N+1 ];
    for (int i=1; i<=N; i++) {
	ary[i] = gen_random(1);
    }

    heapsort(N, ary);

    cout << std::fixed << std::setprecision(10);
    cout << ary[N] << endl;

    delete[] ary;
    return(0);
}

// -*- mode: c++ -*-
// $Id: hello.gpp,v 1.1 2004-11-10 06:42:07 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <iostream>

using namespace std;

int main() {
    cout << "hello world" << endl;
    return(0);
}
// -*-c++-*-
// The Great Computer Language Shootout
// http://shootout.alioth.debian.org/
//
// contributed by Sebastien Loisel
//
// OVERVIEW: In this test, we solve an ordinary differential equation
//    u'=f(t,u)
// using the Trapezoid numerical method, which can be written as
//    (u[k+1]-u[k])=(f(t[k],u[k])+f(t[k]+dt,u[k+1]))*dt/2,
// where t[k], u[k], dt and the function f are known and u[k+1] is the
// unknown.
//
// Since u[k+1] appears on both sides of the equation, we use an iterative
// solver called the newton iteration to compute u[k+1]. The newton iteration
// computes the solution to
//    h(x)=0
// where h is a known function and x is the unknown 0 of h, using the method
//    x[k+1]=x[k]-f(x[k])/f'(x[k]).
// Here, f' denotes the derivative of f.
//
// To compute f' from the definition of f alone, we use a technique called
// automatic differentiation. This works by replacing all floating point
// variables by a special type we call ad (for automatic differentiation.)
// If the python program for f is called with parameter x of type ad,
// it will do the same work as if it were called with the equivalent parameter
// of type floating point, but will also return f'. That's why it's called
// "automatic."
//
// To shake things up, we also have another type, fl (for "float") which
// works exactly like a double precision floating point, but with much
// less precision.

#include <math.h>
#include <iostream>
#include <complex>
#include <stdio.h>
#include <string>

using namespace std;
#define op operator

template <class F> F sqr(const F &x) { return x*x; }
template <class F> F pow(const F &x, int i)
{ if(i<=0) return F(1); if(i&1) return x*pow(x,i-1); return sqr(pow(x,i/2)); }

struct fl
{
  double a;
  fl() : a(0) {}
  void set(const double x)
  {
    if(x==0) { a=0; return; }
    int k=(int)log(fabs(x));
    a=round(x*exp(-k+6.0))*exp(k-6.0);
  }
  fl(int x) { set(x); }
  fl(double x) { set(x); }
  fl op +(const fl &y) const { return fl(a+y.a); }
  fl &op +=(const fl &y) { *this=(*this)+y; return *this; }
  fl op -(const fl &y) const { return fl(a-y.a); }
  fl &op -=(const fl &y) { *this=(*this)-y; return *this; }
  fl op *(const fl &y) const { return fl(a*y.a); }
  fl op /(const fl &y) const { return fl(a/y.a); }
};

template <class F>
struct ad
{
  F x,dx;
  ad() : x(0), dx(0) {}
  ad(int y) : x(y), dx(0) {}
  ad(const F &y, F dy=F(0)) : x(y), dx(dy) {}
  ad op +(const ad &y) const { return ad(x+y.x,dx+y.dx); }
  ad op -(const ad &y) const { return ad(x-y.x,dx-y.dx); }
  ad op *(const ad &y) const { return ad(x*y.x,dx*y.x+x*y.dx); }
  ad op / (const ad &y) const { return ad(x/y.x,(dx*y.x-x*y.dx)/(y.x*y.x)); }
};

template <class F> F rat(const F &x)
{ return (x*F(2)+pow(x,2)*F(3)+pow(x,6)*F(7)+pow(x,11)*F(5)+F(1))/
    (x*F(5)-pow(x,3)*F(6)-pow(x,7)*F(3)+F(2)); }

template <class F, class fun>
F newton(F x0, int n, fun &g)
{
  ad<F> val; int i;
  for(i=0;i<n;i++) { val=g(ad<F>(x0,F(1))); x0=x0-val.x/val.dx; }
  return x0;
}

template <class F> struct sqrfinder
{ ad<F> op () (const ad<F> &z) { return sqr(z)-ad<F>(2); } };
template <class F> struct ratfinder
{ ad<F> op () (const ad<F> &z) { return rat(z); } };

template <class F, class fun>
struct trapezoid_method_rooter
{
  fun g;
  ad<F> g0;
  F y0,t0,t1;
  trapezoid_method_rooter(fun &G, const F &Y0, const F &T0, const F &T1) :
    g(G),y0(Y0),t0(T0),t1(T1),g0(G(T0,Y0)) {}
  ad<F> op () (const ad<F> &y1)
  { return (g(ad<F>(t1),y1)+g0)*((t1-t0)/F(2))+ad<F>(y0)-y1; }
};

template <class F, class fun>
F trapezoid_method(F t0, const F &dt, F y0, fun &g, int numsteps)
{
  int i;
  for(i=0;i<numsteps;i++)
    {
      trapezoid_method_rooter<F,fun> solver(g,y0,t0,t0+dt);
      y0=newton(y0,10,solver); t0=t0+dt;
    }
  return y0;
}

string pr(double x) { char s[100]; sprintf(s,"%.12e",x); return string(s); }
string pr(const fl &x) {
  char s[100];
  sprintf(s,"%.2e",x.a);
  return string(s);
}

template <class F>
string pr(const complex<F> &x) { return pr(real(x))+" "+pr(imag(x)); }
template <class F>
ostream & op <<(ostream &o, const ad<F> &x) {
  return o<<pr(x.x)<<" "<<pr(x.dx);
}

template <class F>
struct sqrintegrand { F op () (const F &t, const F &y) { return sqr(y); } };
template <class F>
struct ratintegrand { F op () (const F &t, const F &y) { return rat(y)-t; } };

template <class F>
void integrate_functions(F x0, int n)
{
  sqrintegrand<ad<F> > i1;
  ratintegrand<ad<F> > i2;
  cout<<"i1 "<<pr(trapezoid_method(F(1),F(1)/F(n),x0,i1,n))
    <<"\ni2 "<<pr(trapezoid_method(F(1),F(1)/F(n),x0,i2,n))<<"\n";
}

int main(int argc, char *argv[])
{
  int N=(argc==2)?(atoi(argv[1])):50;
  sqrfinder<double> mysqrt; ratfinder<double> myratt;
  double x(newton(-1.0,6,myratt));
  cout<<"rational_taylor_series: "<<rat(ad<double>(0.25,1.0))<<endl;
  cout<<"newton-sqrt_2: "<<pr(newton(1.0,10,mysqrt))<<endl;
  cout<<"newton-rat: "<<pr(x)<<endl;
  integrate_functions(0.02,N*4);
  integrate_functions(fl(0.02),N);
  integrate_functions(complex<double>(0.02,0.02),N);
  integrate_functions(complex<fl>(fl(0.02),fl(0.02)),N);
  return 0;
}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/

// Copy task division idea from Java entry, contributed by James McIlree
// Contributed by The Anh Tran

#include <omp.h>
#include <sched.h>

#include <algorithm>
#include <vector>
#include <iostream>
#include <sstream>
#include <stdio.h>

//#include <ext/hash_map>
//#include <boost/unordered_map.hpp>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>

#include <boost/algorithm/string/case_conv.hpp>
#include <boost/lambda/lambda.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/format.hpp>
#include <boost/foreach.hpp>
#define foreach BOOST_FOREACH


typedef unsigned int   uint;

int const MAX_CORE = 16;
uint const SEED = 183; //183 193 405 <= zero collision for hashing algorithm


// Hash_table key type, with key's length = reading_frame_size
template <int frm_sz>
struct Key_T
{
   uint   hash_value;
   char   key[frm_sz +1];

   Key_T()             {   memset(this, 0, sizeof(*this));      }
   Key_T(Key_T const& k)   {   memcpy(this, &k, sizeof(*this));   }
   Key_T(char const * str)   {   ReHash (str);   }

   void 
   ReHash(char const *str)
   {
      // naive hashing algorithm.
      hash_value = 0;

      for (int i = 0; i < frm_sz; ++i)
      {
         key[i] = str[i];
         hash_value = (hash_value * SEED) + str[i];
      }
   }


   // Hash functor Hash<HKey_T>
   uint 
   operator() (const Key_T &k) const   {   return k.hash_value;   }


   // Comparison functor equal_to<HKey_T>(Left, Right)
   bool 
   operator() (const Key_T &k1, const Key_T &k2) const
   {
      if (k1.hash_value == k2.hash_value)
      {
         for (int i = 0; i < frm_sz; ++i)
         {
            if ( __builtin_expect((k1.key[i] != k2.key[i]), false) )
            {
               //++collision;
               return false;   
            }
         }
         return true;
      }
      return false;
   }
};


// Game's rule: function to update hashtable
template <int hash_len, bool MT, typename Input_T, typename HTable_T>
void 
calculate_frequency(Input_T const &input, HTable_T& hash_table)
{
   hash_table.clear();
   int   const total_length = static_cast<int>(input.size() - hash_len +1);

   typedef typename Input_T::const_pointer   Ite_T;
   Ite_T const   ite_beg   = &(input[0]);
   Ite_T const   ite_end   = &(input[0]) + total_length;

   typename HTable_T::key_type key;

   if (MT)
   {
      static int char_done[hash_len] = {0};
      int const chunk_sz = std::max(512, std::min(1024*1024, total_length / omp_get_num_threads() / 128));
      int ichunk;

      for(int offset = 0; offset < hash_len; ++offset)
      {
         // Fetch task. Each thread hashes a block, which block size = chunk
         while ( (ichunk = __sync_fetch_and_add(char_done + offset, chunk_sz)) < total_length )
         {
            Ite_T ite   = ite_beg + ichunk + offset;
            Ite_T end   = std::min(ite_beg + ichunk + chunk_sz, ite_end);
         
            for (; ite < end; ite += hash_len)
            {
               key.ReHash(ite);
               ++(hash_table[key]);
            }
         }
      }
   }
   else
   {
      for(int offset = 0; offset < hash_len; ++offset)
      {
         for (Ite_T index = ite_beg + offset; index < ite_end; index += hash_len)
         {
            key.ReHash(index);
            ++(hash_table[key]);
         }
      }
   }
}


// Build a hash_table, count all key with hash_len = 1, 2
// write the code and percentage frequency
template <int hash_len, typename Input_T>
void 
write_frequencies(Input_T const &input, std::ostream &output)
{
   typedef Key_T<hash_len>         HKey_T;

   //typedef __gnu_cxx::hash_map <
   //typedef boost::unordered_map <
   typedef __gnu_pbds::cc_hash_table   <
                                 HKey_T,   // key type
                                 uint,   // map type
                                 HKey_T,   // hash functor
                                 HKey_T   // equal_to functor
                              >    HTable_T;


   static HTable_T hash_table[MAX_CORE];

   // parallel hashing. Each thread updates its own hash_table.
   if (omp_get_num_threads() > 1)
      calculate_frequency<hash_len, true>(input, hash_table[omp_get_thread_num()]);
   else
      calculate_frequency<hash_len, false>(input, hash_table[omp_get_thread_num()]);


   // only the last thread, reaching this code block, to process result
   static int thread_passed = 0;
   if (__sync_add_and_fetch(&thread_passed, 1) == omp_get_num_threads())
   {
      // merge thread local results to main hash_table
      HTable_T &merge_table (hash_table[0]);

      for (int i = 1; i < omp_get_num_threads(); ++i)
      {
         foreach (typename HTable_T::value_type const & e, hash_table[i])
            merge_table[e.first] += e.second;
      }
      
   
      typedef std::pair<HKey_T, uint>   HValue_T;
      typedef std::vector<HValue_T>    List_T;

      // Copy results from hash_table to list
      List_T order_table(merge_table.begin(), merge_table.end());

      {
         // Sort with descending frequency
         using namespace boost::lambda;
         std::sort(   order_table.begin(), order_table.end(),
            ( !(bind(&HValue_T::second, _1) < bind(&HValue_T::second, _2)) )   );
      }

      float const total_char = static_cast<float>(input.size() - hash_len +1);
      boost::format fmt("%|1$s| %|2$0.3f|\n");

      foreach(typename List_T::value_type &e, order_table)
      {
         e.first.key[hash_len] = 0; // ensure proper null terminated
         boost::to_upper(e.first.key);

         float percent = static_cast<float>(e.second) * 100.0f / total_char;
         fmt % e.first.key % percent;

         output << fmt;
      }

      output << std::endl;
      thread_passed = 0;
   }
}


// Build a hash_table, count all key with hash_len = 3, 4, 6, 12, 18
// Then print a specific sequence's count
template <int hash_len, typename Input_T>
void 
write_frequencies(Input_T const &input, std::ostream &output, char const *specific)
{
   typedef Key_T<hash_len>      HKey_T;
   typedef __gnu_pbds::cc_hash_table   <
                                 HKey_T,   // key type
                                 uint,   // map type
                                 HKey_T,   // hash functor
                                 HKey_T   // equal_to functor
                              >    HTable_T;

   HTable_T local_table;   // private for each thread
   if (omp_get_num_threads() > 1)
      calculate_frequency<hash_len, true>(input, local_table);   // parallel hash
   else
      calculate_frequency<hash_len, false>(input, local_table);   // parallel hash

   // Build hash key for searching
   HKey_T printkey(specific);

   // count how many matched for specific sequence
   static uint total_matched = 0;
   
   {
      // parallel look up
      uint match = local_table[printkey];
      #pragma omp atomic
      total_matched += match;
   }

   // The last thread, reaching this code block, will print result
   static int thread_passed = 0;
   if (__sync_add_and_fetch(&thread_passed, 1) == omp_get_num_threads())
   {
      printkey.key[hash_len] = 0; // null terminated
      boost::to_upper(printkey.key);

      boost::format fmt("%1%\t%2%\n");
      fmt % total_matched % printkey.key;
      output << fmt;

      thread_passed = 0;
      total_matched = 0;
   }
}

int 
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < MAX_CORE; ++i)
   {
      if (CPU_ISSET(i, &cs))
         ++count;
   }
   return count;
}

int 
main()
{
   typedef std::vector<char> Input_T;
   Input_T input;
   input.reserve(256*1024*1024); // 256MB

   char buffer[64];

   // rule: read line-by-line
   while (fgets(buffer, sizeof(buffer), stdin))
   {
      if(strncmp(buffer, ">THREE", 6) == 0)
         break;
   }

   std::back_insert_iterator<Input_T> back_ite (input);
   while (fgets(buffer, sizeof(buffer), stdin))
   {
      size_t sz = strlen(buffer);
      if (buffer[sz -1] == '\n')
         --sz;

      std::copy(buffer, buffer + sz, back_ite);
   }

   std::ostringstream output[7];
   #pragma omp parallel num_threads(GetThreadCount()) default(shared)
   {
      write_frequencies<18>( input, output[6], "ggtattttaatttatagt" );
      write_frequencies<12>( input, output[5], "ggtattttaatt" );
      write_frequencies< 6>( input, output[4], "ggtatt" );
      write_frequencies< 4>( input, output[3], "ggta" );
      write_frequencies< 3>( input, output[2], "ggt" );
      write_frequencies< 2>( input, output[1] );
      write_frequencies< 1>( input, output[0] );
   }

   foreach(std::ostringstream const& s, output)
      std::cout << s.str();
      
   return 0;
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Contributed by Andrew Moon
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>

#include <sched.h>
#include <pthread.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>

typedef unsigned long long u64;
typedef unsigned int u32;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned char u8;

using namespace std;

struct CPUs {
  CPUs() {
    cpu_set_t cs;
    CPU_ZERO( &cs );
    sched_getaffinity( 0, sizeof(cs), &cs );
    count = 0;
    for ( size_t i = 0; i < CPU_SETSIZE; i++ )
      count += CPU_ISSET( i, &cs ) ? 1 : 0;
    count = std::max( count, u32(1) );
  }

  u32 count;
} cpus;


/*
  Smart selection of u32 or u64 based on storage needs

  PreferU64 will use u32 if (size == 4 && system = 32bit), otherwise u64.
*/

template< int N > struct TypeSelector;
template<> struct TypeSelector<4> { enum { bits = 32, }; typedef u32 tint; };
template<> struct TypeSelector<8> { enum { bits = 64, }; typedef u64 tint; };

template< int N > struct PreferU64 { 
  enum { bits = TypeSelector<8>::bits }; 
  typedef typename TypeSelector<8>::tint tint;
};

template<> struct PreferU64<4> {
  enum { selector = sizeof(u32 *) };
  enum { bits = TypeSelector<selector>::bits }; 
  typedef TypeSelector<selector>::tint tint;
};

typedef TypeSelector<sizeof(int *)>::tint tint;

/*
  DNASource handles enum defs we're interested in and extracting
  DNA sequences from a packed DNA stream (2 bits per nucleotide)

  Will use 64 bits for the state on 64bit machines, otherwise
  32/64 bits depending on the size of the DNA sequence

  left0 = # of nucleotides left in state
  left1 = # of nucleotides left in the upcoming tstore, lower[1]
*/

template< int N >
struct DNASource {
  enum {
    completedwords = N / 4,
    partialbytes = N & 3,
    storagedwords = ( N + 15 ) / 16,
    storagebytes = storagedwords * 4,

    bits = PreferU64<storagebytes>::bits,
    maxsequences = bits / 2,
    sequencebits = N * 2,
  };
  typedef typename TypeSelector<storagebytes>::tint tint;
  typedef typename PreferU64<storagebytes>::tint tstore;

  DNASource( const char *data, u32 offset ) : in(data) {
    const u32 partial = offset & ( maxsequences - 1 );
    lower = (tstore *)data + ( offset / maxsequences );
    const u32 rshift = partial * 2, lshift = bits - rshift;    
    state = ( partial ) ? ( lower[0] >> rshift ) | ( lower[1] << lshift ) : lower[0];
    left0 = maxsequences;
    left1 = lshift / 2;
  }

  inline void extractto( tint &out ) {
    // reload if needed
    if ( ( N > maxsequences / 2 ) || ( left0 < N ) ) {
      s32 want = maxsequences - left0;
      state |= ( lower[1] >> ( ( maxsequences - left1 ) * 2 ) ) << ( left0 * 2 );
      if ( left1 > want ) {
        left1 -= want;
      } else {
        lower++;
        left1 += left0;
      }
      if ( left1 != maxsequences )
        state |= ( lower[1] << ( left1 * 2 ) );
      left0 = maxsequences;
    }

    // load the nucleotides
    if ( sequencebits != bits ) {
      tstore shift = sequencebits, mask = ( tstore(1) << shift ) - 1;
      out = tint(state & mask);
    } else {
      out = tint(state);
    }
    state >>= ( N * 2 );
    left0 -= N;
  }

protected:
  const char *in;
  s32 left0, left1;
  tstore state, *lower;
};

/*
  A packed DNA key. Each nucleotide is packed down to 2 bits (we only have
  4 to keep track of).

  0000:0xx0 are the bits we want. A,C,G,T and a,c,g,t both map to the same
  four values with this bitmask, but not in alphabetical order. Convert
  the key to a string to sort!
*/

template< int N >
struct Key {
  typedef typename DNASource<N>::tint tint;

  struct Ops {
    enum { bucket_size = 4, min_buckets = 8 };
    // hash
    u32 operator() ( const Key &k ) const {
      if ( N <= 4 ) {
        return u32(~k);
      } else if ( N <= 16 ) {
        u8 shift = N / 2;
        return u32(~k + ( ~k >> shift ));
      } else {
        u8 shift = N / 2;
        return u32(~k + ( ~k >> 13 ) + ( ~k >> shift ));
      }
    }

    // equals
    bool operator() ( const Key &a, const Key &b ) const { return ~a == ~b; }
  };

  Key() {}

  // packing this way isn't efficient, but called rarely
  Key( const char *in ) : packed(0) {
    u8 *bytes = (u8 *)&packed;
    for ( int i = 0; i < N; i++ )
      bytes[i/4] |= ( ( *in++ >> 1 ) & 0x3 ) << ( ( i % 4 ) * 2 );
  }

  // up to 2 instances active at once
  const char *tostring() const {
    static char names[2][N+1], table[4] = { 'A', 'C', 'T', 'G' };
    static u32 on = 0;
    u64 bits = packed;
    on ^= 1;
    for ( int i = 0; i < N; i++, bits >>= 2 )
      names[on][i] = table[bits & 3];
    names[on][N] = 0;
    return names[on];
  }

  // for sorting
  bool operator< ( const Key &b ) const {
    return strcmp( tostring(), b.tostring() ) < 0;
  }

  // direct access
  tint &operator~ () { return packed; }
  const tint &operator~ () const { return packed; }

protected:
  tint packed;
};

// hash table wrapper
template< int N >
  class KeyHash :
    public __gnu_pbds::cc_hash_table <
      Key<N>, // key
      u32, // value
      typename Key<N>::Ops, // hash
      typename Key<N>::Ops // equality
    > {};

static const u32 lengths[] = { 18, 12, 6, 4, 3, 2, 1 }, numLengths = 7;
static const u32 lineLength = 60;

/*
  A DNA block to analyze. Requires a single block of memory to
  hold the block for efficiency. Block starts at 32mb and grows
  exponentially
*/

struct Block {
  Block() : data(NULL), count(0), alloc(32 * 1048576) {
    data = (char *)realloc( data, alloc );
  }

  ~Block() { free( data ); }

  // read the block in until the end of the sequence or a new sequence starts
  void read() {
    char buffer[lineLength + 2];
    buffer[lineLength] = -1;
    while ( fgets_unlocked( buffer, lineLength + 2, stdin ) ) {
      if ( buffer[0] == '>' )
        return;
      // -1 trick should keep us from calling strlen
      if ( buffer[lineLength] != 0xa )
        return addline( buffer, int(strlen( buffer )) - 1 );
      addline( buffer, lineLength );
      buffer[lineLength] = -1;
    }
  }

  // read lines until we get a match
  bool untilheader( const char *match ) {
    size_t len = strlen( match );
    const u32 *in = (const u32 *)data, *want = (const u32 *)match;
    while ( fgets_unlocked( data, alloc, stdin ) )
      if ( ( *in == *want ) && ( memcmp( data, match, len ) == 0 ) )
        return true;
    return false;
  }

  int getcount() const { return count; }
  char *getdata() { return data; }

protected:
  // convert a string of input to packed DNA
  void addline( const char *buffer, int bytes ) {
    if ( ( ( count + bytes ) / 4 ) > alloc ) {
      alloc *= 2;
      data = (char *)realloc( data, alloc );
    }
    const u32 *in = (const u32 *)buffer;
    u8 *out = (u8 *)( data + count / 4 );
    // 00000dd0:00000cc0-00000bb0:00000aa0 -> ddccbbaa
    for ( int i = bytes / 4; i; i-- ) {
      u32 conv = ( *in++ >> 1 ) & 0x03030303;
      *out++ = conv | ( conv >> 6 ) | ( conv >> 12 ) | ( conv >> 18 );
    }
    buffer = (const char *)in;
    for ( int i = bytes & 3, shift = 0; i; i--, shift += 2 )
      *out |= ( (unsigned )( *buffer++ & 6 ) >> 1 ) << (shift & 7);
    count += bytes;
  }

  char *data;
  int count, alloc;
};

/*
  Queue hands out work states to process
  
  st holds two u16 values, the current offset in the sequence, and the
  current length of the sequence
*/

struct Queue {
  Queue() : st(0) {}

  bool get( u32 &sequence, u32 &offset ) {
    while ( true ) {
      u32 cur = st;
      if ( ( cur >> 16 ) == numLengths )
        return false;

      // try to claim the next set
      if ( __sync_val_compare_and_swap( &st, cur, nextstate( cur ) ) != cur )
        continue;

      // it's ours
      sequence = lengths[cur >> 16];
      offset = cur & 0xffff;
      return true;
    }
  }

  u32 nextstate( u32 cur ) {
    u16 offset = ( cur & 0xffff ), length = ( cur >> 16 );
    if ( ++offset == lengths[length] ) {
      offset = 0;
      length++;
    }
    return ( length << 16 ) | offset;
  }

protected:
  volatile u32 st;
};


struct Worker {
  Worker() {}

  template< int N, class Hash >
  void process( Hash &hash ) {
    Key<N> key;
    DNASource<N> source( block->getdata(), offset );
    for ( int i = block->getcount() - offset; i >= N; i -= N ) {
      source.extractto( ~key );
      hash[key]++;
    }
  }

  void run() {
    while ( workQueue->get( length, offset ) ) {
      switch ( length ) {
        case 1: process<1>( hash1 ); break;
        case 2: process<2>( hash2 ); break;
        case 3: process<3>( hash3 ); break;
        case 4: process<4>( hash4 ); break;
        case 6: process<6>( hash6 ); break;
        case 12: process<12>( hash12 ); break;
        case 18: process<18>( hash18 ); break;
        default: break;
      }
    }
  }

  void join() { pthread_join( handle, 0 ); }
  void start( Queue *queue, Block *in ) {
    workQueue = queue;
    block = in;
    pthread_create( &handle, 0, Worker::thread, this );
  }
  static void *thread( void *arg ) { ((Worker *)arg)->run(); return 0; }

  pthread_t handle;
  Block *block;
  Queue *workQueue;
  u32 length, offset;

  KeyHash<18> hash18;
  KeyHash<12> hash12;
  KeyHash<6> hash6;
  KeyHash<4> hash4;
  KeyHash<3> hash3;
  KeyHash<2> hash2;
  KeyHash<1> hash1;
};

template< int N, class W > KeyHash<N> &Get( W &w );

template<> KeyHash<1> &Get( Worker &w ) { return w.hash1; }
template<> KeyHash<2> &Get( Worker &w ) { return w.hash2; }
template<> KeyHash<3> &Get( Worker &w ) { return w.hash3; }
template<> KeyHash<4> &Get( Worker &w ) { return w.hash4; }
template<> KeyHash<6> &Get( Worker &w ) { return w.hash6; }
template<> KeyHash<12> &Get( Worker &w ) { return w.hash12; }
template<> KeyHash<18> &Get( Worker &w ) { return w.hash18; }

template< int N >
void printcount( Worker *workers, const char *key ) {
  Key<N> find( key );
  u32 count = 0;
  for ( u32 i = 0; i < cpus.count; i++ )
    count += Get<N>( workers[i] )[find];
  cout << count << '\t' << find.tostring() << endl;
}

template<class T>
struct CompareFirst {
  bool operator() ( const T &a, const T &b ) { return a.first < b.first; }
};

template<class T>
struct CompareSecond {
  bool operator() ( const T &a, const T &b ) { return a.second > b.second; }
};


template< int N >
void printfreq( Worker *workers ) {
  cout.setf( ios::fixed, ios::floatfield );
  cout.precision( 3 );

  u32 count = 0;
  KeyHash<N> sum;
  for ( u32 i = 0; i < cpus.count; i++ ) {
    KeyHash<N> &hash = Get<N>( workers[i] );
    typename KeyHash<N>::iterator iter = hash.begin(), end = hash.end();
    for ( ; iter != end; ++iter ) {
      count += iter->second;
      sum[iter->first] += iter->second;
    }
  }

  typedef pair< Key<N>, u32 > sequence;
  vector<sequence> seqs( sum.begin(), sum.end() );
  stable_sort( seqs.begin(), seqs.end(), CompareFirst<sequence>() ); // by name
  stable_sort( seqs.begin(), seqs.end(), CompareSecond<sequence>() ); // by count

  typename vector<sequence>::iterator iter = seqs.begin(), end = seqs.end();
  for ( ; iter != end; ++iter )
    cout <<  iter->first.tostring() << " " << (100.0f * iter->second / count) << endl;
  cout << endl;
}


int main( int argc, const char *argv[] ) {
  Block *block = new Block();
  if ( !block->untilheader( ">THREE" ) )
    return -1;
  block->read();

  Queue workQueue;
  Worker *workers = new Worker[cpus.count];
  for ( u32 i = 0; i < cpus.count; i++ )
    workers[i].start( &workQueue, block );
  for ( u32 i = 0; i < cpus.count; i++ )
    workers[i].join();

  printfreq<1>( workers );
  printfreq<2>( workers );

  printcount<3>( workers, "ggt" );
  printcount<4>( workers, "ggta" );
  printcount<6>( workers, "ggtatt" );
  printcount<12>( workers, "ggtattttaatt" );
  printcount<18>( workers, "ggtattttaatttatagt" );

  delete[] workers;
  return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Contributed by Andrew Moon
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>

#include <sched.h>
#include <pthread.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>

typedef unsigned long long u64;
typedef unsigned int u32;
typedef signed int s32;
typedef unsigned short u16;
typedef unsigned char u8;

using namespace std;

struct CPUs {
   CPUs() {
      cpu_set_t cs;
      CPU_ZERO( &cs );
      sched_getaffinity( 0, sizeof(cs), &cs );
      count = 0;
      for ( size_t i = 0; i < CPU_SETSIZE; i++ )
         count += CPU_ISSET( i, &cs ) ? 1 : 0;
      count = std::max( count, u32(1) );
   }

   u32 count;
} cpus;


/*
   Smart selection of u32 or u64 based on storage needs

   PreferU64 will use u32 if (size == 4 && system = 32bit), otherwise u64.
*/

template< u32 N > struct TypeSelector;
template<> struct TypeSelector<4> { enum { bits = 32, }; typedef u32 tint; };
template<> struct TypeSelector<8> { enum { bits = 64, }; typedef u64 tint; };

template< u32 N > struct PreferU64 { 
   enum { bits = TypeSelector<8>::bits }; 
   typedef typename TypeSelector<8>::tint tint;
};

template<> struct PreferU64<4> {
   enum { selector = sizeof(u32 *) };
   enum { bits = TypeSelector<selector>::bits }; 
   typedef TypeSelector<selector>::tint tint;
};

/*
   DNASource handles enum defs we're interested in and extracting
   DNA sequences from an -unpacked- DNA stream

   Will use 64 bits for the state on 64bit machines, otherwise
   32/64 bits depending on the size of the DNA sequence

   All reads from the unpacked stream are dword aligned

   left0 = # of nucleotides left in state
   left1 = # of nucleotides left in the upcoming tstore, lower[1]
*/

template< u32 N >
struct DNASource {
   enum {
      completedwords = N / 4,
      partialbytes = N & 3,
      storagedwords = ( N + 15 ) / 16,
      storagebytes = storagedwords * 4,

      bits = PreferU64<storagebytes>::bits,
      bytes = bits / 8,
      maxsequences = bits / 2,
      sequencebits = N * 2,
   };
   typedef typename TypeSelector<storagebytes>::tint tint;
   typedef typename PreferU64<storagebytes>::tint tstore;

   DNASource( const char *data, const u32 offset ) : in(data) {
      const u32 partial = offset & ( maxsequences - 1 );
      const u32 rshift = partial * 2, lshift = bits - rshift;
      in += ( offset / maxsequences );
      pack(0); pack(1);
      state = ( partial ) ? ( lower[0] >> rshift ) | ( lower[1] << lshift ) : lower[0];
      left0 = maxsequences;
      left1 = lshift / 2;
   }

   void pack( const u32 slot ) {
      u8 *out = (u8 *)&lower[slot];

      // 00000dd0:00000cc0-00000bb0:00000aa0 -> ddccbbaa
      for ( u32 i = 0; i < bytes; i++, in += 4 ) {
         u32 conv = ( *(const u32 *)in >> 1 ) & 0x03030303;
         *out++ = conv | ( conv >> 6 ) | ( conv >> 12 ) | ( conv >> 18 );
      }
   }

   inline void getandadvance( tint &out, const u32 increment = N ) {
      // reload if needed
      if ( ( N > maxsequences / 2 ) || ( left0 < N ) ) {
         u32 want = maxsequences - left0;
         state |= ( lower[1] >> ( ( maxsequences - left1 ) * 2 ) ) << ( left0 * 2 );
         if ( left1 > want ) {
            left1 -= want;
         } else {
            lower[0] = lower[1];
            left1 += left0;
            pack(1); // need more state in lower1
         }
         if ( left1 != maxsequences )
            state |= ( lower[1] << ( left1 * 2 ) );
         left0 = maxsequences;
      }

      // load the nucleotides
      if ( sequencebits != bits ) {
         tstore shift = sequencebits, mask = ( tstore(1) << shift ) - 1;
         out = tint(state & mask);
      } else {
         out = tint(state);
      }
      state >>= ( increment * 2 );
      left0 -= increment;
   }

protected:
   const char *in;
   u32 left0, left1;
   tstore state, lower[2];
};

/*
   A packed DNA key. Each nucleotide is packed down to 2 bits (we only have
   4 to keep track of).

   0000:0xx0 are the bits we want. A,C,G,T and a,c,g,t both map to the same
   four values with this bitmask, but not in alphabetical order. Convert
   the key to a string to sort!
*/

template< u32 N >
struct Key {
   typedef typename DNASource<N>::tint tint;

   struct Ops {
      // hash
      u32 operator() ( const Key &k ) const {
         if ( N <= 4 ) {
            return u32(~k);
         } else if ( N <= 16 ) {
            u8 shift = N / 2;
            return u32(~k + ( ~k >> shift ));
         } else {
            u8 shift = N / 2;
            return u32(~k + ( ~k >> 13 ) + ( ~k >> shift ));
         }
      }

      // equals
      bool operator() ( const Key &a, const Key &b ) const { return ~a == ~b; }
   };

   Key() {}

   // packing this way isn't efficient, but called rarely
   Key( const char *in ) : packed(0) {
      u8 *bytes = (u8 *)&packed;
      for ( u32 i = 0; i < N; i++ )
         bytes[i/4] |= ( ( *in++ >> 1 ) & 0x3 ) << ( ( i % 4 ) * 2 );
   }

   // up to 2 instances active at once
   const char *tostring() const {
      static char names[2][N+1], table[4] = { 'A', 'C', 'T', 'G' };
      static u32 on = 0;
      u64 bits = packed;
      on ^= 1;
      for ( u32 i = 0; i < N; i++, bits >>= 2 )
         names[on][i] = table[bits & 3];
      names[on][N] = 0;
      return names[on];
   }

   // for sorting
   bool operator< ( const Key &b ) const {
      return strcmp( tostring(), b.tostring() ) < 0;
   }

   // direct access
   tint &operator~ () { return packed; }
   const tint &operator~ () const { return packed; }

protected:
   tint packed;
};

// hash table wrapper
template< u32 N >
   class KeyHash :
      public __gnu_pbds::cc_hash_table <
         Key<N>, // key
         u32, // value
         typename Key<N>::Ops, // hash
         typename Key<N>::Ops // equality
      > {};

static const u32 lengths[] = { 1, 2, 3, 4, 6, 12, 18 }, numLengths = 7;
static const u32 lineLength = 60;

/*
   For sequences <= sequentialMax, process them sequentially in one pass
   instead of splitting them in to multiple tasks

   Things stay fast until 9, where processing sequentially really kills
   performance for some reason I have no figured out!
*/

static const u32 sequentialMax = 8;

/*
   A DNA block to analyze. Requires a single block of memory to
   hold the block for efficiency. Block starts at 4mb and grows
   exponentially
*/

struct Block {
   Block() : data(NULL), count(0), alloc(4 * 1048576) {
      data = (char *)realloc( data, alloc );
   }

   ~Block() { free( data ); }

   // read the block in until the end of the sequence or a new sequence starts
   void read() {
      data[lineLength] = -1;
      while ( fgets_unlocked( data + count, lineLength + 2, stdin ) ) {
         if ( data[count] == '>' )
            return;
         
         // -1 trick should keep us from calling strlen
         if ( data[count + lineLength] != 0xa ) {
            count += u32(strlen( data + count )) - 1;
            data = (char *)realloc( data, count + 64 * 2 );
            return;
         }

         count += lineLength;
         if ( ( ( count + lineLength ) ) > alloc ) {
            alloc *= 2;
            data = (char *)realloc( data, alloc );
         }

         data[count + lineLength] = -1;
      }
   }

   // read lines until we get a match
   bool untilheader( const char *match ) {
      size_t len = strlen( match );
      const u32 *in = (const u32 *)data, *want = (const u32 *)match;
      while ( fgets_unlocked( data, alloc, stdin ) )
         if ( ( *in == *want ) && ( memcmp( data, match, len ) == 0 ) )
            return true;
      return false;
   }

   u32 getcount() const { return count; }
   char *getdata() { return data; }

protected:
   char *data;
   u32 count, alloc;
};

/*
   Queue hands out work states to process
   
   st holds two u16 values, the current offset in the sequence, and the
   current length of the sequence
*/

struct Queue {
   Queue() : st(0) {}

   bool get( u32 &sequence, u32 &offset ) {
      while ( true ) {
         u32 cur = st;
         if ( ( cur >> 16 ) == numLengths )
            return false;

         // try to claim the next set
         if ( __sync_val_compare_and_swap( &st, cur, nextstate( cur ) ) != cur )
            continue;

         // it's ours
         sequence = lengths[cur >> 16];
         offset = cur & 0xffff;
         return true;
      }
   }

   u32 nextstate( u32 cur ) {
      u16 offset = ( cur & 0xffff ), length = ( cur >> 16 );
      if ( ( lengths[length] <= sequentialMax ) || ( ++offset == lengths[length] ) ) {
         offset = 0;
         length++;
      }
      return ( length << 16 ) | offset;
   }

protected:
   volatile u32 st;
};


struct Worker {
   Worker() {}

   template< u32 N, class Hash >
   void process( Hash &hash ) {
      Key<N> key;
      DNASource<N> source( block->getdata(), offset );
      const u32 advance = ( N <= sequentialMax ) ? 1 : N;
      for ( u32 i = block->getcount() - offset; i >= N; i -= advance ) {
         source.getandadvance( ~key, advance );
         hash[key]++;
      }
   }

   void run() {
      while ( workQueue->get( length, offset ) ) {
         switch ( length ) {
            case 1: process<1>( hash1 ); break;
            case 2: process<2>( hash2 ); break;
            case 3: process<3>( hash3 ); break;
            case 4: process<4>( hash4 ); break;
            case 6: process<6>( hash6 ); break;
            case 12: process<12>( hash12 ); break;
            case 18: process<18>( hash18 ); break;
            default: break;
         }
      }
   }

   void join() { pthread_join( handle, 0 ); }
   void start( Queue *queue, Block *in ) {
      workQueue = queue;
      block = in;
      pthread_create( &handle, 0, Worker::thread, this );
   }
   static void *thread( void *arg ) { ((Worker *)arg)->run(); return 0; }

   pthread_t handle;
   Block *block;
   Queue *workQueue;
   u32 length, offset;

   KeyHash<18> hash18;
   KeyHash<12> hash12;
   KeyHash<6> hash6;
   KeyHash<4> hash4;
   KeyHash<3> hash3;
   KeyHash<2> hash2;
   KeyHash<1> hash1;
};

template< u32 N, class W > KeyHash<N> &Get( W &w );

template<> KeyHash<1> &Get( Worker &w ) { return w.hash1; }
template<> KeyHash<2> &Get( Worker &w ) { return w.hash2; }
template<> KeyHash<3> &Get( Worker &w ) { return w.hash3; }
template<> KeyHash<4> &Get( Worker &w ) { return w.hash4; }
template<> KeyHash<6> &Get( Worker &w ) { return w.hash6; }
template<> KeyHash<12> &Get( Worker &w ) { return w.hash12; }
template<> KeyHash<18> &Get( Worker &w ) { return w.hash18; }

template< u32 N >
void printcount( Worker *workers, const char *key ) {
   Key<N> find( key );
   u32 count = 0;
   for ( u32 i = 0; i < cpus.count; i++ )
      count += Get<N>( workers[i] )[find];
   cout << count << '\t' << find.tostring() << endl;
}

template<class T>
struct CompareFirst {
   bool operator() ( const T &a, const T &b ) { return a.first < b.first; }
};

template<class T>
struct CompareSecond {
   bool operator() ( const T &a, const T &b ) { return a.second > b.second; }
};


template< u32 N >
void printfreq( Worker *workers ) {
   cout.setf( ios::fixed, ios::floatfield );
   cout.precision( 3 );

   u32 count = 0;
   KeyHash<N> sum;
   for ( u32 i = 0; i < cpus.count; i++ ) {
      KeyHash<N> &hash = Get<N>( workers[i] );
      typename KeyHash<N>::iterator iter = hash.begin(), end = hash.end();
      for ( ; iter != end; ++iter ) {
         count += iter->second;
         sum[iter->first] += iter->second;
      }
   }

   typedef pair< Key<N>, u32 > sequence;
   vector<sequence> seqs( sum.begin(), sum.end() );
   stable_sort( seqs.begin(), seqs.end(), CompareFirst<sequence>() ); // by name
   stable_sort( seqs.begin(), seqs.end(), CompareSecond<sequence>() ); // by count

   typename vector<sequence>::iterator iter = seqs.begin(), end = seqs.end();
   for ( ; iter != end; ++iter )
      cout <<   iter->first.tostring() << " " << (100.0f * iter->second / count) << endl;
   cout << endl;
}


int main( int argc, const char *argv[] ) {
   Block *block = new Block();
   if ( !block->untilheader( ">THREE" ) )
      return -1;
   block->read();

   Queue workQueue;
   Worker *workers = new Worker[cpus.count];
   for ( u32 i = 0; i < cpus.count; i++ )
      workers[i].start( &workQueue, block );
   for ( u32 i = 0; i < cpus.count; i++ )
      workers[i].join();

   printfreq<1>( workers );
   printfreq<2>( workers );

   printcount<3>( workers, "ggt" );
   printcount<4>( workers, "ggta" );
   printcount<6>( workers, "ggtatt" );
   printcount<12>( workers, "ggtattttaatt" );
   printcount<18>( workers, "ggtattttaatttatagt" );

   delete[] workers;

   return 0;
}
// -*- mode: c++ -*-
// $Id: lists.gpp,v 1.2 2004-11-30 07:10:03 bfulgham Exp $
// http://shootout.alioth.debian.org/
// from Bill Lear, with improvements by Thomas Hyer
//
// 08-16-2004:  Revised by the Gwydion Dylan Maintainers to use
//   the Deque class, which provides a realistic implementation
//   of this test (i.e., with good performance).

#include <algorithm>
#include <iostream>
#include <deque>
#include <numeric>
#if (defined(__INTEL_COMPILER))
#define __gnu_cxx std
#else
#include <ext/numeric>
#endif

using namespace std;

const size_t SIZE = 10000;

size_t test_lists() {
    std::deque<size_t> li1(SIZE);

    __gnu_cxx::iota(li1.begin(), li1.end(), 1);

    std::deque<size_t> li2(li1), li3;

    while (! li2.empty()) {
        li3.push_back(li2.front());
        li2.pop_front();
    }

    while (! li3.empty()) {
        li2.push_back(li3.back());
        li3.pop_back();
    }

    //li1.reverse();
    reverse(li1.begin(), li1.end());

    return (li1.front() == SIZE) && (li1 == li2) ? li1.size() : 0;
}

int main(int argc, char* argv[]) {
    size_t ITER = (argc == 2 ? (atoi(argv[1]) < 1 ? 1 : atoi(argv[1])): 1);

    size_t result = 0;
    while (ITER > 0) {
        result = test_lists();
        --ITER;
    }

    std::cout << result << std::endl;
}
/*   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Paolo Bonzini
   further optimized by Jason Garrett-Glaser
   OpenMP by The Anh Tran
*/

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sched.h>
#include <memory.h>

// need "-fopenmp" flag when compile
#include <omp.h>

#define L2_CACHE_LINE   64
#define BYTE_A_TIME      L2_CACHE_LINE
#define COLUMN_FETCH    (BYTE_A_TIME * 8)


typedef double   v2d   __attribute__ ((vector_size(16))); // vector of two doubles

const v2d v10   = { 1.0, 1.0 };
const v2d v15   = { 1.5, 1.5 };
const v2d v40   = { 4.0, 4.0 };

v2d inv_2n;   // {2.0/N, 2.0/N}
v2d inv_4n;   // {4.0/N, 4.0/N}


int 
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < CPU_SETSIZE; ++i)
   {
      if (CPU_ISSET(i, &cs))
         ++count;
   }
   return count;
}


struct MB_Element
{
private:
   v2d   Crv, Civ, Zrv, Ziv, Trv, Tiv;
   
public:
   // Z1 is point [x, y],   Z2 is point [x+1, y]
   // r = 3 <=> |Z2| <= 4   |Z1| <= 4
   // r = 2 <=> |Z2| > 4   |Z1| <= 4
   // r = 1 <=> |Z2| <= 4   |Z1| > 4
   // r = 0 <=> |Z2| > 4    |Z1| > 4
   int result;
   
   // construct 2 elements from C.real & C.img
   // C.real = Coordinate.x * 2 / N -1.5
   // C.img = Coordinate.y * 2 / N -1.0
   MB_Element(int r, v2d cimg)
   {
      double tmp[2] = {r+1, r};
      Crv = __builtin_ia32_loadupd(tmp);
      
      Crv = Crv * inv_2n - v15;
      Civ = cimg;

      Zrv = Crv;
      Ziv = cimg;

      Trv = Crv * Crv;
      Tiv = cimg * cimg;

      result = 3; // assume that 2 elements belong to MB set
   }

   // construct 2 elements, next to passed MB_Element object
   // Passed object: Tuple(Z1 = {x, y}, Z2 = {x+1, y})
   // Newly construct object: Tuple({x+2, y}, {x+3, y})
   MB_Element(MB_Element const& o)
   {
      Crv = o.Crv + inv_4n;   // c2 = (c1+2)*N = c1*N + 2*N
      Civ = o.Civ;
      
      Zrv = Crv;
      Ziv = o.Ziv;
      
      Trv = Crv * Crv;
      Tiv = o.Tiv;
      
      result = 3;
   }

   int
   eval()
   {
      v2d ZZ = Zrv * Ziv;
      Zrv = Trv - Tiv + Crv;
      Ziv = ZZ + ZZ + Civ;
      Trv = Zrv * Zrv;
      Tiv = Ziv * Ziv;

      // delta = (Trv + Tiv) <= 4.0 ? 0xff : 0x00
      v2d delta = (v2d)__builtin_ia32_cmplepd( (Trv + Tiv), v40 );
      // mask-out elements that goes outside MB set
      result &= __builtin_ia32_movmskpd(delta);

      return result;
   }
};

void 
mandelbrot(int N, char* data)
{
   // counter of each line, how many columns are processed
   __attribute__ ((aligned(L2_CACHE_LINE))) int jobs[N];
   memset(jobs, 0, sizeof(jobs));

   #pragma omp parallel default(shared) firstprivate(data) num_threads(GetThreadCount())
   {
      // foreach line
      for (int y = 0; y < N; ++y, data += (N >> 3)) 
      {
         // Calculate C.img = y*2/N -1.0
         v2d Civ = {y, y};
         Civ = Civ * inv_2n - v10;

         // Divide task for each thread here:
         // claim that me (this thread) will handle K-not-yet-process columns
         // K/8 bytes output should fit cache line size.
         int x;
         while ((x = __sync_fetch_and_add(jobs + y, COLUMN_FETCH)) < N)
         {
            int limit = std::min(x +COLUMN_FETCH, N);
            // unroll loop, evaluate 8 columns at once
            for (; x < limit; x += 8)
            {
               // each MB_Element represents 2 mandelbrot points
               MB_Element   e1(x, Civ), e2(e1), e3(e2), e4(e3);
               
               int i = 1;
               while ( (e1.result || e2.result || e3.result || e4.result) 
                     && (i++ < 50) )
               {
                  e1.eval();
                  e2.eval();
                  e3.eval();
                  e4.eval();
               }   
               
               int byte_acc = (e1.result << 6)|(e2.result << 4)|(e3.result << 2)|e4.result;
               data[x >> 3] = static_cast<char>(byte_acc);
            } // end foreach (column)
         }
      } // end foreach (line)
   } // end parallel region
}


int 
main (int argc, char **argv)
{
   int N = (argc == 2) ? atoi(argv[1]) : 200;
   assert((N % 8) == 0);

   printf("P4\n%d %d\n", N, N);
   int width_bytes = N >> 3;

   {
      double t[2];
      t[0] = t[1] = 2.0 / N;
      inv_2n = __builtin_ia32_loadupd(t);
      inv_4n = inv_2n + inv_2n;   // 4.0/N
   }

   char* data = 0;
   assert(   posix_memalign(reinterpret_cast<void**>(&data), L2_CACHE_LINE, width_bytes * N)
         == 0);

   mandelbrot(N, data);

   fwrite( data, width_bytes, N, stdout);
   free(data);

   return 0;
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Greg Buchholz
   compile:  g++ -O3
*/

#include <stdio.h>
#include <stdlib.h>
#include<iostream>
#include<complex>

int main (int argc, char **argv)
{
  char  bit_num = 0, byte_acc = 0;
  const int iter = 50;
  const double lim = 2.0 * 2.0;
  
  std::ios_base::sync_with_stdio(false);
  int n = atoi(argv[1]);

  std::cout << "P4\n" << n << " " << n << std::endl;

  for(int y=0; y<n; ++y) 
    for(int x=0; x<n; ++x)
    {
       std::complex<double> Z(0,0),C(2*(double)x/n - 1.5, 2*(double)y/n - 1.0);
       
       //manually inlining "norm" results in a 5x-7x speedup on gcc
       for(int i=0; i<iter and Z.real()*Z.real() + Z.imag()*Z.imag() <= lim; ++i)
         Z = Z*Z + C;
        
       byte_acc = (byte_acc << 1) | ((norm(Z) > lim) ? 0x00:0x01);

       if(++bit_num == 8){ std::cout << byte_acc; bit_num = byte_acc = 0; }
       else if(x == n-1) { byte_acc  <<= (8-n%8);
                           std::cout << byte_acc;
                           bit_num = byte_acc = 0; }
    }
}
/*   
   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Paolo Bonzini
   further optimized by Jason Garrett-Glaser
   OpenMP by The Anh Tran
   10-11-2010, modified by The Anh Tran:
      _ remove builtin function
      _ copy bit shift idea from C entry
*/

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sched.h>
#include <memory.h>

#include <omp.h>
#include <sys/types.h>

#define L2_CACHE_LINE   64
#define ALIGN         __attribute__ ((aligned(L2_CACHE_LINE)))


typedef unsigned char   byte;
typedef double         v2d   __attribute__ ((vector_size(16)));
typedef int32_t       v4i   __attribute__ ((vector_size(16)));

const v2d v10      = { 1.0, 1.0 };
const v2d v15      = { 1.5, 1.5 };
const v2d v40      = { 4.0, 4.0 };

v2d inv_2n;   // {2.0/N, 2.0/N}


int
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < CPU_SETSIZE; ++i)
      count += CPU_ISSET(i, &cs);

   return count;
}


void
mandelbrot(int N, byte* data)
{
   ALIGN int row_processed = 0;

   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      int y = 0;
      while ((y = __sync_fetch_and_add(&row_processed, 1)) < N)
      {
         byte* row_output = data + y * (N >> 3);
         
         v2d Civ = {y, y};
         Civ = Civ * inv_2n - v10;

            for (int x = 0; x < N; x += 2)
            {
            v2d   Crv = {x+1, x};
            Crv = Crv * inv_2n - v15;
            v2d Zrv = Crv;
            v2d Ziv = Civ;
            v2d Trv = Crv * Crv;
            v2d Tiv = Civ * Civ;

            int result = 3; // assume that 2 elements belong to MB set
            int i = 1;

            while ( result && (i++ < 50) )
            {
               v2d ZZ = Zrv * Ziv;
               Zrv = Trv - Tiv + Crv;
               Ziv = ZZ + ZZ + Civ;
               Trv = Zrv * Zrv;
               Tiv = Ziv * Ziv;

               {
                  // trv + tiv <= 4.0
                  v2d delta = v40 - (Trv + Tiv);
                  v4i db = reinterpret_cast<v4i>(delta);
                  
                  const int32_t* pb = reinterpret_cast<const int32_t*>(&db);
                  result = (pb[1] >= 0) | ((pb[3] >= 0) << 1);
               }            
            }

            {
               int bit_shift = 6 - (x & 7);
               row_output[x >> 3] |= static_cast<byte>(result << bit_shift);
            }
         }
      }
   }
}


int
main (int argc, char **argv)
{
   const int N = (argc == 2) ? std::atoi(argv[1]) : 200;
   assert((N % 8) == 0);
   printf("P4\n%d %d\n", N, N);

   {
      double* p_iv = reinterpret_cast<double*>(&inv_2n);
      p_iv[0] = p_iv[1] = 2.0 / N;
   }

   const int bytes_count = (N >> 3) * N;
   byte* data = 0;
   assert(   posix_memalign(reinterpret_cast<void**>(&data), L2_CACHE_LINE, bytes_count)
         == 0);
   memset(data, 0, bytes_count);

   mandelbrot(N, data);

   fwrite( data, bytes_count, 1, stdout);
   fflush(stdout);
   free(data);

   return 0;
}

/*   
   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Paolo Bonzini
   further optimized by Jason Garrett-Glaser
   OpenMP by The Anh Tran
   10-11-2010, modified by The Anh Tran:
      _ copy bit shift idea from C entry
*/

#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sched.h>
#include <memory.h>

#include <omp.h>
#include <sys/types.h>

#define L2_CACHE_LINE   64
#define ALIGN         __attribute__ ((aligned(L2_CACHE_LINE)))


typedef unsigned char   byte;
typedef double         v2d   __attribute__ ((vector_size(16)));
typedef int32_t       v4i   __attribute__ ((vector_size(16)));

const v2d v10      = { 1.0, 1.0 };
const v2d v15      = { 1.5, 1.5 };
const v2d v40      = { 4.0, 4.0 };

v2d inv_2n;   // {2.0/N, 2.0/N}


int
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < CPU_SETSIZE; ++i)
      count += CPU_ISSET(i, &cs);

   return count;
}


void
mandelbrot(int N, byte* data)
{
   ALIGN int row_processed = 0;

   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      int y = 0;
      while ((y = __sync_fetch_and_add(&row_processed, 1)) < N)
      {
         byte* row_output = data + y * (N >> 3);
         
         v2d Civ = {y, y};
         Civ = Civ * inv_2n - v10;

            for (int x = 0; x < N; x += 2)
            {
            v2d   Crv = {x+1, x};
            Crv = Crv * inv_2n - v15;
            v2d Zrv = Crv;
            v2d Ziv = Civ;
            v2d Trv = Crv * Crv;
            v2d Tiv = Civ * Civ;

            int result = 3; // assume that 2 elements belong to MB set
            int i = 1;

            while ( result && (i++ < 50) )
            {
               v2d ZZ = Zrv * Ziv;
               Zrv = Trv - Tiv + Crv;
               Ziv = ZZ + ZZ + Civ;
               Trv = Zrv * Zrv;
               Tiv = Ziv * Ziv;
           
               // trv + tiv <= 4.0
               v2d delta = (v2d)__builtin_ia32_cmplepd( (Trv + Tiv), v40 );
               result = __builtin_ia32_movmskpd(delta);              
            }

            {
               int bit_shift = 6 - (x & 7);
               row_output[x >> 3] |= static_cast<byte>(result << bit_shift);
            }
         }
      }
   }
}


int
main (int argc, char **argv)
{
   const int N = (argc == 2) ? std::atoi(argv[1]) : 200;
   assert((N % 8) == 0);
   printf("P4\n%d %d\n", N, N);

   {
      double* p_iv = reinterpret_cast<double*>(&inv_2n);
      p_iv[0] = p_iv[1] = 2.0 / N;
   }

   const int bytes_count = (N >> 3) * N;
   byte* data = 0;
   assert(   posix_memalign(reinterpret_cast<void**>(&data), L2_CACHE_LINE, bytes_count)
         == 0);
   memset(data, 0, bytes_count);

   mandelbrot(N, data);

   fwrite( data, bytes_count, 1, stdout);
   fflush(stdout);
   free(data);

   return 0;
}

// -*- mode: c++ -*-
// $Id: matrix.gpp-2.gpp,v 1.1 2004-11-10 06:47:57 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/
// from katsuo2

#include <iostream> 
#include <vector> 
#include <stdlib.h> 

using namespace std; 

class CMatrix 
{ 
private: 
    vector<vector<int> > m; 
    int m_Rows, m_Cols; 
public: 
    CMatrix(int rows, int cols); 
    void Clear(); 
    friend CMatrix operator*(const CMatrix &m1, const CMatrix &m2); 
    friend ostream& operator<<(ostream &o, const CMatrix &m); 
}; 

int main(int argc, char *argv[]) { 
    int n = ((argc == 2) ? atoi(argv[1]) : 1); 
    const int size = 30; 
    
    CMatrix m1(size, size), m2(size, size), mm(size, size); 
    for (int i = 0; i < n; i++) { 
	mm = m1 * m2; 
    } 
    cout << mm << endl; 
    return EXIT_SUCCESS; 
} 

CMatrix::CMatrix(int rows, int cols) 
    : m_Rows(rows), m_Cols(cols), m(rows) 
{ 
    int count(1); 
    for (int i = 0; i < rows; i++){ 
	m[i].resize(cols); 
	for (int j = 0; j < cols; j++) { 
	    m[i][j] = count++; 
	} 
    } 
} 

void CMatrix::Clear() 
{ 
    for (int i = 0; i < m_Rows; i++) 
	for (int j = 0; j < m_Cols; j++) 
	    m[i][j] = 0; 
} 

CMatrix operator*(const CMatrix &m1, const CMatrix &m2) 
{ 
    //assert(m1.m_Rows==m2.m_Rows && m1.m_Cols==m2.m_Cols); 
    CMatrix result(m1.m_Rows, m1.m_Cols); 
    for (int i = 0; i < m1.m_Rows; i++) { 
	for (int j = 0; j < m1.m_Cols; j++) { 
	    int val(0); 
	    for (int k = 0; k < m1.m_Cols; k++) { 
		val += m1.m[i][k] * m2.m[k][j]; 
	    } 
	    result.m[i][j] = val; 
	} 
    } 
    return result; 
} 

ostream& operator<<(ostream &o, const CMatrix &mm) 
{ 
    return o << mm.m[0][0] << " " << mm.m[2][3] << " " << mm.m[3][2] << " " << mm.m[4][4]; 
} 
// -*- mode: c++ -*-
// $Id: matrix.gpp-3.gpp,v 1.1 2004-11-10 06:47:57 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/
// with help from Thomas Hyer

#include <iostream>
#include <stdlib.h>

#include <vector>
#include <numeric>
using std::vector;
using std::inner_product;

using namespace std;

#define SIZE 30

int **mkmatrix(int rows, int cols) {
    int i, j, count = 1;
    int **m = (int **) malloc(rows * sizeof(int *));
    for (i=0; i<rows; i++) {
	m[i] = (int *) malloc(cols * sizeof(int));
	for (j=0; j<cols; j++) {
	    m[i][j] = count++;
	}
    }
    return(m);
}

void zeromatrix(int rows, int cols, int **m) {
    int i, j;
    for (i=0; i<rows; i++)
	for (j=0; j<cols; j++)
	    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
    while (--rows > -1) { free(m[rows]); }
    free(m);
}

int** mmult(int rows, int cols, int** m1, int** m2, int** m3) {
	vector<int> col2(cols);
	for (int j = 0; j < cols; ++j) {
		for (int k = 0; k < cols; ++k) {
			col2[k] = m2[k][j];
		}
		for (int i = 0; i < rows; ++i) {
			m3[i][j] = inner_product(col2.begin(), col2.end(), 
m1[i], 0.0);
		}
	}
	return m3;
}

int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
	
    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (i=0; i<n; i++) {
	mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
    cout << mm[0][0] << " " << mm[2][3] << " " << mm[3][2] << " " << mm[4][4] << endl;

    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
    return(0);
}
// -*- mode: c++ -*-
// $Id: matrix.gpp,v 1.2 2004-11-30 07:10:04 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <iostream>
#include <stdlib.h>

using namespace std;

#define SIZE 30
typedef int* int_ptr;

int **mkmatrix(int rows, int cols) {
    int j, count = 1;
    int **m = new int_ptr [rows];
    for (int i=0; i<rows; i++) {
	m[i] = new int[ cols ];
	for (j=0; j<cols; j++) {
	    m[i][j] = count++;
	}
    }
    return(m);
}

void zeromatrix(int rows, int cols, int **m) {
    int i, j;
    for (i=0; i<rows; i++)
	for (j=0; j<cols; j++)
	    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
    while (--rows > -1) { delete[] m[rows]; }
    delete[] m;
}

int **mmult(int rows, int cols, int **m1, int **m2, int **m3) {
    int j,k,val;
    for (int i=0; i<rows; i++) {
	for (j=0; j<cols; j++) {
	    val = 0;
	    for (k=0; k<cols; k++) {
		val += m1[i][k] * m2[k][j];
	    }
	    m3[i][j] = val;
	}
    }
    return(m3);
}

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
	
    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (int i=0; i<n; i++) {
	mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
    cout << mm[0][0] << " " << mm[2][3] << " " << mm[3][2] << " " << mm[4][4] << endl;

    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
    return(0);
}
/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * Contributed by Branimir Maksimovic
 */

#include <pthread.h>
#include <errno.h>
#include <cstdlib>
#include <iostream>
#include <ostream>
#include <deque>
using namespace std;

#define STACK_SIZE 65536

extern "C"
{
  static void* thread_run(void*);
}

class Mutex{
public:
  Mutex()
  {
    pthread_mutex_init(&m,0);
  }
  void lock()
  {
    pthread_mutex_lock(&m);
  }
  void unlock()
  {
    pthread_mutex_unlock(&m);
  }
  ~Mutex()
  {
    pthread_mutex_destroy(&m);
  }
private:
  Mutex(const Mutex&);
  Mutex& operator=(const Mutex&);
  pthread_mutex_t m;
  friend class Cond;
};

class Cond{
public:
  Cond()
  {
    pthread_cond_init(&c,0);
  }
  void wait(Mutex& m)
  {
    pthread_cond_wait(&c,&m.m);
  }
  void signal()
  {
    pthread_cond_signal(&c);
  }

  ~Cond()
  {
    pthread_cond_destroy(&c);
  }
private:
  Cond(const Cond&);
  Cond& operator=(const Cond&);
  pthread_cond_t c;
};

struct Sum{
int sum;
int increments;
Mutex m;
Cond c;
}gs;

class Thread{
public:
  Thread(Thread* t=0)
  :next_(t),message(0),stop_(false)
  {
  }

  Thread* next(){ return next_; }

  void start()
  {
    pthread_attr_t attrs;
    pthread_attr_init(&attrs);
    pthread_attr_setstacksize(&attrs,STACK_SIZE);
    while(int err = pthread_create(&tid,&attrs,thread_run,this))
    {
      if(err == EAGAIN)
      {
        cout<<"pthread create EAGAIN...\n";
        sleep(1);
      }
      else exit(EXIT_FAILURE);
    }
  }
  void join()
  {
    pthread_join(tid,0);
  }
  void stop()
  {
    mutex.lock();
    stop_=true;
    monitor.signal();
    mutex.unlock();
  }

  void push(int msg)
  {
    mutex.lock();
    message.push_front(msg);
    monitor.signal();
    mutex.unlock();
  }

  int run()
  {
    while(true)
    {
      mutex.lock();
      while(message.empty() && !stop_)monitor.wait(mutex);
      if(stop_)
      {
        mutex.unlock();
        break;
      }  
      if(next_)
      {
        next_->mutex.lock();
        next_->message.push_front(message.back()+1);
        next_->monitor.signal();
        next_->mutex.unlock();
      }
      else
      {
        gs.m.lock();
        gs.sum+=message.back()+1;
        gs.increments++;
        gs.c.signal();
        gs.m.unlock();
      }
      message.pop_back();
      mutex.unlock();
    }
    return 0;
  }

private:
  Cond monitor;
  Mutex mutex;
  Thread* next_;
  deque<int> message;
  pthread_t tid;
  bool stop_;
};

extern "C"
{
  static void* thread_run(void* t)
  {
    return (void*)((Thread*)t)->run();
  }
}

int main(int argc, char* argv[])
{
  int N=1;
  gs.sum=0;
  gs.increments=0;
  const int NTHREADS = 500;
  if(argc>1)N=atoi(argv[1]);

  Thread *first=0,*tmp=new Thread();
  tmp->start();
  for(int i=1;i<NTHREADS;++i)
  {
    first = new Thread(tmp);
    tmp = first;
    first->start();
  }

  for(int i=0;i<N;++i)
  {
    first->push(0);
  }

  gs.m.lock();
  while(gs.increments<N)gs.c.wait(gs.m);
  gs.m.unlock();

  tmp = first;

  while(tmp)
  {
    tmp->stop();
    tmp=tmp->next();
  }

  Thread* tmp1 = first;
  while(tmp1)
  {
    tmp1->join();
    tmp = tmp1;
    tmp1=tmp1->next();
    delete tmp;
  }
  cout<<gs.sum<<'\n';
}
//   The Computer Language Shootout
//   http://shootout.alioth.debian.org/
//   contributed by Paul Kitchin
//   compile with -lpthread

#include <iostream>
#include <sstream>
#include <pthread.h>
#include <semaphore.h>

unsigned int const number_of_threads = 500;
unsigned int const thread_stack_size = 100 * 1024;
unsigned int number_of_messages_per_thread;
unsigned int message_total;

sem_t signals[number_of_threads][2];
unsigned int volatile messages[number_of_threads];

void * thread_function(void * argument)
{
   unsigned int thread_id = reinterpret_cast< unsigned int >(argument);
   sem_t & thread_signal_1(signals[thread_id][0]);
   sem_t & thread_signal_2(signals[thread_id][1]);
   unsigned int volatile & thread_message(messages[thread_id]);
   unsigned int messages_received = 0;
   if (thread_id + 1 != number_of_threads)
   {
      sem_t & next_thread_signal_1(signals[thread_id + 1][0]);
      sem_t & next_thread_signal_2(signals[thread_id + 1][1]);
      unsigned int volatile & next_thread_message(messages[thread_id + 1]);
      while (messages_received != number_of_messages_per_thread)
      {
         sem_wait(&thread_signal_2);
         sem_wait(&next_thread_signal_1);
         next_thread_message = thread_message + 1;
         thread_message = 0;
         sem_post(&next_thread_signal_2);
         sem_post(&thread_signal_1);
         ++messages_received;
      }
   }
   else
   {
      while (messages_received != number_of_messages_per_thread)
      {
         sem_wait(&thread_signal_2);
         message_total += thread_message + 1;
         thread_message = 0;
         sem_post(&thread_signal_1);
         ++messages_received;
      }
   }
   return 0;
}

int main(int argc, char * * argv)
{
   if (argc != 2)
   {
      std::cout << "Usage: " << argv[0] << " <n>\n";
      return 1;
   }
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> number_of_messages_per_thread) || !convertor.eof())
      {
         std::cout << "Usage: " << argv[0] << " <n>\n";
         std::cout << "\tn must be an integer\n";
         return 1;
      }
   }
   pthread_attr_t thread_attributes;
   if (pthread_attr_init(&thread_attributes) != 0 || pthread_attr_setstacksize(&thread_attributes, thread_stack_size) != 0)
   {
      std::cout << "pthread attribute error\n";
      return 1;
   }
   pthread_t threads[number_of_threads];
   for (unsigned int thread_number = 0; thread_number < number_of_threads; ++thread_number)
   {
      if (sem_init(&signals[thread_number][0], 0, 1) != 0 || sem_init(&signals[thread_number][1], 0, 0) != 0)
      {
         std::cout << thread_number << "pthread semaphore creation error\n";
         return 1;
      }
      if (pthread_create(&threads[thread_number], &thread_attributes, thread_function, reinterpret_cast< void * >(thread_number)) != 0)
      {
         std::cout << thread_number << "pthread thread creation error\n";
         return 1;
      }
   }
   for (unsigned int message_number = 0; message_number < number_of_messages_per_thread; ++message_number)
   {
      sem_wait(&signals[0][0]);
      messages[0] = 0;
      sem_post(&signals[0][1]);
   }
   for (unsigned int thread_number = 0; thread_number < number_of_threads; ++thread_number)
   {
      void * return_value;
      if (pthread_join(threads[thread_number], &return_value) != 0)
      {
         std::cout << "pthread thread completion error\n";
         return 1;
      }
      sem_destroy(&signals[thread_number][0]);
      sem_destroy(&signals[thread_number][1]);
   }
   std::cout << message_total << '\n';
}
//   The Computer Language Shootout
//   http://shootout.alioth.debian.org/
//   contributed by Paul Kitchin

#include <iostream>
#include <list>
#include <sstream>

namespace threads
{

   class thread;

   struct thread_parameter
   {

      thread_parameter(unsigned int id, thread * next_thread)
         :
         id(id),
         next_thread(next_thread)
      {
      }

      unsigned int id;
      thread * next_thread;

   };

   class thread
   {

      public:

         thread(unsigned int (*function)(thread_parameter const &), thread_parameter const & arguments)
            :
            stack_top_(reinterpret_cast< std::size_t >(stack_ + (sizeof(stack_) / sizeof(unsigned int)))),
            function_(function),
            arguments_(arguments),
            running_(true)
         {
         }

         std::size_t stack_top() const
         {
            return stack_top_;
         }

         bool terminated() const
         {
            return !running_;
         }

      private:

         std::size_t stack_top_;
         unsigned int (*function_)(thread_parameter const &);
         thread_parameter arguments_;
         bool running_;
         unsigned int stack_[128];

   };

   std::list< thread * > waiting_threads;
   thread main_thread_object(0, thread_parameter(0, 0));
   thread * current_thread = &main_thread_object;

   std::size_t yield_thread()
   {
      return waiting_threads.front()->stack_top();
   }

   void schedule_thread()
   {
      current_thread = waiting_threads.front();
      waiting_threads.pop_front();
   }

   void yield();

   void naked()
   {
      asm
      (
         "_ZN7threads5yieldEv:\n\t"
         "pusha\n\t"
         "pushf\n\t"
         "mov   _ZN7threads14current_threadE, %eax\n\t"
         "mov   %esp, (%eax)\n\t"
         "call   _ZN7threads12yield_threadEv\n\t"
         "mov   %eax, %esp\n\t"
         "popf\n\t"
         "popa\n\t"
         "call   _ZN7threads15schedule_threadEv\n\t"
         "ret\n"
         "_ZN7threads21thread_start_functionEv:\n\t"
         "pusha\n\t"
         "pushf\n\t"
         "mov   %esp, (%eax)\n\t"
         "mov   %ebx, %esp\n\t"
         "ret\n"
         "_ZN7threads12thread_startEv:\n\t"
         "mov   %esp, %ebx\n\t"
         "mov   (%eax), %esp\n\t"
         "call   _ZN7threads21thread_start_functionEv\n\t"
         "subl   $4, %esp\n\t"
         "movl   _ZN7threads14current_threadE, %eax\n\t"
         "leal   8(%eax), %ecx\n\t"
         "movl   %ecx, (%esp)\n\t"
         "call   *4(%eax)\n\t"
         "movl   _ZN7threads14current_threadE, %edx\n\t"
         "movb   $0, 16(%edx)\n\t"
         "call   _ZN7threads5yieldEv\n\t"
         "ret\n"
      );
   }

   thread * create_thread(unsigned int (*thread_function)(thread_parameter const &), thread_parameter const & parameters)
   {
      thread * thread_ = new thread(thread_function, parameters);
      asm
      (
         "push   %%eax\n\t"
         "push   %%ebx\n\t"
         "add   $8, %%esp\n\t"
         "mov   %0, %%eax\n\t"
         "sub   $8, %%esp\n\t"
         "call   _ZN7threads12thread_startEv\n\t"
         "pop   %%ebx\n\t"
         "pop   %%eax"
         :
         :
         "m"(thread_)
      );
      return thread_;
   }

   void resume(thread * thread)
   {
      waiting_threads.push_back(thread);
   }

   void suspend()
   {
      yield();
   }

   void join(thread * thread)
   {
      while (!thread->terminated())
      {
         yield();
      }
      delete thread;
   }

}

unsigned int const number_of_threads = 500;
unsigned int number_of_messages_per_thread;
unsigned int message_total = 0;

unsigned int volatile messages[number_of_threads];

unsigned int thread_function(threads::thread_parameter const & parameters)
{
   using namespace threads;
   unsigned int volatile & thread_message(messages[parameters.id]);
   unsigned int messages_received = 0;
   if (parameters.id + 1 != number_of_threads)
   {
      unsigned int volatile & next_thread_message(messages[parameters.id + 1]);
      while (messages_received != number_of_messages_per_thread)
      {
         next_thread_message = thread_message + 1;
         thread_message = 0;
         ++messages_received;
         resume(parameters.next_thread);
         if (messages_received != number_of_messages_per_thread)
         {
            suspend();
         }
      }
   }
   else
   {
      while (messages_received != number_of_messages_per_thread)
      {
         message_total += thread_message + 1;
         thread_message = 0;
         ++messages_received;
         resume(parameters.next_thread);
         if (messages_received != number_of_messages_per_thread)
         {
            suspend();
         }
      }
   }
   return 0;
}

int main(int argc, char * * argv)
{
   using namespace threads;
   if (argc != 2)
   {
      std::cout << "Usage: " << argv[0] << " <n>\n";
      return 1;
   }
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> number_of_messages_per_thread) || !convertor.eof())
      {
         std::cout << "Usage: " << argv[0] << " <n>\n";
         std::cout << "\tn must be an integer\n";
         return 1;
      }
   }
   thread * threads[number_of_threads + 1];
   threads[number_of_threads] = &main_thread_object;
   for (unsigned int thread_number = number_of_threads; thread_number != 0;)
   {
      thread_parameter thread_parameters(thread_number - 1, threads[thread_number]);
      --thread_number;
      threads[thread_number] = create_thread(thread_function, thread_parameters);
   }
   for (unsigned int message_number = 0; message_number < number_of_messages_per_thread; ++message_number)
   {
      messages[0] = 0;
      resume(threads[0]);
      suspend();
   }
   for (unsigned int thread_number = 0; thread_number < number_of_threads; ++thread_number)
   {
      join(threads[thread_number]);
   }
   std::cout << message_total << '\n';
}
// The Computer Language Benchmarks Game
//  http://shootout.alioth.debian.org
//  contributed by Kevin Barnes

#include <memory.h>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <vector>
#include <string>
#include <set>

using namespace std;

#define WEST 0
#define EAST 1
#define SW 2
#define SE 3
#define NW 4
#define NE 5

#define BIT ((long long)1)

// constant masks
const long long row_mask = (long long)31;
const long long full_mask = (BIT << 50) - 1;
const long long row_masks[] = { row_mask, row_mask << 5, row_mask << 10, row_mask << 15, row_mask << 20, row_mask << 25, row_mask << 30,
row_mask << 35, row_mask << 40, row_mask << 45 };
const long long all_even_rows = row_masks[0] | row_masks[2] | row_masks[4] | row_masks[6] | row_masks[8];
const long long all_odd_rows = row_masks[1] | row_masks[3] | row_masks[5] | row_masks[7] | row_masks[9];
const long long all_rows[2] = { all_even_rows, all_odd_rows };

const long long even_left_edges = BIT | (BIT << 10) | (BIT << 20) | (BIT << 30 | (BIT << 40));
const long long odd_left_edges = (BIT << 5) | (BIT << 15) | (BIT << 25) | (BIT << 35) | (BIT << 45);
const long long left_edges = even_left_edges | odd_left_edges;
const long long even_right_edges = even_left_edges << 4;
const long long odd_right_edges = odd_left_edges << 4;
const long long right_edges = left_edges << 4;
const long long top_edge = row_masks[0];
const long long bottom_edge = row_masks[9];

const long long illegal_move_masks[6] = {
   left_edges, right_edges,
   bottom_edge | even_left_edges, bottom_edge | odd_right_edges,
   top_edge | even_left_edges, top_edge | odd_right_edges };

// mapping and bit manipulation
inline int location_of( int row, int col) { return row * 5 + col; }
inline int row_of( int location) { return location / 5; }
inline int col_of( int location) { return location % 5; }
inline long long get_bit( long long value, int pos) { return value & (BIT << pos); }
inline long long get_bit( long long value, int row, int col) { return value & (BIT << location_of(row, col)); }
inline long long has_bit( long long value, int pos) { return get_bit(value, pos) ? true : false; }
inline long long has_bit( long long value, int row, int col) { return get_bit(value, row, col) ? true : false;  }
inline void set_bit( long long &value, int pos) { value |= (BIT << pos); }
inline void set_bit( long long &value, int row, int col) { value |= (BIT << location_of(row, col)); }
inline int get_row( long long mask, int row) { return (int)((mask >> (row * 5)) & row_mask); }

inline long long shift_east( const long long mask) { return mask << 1; }
inline long long shift_west( const long long mask) { return mask >> 1; }
inline long long shift_nw( const long long mask) { return ((mask & all_even_rows) >> 6) | ((mask & all_odd_rows) >> 5); }
inline long long shift_ne( const long long mask) { return ((mask & all_even_rows) >> 5) | ((mask & all_odd_rows) >> 4); }
inline long long shift_sw( const long long mask) { return ((mask & all_even_rows) << 4) | ((mask & all_odd_rows) << 5); }
inline long long shift_se( const long long mask) { return ((mask & all_even_rows) << 5) | ((mask & all_odd_rows) << 6); }
inline long long shift_mask( int direction, const long long mask) {
   switch (direction) {
  case WEST: return shift_west(mask);
  case EAST: return shift_east(mask);
  case SW: return shift_sw(mask);
  case SE: return shift_se(mask);
  case NW: return shift_nw(mask);
   }
   return shift_ne(mask);
}


char const* dir_texts[] =       {"WEST","EAST","SW",  "SE",  "NW",  "NE"  };
int rotation_adder[2][6] = {
   { -1,    1,     4,     5,     -6,    -5   },
   { -1,    1,     5,     6,     -5,    -4   } };

int flip_transform[6] =    { WEST,  EAST,  NW,    NE,    SW,    SE   };
int rotate_transform[6] =  { NW,    SE,    WEST,  SW,    NE,    EAST };
int opposite_transform[6] ={ EAST,  WEST,  NE,    NW,    SE,    SW   };

int two_row_mask = 1024-1;
int bit_counts[32];
int first_bits[32];


typedef struct MaskInfo {
   bool is_legal[2];
   int start;

   MaskInfo() { is_legal[0] = is_legal[1] = true; }
   // bool piece_allowed[10];
};

MaskInfo big_map[1024];

long long flood_fill_actual( long long &mask, const int pos) {
   set_bit(mask, pos);
   if (pos % 5 && !has_bit( mask, pos - 1)) flood_fill_actual( mask, pos - 1);
   if (pos % 5 < 4 && !has_bit( mask, pos + 1)) flood_fill_actual( mask, pos + 1);
   if (pos >= 5) {
      if (!has_bit( mask, pos - 5)) flood_fill_actual( mask, pos - 5);
      if (pos / 10 < 5) {
         if (pos % 5 && !has_bit( mask, mask, pos - 6)) flood_fill_actual( mask, pos - 6);
      } else {
         if (pos % 5 < 4 && !has_bit( mask, mask, pos - 4)) flood_fill_actual( mask, pos - 4);
      }
   }
   if (pos < 45) {
      if (!has_bit( mask, pos + 5)) flood_fill_actual( mask, pos + 5);
      if (pos / 10 < 5) {
         if (pos % 5 && !has_bit( mask, pos + 4)) flood_fill_actual( mask, pos + 4);
      } else {
         if (pos % 5 < 4 && !has_bit( mask, pos + 6)) flood_fill_actual( mask, pos + 6);
      }
   }
   return mask;
}

long long flood_fill_down( long long mask, int row, int col) {
   if (row & row_masks[row]) {
      flood_fill_actual( mask, location_of(row, col));
      return mask;
   }

   while (row < 10 && !(mask & row_masks[row])) {
      mask |= row_masks[row];
      row++;
   }

   if (row < 10) for (int i = row * 5; i < (row + 1) * 5; i++) {
      if (!has_bit( mask, i)) flood_fill_actual( mask, i);
   }
   return mask;
}

long long flood_fill_up( long long mask, int row, int col) {
   if (row & row_masks[row]) {
      flood_fill_actual( mask, location_of(row, col));
      return mask;
   }

   while (row >= 0 && !(mask & row_masks[row])) {
      mask |= row_masks[row];
      row--;
   }

   if (row >= 0) for (int i = row * 5; i < (row + 1) * 5; i++) {
      if (!has_bit( mask, i)) flood_fill_actual( mask, i);
   }
   return mask;
}

typedef struct MaskData {
   long long mask[2];
   int height;
   int min_col[2];
   int max_col[2];

   MaskData() {
      mask[0] = 0;
      mask[1] = 0;
      height = 0;
      min_col[0] = 0;
      min_col[1] = 0;
      max_col[0] = 0;
      max_col[1] = 0;
   }
};

typedef struct RotationData {
   int mask;
   int iMask;
   int cMask;
   int row;
   int positions[5];
   int number;
};

void print_mask( long long mask) {
   for (int row = 0; row < 10; row++) {
      if (row % 2) cout << " ";
      for (int col = 0; col < 5; col++) {
         cout << (get_bit( mask, row, col)?"1":"0") << " ";
      }
      cout << "\n";
   }
   cout << "\n";
}

class LList {
public:
   LList *next;
   LList() { next = NULL; }
};

struct RotationSet {
   int size;
   RotationData rotations[12];

   RotationSet() { size = 0; }

   void add( RotationData &data) { rotations[ size] = data; size++; }
};

class PieceData : public LList {
private:
   void transform( const int matrix [], vector<int> &list ) {
      for (int i = 0; i < list.size(); i++) {
         list[i] = matrix[list[i]];
      }
   }

   int get_offset( vector<int> &directions ) {
      int offset = 0;
      for (int i = 0; i < directions.size(); i++) {
         if (directions[i] == SW || directions[i] == NW || directions[i] == WEST) offset++;
         if (directions[i] == NW || directions[i] == NE) offset += 5;
      }
      return offset;
   }

   MaskData mask_for_directions( vector<int> &directions) {
      MaskData data;

      long long mask = 0;
      int start_offset = get_offset( directions);
      int location = start_offset;
      for (int i = 0; i < directions.size(); i++) {
         set_bit( mask, location);
         int addition = rotation_adder[ (location / 5) % 2 ][ directions[i] ];
         //             int row = location / 5;
         //             int other_row = (location + addition) / 5;
         //             char * error = NULL;
         //             if ((directions[i] == SW || directions[i] == SE) && other_row != row + 1) error = "ERROR moving down!";
         //             if ((directions[i] == NW || directions[i] == NE) && other_row != row - 1) error =  "ERROR moving up!";
         //             if ((directions[i] == EAST || directions[i] == WEST) &&row != other_row) error = "ERROR moving to the side!";
         //             if (error != NULL) {
         //               int opposite = opposite_transform[directions[i]];
         //               if (illegal_move_masks[opposite] & mask) {
         //                  cout << error << " directions = ";
         //                  for (int j = 0; j < directions.size(); j++) cout << dir_texts[directions[j]] << " ";
         //                  cout << " [[[ current direction = " << dir_texts[directions[i]] << "]]]" << " opposite unavailable: " << dir_texts[opposite] << "\n";
         //                  cout << "row = " << row << ", other row = " << other_row <<"\n";
         //                  print_mask( mask);
         //               } else {
         //                  addition = 0;
         //                  mask = shift_mask( opposite, mask);
         //               }
         //             }
         location += addition;
      }
      set_bit( mask, location);

      while (!(mask & top_edge)) {
         if (illegal_move_masks[NW] & mask) {
            if (illegal_move_masks[NE] & mask) cout << "ERROR SHIFTING UPWARD\n";
            else mask = shift_ne(mask);
         } else mask = shift_nw(mask);
      }

      for (int row = 0; mask & row_masks[row]; row++) data.height++;
      while (!(mask & right_edges)) mask = shift_east(mask);
      for (int col_on = 0; !has_bit(mask, 0, col_on); col_on++) data.max_col[0]++;
      while (!(mask & left_edges)) mask = shift_west(mask);
      for (int col_on = 0; !has_bit(mask, 0, col_on); col_on++) data.min_col[0]++;
      data.mask[0] = mask >> data.min_col[0];

      if (mask & illegal_move_masks[SE]) {
         cout << "ERROR SHIFTING DOWNWARD\n";
      } else {
         mask = shift_se( mask);
         while (!(mask & right_edges)) mask = shift_east(mask);
         for (int col_on = 0; !get_bit(mask, 1, col_on); col_on++) data.max_col[1]++;
         while (!(mask & left_edges)) mask = shift_west(mask);
         for (int col_on = 0; !get_bit(mask, 1, col_on); col_on++) data.min_col[1]++;
         data.mask[1] = mask >> (data.min_col[1] + 5);
      }

      //cout << "\nDIRECTIONS: " << directions[0] << directions[1] << directions[2] << directions[3] << " [" << start_offset << "]\n";
      //cout << "height = " << data.height << ", min[0] = " << data.min_col[0] << ", max[0] = " << data.max_col[0] <<
      //   ", min[1] = " << data.min_col[1] << ", max[1] = " << data.max_col[1] << "\n";
      //print_mask( data.mask[1]);
      //exit(0);

      return data;
   }

   void compute_rotation_positions( long long board, RotationData &rotation) {
      int pos = rotation.row * 5;
      for (int num = 0; num < 5; pos++) {
         if (has_bit(board, pos)) {
            rotation.positions[num] = pos;
            num++;
         }
      }
   }

   void add_rotation( long long mask, int row, int col) {
      RotationData rotation;
      rotation.row = row;
      rotation.mask = (int)(mask >> (5 * row));
      rotation.number = number;
      long long board = 0;
      for (int i = 0; i < row; i++) board |= row_masks[i];
      for (int i = 0; i < col; i++) set_bit( board, row, i);
      board |= mask;
      for (int i = 4; i >= 0; i--) {
         if (!has_bit( board, 9, i)) {
            board = flood_fill_up( board, 9, i);
            break;
         }
      }
      if (board == full_mask) {
         rotation.iMask = rotation.mask;
         rotation.cMask = 0;
      } else {
         int count = 0;
         long long cMask = 0;
         for (int pos = location_of(row, col); pos < 50; pos++) {
            if (!has_bit(board,pos)) {
               set_bit(cMask, pos);
               count++;
            }
            if (count >= 5) {
               cMask = 0;
               break;
            }
         }
         rotation.cMask = (int)(cMask >> (5 * row));
         rotation.iMask = rotation.mask | rotation.cMask;
      }

      compute_rotation_positions( mask, rotation);
      rotation_sets[row][col].add( rotation);
   }

   void build_piece( vector<int> &directions) {
      vector<MaskData> base_masks;
      for (int i = 0; i < 2; i++) {
         for (int j = 0; j < 6; j++) {
            base_masks.push_back(mask_for_directions(directions));
            transform( rotate_transform, directions);
         }
         transform( flip_transform, directions);
      }

      for (int mask_on = 0; mask_on < base_masks.size(); mask_on++) {
         MaskData data = base_masks[mask_on];
         for (int row = 0; row <= (10 - data.height); row++) {
            for (int col = data.min_col[row % 2]; col <= data.max_col[row % 2]; col++) {
               long long mask = data.mask[row % 2] << (row * 5 + col);
               long long board = mask;
               if ( row >= 3) board = flood_fill_down( board, 0, 0);
               else board = flood_fill_up( board, 9, 4);
               if (board == full_mask) {
                  add_rotation( mask, row, col);
               } else {
                  int count = 0;
                  for (int t = 0; t < 10; t++) count += bit_counts[ (int)((board >> (t * 5)) & row_masks[0])];
                  if (count % 5 == 0) {
                     add_rotation( mask, row, col);
                  }
               }
            }
         }
      }
   }

public:
   int number;
   RotationSet rotation_sets[10][5];

   PieceData( int d1, int d2, int d3, int d4, int piece_number ) : LList()  {
      number = piece_number;
      vector<int> directions;
      directions.push_back(d1);
      directions.push_back(d2);
      directions.push_back(d3);
      directions.push_back(d4);
      build_piece( directions);
   }

   PieceData( int d1, int d2, int d3, int d4, int d5, int piece_number ) : LList() {
      number = piece_number;
      vector<int> directions;
      directions.push_back(d1);
      directions.push_back(d2);
      directions.push_back(d3);
      directions.push_back(d4);
      directions.push_back(d5);
      build_piece( directions);
   }
};

// GOLBAL VARIABLES MUH-HA-HA-HA
LList *head;
LList *tail;

int num_placed = 0;
int num_found = 0;
int num_to_find = 0;
int tries[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
RotationData *active_rotations[10];
set<string> found_boards;

void create_piece_maps() {
   tail = head = new PieceData( NW, NE, EAST, EAST,  2);
   tail->next = new PieceData( NE, SE, EAST, NE,  7);
   tail = tail->next;
   tail->next = new PieceData( NE, EAST, NE, NW,  1);
   tail = tail->next;
   tail->next = new PieceData( EAST, SW, SW, SE,  6);
   tail = tail->next;
   tail->next = new PieceData( EAST, NE, SE, NE,  5);
   tail = tail->next;
   tail->next = new PieceData( EAST, EAST, EAST, SE,  0);
   tail = tail->next;
   tail->next = new PieceData( NE, NW, SE, EAST, SE,  4);
   tail = tail->next;
   tail->next = new PieceData( SE, SE, SE, WEST,  9);
   tail = tail->next;
   tail->next = new PieceData( SE, SE, EAST, SE,  8);
   tail = tail->next;
   tail->next = new PieceData( EAST, EAST, SW, SE,  3);
   tail = tail->next;
}

void print_board( string board_string) {
   for (int row = 0; row < 10; row++) {
      if (row % 2) cout << " ";
      for (int col = 0; col < 5; col++) cout << board_string[row * 5 + col] << " ";
      cout << "\n";
   }
   cout << "\n";
}

void print_results() {
   cout << num_found << " solutions found\n\n";
   print_board( *found_boards.begin());
   print_board( *found_boards.rbegin());
}

void add_board_string( const char * board_string) {
   string s = board_string;
   if (found_boards.count(s) == 0) {
      found_boards.insert(s);
      num_found++;
      if (num_to_find == num_found) {
         print_results();
         exit(0);
      }
   }
}


void board_found() {
   char board_string[51];
   memset(board_string,'x',51);
   for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 5; j++) {
         board_string[active_rotations[i]->positions[j]] = '0' + active_rotations[i]->number;
      }
   }
   board_string[50] = 0;
   add_board_string( board_string);
   for (int i = 0; i < 25; i++) { char c = board_string[i]; board_string[i] = board_string[49 - i]; board_string[49-i] = c; }
   add_board_string( board_string);
}

void find( int row, int board) {
   while ((board & 31) == 31) {
      row++;
      board >>= 5;
   }
   MaskInfo &info = big_map[board & two_row_mask];
   if (!info.is_legal[row % 2]) return;
   int col = info.start;


   PieceData *start = (PieceData *)head;
   do {
      PieceData *piece = (PieceData *)head;
      head = piece->next;
      piece->next = NULL;
      RotationSet *rotations = &(piece->rotation_sets[row][col]);
      for (int i = rotations->size-1; i >= 0; i--) {
         //tries[num_placed]++;
         RotationData *rotation = &rotations->rotations[i];
         if ((board & rotation->iMask) == rotation->cMask) {
            if (num_placed == 9) {
               active_rotations[num_placed] = rotation;
               board_found();
            } else {
               active_rotations[num_placed] = rotation;
               num_placed++;
               find( row, board | rotation->mask);
               num_placed--;
            }
         }
      }
      if (head == NULL) head = piece;
      else tail->next = piece;
      tail = piece;
   } while (start != head);
}

void find_all() {
   num_found = 0;
   num_placed = 1;
   found_boards.clear();
   PieceData *start = (PieceData *)head;
   for (int odd = 0; odd < 2; odd++) {
      do {
         PieceData *piece = (PieceData *)head;
         head = piece->next;
         piece->next = NULL;
         if (head != start) {
            RotationSet *rotations = &(piece->rotation_sets[0][0]);
            for (int i = rotations->size-1; i >= 0; i--) {
               if (i % 2 == odd) {
                  RotationData *rotation = &rotations->rotations[i];
                  active_rotations[0] = rotation;
                  find( 0, rotation->mask);
               }
            }
         }
         if (head == NULL) head = piece;
         else tail->next = piece;
         tail = piece;
      } while (start != head);
   }
}


void create_utlity_maps() {
   for (int i = 0; i < 32; i++) {
      bit_counts[i] = 0;
      for (int j = 0; j < 5; j++) if ((1 << j) & i) bit_counts[i]++;
      for (first_bits[i] = 0; (1 << first_bits[i]) & i; first_bits[i]++);
   }

   // build starts
   for (int i = 0; i < 1024; i++) big_map[i].start = first_bits[i & 31];

   // build legality
   int legal_count = 0;
   for (int i = 0; i < 1024; i++) {
      for (int odd = 0; odd < 2; odd++) {
         int legal = 2;
         int bit = 1;
         while (legal && bit < 32) {
            if (i & bit) {
               if (legal == 2 && bit > 1 && ((bit >> 1) & i) == 0) legal = 0;
               else legal = 2;
            } else if (legal == 2) {
               if (((bit << 5) & i) == 0) legal = 1;
               else {
                  if (odd) {
                     if ( (bit < 16) && (((bit << 6) & i) == 0)) legal = 1;
                  } else {
                     if ( (bit > 1) && (((bit << 4) & i) == 0)) legal = 1;
                  }
               }
            }
            bit <<= 1;
         }
         if (legal == 2 && ((bit >> 1) & i) == 0) legal = 0;
         big_map[i].is_legal[odd] = legal ? true : false;
         if (legal) legal_count++;
      }
   }
}

int main (int argc, char * const argv[]) {
   num_to_find = 2098;
   if (argc > 1) sscanf(argv[1],"%d", &num_to_find);

   create_piece_maps();
   create_utlity_maps();
   find_all();
   print_results();

   return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
// contributed by Ben St. John

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <string>
#include <memory.h>

using namespace std;

#define FREE(p) {free(p); p = NULL;}

enum {X, Y, N_DIM};
enum {EVEN, ODD, N_PARITY};

typedef unsigned int TUInt32;
typedef unsigned long long TUInt64;
typedef signed char TInt8;

typedef TUInt64 BitVec;

namespace Meteor
{
   static const int N_COL = 5;
   static const int N_ROW = 10;
   static const int N_CELL = N_COL * N_ROW;

   class Piece;

   //------------------------------------

   class Solution
   {
   public:
      static const int NO_PIECE = -1;

      void addPiece(const BitVec & vec, int iPiece);
      void removeLastPiece(void);
      void setCells(void);
      bool lessThan(Solution & r); ///< I don't feel like operator overloading
      string toString(void) const;
      void fill(int val);
      bool isEmpty(void) {return (m_pieces.size() == 0);}
      void spin(Solution & spun);

      Solution(int fillVal);
      Solution() {m_synched = false;}

   private:
      struct SPiece {
         BitVec vec;
         TUInt32 iPiece;
      };
      vector<SPiece> m_pieces;
      TInt8 m_cells[N_ROW][N_COL];
      bool m_synched;
   };

   //------------------------------------

   class Board
   {
   public:
      static const BitVec L_EDGE_MASK =
         (1LL <<  0) | (1LL <<  5) | (1LL << 10) | (1LL << 15) |
         (1LL << 20) | (1LL << 25) | (1LL << 30) | (1LL << 35) |
         (1LL << 40) | (1LL << 45) | (1LL << 50) | (1LL << 55);
      static const BitVec R_EDGE_MASK = L_EDGE_MASK << 4;
      static const BitVec TOP_ROW = 0x1fLL;
      static const BitVec ROW_0_MASK =
         ( TOP_ROW        | (TOP_ROW << 10) | (TOP_ROW << 20) | (TOP_ROW << 30) |
         (TOP_ROW << 40) | (TOP_ROW << 50));
      static const BitVec ROW_1_MASK = ROW_0_MASK << 5;
      static const BitVec BOARD_MASK = (1LL << N_CELL) - 1;

      Board();

      static TUInt32 getIndex(TUInt32 x, TUInt32 y) { return y * N_COL + x;    }
      static bool hasBadFirstRegion(BitVec & toFill);
      static bool hasBadIslands(const BitVec & boardVec);

      void genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 iNextFill, const BitVec & maskNextFill);
      void recordSolution(Solution & s);

      Solution m_curSolution;
      Solution m_minSolution;
      Solution m_maxSolution;
      TUInt32 m_nSolutionFound;
   };

   //------------------------------------

   class Piece
   {
   public:
      struct Instance {
         BitVec m_vec;
         BitVec m_allowed;
         TUInt32 m_offset;
         TUInt32 m_w;
         TUInt32 m_h;
      };

      static const int N_ELEM = 5;
      static const int N_ORIENT = 12;
      static const int N_TYPE = 10;
      static const int ALL_PIECE_MASK = (1 << N_TYPE) - 1;
      static const TUInt32 SKIP_PIECE = 5; // it's magic!

      typedef int TCoordList[N_ELEM][N_DIM];

      static const BitVec BaseDefinitions[N_TYPE];
      static Piece s_basePiece[N_TYPE][N_ORIENT];

      static const Instance & getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity);
      static bool checkBaseDefinitions(void);
      static BitVec toBitVector(const TCoordList & coords);
      static void genOrientation(const BitVec & vec, TUInt32 iOrient, Piece & target);
      static void setCoordList(const BitVec & vec, TCoordList & coords);
      static void shiftUpLines(TCoordList & coords, int shift);
      static void shiftToX0(TCoordList & coords, Instance & instance, int offsetRow);
      static void setAllowedPositions(Instance & p);
      static void genAllOrientations(void);

      Instance m_instance[N_PARITY];
   };

   //------------------------------------
   Solution::Solution(int fillVal)
   {
      fill(fillVal);
      m_pieces.reserve(Piece::N_TYPE);
   }

   void Solution::fill(int val)
   {
      m_synched = false;
      memset(&m_cells[0][0], val, N_CELL);
   }

   string Solution::toString(void) const
   {
      string result;
      result.reserve(N_CELL * 2);

      for (int y = 0; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            int val = m_cells[y][x];
            result += ((val == NO_PIECE) ? '.' : char('0' + val));
            result += ' ';
         }
         result += '\n';

         // indent every second line
         if (y % 2 == 0)
            result += " ";
      }

      return result; // copies result. Oh well
   }

   void Solution::setCells(void)
   {
      if (m_synched)
         return;

      fill(NO_PIECE);

      // could be more efficient
      for (TUInt32 iPiece = 0; iPiece < m_pieces.size(); iPiece++) {

         const BitVec & vec = m_pieces[iPiece].vec;
         int pID = m_pieces[iPiece].iPiece;
         BitVec mask = 1LL;
         int nNewCells = 0;

         for (int y = 0; y < N_ROW; y++) {
            for (int x = 0; x < N_COL; x++) {
               if (mask & vec) {
                  m_cells[y][x] = (TInt8)pID;

                  nNewCells++;
               }
               mask <<= 1;
            }
            if (nNewCells == Piece::N_ELEM)
               break;
         }
      }

      m_synched = true;
   }

   void Solution::addPiece(const BitVec & vec, int iPiece) {
      SPiece p = {vec, iPiece};
      m_pieces.push_back(p);
   }

   void Solution::removeLastPiece(void) {
      m_pieces.pop_back();
      m_synched = false;
   }

   bool Solution::lessThan(Solution & r)
   {
      if (m_pieces[0].iPiece != r.m_pieces[0].iPiece) {
         return m_pieces[0].iPiece < r.m_pieces[0].iPiece;
      }

      setCells();
      r.setCells();

      int y;
      for (y = 0; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            int lval = m_cells[y][x];
            int rval = r.m_cells[y][x];

            if (lval != rval)
               return (lval < rval);
         }
      }

      return false; // solutions are equal
   }

   void Solution::spin(Solution & spun)
   {
      setCells();

      // swap cells
      for (int y = 0; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            TInt8 flipped = m_cells[N_ROW - y - 1][N_COL - x - 1];
            spun.m_cells[y][x] = flipped;
         }
      }

      // swap first and last pieces (the rest aren't used)
      spun.m_pieces.push_back(m_pieces[Piece::N_TYPE - 1]);
      spun.m_synched = true;
   }

   //------------------------------------

   Piece Piece::s_basePiece[N_TYPE][N_ORIENT];

   const BitVec Piece::BaseDefinitions[] = {
      0x010f,   0x00cb, 0x1087, 0x0427, 0x0465,
      0x00c7, 0x08423, 0x00a7, 0x0187, 0x008f
   };

   int floor(int top, int bot) {
      int toZero = top / bot;
      // negative numbers should be rounded down, not towards zero
      if ((toZero * bot != top) && ((top < 0) != (bot <= 0)))
         toZero--;

      return toZero;
   }

   TUInt32 getFirstOne(const BitVec & v, TUInt32 startPos = 0) {
      if (v == (BitVec)0)
         return 0;

      static const TUInt32 firstOne[16] =   {
         0, 0, 1, 0,
         2, 0, 1, 0,
         3, 0, 1, 0,
         2, 0, 1, 0,
      };

      TUInt32 iPos = startPos;
      BitVec mask = 0xffLL << startPos;
      while ((mask & v) == 0) {
         mask <<= 8;
         iPos += 8;
      }
      TUInt32 result = TUInt32((mask & v) >> iPos);
      TUInt32 resultLow = result & 0x0f;
      if (resultLow != 0)
         iPos += firstOne[resultLow];
      else
         iPos += 4 + firstOne[result >> 4];

      return iPos;
   }

   TUInt32 countOnes(BitVec v) {
      TUInt32 n = 0;
      while (v) {
         n++;
         v = v & (v - 1);
      }

      return n;
   }

   void Piece::genAllOrientations(void) {
      for (int iPiece = 0; iPiece < N_TYPE; iPiece++) {
         const BitVec & refPiece = BaseDefinitions[iPiece];
         for (int iOrient = 0; iOrient < N_ORIENT; iOrient++)
            genOrientation(refPiece, iOrient, s_basePiece[iPiece][iOrient]);
      }
   }

   void Piece::setCoordList(const BitVec & vec, TCoordList & coords) {
      int iCoord = 0;
      BitVec mask = 1LL;
      for (int y = 0; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            if (mask & vec) {
               coords[iCoord][X] = x;
               coords[iCoord][Y] = y;

               iCoord++;
            }
            mask <<= 1;
         }
      }
   }

   BitVec Piece::toBitVector(const TCoordList & coords)
   {
      int y, x;
      BitVec result = 0;
      for (int iCoord = 0; iCoord < N_ELEM; iCoord++) {
         x = coords[iCoord][X];
         y = coords[iCoord][Y];

         int pos = Board::getIndex(x, y);
         result |= (1LL << pos); // to generate a 64 bit representation of 1
      }

      return result;
   }

   void Piece::shiftUpLines(TCoordList & coords, int shift)
   {
      // apply shifts are not so simple in the vertical direction
      for (int iCoord = 0; iCoord < N_ELEM; iCoord++) {
         int & rx = coords[iCoord][X];
         int & ry = coords[iCoord][Y];

         if (ry & shift & 0x1)
            rx++;
         ry -= shift;
      }
   }

   void Piece::shiftToX0(TCoordList & coords, Piece::Instance & instance, int offsetRow)
   {
      // .. determine shift
      int x, y;
      int xMin = coords[0][X];
      int xMax = xMin;
      int iCoord;
      for (iCoord = 1; iCoord < N_ELEM; iCoord++) {
         x = coords[iCoord][X];
         y = coords[iCoord][Y];

         if (x < xMin)
            xMin = x;
         else if (x > xMax)
            xMax = x;
      }

      // I'm dying for a 'foreach' here
      int offset = N_ELEM;

      for (iCoord = 0; iCoord < N_ELEM; iCoord++) {
         int & rx = coords[iCoord][X];
         int & ry = coords[iCoord][Y];

         rx -= xMin;

         // check offset -- leftmost cell on top line
         if ((ry == offsetRow) && (rx < offset))
            offset = rx;
      }

      instance.m_w = xMax - xMin;
      instance.m_offset = offset;
      instance.m_vec = toBitVector(coords);
   }

   void Piece::setAllowedPositions(Piece::Instance & p)
   {
      BitVec & allowed = p.m_allowed = 0;
      BitVec posMask = 1LL;
      TUInt32 iPos = 0;
      for (int y = 0; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++, iPos++, posMask <<= 1){
            // check if the new position is on the board
            int xPos = x - p.m_offset;
            if ((xPos < 0) || (y + p.m_h >= N_ROW) || (xPos + p.m_w >= N_COL))
               continue;

            // move it to the desired location
            BitVec pieceVec = p.m_vec << (iPos - p.m_offset);

            if (Board::hasBadIslands(pieceVec))
               continue;

            // position is allowed
            allowed |= posMask;
         }
      }
   }

   void Piece::genOrientation(const BitVec & vec, TUInt32 iOrient, Piece & target)
   {
      // get (x,y) coordinates
      TCoordList coords;
      setCoordList(vec, coords);

      int y, x;
      int iCoord = 0;
      int rot = iOrient % 6;
      int flip = iOrient >= 6;
      if (flip) {
         for (iCoord = 0; iCoord < N_ELEM; iCoord++)
            coords[iCoord][Y] = -coords[iCoord][Y];
      }

      // rotate (if necessary)
      while (rot--) {
         for (iCoord = 0; iCoord < N_ELEM; iCoord++) {
            x = coords[iCoord][X];
            y = coords[iCoord][Y];

            // I just worked this out by hand. Took a while.
            int xNew = floor((2 * x - 3 * y + 1), 4);
            int yNew = floor((2 * x + y + 1), 2);
            coords[iCoord][X] = xNew;
            coords[iCoord][Y] = yNew;
         }
      }

      // shift vertically
      // .. determine shift
      int yMin = coords[0][Y];
      int yMax = yMin;
      for (iCoord = 1; iCoord < N_ELEM; iCoord++) {
         y = coords[iCoord][Y];

         if (y < yMin)
            yMin = y;
         else if (y > yMax)
            yMax = y;
      }
      TUInt32 h = yMax - yMin;
      target.m_instance[EVEN].m_h = h;
      target.m_instance[ODD].m_h = h;

      shiftUpLines(coords, yMin);
      shiftToX0(coords, target.m_instance[EVEN], 0);
      setAllowedPositions(target.m_instance[EVEN]);

      // shift down one line
      shiftUpLines(coords, -1);
      shiftToX0(coords, target.m_instance[ODD], 1);
      // shift the bitmask back one line
      target.m_instance[ODD].m_vec >>= N_COL;
      setAllowedPositions(target.m_instance[ODD]);
   }

   const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
      return s_basePiece[iPiece][iOrient].m_instance[iParity];
   }

   // ------------------------------------

   Board::Board() :
   m_curSolution(Solution::NO_PIECE), m_minSolution(Piece::N_TYPE),
      m_maxSolution(Solution::NO_PIECE), m_nSolutionFound(0)
   {
   }

   bool Board::hasBadFirstRegion(BitVec & toFill)
   {
      int iPos = getFirstOne(toFill);

      // grow empty region, until it doesn't change any more
      BitVec region;
      BitVec rNew = 1LL << iPos;
      do {
         region = rNew;

         // grow right/left
         rNew |= (region & ~L_EDGE_MASK) >> 1;
         rNew |= (region & ~R_EDGE_MASK) << 1;

         // simple grow up/down
         rNew |= (region >> N_COL);
         rNew |= (region << N_COL);

         // tricky growth
         BitVec evenRegion = region & (ROW_0_MASK & ~L_EDGE_MASK);
         rNew |= evenRegion >> (N_COL + 1);
         rNew |= evenRegion << (N_COL - 1);

         BitVec oddRegion = region & (ROW_1_MASK & ~R_EDGE_MASK);
         rNew |= oddRegion >> (N_COL - 1);
         rNew |= oddRegion << (N_COL + 1);

         // clamp against existing pieces
         rNew &= toFill;
      }
      while ((rNew != toFill) && (rNew != region));

      // subtract empty region from board
      toFill ^= rNew;

      TUInt32 nEmptyCells = countOnes(toFill);
      if (nEmptyCells % 5 != 0)
         return true;

      return false;
   }

   bool Board::hasBadIslands(const BitVec & boardVec)
   {
      BitVec toFill = ~boardVec & BOARD_MASK;

      // a little pre-work to speed things up
      BitVec row = (Board::TOP_ROW << ((N_ROW - 1) * N_COL));
      bool filled = ((row & toFill) == row);
      while ((row & toFill) == row) {
         toFill ^= row;
         row >>= N_COL;
      }
      // undo the last row, so regions stay connected
      if (filled)   {
         row <<= N_COL;
         toFill |= row;
      }

      while (toFill)    {
         if (hasBadFirstRegion(toFill))
            return true;
      }

      return false;
   }

   // recursive vs iterative?
   void Board::genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 iNextFill, const BitVec & maskNextFill)
   {
      BitVec pieceVec;
      int pieceMask = 1;
      int y = iNextFill / N_COL;
      int isOddLine = y & 1;

      for (int iPlacedPiece = 0; iPlacedPiece < Piece::N_TYPE; iPlacedPiece++, pieceMask <<= 1)
      {
         TUInt32 iPiece = iPlacedPiece; // leftover from when I remapped it

         // skip if we've already used this piece
         if (pieceMask & placedPieces)
            continue;

         // try to fit piece
         bool skipFlippedOdd = (iPiece == Piece::SKIP_PIECE);
         for (int iOrient = 0; iOrient < Piece::N_ORIENT; iOrient++)
         {
            if (skipFlippedOdd && ((iOrient / 3) & 1))
               continue;

            // get the particular piece in the particular orientation
            const Piece::Instance & p = Piece::getPiece(iPiece, iOrient, isOddLine);

            // check if the new position is allowed on the board
            if (!(p.m_allowed & maskNextFill))
               continue;

            // move it to the desired location, if possible and
            pieceVec = p.m_vec << (iNextFill - p.m_offset);

            // check if piece conflicts with other pieces
            if (pieceVec & boardVec)
               continue;

            // add the piece to the board
            boardVec |= pieceVec;

            if ((boardVec != pieceVec) && hasBadIslands(boardVec)) {
               // remove the piece from the board vector
               boardVec ^= pieceVec;
               continue;
            }

            // mark piece as placed
            placedPieces |= pieceMask;
            m_curSolution.addPiece(pieceVec, iPiece);

            // recur if not done
            if (placedPieces != Piece::ALL_PIECE_MASK)   {
               // need to find the next unfilled cell
               TUInt32 iCell = getFirstOne(~boardVec, iNextFill + 1);
               BitVec mNextFill = (maskNextFill << (iCell - iNextFill));

               genAllSolutions(boardVec, placedPieces, iCell, mNextFill);
            }
            else {
               // done, record piece/solution and end recursion
               recordSolution(m_curSolution);
            }

            // remove the piece before continuing with a new piece
            boardVec ^= pieceVec;
            m_curSolution.removeLastPiece();
         }

         placedPieces &= ~pieceMask;
      }
   }

   void Board::recordSolution(Solution & s)
   {
      m_nSolutionFound += 2; // we add the solution and its rotation

      if (m_minSolution.isEmpty()) {
         m_minSolution = m_maxSolution = s;
         return;
      }

      if (s.lessThan(m_minSolution))
         m_minSolution = s;
      else if (m_maxSolution.lessThan(s))
         m_maxSolution = s;

      Solution spun;
      s.spin(spun);
      if (spun.lessThan(m_minSolution))
         m_minSolution = spun;
      else if (m_maxSolution.lessThan(s))
         m_maxSolution = spun;
   }

} // namespace

using namespace Meteor;

int main(int argc, char * argv [])
{
   const int N_SOLUTION = 2098;
   TUInt32 nSolMax = N_SOLUTION;
   if (argc > 2)
      return 1; // spec says this is an error
   else if (argc == 2)
      nSolMax = *((TUInt32 *)argv[1]);

   Board board;
   Piece::genAllOrientations();
   board.genAllSolutions(0, 0, 0, 1LL);

   cout << board.m_nSolutionFound << " solutions found\n\n";
   cout << board.m_minSolution.toString() << '\n';
   cout << board.m_maxSolution.toString() << endl;

   //   if (nSolMax != N_SOLUTION)
   //      return 1;

   return 0;
}


// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
// contributed by Ben St. John
// some ideas taken from Kevin Barnes' implementation

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <vector>
#include <string>
#include <memory.h>

using namespace std;

#define getMask(iPos) (1 << iPos)

enum {X, Y, N_DIM};
enum {EVEN, ODD, N_PARITY};

typedef unsigned int TUInt32;
typedef unsigned long long TUInt64;
typedef signed char TInt8;
typedef TUInt32 BitVec;

static const int N_COL = 5;
static const int N_ROW = 10;
static const int N_CELL = N_COL * N_ROW;
static const int N_PIECE_TYPE = 10;

class Piece;
struct Solution
{
   static const int NO_PIECE = -1;

   void setCells(void);
   bool lessThan(Solution & r);
   string toString(void) const;
   void fill(int val);
   void spin(Solution & spun);

   bool isEmpty(void) {return (m_nPiece == 0);}
   void removeLastPiece(void) {m_nPiece--; m_synched = false;}
   void addPiece(const BitVec & vec, int iPiece, int row) {
      SPiece & p = m_pieces[m_nPiece++];
      p.vec = vec;
      p.iPiece = (short)iPiece;
      p.row = (short)row;
   }

   Solution(int fillVal);
   Solution() : m_synched(false), m_nPiece(0) {}

   struct SPiece {
      BitVec vec;
      short iPiece;
      short row;
      SPiece() {}
      SPiece(BitVec avec, TUInt32 apiece, TUInt32 arow) :
      vec(avec), iPiece(short(apiece)), row(short(arow))
      {}
   };
   SPiece m_pieces[N_PIECE_TYPE];
   TUInt32 m_nPiece;
   TInt8 m_cells[N_ROW][N_COL];
   bool m_synched;
};

//------------------------------------
struct Board
{
   static const BitVec L_EDGE_MASK =
      (1LL <<  0) | (1LL <<  5) | (1LL << 10) | (1LL << 15) |
      (1LL << 20) | (1LL << 25) | (1LL << 30);
   static const BitVec R_EDGE_MASK = L_EDGE_MASK << 4;
   static const BitVec TOP_ROW = (1 << N_COL) - 1;
   static const BitVec ROW_0_MASK =
      TOP_ROW        | (TOP_ROW << 10) | (TOP_ROW << 20) | (TOP_ROW << 30);
   static const BitVec ROW_1_MASK = ROW_0_MASK << 5;
   static const BitVec BOARD_MASK = (1 << 30) - 1;

   Board();

   static TUInt32 getIndex(TUInt32 x, TUInt32 y) { return y * N_COL + x;    }
   static bool hasBadFirstRegion(BitVec & toFill, BitVec rNew);
   static bool hasBadIslands(BitVec boardVec, int row);
   static bool calcBadIslands(const BitVec boardVec, int row);
   static bool hasBadIslandsSingle(const BitVec & boardVec, int row);

   void genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 iNextFill);
   void recordSolution(Solution & s);

   Solution m_curSolution;
   Solution m_minSolution;
   Solution m_maxSolution;
   TUInt32 m_nSolutionFound;
};

//------------------------------------

class Piece
{
public:
   struct Instance {
      TUInt64 m_allowed;
      BitVec m_vec;
      int m_offset;
      int m_w;
      int m_h;
   };

   static const int N_ELEM = 5;
   static const int N_ORIENT = 12;
   static const int ALL_PIECE_MASK = (1 << N_PIECE_TYPE) - 1;
   static const TUInt32 SKIP_PIECE = 5; // it's magic!

   typedef int TCoordList[N_ELEM][N_DIM];

   static const BitVec BaseDefinitions[N_PIECE_TYPE];
   static Piece s_basePiece[N_PIECE_TYPE][N_ORIENT];

   static const Instance & getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity);
   static bool checkBaseDefinitions(void);
   static BitVec toBitVector(const TCoordList & coords);
   static void genOrientation(const BitVec & vec, TUInt32 iOrient, Piece & target);
   static void setCoordList(const BitVec & vec, TCoordList & coords);
   static void shiftUpLines(TCoordList & coords, int shift);
   static void shiftToX0(TCoordList & coords, Instance & instance, int offsetRow);
   void setAllowedPositions(TUInt32 isOdd);
   static void genAllOrientations(void);

   Instance m_instance[N_PARITY];
};

struct AllowedPieces {
   signed char nPieces[N_PIECE_TYPE];
   // DEVNOTE: could be done more efficiently (space-wise)
   TUInt32 pieceVec[N_PIECE_TYPE][Piece::N_ORIENT];
};

AllowedPieces g_allowedPieces[N_ROW][N_COL] = {{0}};

// should be moved in Board, but I'm lazy
enum {CLOSED, OPEN, N_FIXED};
#define MAX_ISLAND_OFFSET 1024
struct IslandInfo {
   TUInt32 hasBadIslands[N_FIXED][N_PARITY];
   TUInt32 isKnown[N_FIXED][N_PARITY];
};

IslandInfo g_islandInfo[MAX_ISLAND_OFFSET] = {0};
int g_nIslandInfo = 0;

//------------------------------------
Solution::Solution(int fillVal) :
m_nPiece(0) {
   fill(fillVal);
}

void Solution::fill(int val)
{
   m_synched = false;
   memset(&m_cells[0][0], val, N_CELL);
}

string Solution::toString(void) const
{
   string result;
   result.reserve(N_CELL * 2);

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int val = m_cells[y][x];
         result += ((val == NO_PIECE) ? '.' : char('0' + val));
         result += ' ';
      }
      result += '\n';

      // indent every second line
      if (y % 2 == 0)
         result += " ";
   }

   return result; // copies result. Oh well
}

void Solution::setCells(void)
{
   if (m_synched)
      return;

   fill(NO_PIECE);

   // could be more efficient
   for (TUInt32 iPiece = 0; iPiece < m_nPiece; iPiece++) {
      const SPiece & p = m_pieces[iPiece];
      BitVec vec = p.vec;
      TInt8 pID = (TInt8)p.iPiece;
      int rowOffset = p.row;

      int nNewCells = 0;
      for (int y = rowOffset; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            if (vec & 1) {
               m_cells[y][x] = pID;
               nNewCells++;
            }
            vec >>= 1;
         }
         if (nNewCells == Piece::N_ELEM)
            break;
      }
   }


   m_synched = true;
}

bool Solution::lessThan(Solution & r)
{
   if (m_pieces[0].iPiece != r.m_pieces[0].iPiece) {
      return m_pieces[0].iPiece < r.m_pieces[0].iPiece;
   }

   setCells();
   r.setCells();

   int y;
   for (y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int lval = m_cells[y][x];
         int rval = r.m_cells[y][x];

         if (lval != rval)
            return (lval < rval);
      }
   }

   return false; // solutions are equal
}

void Solution::spin(Solution & spun)
{
   setCells();

   // swap cells
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         TInt8 flipped = m_cells[N_ROW - y - 1][N_COL - x - 1];
         spun.m_cells[y][x] = flipped;
      }
   }

   // swap first and last pieces (the rest aren't used)
   spun.m_pieces[0].iPiece = m_pieces[N_PIECE_TYPE - 1].iPiece;
   spun.m_synched = true;
}

//------------------------------------

Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];

const BitVec Piece::BaseDefinitions[] = {
   0x010f,   0x00cb, 0x1087, 0x0427, 0x0465,
   0x00c7, 0x08423, 0x00a7, 0x0187, 0x008f
};

int floor(int top, int bot) {
   int toZero = top / bot;
   // negative numbers should be rounded down, not towards zero
   if ((toZero * bot != top) && ((top < 0) != (bot <= 0)))
      toZero--;

   return toZero;
}

static const TUInt32 s_firstOne[32] =   {
   0, 0, 1, 0,
   2, 0, 1, 0,
   3, 0, 1, 0,
   2, 0, 1, 0,

   4, 0, 1, 0,
   2, 0, 1, 0,
   3, 0, 1, 0,
   2, 0, 1, 0,
};

TUInt32 getFirstOne(const BitVec & v, TUInt32 startPos = 0) {
   if (v == (BitVec)0)
      return 0;

   TUInt32 iPos = startPos;
   BitVec mask = 0xff << startPos;
   while ((mask & v) == 0) {
      mask <<= 8;
      iPos += 8;
   }
   TUInt32 result = TUInt32((mask & v) >> iPos);
   TUInt32 resultLow = result & 0x0f;
   if (resultLow != 0)
      iPos += s_firstOne[resultLow];
   else
      iPos += 4 + s_firstOne[result >> 4];

   return iPos;
}

TUInt32 countOnes(BitVec v) {
   TUInt32 n = 0;
   while (v) {
      n++;
      v = v & (v - 1);
   }

   return n;
}

void Piece::setCoordList(const BitVec & vec, TCoordList & coords) {
   int iCoord = 0;
   BitVec mask = 1;
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         if (mask & vec) {
            coords[iCoord][X] = x;
            coords[iCoord][Y] = y;

            iCoord++;
         }
         mask <<= 1;
      }
   }
}

BitVec Piece::toBitVector(const TCoordList & coords) {
   int y, x;
   BitVec result = 0;
   for (int iCoord = 0; iCoord < N_ELEM; iCoord++) {
      x = coords[iCoord][X];
      y = coords[iCoord][Y];

      int pos = Board::getIndex(x, y);
      result |= (1 << pos);
   }

   return result;
}

void Piece::shiftUpLines(TCoordList & coords, int shift) {
   // shifts are not so simple in the vertical direction
   for (int iCoord = 0; iCoord < N_ELEM; iCoord++) {
      int & rx = coords[iCoord][X];
      int & ry = coords[iCoord][Y];

      if (ry & shift & 0x1)
         rx++;
      ry -= shift;
   }
}

void Piece::shiftToX0(TCoordList & coords, Piece::Instance & instance, int offsetRow)
{
   // .. determine shift
   int x, y;
   int xMin = coords[0][X];
   int xMax = xMin;
   int iCoord;
   for (iCoord = 1; iCoord < N_ELEM; iCoord++) {
      x = coords[iCoord][X];
      y = coords[iCoord][Y];

      if (x < xMin)
         xMin = x;
      else if (x > xMax)
         xMax = x;
   }

   // I'm dying for a 'foreach' here
   int offset = N_ELEM;
   for (iCoord = 0; iCoord < N_ELEM; iCoord++) {
      int & rx = coords[iCoord][X];
      int & ry = coords[iCoord][Y];

      rx -= xMin;

      // check offset -- leftmost cell on top line
      if ((ry == offsetRow) && (rx < offset))
         offset = rx;
   }

   instance.m_w = xMax - xMin;
   instance.m_offset = offset;
   instance.m_vec = toBitVector(coords);
}

void Piece::setAllowedPositions(TUInt32 isOdd)
{
   Piece::Instance & p = m_instance[isOdd];
   TUInt64 & allowed = p.m_allowed = 0;
   TUInt64 posMask = 1LL << (isOdd * N_COL);

   for (int y = isOdd; y < N_ROW - p.m_h; y+=2, posMask <<= N_COL) {
      if (p.m_offset)
         posMask <<= p.m_offset;

      for (int xPos = 0; xPos < N_COL - p.m_offset; xPos++, posMask <<= 1){
         // check if the new position is on the board
         if (xPos >= N_COL - p.m_w)
            continue;

         // move it to the desired location
         BitVec pieceVec = p.m_vec << xPos;

         if (Board::hasBadIslandsSingle(pieceVec, y))
            continue;

         // position is allowed
         allowed |= posMask;
      }
   }
}

void Piece::genOrientation(const BitVec & vec, TUInt32 iOrient, Piece & target)
{
   // get (x,y) coordinates
   TCoordList coords;
   setCoordList(vec, coords);

   int y, x;
   int iCoord = 0;
   int rot = iOrient % 6;
   int flip = iOrient >= 6;
   if (flip) {
      for (iCoord = 0; iCoord < N_ELEM; iCoord++)
         coords[iCoord][Y] = -coords[iCoord][Y];
   }

   // rotate (if necessary)
   while (rot--) {
      for (iCoord = 0; iCoord < N_ELEM; iCoord++) {
         x = coords[iCoord][X];
         y = coords[iCoord][Y];

         // I just worked this out by hand. Took a while.
         int xNew = floor((2 * x - 3 * y + 1), 4);
         int yNew = floor((2 * x + y + 1), 2);
         coords[iCoord][X] = xNew;
         coords[iCoord][Y] = yNew;
      }
   }

   // shift vertically
   // .. determine shift
   int yMin = coords[0][Y];
   int yMax = yMin;
   for (iCoord = 1; iCoord < N_ELEM; iCoord++) {
      y = coords[iCoord][Y];

      if (y < yMin)
         yMin = y;
      else if (y > yMax)
         yMax = y;
   }
   TUInt32 h = yMax - yMin;
   Instance & even = target.m_instance[EVEN];
   Instance & odd = target.m_instance[ODD];
   even.m_h = h;
   odd.m_h = h;

   shiftUpLines(coords, yMin);
   shiftToX0(coords, even, 0);
   target.setAllowedPositions(EVEN);
   even.m_vec >>= even.m_offset;

   // shift down one line
   shiftUpLines(coords, -1);
   shiftToX0(coords, odd, 1);
   // shift the bitmask back one line
   odd.m_vec >>= N_COL;
   target.setAllowedPositions(ODD);
   odd.m_vec >>= odd.m_offset;
}

void Piece::genAllOrientations(void) {
   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      const BitVec & refPiece = BaseDefinitions[iPiece];
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         Piece & p = s_basePiece[iPiece][iOrient];
         genOrientation(refPiece, iOrient, p);
         if ((iPiece == SKIP_PIECE) && ((iOrient / 3) & 1))
            p.m_instance[0].m_allowed = p.m_instance[1].m_allowed = 0;
      }
   }

   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         TUInt64 mask = 1;
         for (int iRow = 0; iRow < N_ROW; iRow++) {
            const Piece::Instance & p = getPiece(iPiece, iOrient, (iRow & 1));
            for (int iCol = 0; iCol < N_COL; iCol++) {
               AllowedPieces & allowed = g_allowedPieces[iRow][iCol];
               if (p.m_allowed & mask) {
                  signed char & nPiece = allowed.nPieces[iPiece];
                  allowed.pieceVec[iPiece][nPiece] = p.m_vec << iCol;
                  nPiece++;
               }

               mask <<= 1;
            }
         }
      }
   }
}


const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
   return s_basePiece[iPiece][iOrient].m_instance[iParity];
}

// ------------------------------------

Board::Board() :
m_curSolution(Solution::NO_PIECE), m_minSolution(N_PIECE_TYPE),
m_maxSolution(Solution::NO_PIECE), m_nSolutionFound(0)
{
}

bool Board::hasBadFirstRegion(BitVec & toFill, BitVec rNew)
{
   // grow empty region, until it doesn't change any more
   BitVec region;
   do {
      region = rNew;

      // grow right/left
      rNew |= (region & ~L_EDGE_MASK) >> 1;
      rNew |= (region & ~R_EDGE_MASK) << 1;

      // simple grow up/down
      rNew |= (region >> N_COL);
      rNew |= (region << N_COL);

      // tricky growth
      BitVec evenRegion = region & (ROW_0_MASK & ~L_EDGE_MASK);
      rNew |= evenRegion >> (N_COL + 1);
      rNew |= evenRegion << (N_COL - 1);

      BitVec oddRegion = region & (ROW_1_MASK & ~R_EDGE_MASK);
      rNew |= oddRegion >> (N_COL - 1);
      rNew |= oddRegion << (N_COL + 1);

      // clamp against existing pieces
      rNew &= toFill;
   }
   while ((rNew != toFill) && (rNew != region));

   // subtract empty region from board
   toFill ^= rNew;

   TUInt32 nEmptyCells = countOnes(toFill);
   if (nEmptyCells % Piece::N_ELEM != 0)
      return true;

   return false;
}

bool Board::hasBadIslands(BitVec boardVec, int row)
{
   // skip over any filled rows
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }

   if (boardVec == 0)
      return false;

   if (boardVec & (TOP_ROW << N_COL * 3))
      return calcBadIslands(boardVec, row);

   int isOdd = row & 1;
   TUInt32 iInfo = boardVec & ((1 << 2 * N_COL) - 1);
   TUInt32 lastRow = (boardVec >> (2 * N_COL)) & TOP_ROW;
   int isClosed = row > 6;

   IslandInfo & islandInfo = g_islandInfo[iInfo];
   TUInt32 mask = getMask(lastRow);
   TUInt32 & isKnownVector = islandInfo.isKnown[isOdd][isClosed];
   TUInt32 & badIsleVector = islandInfo.hasBadIslands[isOdd][isClosed];

   if (isKnownVector & mask)
      return ((badIsleVector & mask) != 0);

   isKnownVector |= mask;

   // calc island info
   bool hasBad = calcBadIslands(boardVec, row);

   // set it
   if (hasBad)
      badIsleVector |= mask;

   return hasBad;
}

bool Board::calcBadIslands(const BitVec boardVec, int row)
{
   BitVec toFill = ~boardVec;
   if (row & 1) {
      row--;
      toFill <<= N_COL;
   }

   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row > 4) {
      int boardMaskShift = (row - 4) * N_COL;
      boardMask >>= boardMaskShift;
   }
   toFill &= boardMask;

   // a little pre-work to speed things up
   BitVec bottom = (TOP_ROW << (5 * N_COL));
   bool filled = ((bottom & toFill) == bottom);
   while ((bottom & toFill) == bottom) {
      toFill ^= bottom;
      bottom >>= N_COL;
   }

   BitVec startRegion;
   int iPos;
   if (filled || (row < 4))   {
      startRegion = bottom & toFill;
   } else {
      iPos = getFirstOne(toFill);
      startRegion = 1 << iPos;
      //      startRegion |= ((startRegion & ~R_EDGE_MASK) << 1) & toFill;
      startRegion |= (startRegion << N_COL) & toFill;
   }

   while (toFill)    {
      if (hasBadFirstRegion(toFill, startRegion))
         return true;
      iPos = getFirstOne(toFill);
      startRegion = 1 << iPos;
   }

   return false;
}

bool Board::hasBadIslandsSingle(const BitVec & boardVec, int row)
{
   BitVec toFill = ~boardVec;
   bool isOdd = (row & 1);
   if (isOdd) {
      row--;
      toFill <<= N_COL; // shift to even aligned
      toFill |= TOP_ROW;
   }

   BitVec startRegion = TOP_ROW;
   BitVec lastRow = TOP_ROW << (5 * N_COL);

   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row >= 4) {
      int boardMaskShift = (row - 4) * N_COL;
      boardMask >>= boardMaskShift;
   }
   else if ( isOdd || (row == 0) /* || (boardVec & lastRow) */) {
      startRegion = lastRow;
   }

   toFill &= boardMask;
   startRegion &= toFill;

   while (toFill)    {
      if (hasBadFirstRegion(toFill, startRegion))
         return true;
      int iPos = getFirstOne(toFill);
      startRegion = 1 << iPos;
   }

   return false;
}

// recursive vs iterative?
void Board::genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 row)
{
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }
   TUInt32 iNextFill = s_firstOne[~boardVec & TOP_ROW];

   int pieceMask = 1;
   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++, pieceMask <<= 1)
   {
      // skip if we've already used this piece
      if (pieceMask & placedPieces)
         continue;
      const AllowedPieces & allowed = g_allowedPieces[row][iNextFill];
      for (int iOrient = 0; iOrient < allowed.nPieces[iPiece]; iOrient++)
      {
         BitVec pieceVec = allowed.pieceVec[iPiece][iOrient];

         // check if piece conflicts with other pieces
         if (pieceVec & boardVec)
            continue;

         // add the piece to the board
         boardVec |= pieceVec;

         if (hasBadIslands(boardVec, row)) {
            // remove the piece from the board vector
            boardVec ^= pieceVec;
            continue;
         }

         // mark piece as placed
         placedPieces |= pieceMask;
         m_curSolution.addPiece(pieceVec, iPiece, row);

         // recur if not done
         if (placedPieces != Piece::ALL_PIECE_MASK)
            genAllSolutions(boardVec, placedPieces, row);
         else
            recordSolution(m_curSolution);

         // remove the piece before continuing with a new piece
         boardVec ^= pieceVec;
         m_curSolution.removeLastPiece();
      }

      placedPieces &= ~pieceMask;
   }
}

void Board::recordSolution(Solution & s)
{
   m_nSolutionFound += 2; // we add the solution and its rotation

   if (m_minSolution.isEmpty()) {
      m_minSolution = m_maxSolution = s;
      return;
   }

   if (s.lessThan(m_minSolution))
      m_minSolution = s;
   else if (m_maxSolution.lessThan(s))
      m_maxSolution = s;

   Solution spun;
   s.spin(spun);
   if (spun.lessThan(m_minSolution))
      m_minSolution = spun;
   else if (m_maxSolution.lessThan(spun))
      m_maxSolution = spun;
}

int main(int argc, char *[])
{
   const int N_SOLUTION = 2098;
   if (argc > 2)
      return 1; // spec says this is an error

   Board board;
   Piece::genAllOrientations();
   board.genAllSolutions(0, 0, 0);

   int nFound = board.m_nSolutionFound;

   cout << nFound << " solutions found\n\n";
   cout << board.m_minSolution.toString() << '\n';
   cout << board.m_maxSolution.toString() << endl;

   if (nFound != N_SOLUTION)
      return 1;

   return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
// contributed by Ben St. John
// some ideas taken from Kevin Barnes' implementation

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <memory.h>

using namespace std;

#define getMask(iPos) (1 << (iPos))

enum {X, Y, N_DIM};
enum {EVEN, ODD, N_PARITY};
enum {GOOD, BAD, ALWAYS_BAD};

typedef unsigned int TUInt32;
typedef unsigned long long TUInt64;
typedef signed char TInt8;
typedef TUInt32 BitVec;

static const int N_COL = 5;
static const int N_ROW = 10;
static const int N_CELL = N_COL * N_ROW;
static const int N_PIECE_TYPE = 10;

struct Piece;

struct Soln {
   static const int NO_PIECE = -1;

   void setCells(void);
   bool lessThan(Soln & r);
   string toString(void) const;
   void fill(int val);
   void spin(Soln & spun);

   bool isEmpty(void) {return (m_nPiece == 0);}
   void popPiece(void) {m_nPiece--; m_synched = false;}
   void pushPiece(BitVec vec, int iPiece, int row) {
      SPiece & p = m_pieces[m_nPiece++];
      p.vec = vec;
      p.iPiece = (short)iPiece;
      p.row = (short)row;
   }

   Soln(int fillVal);
   Soln() : m_synched(false), m_nPiece(0) {}

   struct SPiece {
      BitVec vec;
      short iPiece;
      short row;
      SPiece() {}
      SPiece(BitVec avec, TUInt32 apiece, TUInt32 arow) :
      vec(avec), iPiece(short(apiece)), row(short(arow))
      {}
   };
   SPiece m_pieces[N_PIECE_TYPE];
   TUInt32 m_nPiece;
   TInt8 m_cells[N_ROW][N_COL];
   bool m_synched;
};

//------------------------------------
struct Board {
   static const BitVec L_EDGE_MASK =
      (1LL <<  0) | (1LL <<  5) | (1LL << 10) | (1LL << 15) |
      (1LL << 20) | (1LL << 25) | (1LL << 30);
   static const BitVec R_EDGE_MASK = L_EDGE_MASK << 4;
   static const BitVec TOP_ROW = (1 << N_COL) - 1;
   static const BitVec ROW_0_MASK =
      TOP_ROW | (TOP_ROW << 10) | (TOP_ROW << 20) | (TOP_ROW << 30);
   static const BitVec ROW_1_MASK = ROW_0_MASK << 5;
   static const BitVec BOARD_MASK = (1 << 30) - 1;

   Board();

   static TUInt32 getIndex(TUInt32 x, TUInt32 y) { return y * N_COL + x; }
   static bool badRegion(BitVec & toFill, BitVec rNew);
   static int hasBadIslands(BitVec boardVec, int row);
   static int calcBadIslands(BitVec boardVec, int row);
   static bool hasBadIslandsSingle(BitVec boardVec, int row);
   static void calcAlwaysBad(void);

   void genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 iNextFill);
   void recordSolution(Soln & s);

   Soln m_curSoln;
   Soln m_minSoln;
   Soln m_maxSoln;
   TUInt32 m_nSoln;
};

//------------------------------------

struct Piece {
   struct Instance {
      TUInt64 m_allowed;
      BitVec m_vec;
      int m_offset;
   };

   static const int N_ELEM = 5;
   static const int N_ORIENT = 12;
   static const int ALL_PIECE_MASK = (1 << N_PIECE_TYPE) - 1;
   static const TUInt32 SKIP_PIECE = 5; // it's magic!

   typedef int TPts[N_ELEM][N_DIM];

   static const BitVec BaseVecs[N_PIECE_TYPE];
   static Piece s_basePiece[N_PIECE_TYPE][N_ORIENT];

   static const Instance & getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity);
   static BitVec toBitVector(const TPts & pts);
   static void genOrientation(BitVec vec, TUInt32 iOrient, Piece & target);
   static void setCoordList(BitVec vec, TPts & pts);
   static void shiftUpLines(TPts & pts, int shift);
   static int shiftToX0(TPts & pts, Instance & instance, int offsetRow);
   void setOkPos(TUInt32 isOdd, int w, int h);
   static void genAllOrientations(void);

   Instance m_instance[N_PARITY];
};

struct OkPieces {
   TInt8 nPieces[N_PIECE_TYPE];
   TUInt32 pieceVec[N_PIECE_TYPE][Piece::N_ORIENT];
};

OkPieces g_okPieces[N_ROW][N_COL] = {{0}};

enum {OPEN, CLOSED, N_FIXED};
#define MAX_ISLAND_OFFSET 1024
struct IslandInfo {
   TUInt32 hasBad[N_FIXED][N_PARITY];
   TUInt32 isKnown[N_FIXED][N_PARITY];
   TUInt32 alwaysBad[N_PARITY];
};

IslandInfo g_islandInfo[MAX_ISLAND_OFFSET] = {0};
int g_nIslandInfo = 0;

//------------------------------------
Soln::Soln(int fillVal) :
m_nPiece(0) {
   fill(fillVal);
}

void Soln::fill(int val) {
   m_synched = false;
   memset(m_cells, val, N_CELL);
}

string Soln::toString(void) const {
   string result;
   result.reserve(N_CELL * 2);

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int val = m_cells[y][x];
         result += ((val == NO_PIECE) ? '.' : char('0' + val));
         result += ' ';
      }
      result += '\n';

      // indent every second line
      if (y % 2 == 0)
         result += " ";
   }
   return result;
}

void Soln::setCells(void) {
   if (m_synched)
      return;

   for (TUInt32 iPiece = 0; iPiece < m_nPiece; iPiece++) {
      const SPiece & p = m_pieces[iPiece];
      BitVec vec = p.vec;
      TInt8 pID = (TInt8)p.iPiece;
      int rowOffset = p.row;

      int nNewCells = 0;
      for (int y = rowOffset; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            if (vec & 1) {
               m_cells[y][x] = pID;
               nNewCells++;
            }
            vec >>= 1;
         }
         if (nNewCells == Piece::N_ELEM)
            break;
      }
   }
   m_synched = true;
}

bool Soln::lessThan(Soln & r) {
   if (m_pieces[0].iPiece != r.m_pieces[0].iPiece) {
      return m_pieces[0].iPiece < r.m_pieces[0].iPiece;
   }

   setCells();
   r.setCells();

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int lval = m_cells[y][x];
         int rval = r.m_cells[y][x];

         if (lval != rval)
            return (lval < rval);
      }
   }

   return false; // solutions are equal
}

void Soln::spin(Soln & spun) {
   setCells();

   // swap cells
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         TInt8 flipped = m_cells[N_ROW - y - 1][N_COL - x - 1];
         spun.m_cells[y][x] = flipped;
      }
   }

   // swap first and last pieces (the rest aren't used)
   spun.m_pieces[0].iPiece = m_pieces[N_PIECE_TYPE - 1].iPiece;
   spun.m_synched = true;
}

//------------------------------------

Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];

const BitVec Piece::BaseVecs[] = {
   0x10f, 0x0cb, 0x1087, 0x427, 0x465,
   0x0c7, 0x8423, 0x0a7, 0x187, 0x08f
};

int floor(int top, int bot) {
   int toZero = top / bot;
   // negative numbers should be rounded down, not towards zero
   if ((toZero * bot != top) && ((top < 0) != (bot <= 0)))
      toZero--;

   return toZero;
}

const TUInt32 s_firstOne[32] = {
   0, 0, 1, 0,   2, 0, 1, 0,
   3, 0, 1, 0,   2, 0, 1, 0,

   4, 0, 1, 0,   2, 0, 1, 0,
   3, 0, 1, 0,   2, 0, 1, 0,
};

TUInt32 getFirstOne(BitVec v, TUInt32 startPos = 0) {
   if (v == (BitVec)0)
      return 0;

   TUInt32 iPos = startPos;
   BitVec mask = 0xff << startPos;
   while ((mask & v) == 0) {
      mask <<= 8;
      iPos += 8;
   }
   TUInt32 result = TUInt32((mask & v) >> iPos);
   TUInt32 resultLow = result & 0x0f;
   if (resultLow != 0)
      iPos += s_firstOne[resultLow];
   else
      iPos += 4 + s_firstOne[result >> 4];

   return iPos;
}

TUInt32 countOnes(BitVec v) {
   TUInt32 n = 0;
   while (v) {
      n++;
      v = v & (v - 1);
   }

   return n;
}

void Piece::setCoordList(BitVec vec, TPts & pts) {
   int iPt = 0;
   BitVec mask = 1;
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         if (mask & vec) {
            pts[iPt][X] = x;
            pts[iPt][Y] = y;

            iPt++;
         }
         mask <<= 1;
      }
   }
}

BitVec Piece::toBitVector(const TPts & pts) {
   int y, x;
   BitVec result = 0;
   for (int iPt = 0; iPt < N_ELEM; iPt++) {
      x = pts[iPt][X];
      y = pts[iPt][Y];

      int pos = Board::getIndex(x, y);
      result |= (1 << pos);
   }

   return result;
}

void Piece::shiftUpLines(TPts & pts, int shift) {
   // vertical shifts have a twist
   for (int iPt = 0; iPt < N_ELEM; iPt++) {
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      if (ry & shift & 0x1)
         rx++;
      ry -= shift;
   }
}

int Piece::shiftToX0(TPts & pts, Instance & instance, int offsetRow)
{
   // .. determine shift
   int x, y, iPt;
   int xMin = pts[0][X];
   int xMax = xMin;
   for (iPt = 1; iPt < N_ELEM; iPt++) {
      x = pts[iPt][X];
      y = pts[iPt][Y];

      if (x < xMin)
         xMin = x;
      else if (x > xMax)
         xMax = x;
   }

   // I'm dying for a 'foreach' here
   int offset = N_ELEM;
   for (iPt = 0; iPt < N_ELEM; iPt++) {
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      rx -= xMin;

      // check offset -- leftmost cell on top line
      if ((ry == offsetRow) && (rx < offset))
         offset = rx;
   }

   instance.m_offset = offset;
   instance.m_vec = toBitVector(pts);
   return xMax - xMin;
}

void Piece::setOkPos(TUInt32 isOdd, int w, int h) {
   Instance & p = m_instance[isOdd];
   TUInt64 & allowed = p.m_allowed = 0;
   TUInt64 posMask = 1LL << (isOdd * N_COL);

   for (int y = isOdd; y < N_ROW - h; y+=2, posMask <<= N_COL) {
      if (p.m_offset)
         posMask <<= p.m_offset;

      for (int xPos = 0; xPos < N_COL - p.m_offset; xPos++, posMask <<= 1) {
         // check if the new position is on the board
         if (xPos >= N_COL - w)
            continue;

         // move it to the desired location
         BitVec pieceVec = p.m_vec << xPos;

         if (Board::hasBadIslandsSingle(pieceVec, y))
            continue;

         // position is allowed
         allowed |= posMask;
      }
   }
}

void Piece::genOrientation(BitVec vec, TUInt32 iOrient, Piece & target)
{
   // get (x,y) coordinates
   TPts pts;
   setCoordList(vec, pts);

   int y, x, iPt;
   int rot = iOrient % 6;
   int flip = iOrient >= 6;
   if (flip) {
      for (iPt = 0; iPt < N_ELEM; iPt++)
         pts[iPt][Y] = -pts[iPt][Y];
   }

   // rotate as necessary
   while (rot--) {
      for (iPt = 0; iPt < N_ELEM; iPt++) {
         x = pts[iPt][X];
         y = pts[iPt][Y];

         // I just worked this out by hand. Took a while.
         int xNew = floor((2 * x - 3 * y + 1), 4);
         int yNew = floor((2 * x + y + 1), 2);
         pts[iPt][X] = xNew;
         pts[iPt][Y] = yNew;
      }
   }

   // determine vertical shift
   int yMin = pts[0][Y];
   int yMax = yMin;
   for (iPt = 1; iPt < N_ELEM; iPt++) {
      y = pts[iPt][Y];

      if (y < yMin)
         yMin = y;
      else if (y > yMax)
         yMax = y;
   }
   int h = yMax - yMin;
   Instance & even = target.m_instance[EVEN];
   Instance & odd = target.m_instance[ODD];

   shiftUpLines(pts, yMin);
   int w = shiftToX0(pts, even, 0);
   target.setOkPos(EVEN, w, h);
   even.m_vec >>= even.m_offset;

   // shift down one line
   shiftUpLines(pts, -1);
   w = shiftToX0(pts, odd, 1);
   // shift the bitmask back one line
   odd.m_vec >>= N_COL;
   target.setOkPos(ODD, w, h);
   odd.m_vec >>= odd.m_offset;
}

void Piece::genAllOrientations(void) {
   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      BitVec refPiece = BaseVecs[iPiece];
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         Piece & p = s_basePiece[iPiece][iOrient];
         genOrientation(refPiece, iOrient, p);
         if ((iPiece == SKIP_PIECE) && ((iOrient / 3) & 1))
            p.m_instance[0].m_allowed = p.m_instance[1].m_allowed = 0;
      }
   }

   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         TUInt64 mask = 1;
         for (int iRow = 0; iRow < N_ROW; iRow++) {
            const Instance & p = getPiece(iPiece, iOrient, (iRow & 1));
            for (int iCol = 0; iCol < N_COL; iCol++) {
               OkPieces & allowed = g_okPieces[iRow][iCol];
               if (p.m_allowed & mask) {
                  TInt8 & nPiece = allowed.nPieces[iPiece];
                  allowed.pieceVec[iPiece][nPiece] = p.m_vec << iCol;
                  nPiece++;
               }

               mask <<= 1;
            }
         }
      }
   }
}


inline const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
   return s_basePiece[iPiece][iOrient].m_instance[iParity];
}

// ------------------------------------

Board::Board() :
m_curSoln(Soln::NO_PIECE), m_minSoln(N_PIECE_TYPE),
m_maxSoln(Soln::NO_PIECE), m_nSoln(0)
{}

bool Board::badRegion(BitVec & toFill, BitVec rNew)
{
   // grow empty region, until it doesn't change any more
   BitVec region;
   do {
      region = rNew;

      // simple grow up/down
      rNew |= (region >> N_COL);
      rNew |= (region << N_COL);

      // grow right/left
      rNew |= (region & ~L_EDGE_MASK) >> 1;
      rNew |= (region & ~R_EDGE_MASK) << 1;

      // tricky growth
      BitVec evenRegion = region & (ROW_0_MASK & ~L_EDGE_MASK);
      rNew |= evenRegion >> (N_COL + 1);
      rNew |= evenRegion << (N_COL - 1);
      BitVec oddRegion = region & (ROW_1_MASK & ~R_EDGE_MASK);
      rNew |= oddRegion >> (N_COL - 1);
      rNew |= oddRegion << (N_COL + 1);

      // clamp against existing pieces
      rNew &= toFill;
   }
   while ((rNew != toFill) && (rNew != region));

   // subtract empty region from board
   toFill ^= rNew;

   TUInt32 nCells = countOnes(toFill);
   return (nCells % Piece::N_ELEM != 0);
}

int Board::hasBadIslands(BitVec boardVec, int row)
{
   // skip over any filled rows
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }

   TUInt32 iInfo = boardVec & ((1 << 2 * N_COL) - 1);
   IslandInfo & info = g_islandInfo[iInfo];

   TUInt32 lastRow = (boardVec >> (2 * N_COL)) & TOP_ROW;
   TUInt32 mask = getMask(lastRow);
   TUInt32 isOdd = row & 1;
   TUInt32 & alwaysBad = info.alwaysBad[isOdd];

   if (alwaysBad & mask)
      return BAD;

   if (boardVec & (TOP_ROW << N_COL * 3))
      return calcBadIslands(boardVec, row);

   int isClosed = (row > 6); // because we track 3 rows
   TUInt32 & isKnownVector = info.isKnown[isOdd][isClosed];
   TUInt32 & badIsleVector = info.hasBad[isOdd][isClosed];

   if (isKnownVector & mask)
      return ((badIsleVector & mask) != 0);

   if (boardVec == 0)
      return GOOD;

   int hasBad = calcBadIslands(boardVec, row);

   isKnownVector |= mask;
   if (hasBad)
      badIsleVector |= mask;

   return hasBad;
}

TUInt32 g_firstRegion[] = {
   0x00, 0x01, 0x02, 0x03,   0x04, 0x01, 0x06, 0x07,
   0x08, 0x01, 0x02, 0x03,   0x0c, 0x01, 0x0e, 0x0f,

   0x10, 0x01, 0x02, 0x03,   0x04, 0x01, 0x06, 0x07,
   0x18, 0x01, 0x02, 0x03,   0x1c, 0x01, 0x1e, 0x1f
};

int Board::calcBadIslands(BitVec boardVec, int row)
{
   BitVec toFill = ~boardVec;
   if (row & 1) {
      row--;
      toFill <<= N_COL;
   }

   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row > 4) {
      int boardMaskShift = (row - 4) * N_COL;
      boardMask >>= boardMaskShift;
   }
   toFill &= boardMask;

   // a little pre-work to speed things up
   BitVec bottom = (TOP_ROW << (5 * N_COL));
   bool filled = ((bottom & toFill) == bottom);
   while ((bottom & toFill) == bottom) {
      toFill ^= bottom;
      bottom >>= N_COL;
   }

   BitVec startRegion;
   if (filled || (row < 4))
      startRegion = bottom & toFill;
   else {
      startRegion = g_firstRegion[toFill & TOP_ROW];
      if (startRegion == 0)  {
         startRegion = (toFill >> N_COL) & TOP_ROW;
         startRegion = g_firstRegion[startRegion];
         startRegion <<= N_COL;
      }
      startRegion |= (startRegion << N_COL) & toFill;
   }

   while (toFill)    {
      if (badRegion(toFill, startRegion))
         return (toFill ? ALWAYS_BAD : BAD);
      int iPos = getFirstOne(toFill);
      startRegion = getMask(iPos);
   }

   return GOOD;
}

TUInt32 g_flip[] = {
   0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,
   0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,

   0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,
   0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f,
};

inline TUInt32 flipTwoRows(TUInt32 bits) {
   TUInt32 flipped = g_flip[bits >> N_COL] << N_COL;
   return (flipped | g_flip[bits & Board::TOP_ROW]);
}

inline void markBad(IslandInfo & info, TUInt32 mask, int eo, bool always) {
   info.hasBad[eo][OPEN] |= mask;
   info.hasBad[eo][CLOSED] |= mask;

   if (always)
      info.alwaysBad[eo] |= mask;
}

void Board::calcAlwaysBad(void) {
   for (TUInt32 iWord = 1; iWord < MAX_ISLAND_OFFSET; iWord++) {
      IslandInfo & isleInfo = g_islandInfo[iWord];
      IslandInfo & flipped = g_islandInfo[flipTwoRows(iWord)];

      for (TUInt32 i = 0, mask = 1; i < 32; i++, mask <<= 1) {
         TUInt32 boardVec = (i << (2 * N_COL)) | iWord;
         if (isleInfo.isKnown[0][OPEN] & mask)
            continue;

         int hasBad = calcBadIslands(boardVec, 0);
         if (hasBad != GOOD) {
            bool always = (hasBad==ALWAYS_BAD);
            markBad(isleInfo, mask, EVEN, always);

            TUInt32 flipMask = getMask(g_flip[i]);
            markBad(flipped, flipMask, ODD, always);
         }
      }
      flipped.isKnown[1][OPEN] = TUInt32(-1);
      isleInfo.isKnown[0][OPEN] = TUInt32(-1);
   }
}

bool Board::hasBadIslandsSingle(BitVec boardVec, int row)
{
   BitVec toFill = ~boardVec;
   bool isOdd = (row & 1);
   if (isOdd) {
      row--;
      toFill <<= N_COL; // shift to even aligned
      toFill |= TOP_ROW;
   }

   BitVec startRegion = TOP_ROW;
   BitVec lastRow = TOP_ROW << (5 * N_COL);
   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row >= 4)
      boardMask >>= ((row - 4) * N_COL);
   else if (isOdd || (row == 0))
      startRegion = lastRow;

   toFill &= boardMask;
   startRegion &= toFill;

   while (toFill)    {
      if (badRegion(toFill, startRegion))
         return true;
      int iPos = getFirstOne(toFill);
      startRegion = getMask(iPos);
   }

   return false;
}

void Board::genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 row)
{
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }
   TUInt32 iNextFill = s_firstOne[~boardVec & TOP_ROW];
   const OkPieces & allowed = g_okPieces[row][iNextFill];

   int iPiece = getFirstOne(~placedPieces);
   int pieceMask = getMask(iPiece);
   for (; iPiece < N_PIECE_TYPE; iPiece++, pieceMask <<= 1)
   {
      // skip if we've already used this piece
      if (pieceMask & placedPieces)
         continue;

      placedPieces |= pieceMask;
      for (int iOrient = 0; iOrient < allowed.nPieces[iPiece]; iOrient++) {
         BitVec pieceVec = allowed.pieceVec[iPiece][iOrient];

         // check if piece conflicts with other pieces
         if (pieceVec & boardVec)
            continue;

         // add the piece to the board
         boardVec |= pieceVec;

         if (hasBadIslands(boardVec, row)) {
            boardVec ^= pieceVec;
            continue;
         }

         m_curSoln.pushPiece(pieceVec, iPiece, row);

         // recur or record solution
         if (placedPieces != Piece::ALL_PIECE_MASK)
            genAllSolutions(boardVec, placedPieces, row);
         else
            recordSolution(m_curSoln);

         // remove the piece before continuing with a new piece
         boardVec ^= pieceVec;
         m_curSoln.popPiece();
      }

      placedPieces ^= pieceMask;
   }
}

void Board::recordSolution(Soln & s) {
   m_nSoln += 2; // add solution and its rotation

   if (m_minSoln.isEmpty()) {
      m_minSoln = m_maxSoln = s;
      return;
   }

   if (s.lessThan(m_minSoln))
      m_minSoln = s;
   else if (m_maxSoln.lessThan(s))
      m_maxSoln = s;

   Soln spun;
   s.spin(spun);
   if (spun.lessThan(m_minSoln))
      m_minSoln = spun;
   else if (m_maxSoln.lessThan(spun))
      m_maxSoln = spun;
}

int main(int argc, char * []) {
   if (argc > 2)
      return 1; // spec says this is an error

   Board b;
   Piece::genAllOrientations();
   Board::calcAlwaysBad();
   b.genAllSolutions(0, 0, 0);

   cout << b.m_nSoln << " solutions found\n\n";
   cout << b.m_minSoln.toString() << '\n';
   cout << b.m_maxSoln.toString() << endl;

   return 0;
}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
// contributed by Ben St. John
// some ideas taken from Kevin Barnes' implementation
/* A few key optimizations:
- pre-calcing of all possible orientations of each piece
- pre-calcing of which orientations are possible in each board position
- fast calculation of boards with bad islands (which are unsolveable)
- pre-calc of some boards (by top three lines) which *always* have bad islands
- using only 32-bit boards representations (plus row offset)
- improvement since #4 -- no caching of top three lines for other reasons
- not using STL vector -- it noticeably slow things down
- rotating each found solution, so only half need to be calculated -- done by removing
half the rotations of one piece (SKIP_PIECE) chosen as the one with the most valid positions
on the board, so only half the solution space is searched

For size, most seems to come from the standard libs.
I'm tempted to get rid of string, and maybe use cstdio.
*/

#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <memory.h>

using namespace std;

#define getMask(iPos) (1 << (iPos))

enum {X, Y, N_DIM};
enum {EVEN, ODD, N_PARITY};
enum {GOOD, BAD, ALWAYS_BAD};

typedef unsigned int TUInt32;
typedef unsigned long long TUInt64;
typedef signed char TInt8;
typedef TUInt32 BitVec;

static const int N_COL = 5;
static const int N_ROW = 10;
static const int N_CELL = N_COL * N_ROW;
static const int N_PIECE_TYPE = 10;

struct Piece;

struct Soln {
   static const int NO_PIECE = -1;

   void setCells(void);
   bool lessThan(Soln & r);
   string toString(void) const;
   void fill(int val);
   void spin(Soln & spun);

   bool isEmpty(void) {return (m_nPiece == 0);}
   void popPiece(void) {m_nPiece--; m_synched = false;}
   void pushPiece(BitVec vec, int iPiece, int row) {
      SPiece & p = m_pieces[m_nPiece++];
      p.vec = vec;
      p.iPiece = (short)iPiece;
      p.row = (short)row;
   }

   Soln(int fillVal);
   Soln() : m_synched(false), m_nPiece(0) {}

   struct SPiece {
      BitVec vec;
      short iPiece;
      short row;
      SPiece() {}
      SPiece(BitVec avec, TUInt32 apiece, TUInt32 arow) :
      vec(avec), iPiece(short(apiece)), row(short(arow))
      {}
   };
   SPiece m_pieces[N_PIECE_TYPE];
   TUInt32 m_nPiece;
   TInt8 m_cells[N_ROW][N_COL];
   bool m_synched;
};

//------------------------------------
struct Board {
   static const BitVec L_EDGE_MASK =
      (1 <<  0) | (1 <<  5) | (1 << 10) | (1 << 15) |
      (1 << 20) | (1 << 25) | (1 << 30);
   static const BitVec R_EDGE_MASK = L_EDGE_MASK << 4;
   static const BitVec TOP_ROW = (1 << N_COL) - 1;
   static const TUInt32 TWO_ROWS = 2 * N_COL;
   static const BitVec TOP_2_ROWS = (1 << TWO_ROWS) - 1;

   static const BitVec ROW_0_MASK =
      TOP_ROW | (TOP_ROW << 10) | (TOP_ROW << 20) | (TOP_ROW << 30);
   static const BitVec ROW_1_MASK = ROW_0_MASK << 5;
   static const BitVec BOARD_MASK = (1 << 30) - 1;

   Board();

   static TUInt32 getIndex(TUInt32 x, TUInt32 y) { return y * N_COL + x; }
   static bool badRegion(BitVec & toFill, BitVec rNew);
   static int hasBadIslands(BitVec boardVec, int row);
   static int calcBadIslands(BitVec boardVec, int row);
   static bool hasBadIslandsSingle(BitVec boardVec, int row);
   static void calcAlwaysBad(void);

   void genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 iNextFill);
   void recordSolution(Soln & s);

   Soln m_curSoln;
   Soln m_minSoln;
   Soln m_maxSoln;
   TUInt32 m_nSoln;
};

//------------------------------------

struct Piece {
   struct Instance {
      TUInt64 m_allowed;
      BitVec m_vec;
      int m_offset;
   };

   static const int N_ELEM = 5;
   static const int N_ORIENT = 12;
   static const int ALL_PIECE_MASK = (1 << N_PIECE_TYPE) - 1;
   static const TUInt32 SKIP_PIECE = 5; // it's magic!

   typedef int TPts[N_ELEM][N_DIM];

   static const BitVec BaseVecs[N_PIECE_TYPE];
   static Piece s_basePiece[N_PIECE_TYPE][N_ORIENT];

   static const Instance & getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity);
   static BitVec toBitVector(const TPts & pts);
   static void genOrientation(BitVec vec, TUInt32 iOrient, Piece & target);
   static void setCoordList(BitVec vec, TPts & pts);
   static void shiftUpLines(TPts & pts, int shift);
   static int shiftToX0(TPts & pts, Instance & instance, int offsetRow);
   void setOkPos(TUInt32 isOdd, int w, int h);
   static void genAllOrientations(void);

   Instance m_instance[N_PARITY];
};

struct OkPieces {
   TInt8 nPieces[N_PIECE_TYPE];
   TUInt32 pieceVec[N_PIECE_TYPE][Piece::N_ORIENT];
};

static OkPieces g_okPieces[N_ROW][N_COL] = {{0}};

#define MAX_ISLAND_OFFSET 1024
struct IslandInfo {
   TUInt32 alwaysBad[N_PARITY];
};

static IslandInfo g_islandInfo[MAX_ISLAND_OFFSET] = {0};

//------------------------------------
Soln::Soln(int fillVal) :
m_nPiece(0) {
   fill(fillVal);
}

void Soln::fill(int val) {
   m_synched = false;
   memset(m_cells, val, N_CELL);
}

string Soln::toString(void) const {
   string result;
   result.reserve(N_CELL * 2);

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int val = m_cells[y][x];
         result += ((val == NO_PIECE) ? '.' : char('0' + val));
         result += ' ';
      }
      result += '\n';

      // indent every second line
      if (y % 2 == 0)
         result += " ";
   }
   return result;
}

void Soln::setCells(void) {
   if (m_synched)
      return;

   for (TUInt32 iPiece = 0; iPiece < m_nPiece; iPiece++) {
      const SPiece & p = m_pieces[iPiece];
      BitVec vec = p.vec;
      TInt8 pID = (TInt8)p.iPiece;
      int rowOffset = p.row;

      int nNewCells = 0;
      for (int y = rowOffset; y < N_ROW; y++) {
         for (int x = 0; x < N_COL; x++) {
            if (vec & 1) {
               m_cells[y][x] = pID;
               nNewCells++;
            }
            vec >>= 1;
       }
         if (nNewCells == Piece::N_ELEM)
            break;
      }
   }
   m_synched = true;
}

bool Soln::lessThan(Soln & r) {
   if (m_pieces[0].iPiece != r.m_pieces[0].iPiece) {
      return m_pieces[0].iPiece < r.m_pieces[0].iPiece;
   }

   setCells();
   r.setCells();

   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         int lval = m_cells[y][x];
         int rval = r.m_cells[y][x];

         if (lval != rval)
            return (lval < rval);
      }
   }

   return false; // solutions are equal
}

void Soln::spin(Soln & spun) {
   setCells();

   // swap cells
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         TInt8 flipped = m_cells[N_ROW - y - 1][N_COL - x - 1];
         spun.m_cells[y][x] = flipped;
      }
   }

   // swap first and last pieces (the rest aren't used)
   spun.m_pieces[0].iPiece = m_pieces[N_PIECE_TYPE - 1].iPiece;
   spun.m_synched = true;
}

//------------------------------------

Piece Piece::s_basePiece[N_PIECE_TYPE][N_ORIENT];

const BitVec Piece::BaseVecs[] = {
   0x10f, 0x0cb, 0x1087, 0x427, 0x465,
   0x0c7, 0x8423, 0x0a7, 0x187, 0x08f
};

int floor(int top, int bot) {
   int toZero = top / bot;
   // negative numbers should be rounded down, not towards zero
   if ((toZero * bot != top) && ((top < 0) != (bot <= 0)))
      toZero--;

   return toZero;
}

const TUInt32 s_firstOne[32] = {
   0, 0, 1, 0,   2, 0, 1, 0,
   3, 0, 1, 0,   2, 0, 1, 0,

   4, 0, 1, 0,   2, 0, 1, 0,
   3, 0, 1, 0,   2, 0, 1, 0,
};

TUInt32 getFirstOne(BitVec v, TUInt32 startPos = 0) {
   if (v == 0)
      return 0;

   TUInt32 iPos = startPos;
   BitVec mask = 0xff << startPos;
   if ((mask & v) == 0) {
      mask <<= 8; iPos += 8;
      if ((mask & v) == 0) {
         mask <<= 8; iPos += 8;
         if ((mask & v) == 0) {
            mask <<= 8; iPos += 8;
       }
      }
   }

   TUInt32 result = TUInt32((mask & v) >> iPos);
   TUInt32 resultLow = result & 0x0f;
   if (resultLow != 0)
      iPos += s_firstOne[resultLow];
   else
      iPos += 4 + s_firstOne[result >> 4];

   return iPos;
}

void Piece::setCoordList(BitVec vec, TPts & pts) {
   int iPt = 0;
   BitVec mask = 1;
   for (int y = 0; y < N_ROW; y++) {
      for (int x = 0; x < N_COL; x++) {
         if (mask & vec) {
            pts[iPt][X] = x;
            pts[iPt][Y] = y;

            iPt++;
       }
         mask <<= 1;
      }
   }
}

BitVec Piece::toBitVector(const TPts & pts) {
   int y, x;
   BitVec result = 0;
   for (int iPt = 0; iPt < N_ELEM; iPt++) {
      x = pts[iPt][X];
      y = pts[iPt][Y];

      int pos = Board::getIndex(x, y);
      result |= (1 << pos);
   }

   return result;
}

void Piece::shiftUpLines(TPts & pts, int shift) {
   // vertical shifts have a twist
   for (int iPt = 0; iPt < N_ELEM; iPt++) {
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      if (ry & shift & 0x1)
         rx++;
      ry -= shift;
   }
}

int Piece::shiftToX0(TPts & pts, Instance & instance, int offsetRow)
{
   // .. determine shift
   int x, y, iPt;
   int xMin = pts[0][X];
   int xMax = xMin;
   for (iPt = 1; iPt < N_ELEM; iPt++) {
      x = pts[iPt][X];
      y = pts[iPt][Y];

      if (x < xMin)
         xMin = x;
      else if (x > xMax)
         xMax = x;
   }

   // I'm dying for a 'foreach' here
   int offset = N_ELEM;
   for (iPt = 0; iPt < N_ELEM; iPt++) {
      int & rx = pts[iPt][X];
      int & ry = pts[iPt][Y];

      rx -= xMin;

      // check offset -- leftmost cell on top line
      if ((ry == offsetRow) && (rx < offset))
         offset = rx;
   }

   instance.m_offset = offset;
   instance.m_vec = toBitVector(pts);
   return xMax - xMin;
}

void Piece::setOkPos(TUInt32 isOdd, int w, int h) {
   Instance & p = m_instance[isOdd];
   TUInt64 & allowed = p.m_allowed = 0;
   TUInt64 posMask = 1LL << (isOdd * N_COL);

   for (int y = isOdd; y < N_ROW - h; y+=2, posMask <<= N_COL) {
      if (p.m_offset)
         posMask <<= p.m_offset;

      for (int xPos = 0; xPos < N_COL - p.m_offset; xPos++, posMask <<= 1) {
         // check if the new position is on the board
         if (xPos >= N_COL - w)
            continue;

         // move it to the desired location
         BitVec pieceVec = p.m_vec << xPos;

         if (Board::hasBadIslandsSingle(pieceVec, y))
            continue;

         // position is allowed
         allowed |= posMask;
      }
   }
}

void Piece::genOrientation(BitVec vec, TUInt32 iOrient, Piece & target)
{
   // get (x,y) coordinates
   TPts pts;
   setCoordList(vec, pts);

   int y, x, iPt;
   int rot = iOrient % 6;
   int flip = iOrient >= 6;
   if (flip) {
      for (iPt = 0; iPt < N_ELEM; iPt++)
         pts[iPt][Y] = -pts[iPt][Y];
   }

   // rotate as necessary
   while (rot--) {
      for (iPt = 0; iPt < N_ELEM; iPt++) {
         x = pts[iPt][X];
         y = pts[iPt][Y];

         // I just worked this out by hand. Took a while.
         int xNew = floor((2 * x - 3 * y + 1), 4);
         int yNew = floor((2 * x + y + 1), 2);
         pts[iPt][X] = xNew;
         pts[iPt][Y] = yNew;
      }
   }

   // determine vertical shift
   int yMin = pts[0][Y];
   int yMax = yMin;
   for (iPt = 1; iPt < N_ELEM; iPt++) {
      y = pts[iPt][Y];

      if (y < yMin)
         yMin = y;
      else if (y > yMax)
         yMax = y;
   }
   int h = yMax - yMin;
   Instance & even = target.m_instance[EVEN];
   Instance & odd = target.m_instance[ODD];

   shiftUpLines(pts, yMin);
   int w = shiftToX0(pts, even, 0);
   target.setOkPos(EVEN, w, h);
   even.m_vec >>= even.m_offset;

   // shift down one line
   shiftUpLines(pts, -1);
   w = shiftToX0(pts, odd, 1);
   // shift the bitmask back one line
   odd.m_vec >>= N_COL;
   target.setOkPos(ODD, w, h);
   odd.m_vec >>= odd.m_offset;
}

void Piece::genAllOrientations(void) {
   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      BitVec refPiece = BaseVecs[iPiece];
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         Piece & p = s_basePiece[iPiece][iOrient];
         genOrientation(refPiece, iOrient, p);
         if ((iPiece == SKIP_PIECE) && ((iOrient / 3) & 1))
            p.m_instance[0].m_allowed = p.m_instance[1].m_allowed = 0;
      }
   }

   for (int iPiece = 0; iPiece < N_PIECE_TYPE; iPiece++) {
      for (int iOrient = 0; iOrient < N_ORIENT; iOrient++) {
         TUInt64 mask = 1;
         for (int iRow = 0; iRow < N_ROW; iRow++) {
            const Instance & p = getPiece(iPiece, iOrient, (iRow & 1));
            for (int iCol = 0; iCol < N_COL; iCol++) {
               OkPieces & allowed = g_okPieces[iRow][iCol];
               if (p.m_allowed & mask) {
                  TInt8 & nPiece = allowed.nPieces[iPiece];
                  allowed.pieceVec[iPiece][nPiece] = p.m_vec << iCol;
                  nPiece++;
               }

               mask <<= 1;
            }
       }
      }
   }
}


inline const Piece::Instance & Piece::getPiece(TUInt32 iPiece, TUInt32 iOrient, TUInt32 iParity) {
   return s_basePiece[iPiece][iOrient].m_instance[iParity];
}

// ------------------------------------

Board::Board() :
m_curSoln(Soln::NO_PIECE), m_minSoln(N_PIECE_TYPE),
m_maxSoln(Soln::NO_PIECE), m_nSoln(0)
{}

TUInt32 g_flip[] = {
   0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,
   0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,

   0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,
   0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f,
};

inline TUInt32 flipTwoRows(TUInt32 bits) {
   TUInt32 flipped = g_flip[bits >> N_COL] << N_COL;
   return (flipped | g_flip[bits & Board::TOP_ROW]);
}

void Board::calcAlwaysBad(void) {
   for (TUInt32 iWord = 1; iWord < MAX_ISLAND_OFFSET; iWord++) {
      IslandInfo & isleInfo = g_islandInfo[iWord];
      IslandInfo & flipped = g_islandInfo[flipTwoRows(iWord)];

      for (TUInt32 i = 0, mask = 1; i < 32; i++, mask <<= 1) {
         TUInt32 boardVec = (i << TWO_ROWS) | iWord;

         int hasBad = calcBadIslands(boardVec, 0);
         if (hasBad == ALWAYS_BAD) {
            isleInfo.alwaysBad[EVEN] |= mask;

            TUInt32 flipMask = getMask(g_flip[i]);
            flipped.alwaysBad[ODD] |= flipMask;
       }
      }
   }
}

bool Board::hasBadIslandsSingle(BitVec boardVec, int row)
{
   BitVec toFill = ~boardVec;
   bool isOdd = (row & 1);
   if (isOdd) {
      row--;
      toFill <<= N_COL; // shift to even aligned
      toFill |= TOP_ROW;
   }

   BitVec startRegion = TOP_ROW;
   BitVec lastRow = TOP_ROW << (5 * N_COL);
   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row >= 4)
      boardMask >>= ((row - 4) * N_COL);
   else if (isOdd || (row == 0))
      startRegion = lastRow;

   toFill &= boardMask;
   startRegion &= toFill;

   while (toFill)    {
      if (badRegion(toFill, startRegion))
         return true;
      int iPos = getFirstOne(toFill);
      startRegion = getMask(iPos);
   }

   return false;
}

void Board::recordSolution(Soln & s) {
   m_nSoln += 2; // add solution and its rotation

   if (m_minSoln.isEmpty()) {
      m_minSoln = m_maxSoln = s;
      return;
   }

   if (s.lessThan(m_minSoln))
      m_minSoln = s;
   else if (m_maxSoln.lessThan(s))
      m_maxSoln = s;

   Soln spun;
   s.spin(spun);
   if (spun.lessThan(m_minSoln))
      m_minSoln = spun;
   else if (m_maxSoln.lessThan(spun))
      m_maxSoln = spun;
}

TUInt32 countOnes(BitVec v) {
   TUInt32 n = 0;
   while (v) {
      n++;
      v = v & (v - 1);
   }

   return n;
}

bool Board::badRegion(BitVec & toFill, BitVec rNew)
{
   // grow empty region, until it doesn't change any more
   BitVec region;
   do {
      region = rNew;

      // simple grow up/down
      rNew |= (region >> N_COL);
      rNew |= (region << N_COL);

      // grow right/left
      rNew |= (region & ~L_EDGE_MASK) >> 1;
      rNew |= (region & ~R_EDGE_MASK) << 1;

      // tricky growth
      BitVec evenRegion = region & (ROW_0_MASK & ~L_EDGE_MASK);
      rNew |= evenRegion >> (N_COL + 1);
      rNew |= evenRegion << (N_COL - 1);
      BitVec oddRegion = region & (ROW_1_MASK & ~R_EDGE_MASK);
      rNew |= oddRegion >> (N_COL - 1);
      rNew |= oddRegion << (N_COL + 1);

      // clamp against existing pieces
      rNew &= toFill;
   }
   while ((rNew != toFill) && (rNew != region));

   // subtract empty region from board
   toFill ^= rNew;

   TUInt32 nCells = countOnes(toFill);
   return (nCells % Piece::N_ELEM != 0);
}

static TUInt32 g_firstRegion[] = {
   0x00, 0x01, 0x02, 0x03,   0x04, 0x01, 0x06, 0x07,
   0x08, 0x01, 0x02, 0x03,   0x0c, 0x01, 0x0e, 0x0f,

   0x10, 0x01, 0x02, 0x03,   0x04, 0x01, 0x06, 0x07,
   0x18, 0x01, 0x02, 0x03,   0x1c, 0x01, 0x1e, 0x1f
};

int Board::calcBadIslands(BitVec boardVec, int row)
{
   BitVec toFill = ~boardVec;
   if (row & 1) {
      row--;
      toFill <<= N_COL;
   }

   BitVec boardMask = BOARD_MASK; // all but the first two bits
   if (row > 4) {
      int boardMaskShift = (row - 4) * N_COL;
      boardMask >>= boardMaskShift;
   }
   toFill &= boardMask;

   // a little pre-work to speed things up
   BitVec bottom = (TOP_ROW << (5 * N_COL));
   bool filled = ((bottom & toFill) == bottom);
   while ((bottom & toFill) == bottom) {
      toFill ^= bottom;
      bottom >>= N_COL;
   }

   BitVec startRegion;
   if (filled || (row < 4))
      startRegion = bottom & toFill;
   else {
      startRegion = g_firstRegion[toFill & TOP_ROW];
      if (startRegion == 0)  {
         startRegion = (toFill >> N_COL) & TOP_ROW;
         startRegion = g_firstRegion[startRegion];
         startRegion <<= N_COL;
      }
      startRegion |= (startRegion << N_COL) & toFill;
   }

   do {
      if (badRegion(toFill, startRegion))
         return ALWAYS_BAD;
      int iPos = getFirstOne(toFill);
      startRegion = getMask(iPos);
   } while (toFill);

   return GOOD;
}

int Board::hasBadIslands(BitVec boardVec, int row)
{
   // skip over any filled rows
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }

   TUInt32 iInfo = boardVec & TOP_2_ROWS;
   IslandInfo & info = g_islandInfo[iInfo];

   TUInt32 thirdRow = (boardVec >> TWO_ROWS) & TOP_ROW;
   TUInt32 mask = getMask(thirdRow);
   TUInt32 isOdd = row & 1;
   TUInt32 & alwaysBad = info.alwaysBad[isOdd];

   if (alwaysBad & mask)
      return ALWAYS_BAD;

   if (boardVec == 0)
      return GOOD;

   return calcBadIslands(boardVec, row);
}

void Board::genAllSolutions(BitVec boardVec, TUInt32 placedPieces, TUInt32 row)
{
   while ((boardVec & TOP_ROW) == TOP_ROW) {
      boardVec >>= N_COL;
      row++;
   }
   TUInt32 iNextFill = s_firstOne[~boardVec & TOP_ROW];
   const OkPieces & allowed = g_okPieces[row][iNextFill];

   int iPiece = getFirstOne(~placedPieces);
   int pieceMask = getMask(iPiece);

   for (; iPiece < N_PIECE_TYPE; iPiece++, pieceMask <<= 1)
   {
      // skip if we've already used this piece
      if (pieceMask & placedPieces)
         continue;

      placedPieces |= pieceMask;

      for (int iOrient = 0; iOrient < allowed.nPieces[iPiece]; iOrient++) {
         BitVec pieceVec = allowed.pieceVec[iPiece][iOrient];

         // check if piece conflicts with other pieces
         if ((pieceVec & boardVec) || hasBadIslands(boardVec | pieceVec, row))
            continue;

         m_curSoln.pushPiece(pieceVec, iPiece, row);

         // recur or record solution
         if (placedPieces != Piece::ALL_PIECE_MASK)
            genAllSolutions(boardVec | pieceVec, placedPieces, row);
         else
            recordSolution(m_curSoln);

         // remove the piece before continuing with a new piece
         m_curSoln.popPiece();
      }

      placedPieces ^= pieceMask;
   }
}

int main(int argc, char * []) {
   if (argc > 2)
      return 1; // spec says this is an error

   Board b;
   Piece::genAllOrientations();
   Board::calcAlwaysBad();
   b.genAllSolutions(0, 0, 0);
   cout << b.m_nSoln << " solutions found\n\n";
   cout << b.m_minSoln.toString() << '\n';
   cout << b.m_maxSoln.toString() << endl;

   return 0;
}

// -*- mode: c++ -*-
// $Id: methcall.gpp,v 1.1 2004-11-10 07:07:16 bfulgham Exp $
// http://shootout.alioth.debian.org/

// with some help from Bill Lear

#include <stdlib.h>
#include <iostream>

using namespace std;

class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() {
	return(state);
    }
    virtual Toggle& activate() {
	state = !state;
	return(*this);
    }
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
	Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle& activate() {
	if (++this->counter >= this->count_max) {
	    state = !state;
	    counter = 0;
	}
	return(*this);
    }
private:
    int count_max;
    int counter;
};


int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    bool val = true;
    Toggle *toggle = new Toggle(val);
    for (int i=0; i<n; i++) {
	val = toggle->activate().value();
    }
    cout << ((val) ? "true" : "false") << endl;
    delete toggle;

    val = true;
    NthToggle *ntoggle = new NthToggle(val, 3);
    for (int i=0; i<n; i++) {
	val = ntoggle->activate().value();
    }
    cout << ((val) ? "true" : "false") << endl;
    delete ntoggle;

    return 0;
}
// -*- mode: c++ -*-
// $Id moments.gpp,v 1.1.1.1 2004/05/19 18:10:47 bfulgham Exp $
// http://shootout.alioth.debian.org/
// Calculate statistical moments of a region, from Bill Lear
// Modified by Tamás Benkõ
// Further modified by Tom Hyer

#include <vector>
#include <numeric>
#include <iterator>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>

using namespace std;

template <class T>
struct moments {
public:
    template <class InputIterator>
    moments(InputIterator begin, InputIterator end)
        : median(0.0), mean(0.0), average_deviation(0.0),
          standard_deviation(0.0), variance(0.0),
          skew(0.0), kurtosis(0.0)
        {
            T sum = accumulate(begin, end, 0.0);
            size_t N = end - begin;
            mean = sum / N;
            for (InputIterator i = begin; i != end; ++i) {
                T deviation = *i - mean;
                average_deviation += fabs(deviation);
				T temp = deviation * deviation;
                variance += temp;
				temp *= deviation;
                skew += temp;
                kurtosis += temp * deviation;
            }
            average_deviation /= N;
            variance /= (N - 1);
            standard_deviation = sqrt(variance);

            if (variance) {
                skew /= (N * variance * standard_deviation);
                kurtosis = kurtosis/(N * variance * variance) - 3.0;
            }

            InputIterator mid = begin+N/2;
            nth_element(begin, mid, end);
            if (N % 2 == 0) {
				InputIterator next_biggest = max_element(begin, 
mid);
                median = (*mid+*next_biggest)/2;
            }
			else
				median = *mid;
        }

    T median;
    T mean;
    T average_deviation;
    T standard_deviation;
    T variance;
    T skew;
    T kurtosis;
};

int main() {
    vector<double> v;
    double d;

    while (scanf(" %lf", &d) == 1) v.push_back(d);
    moments<double> m(v.begin(), v.end());

    cout << std::fixed << std::setprecision(6);
    cout << "n:                  " << v.end() - v.begin() << endl;
    cout << "median:             " << m.median << endl;
    cout << "mean:               " << m.mean << endl;
    cout << "average_deviation:  " << m.average_deviation << endl;
    cout << "standard_deviation: " << m.standard_deviation << endl;
    cout << "variance:           " << m.variance << endl;
    cout << "skew:               " << m.skew << endl;
    cout << "kurtosis:           " << m.kurtosis << endl;

    return 0;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christoph Bauer
 * slightly improved by Mark Hinds
 * SIMDified by Stefan Krause
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

typedef double v2df __attribute__ (( vector_size(2*sizeof(double)) ));

double __inline lower(const v2df& v) {
    return ((double*)&v)[0];
}

double __inline upper(const v2df& v) {
    return ((double*)&v)[1];
}

struct planet { 
    v2df xy;
    v2df z0; // z and zero
    v2df vxvy;
    v2df vz00;	// vz and zero
    v2df massmass; // the mass in both components
};

void advance(int nbodies, struct planet * bodies, const v2df& dtdt)
{
  int i, j;
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      v2df dxdy = b->xy - b2->xy;
      v2df dz00 = b->z0 - b2->z0;
      v2df tsquare = __builtin_ia32_haddpd(dxdy*dxdy,dz00*dz00);    // dx*dx+dy*dy | dz*dz
      v2df distance2 = __builtin_ia32_haddpd(tsquare,tsquare);      // dx*dx+dy*dy+dz*dz | dx*dx+dy*dy+dz*dz
      v2df magmag = dtdt / (__builtin_ia32_sqrtpd(distance2)*distance2);
      dxdy *= magmag;
      dz00 *= magmag;
      b->vxvy -= dxdy * b2->massmass;
      b->vz00 -= dz00 * b2->massmass;
      b2->vxvy += dxdy * b->massmass;
      b2->vz00 += dz00 * b->massmass;
    }
  }
  for (i = 0; i < nbodies; i++) {
    bodies[i].xy += dtdt * bodies[i].vxvy;
    bodies[i].z0 += dtdt * bodies[i].vz00;
  }
}

double energy(int nbodies, struct planet * bodies)
{
  v2df e = {0.0, 0.0};
  v2df half = {0.5, 0.5};
  int i, j;

  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    v2df sq = b->massmass * __builtin_ia32_haddpd(b->vxvy*b->vxvy, b->vz00*b->vz00);  // b->mass*(vx*vx + vy*vy) | b->mass*(vz*vz + 0*0)
    sq = __builtin_ia32_haddpd(sq,sq);
    e += half * sq;
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      v2df dxdy = b->xy - b2->xy;
      v2df dz00 = b->z0 - b2->z0;
      v2df distance = __builtin_ia32_haddpd(dxdy*dxdy, dz00*dz00);  // b->mass*(vx*vx + vy*vy) | b->mass*(vz*vz + 0*0)
      distance = __builtin_ia32_sqrtpd(__builtin_ia32_haddpd(distance,distance));
      e -= (b->massmass * b2->massmass) / distance;
    }
  }
  return lower(e);
}

void offset_momentum(int nbodies, struct planet * bodies)
{
  v2df pxpy = {0.0, 0.0};
  v2df pz00 = {0.0, 0.0};
  int i;
  for (i = 0; i < nbodies; i++) {
    pxpy += bodies[i].vxvy * bodies[i].massmass;
    pz00 += bodies[i].vz00 * bodies[i].massmass;
  }
  v2df solar_mass_inv = { 1.0 / solar_mass, 1.0 / solar_mass};
  bodies[0].vxvy = - pxpy * solar_mass_inv;
  bodies[0].vz00 = - pz00 * solar_mass_inv;
}

#define NBODIES 5
struct planet bodies[NBODIES] = {
  {                               // sun
      {0, 0}, {0,0}, {0, 0}, {0,0}, {solar_mass,solar_mass}
  },
  {                               // jupiter
      {4.84143144246472090e+00,
    -1.16032004402742839e+00},
    {-1.03622044471123109e-01, 0},
    {1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year},
    {-6.90460016972063023e-05 * days_per_year,0},
    {9.54791938424326609e-04 * solar_mass,9.54791938424326609e-04 * solar_mass}
  },
  {                               // saturn
      {8.34336671824457987e+00,
    4.12479856412430479e+00},
    {-4.03523417114321381e-01, 0},
    {-2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year},
    {2.30417297573763929e-05 * days_per_year,0},
    {2.85885980666130812e-04 * solar_mass,2.85885980666130812e-04 * solar_mass}
  },
  {                               // uranus 
      {1.28943695621391310e+01,
    -1.51111514016986312e+01},
    {-2.23307578892655734e-01,0},
    {2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year},
    {-2.96589568540237556e-05 * days_per_year,0},
    {4.36624404335156298e-05 * solar_mass,4.36624404335156298e-05 * solar_mass}
  },
  {                               // neptune 
      {1.53796971148509165e+01,
    -2.59193146099879641e+01},
    {1.79258772950371181e-01,0},
    {2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year},
    {-9.51592254519715870e-05 * days_per_year,0},
    {5.15138902046611451e-05 * solar_mass,5.15138902046611451e-05 * solar_mass}
  }
};

int main(int argc, char ** argv)
{
  int n = atoi(argv[1]);
  int i;

  offset_momentum(NBODIES, bodies);
  printf ("%.9f\n", energy(NBODIES, bodies));
  v2df dtdt = {0.01, 0.01};
  for (i = 1; i <= n; i++)
    advance(NBODIES, bodies, dtdt);
  printf ("%.9f\n", energy(NBODIES, bodies));
  return 0;
}
// -*- mode: c++ -*-
// $Id: nestedloop.gpp,v 1.1 2004-11-10 06:52:26 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <iostream>
#include <stdlib.h>

using namespace std;

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int a, b, c, d, e, f, x=0;
	
    for (a=0; a<n; a++)
	for (b=0; b<n; b++)
	    for (c=0; c<n; c++)
		for (d=0; d<n; d++)
		    for (e=0; e<n; e++)
			for (f=0; f<n; f++)
			    x++;

    cout << x << endl;
    return(0);
}
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// Precedent C entry modified by bearophile for speed and size, 31 Jan 2006
// Converted to C++ by Paul Kitchin

#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>

void nsieve(std::size_t max)
{
   static std::vector< unsigned char > flags;
   flags.assign(max, false);
   std::size_t count = 0;
   for (std::size_t value = 2; value < max; ++value)
   {
      if (!flags[value])
      {
         ++count;
         for (std::size_t multiple = value * 2; multiple < max; multiple += value)
         {
            flags[multiple] = true;
         }
      }
   }
   std::cout << "Primes up to " << std::setw(8) << max << ' ' << std::setw(8) << count << '\n';
}

int main(int argc, char * * argv)
{
   if (argc != 2)
   {
      std::cerr << "usage: " << argv[0] << " <n>\n";
      return 1;
   }
   unsigned int count;
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> count) || !convertor.eof())
      {
         std::cerr << "usage: " << argv[0] << " <n>\n";
         std::cerr << "\tn must be an integer\n";
         return 1;
      }
   }
   for (std::size_t i = 0; i < 3; ++i)
   {
      nsieve(10000 << (count - i));
   }
}
/*
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Daniel Skiles
-- modified by Vaclav Haisman
*/

#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cstdlib>


using namespace std;


unsigned nsieve (vector<bool> & isPrime)
{
  unsigned count = 0;
  size_t const m = isPrime.size ();

  fill (isPrime.begin () + 2, isPrime.end (), true);

  for (size_t i=2; i<m; ++i)
    if (isPrime[i])
      {
        for(size_t k=i*2; k<m; k+=i)
          isPrime[k] = false;
        ++count;
      }
  return count;
}


int main(int argc, char *argv[])
{
  int n = (argc == 2) ? atoi(argv[1]) : 2;
  unsigned m;

  m = (1<<n)*10000;
  vector<bool> flags (m);
  cout << "Primes up to " << setw(8) << m << " " << setw(8) << nsieve(flags) << endl;

  m = (1<<n-1)*10000;
  flags.resize (m);
  cout << "Primes up to " << setw(8) << m << " " << setw(8) << nsieve(flags) << endl;

  m = (1<<n-2)*10000;
  flags.resize (m);
  cout << "Primes up to " << setw(8) << m << " " << setw(8) << nsieve(flags) << endl;
}
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/
   
   contributed by Felix Koehler
*/ 

#include <vector>
#include <iostream>
#include <iomanip>
#include <cstdlib>

#define bool unsigned char
#define true 1
#define false 0

void nsieve(unsigned m)
{
   unsigned i, j;
   unsigned count=0;
   std::vector<bool> b(m+1, true);
   for (i=2; i<=m; ++i) {
      if (b[i]) {
         ++count;
         j=i*2;
         while (j<=m) {
            b[j]=false;
            j+=i;
         }
      }
   }
   std::cout
      << "Primes up to "
      << std::setw(8) << m << " "
      << std::setw(8) << count << "\n";
}

int main(int argc, char **argv)
{
   unsigned m=std::atoi(argv[1]);
   for (unsigned i = 0; i < 3; i++)
      nsieve(10000 << (m-i));
}

/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Jeffrey Beu
*/

#include <vector>
#include <cstdlib>
#include <iomanip>
#include <iostream>

using namespace std;

unsigned int nsieve(unsigned int m)
{
   typedef vector<unsigned char> vc;
   
   unsigned int count = 0;
   
   vc bflags(m,1);
   
   vc::const_iterator end   = bflags.end();
   vc::const_iterator begin = bflags.begin();

   for(vc::iterator i = bflags.begin() + 2; i < end; ++i)
   {
      if(*i) {
         int off_set = (int)(i - begin);

         for(vc::iterator j = i + off_set; j < end; j += off_set)
         {
            *j = 0;
         }
         ++count;
      }  
   }

   return count;
}

int main(int argc, char* argv[])
{
   unsigned int m = atoi(argv[1]);

   for (int i = 0; i < 3; i++) {
      unsigned int arg_m = 10000 << (m-i);
      unsigned int rslt = nsieve(arg_m);
      cout << "Primes up to" 
           << setw(9) << arg_m 
           << setw(9) << rslt  << '\n';
   }

   return 0;
}

/*   The Computer Language Shootout
   http://shootout.alioth.debian.org/

   written by Jon Harrop, 2005
   modified by Paul Kitchin, 2006
*/

#include <iostream>
#include <iomanip>
#include <limits>
#include <sstream>
#include <vector>

int nsieve(int max)
{
   std::size_t const bits = std::numeric_limits< unsigned int >::digits;
   std::vector< unsigned int > sieve((max / bits) + 1);
   int count = 0;
   for (int value = 2; value <= max; ++value)
   {
      if (!(sieve[value / bits] & (1 << (value % bits))))
      {
         ++count;
         for (int multiple = value * 2; multiple <= max; multiple += value)
         {
            if (!(sieve[multiple / bits] & (1 << (multiple % bits))))
            {
               sieve[multiple / bits] ^= (1 << (multiple % bits));
            }
         }
      }
   }
   return count;
}

void test(int n)
{
   int m = (1 << n) * 10000;
   std::cout << "Primes up to " << std::setw(8) << m << " " << std::setw(8) << nsieve(m) << std::endl;
}

int main(int argc, char * * argv)
{
   if (argc != 2)
   {
      std::cerr << "usage: nsieve <n>\n";
      return 1;
   }
   std::istringstream convertor(argv[1]);
   int n;
   if (!(convertor >> n) || !convertor.eof())
   {
      std::cerr << "usage: nsieve <n>\n";
      std::cerr << "   n must be an integer\n";
      return 1;
   }
   test(n);
   if (n >= 1)
   {
      test(n - 1);
   }
   if (n >= 2)
   {
      test(n - 2);
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Lasse KÃ¤rkkÃ¤inen
*/

#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <vector>

// Taking a REFERENCE to int makes the program slightly faster on G++ 4.20.
void nsieve(int& m) {
	int c=0;
	std::vector<bool> p(m+1, true);
	for (int i=2; i<=m; i++) if (p[i]) {
		for (int j=2*i; j<=m; j+=i) p[j]=false;
		c++;
	}
	std::cout<<"Primes up to "<<std::setw(8)<<m<<" "<<std::setw(8)<<c<<"\n";
}

int main(int m, char** argv) {
	nsieve(m=10000<<std::atoi(argv[1]));
	nsieve(m/=2);
	nsieve(m/=2);
}

/* The Computer Language Shootout
   http://shootout.alioth.debian.org/
   
   contributed by Felix Koehler
*/ 

#include <vector>
#include <iostream>
#include <iomanip>
#include <cstdlib>

void nsieve(unsigned m)
{
   unsigned i, j;
   unsigned count=0;
   std::vector<bool> b(m+1, true);
   for (i=2; i<=m; ++i) {
      if (b[i]) {
         ++count;
         j=i*2;
         while (j<=m) {
            b[j]=false;
            j+=i;
         }
      }
   }
   std::cout
      << "Primes up to "
      << std::setw(8) << m << " "
      << std::setw(8) << count << "\n";
}

int main(int argc, char **argv)
{
   unsigned m=std::atoi(argv[1]);
   for (unsigned i = 0; i < 3; i++)
      nsieve(10000 << (m-i));
}

// -*- mode: c++ -*-
// $Id: objinst.gpp,v 1.1 2004-11-10 06:53:57 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <stdlib.h>
#include <iostream>

using namespace std;

class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() {
	return(state);
    }
    virtual Toggle& activate() {
	state = !state;
	return(*this);
    }
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
	Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle& activate() {
	if (++this->counter >= this->count_max) {
	    state = !state;
	    counter = 0;
	}
	return(*this);
    }
private:
    int count_max;
    int counter;
};

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    Toggle *toggle1 = new Toggle(true);
    for (int i=0; i<5; i++) {
	cout << ((toggle1->activate().value()) ? "true" : "false") << endl;
    }
    delete toggle1;
    for (int i=0; i<n; i++) {
	Toggle *toggle = new Toggle(true);
	delete toggle;
    }
    
    cout << endl;
    
    NthToggle *ntoggle1 = new NthToggle(true, 3);
    for (int i=0; i<8; i++) {
	cout << ((ntoggle1->activate().value()) ? "true" : "false") << endl;
    }
    delete ntoggle1;
    for (int i=0; i<n; i++) {
	NthToggle *ntoggle = new NthToggle(true, 3);
	delete ntoggle;
    }
    return 0;
}
// -*- mode: c++ -*-
// $Id: objinst.gpp-2.gpp,v 1.2 2005-04-01 12:29:56 loisel-guest Exp $
// http://shootout.alioth.debian.org/

/*

  Modified version, old version available by doing g++ -D ORIGINAL
  
  Since Java doesn't have to do deletes, why are we?
  
  Made all classes stack instances instead of heap.  
  
  David McCombs
  
*/

#include <stdlib.h>
#include <iostream>

using namespace std;

#ifdef ORIGINAL 

class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() {
	return(state);
    }
    virtual Toggle& activate() {
	state = !state;
	return(*this);
    }
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
	Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle& activate() {
	if (++this->counter >= this->count_max) {
	    state = !state;
	    counter = 0;
	}
	return(*this);
    }
private:
    int count_max;
    int counter;
};

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    Toggle *toggle1 = new Toggle(true);
    for (int i=0; i<5; i++) {
	cout << ((toggle1->activate().value()) ? "true" : "false") << endl;
    }
    delete toggle1;
    for (int i=0; i<n; i++) {
	Toggle *toggle = new Toggle(true);
	delete toggle;
    }

    cout << endl;

    NthToggle *ntoggle1 = new NthToggle(true, 3);
    for (int i=0; i<8; i++) {
	cout << ((ntoggle1->activate().value()) ? "true" : "false") << endl;
    }
    delete ntoggle1;
    for (int i=0; i<n; i++) {
	NthToggle *ntoggle = new NthToggle(true, 3);
	delete ntoggle;
    }
    return 0;
}

#else
const char * truthvals[] = { "false", "true" };

class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() {
	return(state);
    }
    virtual Toggle& activate() {
	state = !state;
	return(*this);
    }
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
	Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle& activate() {
	if (++this->counter >= this->count_max) {
	    state = !state;
	    counter = 0;
	}
	return(*this);
    }
private:
    int count_max;
    int counter;
};

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    Toggle toggle1 = true;
    for (int i=0; i<5; i++) {
    cout << truthvals[toggle1.activate().value()] << endl;
    }
    
    for (int i=0; i<n; i++) {
    Toggle toggle = true;

    }

    cout << endl;

    NthToggle ntoggle1(true, 3);
    for (int i=0; i<8; i++) {
    cout << truthvals[ntoggle1.activate().value()] << endl;
    }
    
    for (int i=0; i<n; i++) {
    NthToggle ntoggle(true, 3);
    }
    return 0;
}

#endif
//   The Computer Language Shootout
//   http://shootout.alioth.debian.org/
//   contributed by Greg Buchholz
//   compile with:  -O3 -ffast-math

#include<iostream>
#include <iomanip>
#include<cmath>

int main(int argc, char* argv[])
{
    int n = atoi(argv[1]);
    double sum, a, s, s2, c, c2, k2, k3;
    std::cout << std::setprecision(9) << std::fixed;
    
#define psum(name,f) sum = 0; for(double k=1; k<=n; k++){ sum+= f;} \
                     std::cout << sum << "\t" << name << std::endl

    psum("(2/3)^k",pow(2.0/3.0, k-1));  psum("k^-0.5",1.0/sqrt(k)); 
    psum("1/k(k+1)",1.0/(k*(k+1.0))); 
    psum("Flint Hills",  (s=sin(k),1.0/(k*k*k * s*s)));
    psum("Cookson Hills",(c=cos(k),1.0/(k*k*k * c*c))); 
    psum("Harmonic",1.0/k);  psum("Riemann Zeta",1.0/(k*k)); 
    a = -1.0; psum("Alternating Harmonic",(a = -a)/k);
    a = -1.0; psum("Gregory",(a = -a)/(2.0*k -1));
}
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// contributed by Paul Kitchin

#include <cmath>
#include <iomanip>
#include <iostream>
#include <sstream>

int main(int argc, char * * argv)
{
   if (argc != 2)
   {
      std::cerr << "Usage: " << argv[0] << " <n>\n";
      return 1;
   }
   std::size_t n;
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> n) || !convertor.eof())
      {
         std::cerr << "Usage: " << argv[0] << " <n>\n";
         std::cerr << "\tn must be an integer\n";
         return 1;
      }
   }
   ++n;
   double two_thirds_to_the_k = 0.0;
   double one_over_k_squared_plus_k = 0.0;
   double one_over_root_k = 0.0;
   double harmonic = 0.0;
   double alternating_harmonic = 0.0;
   double gregory = 0.0;
   double alternating_value = 1.0;
   int int_value = 0;
   for (double value = 1; value < n; ++value, alternating_value = -alternating_value, ++int_value)
   {
      double one_over_value = 1.0 / value;
      two_thirds_to_the_k += std::pow(2.0 / 3.0, int_value);
      one_over_root_k += 1.0 / std::sqrt(value);
      one_over_k_squared_plus_k += 1.0 / (value * (value + 1.0));
      harmonic += 1.0 / value;
      alternating_harmonic += alternating_value * one_over_value;
      gregory += alternating_value / (2.0 * value - 1.0);
   }
   std::cout << std::setprecision(9) << std::fixed;
   std::cout << two_thirds_to_the_k << "\t(2/3)^k\n";
   std::cout << one_over_root_k << "\tk^-0.5\n";
   std::cout << one_over_k_squared_plus_k << "\t1/k(k+1)\n";
   double flint_hills = 0.0;
   double cookson_hills = 0.0;
   double rieman_zeta = 0.0;
   for (double value = 1; value < n; ++value)
   {
      double value_squared = value * value;
      double value_cubed = value_squared * value;
      double sin_value = std::sin(value);
      double cos_value = std::cos(value);
      flint_hills += 1.0 / (value_cubed * sin_value * sin_value);
      cookson_hills += 1.0 / (value_cubed * cos_value * cos_value);      
      rieman_zeta += 1.0 / value_squared;
   }
   std::cout << flint_hills << "\tFlint Hills\n";
   std::cout << cookson_hills << "\tCookson Hills\n";
   std::cout << harmonic << "\tHarmonic\n";
   std::cout << rieman_zeta << "\tRiemann Zeta\n";
   std::cout << alternating_harmonic << "\tAlternating Harmonic\n";
   std::cout << gregory << "\tGregory\n";
}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/

#include <cmath>
#include <cstdlib>
#include <iostream>

int main(const int argc, const char* argv[])
{
    std::ios_base::sync_with_stdio(false);
    
    std::cout.precision(9u);
    std::cout.flags(std::ios_base::fixed);
    
    const int n = std::atoi(argv[1]);
    
    double res1 = double(n >= 0), res2 = 0.0, res3 = 0.0, 
           res4 = 0.0,            res5 = 0.0, res6 = 0.0, 
           res7 = 0.0,            res8 = 0.0, res9 = 0.0;
    
    if (n > 0) {
        const double dt = 2.0 / 3.0;
        double sink, cosk, pot = 1.0, kd, kd2, kd3;

        for (int k = 1; k <= n; ++k, pot = -pot) {
            kd  = double(k);
            kd2 = kd * kd;
            kd3 = kd * kd2;
            
            sink = std::sin(kd);
            cosk = std::cos(kd);
            
            res1 += std::pow(dt, kd);
            res2 += 1.0 / std::sqrt(kd);
            res3 += 1.0 / (kd2 + kd);
            res4 += 1.0 / (kd3 * sink * sink);
            res5 += 1.0 / (kd3 * cosk * cosk);
            res6 += 1.0 / kd;
            res7 += 1.0 / kd2;
            res8 += pot / kd;
            res9 += pot / (2.0 * kd - 1.0);
        }
    }
    
    std::cout << res1 << "\t(2/3)^k\n"
              << res2 << "\tk^-0.5\n"
              << res3 << "\t1/k(k+1)\n"
              << res4 << "\tFlint Hills\n"
              << res5 << "\tCookson Hills\n"
              << res6 << "\tHarmonic\n"
              << res7 << "\tRiemann Zeta\n"
              << res8 << "\tAlternating Harmonic\n"
              << res9 << "\tGregory\n";
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Marcin Zalewski & Jeremiah Willcock
 */


#include <iostream>
#include <gmpxx.h>
#include <boost/lexical_cast.hpp>
#include <boost/tuple/tuple.hpp>
#include <algorithm>

using namespace boost;

class Digits {
private:
  unsigned int j;
  tuple<mpz_class, mpz_class, mpz_class> nad;
  mpz_class tmp1, tmp2;

public:
  Digits() { j = 0; get<0>(nad) = 1; get<1>(nad) = 0; get<2>(nad) = 1; }

  inline char operator()() {
    ++j;
    next_term();

    if(get<0>(nad) > get<1>(nad)) return (*this)();

    mpz_mul_2exp(tmp1.get_mpz_t(), get<0>(nad).get_mpz_t(), 1);
    tmp1 += get<0>(nad);
    tmp1 += get<1>(nad);

    mpz_fdiv_qr(tmp1.get_mpz_t(), tmp2.get_mpz_t(), tmp1.get_mpz_t(), get<2>(nad).get_mpz_t());

    tmp2 += get<0>(nad);

    if(tmp2 >= get<2>(nad)) {
      return (*this)();
    } else {
      unsigned int d = tmp1.get_ui();
      eliminate_digit(d);
      return d + '0';
    }
  }

private:

  inline void next_term() {
    unsigned int y = j * 2 + 1;
    mpz_mul_2exp(tmp1.get_mpz_t(), get<0>(nad).get_mpz_t(), 1);
    get<1>(nad) += tmp1;
    get<1>(nad) *= y;
    get<0>(nad) *= j;
    get<2>(nad) *= y;
  }

  inline void eliminate_digit(unsigned int d) {
    mpz_submul_ui(get<1>(nad).get_mpz_t(), get<2>(nad).get_mpz_t(), d);
    get<0>(nad) *= 10;
    get<1>(nad) *= 10;
  }

};

void pi(unsigned int n) {
  unsigned int i = 0;
  Digits digits;

  while((i += 10) <= n) {
    for(int count = 0; count < 10; ++count) {
      std::cout << digits();
    }
    std::cout << "\t:" << i << '\n';
  }
  
  i -= 10;
  if(n > i) {
    for(int count = 0; count < n - i; ++count) {
      std::cout << digits();
    }
    i += 10;
    for(int count = 0; count < i - n; ++count) {
      std::cout << ' ';
    }
    std::cout << "\t:" << n << '\n';
  }
}

int main(int argc, char** argv) {
  std::cout.sync_with_stdio(false);
  unsigned int count = (argc >= 2 ? boost::lexical_cast<unsigned int>(argv[1]) : 10000);
  pi(count);
  return 0;
}
// -*- mode: c++ -*-
// $Id: prodcons.gpp,v 1.1 2004-11-10 06:59:16 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <pthread.h>

using namespace std;

pthread_mutex_t mutex;
pthread_cond_t control;
void producer(int *arg);
void consumer(int *arg);
int pcount, data, consumed, produced;


int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    pthread_t t1, t2;
    
    pcount = data = consumed = produced = 0;

    if (pthread_mutex_init(&mutex, NULL)) {
	perror("pthread_mutex_init");
	exit(1);
    }
    if (pthread_cond_init(&control, NULL)) {
	perror("pthread_cond_init");
	exit(1);
    }
    if (pthread_create(&t1, (pthread_attr_t *)NULL,
		       (void * (*)(void *))producer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
    if (pthread_create(&t2, (pthread_attr_t *)NULL,
		       (void * (*)(void *))consumer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
  
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    cout << produced << " " << consumed << endl;
    return(0);
}


void producer(int *arg) {
    int i, n = *arg;
    for (i=1; i<=n; i++) {
	pthread_mutex_lock(&mutex);
	while (pcount == 1) {
	    pthread_cond_wait(&control, &mutex);
	}
	data = i;
	pcount = 1;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	produced++;
    }
}
 

void consumer(int *arg) {
    int i = 0, n = *arg;
    while (1) {
	pthread_mutex_lock(&mutex);
	while (pcount == 0) {
	    pthread_cond_wait(&control, &mutex);
	}
	i = data;
	pcount = 0;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	consumed++;
	if (i == n) return;
    }
}

// -*- mode: c++ -*-
// $Id: random.gpp,v 1.2 2005-05-26 06:51:07 bfulgham Exp $
// http://shootout.alioth.debian.org/

#include <iostream>
#include <stdlib.h>
#include <math.h>

using namespace std;

#define IM 139968
#define IA 3877
#define IC 29573

inline double gen_random(double max) {
    static long last = 42;
    last = (last * IA + IC) % IM;
    return( max * last / IM );
}

int main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    double result = 0;
    
    while (N-- > 1) {
	gen_random(100.0);
    }
    cout.precision(9);
    cout.setf(ios::fixed);
    cout << gen_random(100.0) << endl;
    return(0);
}

// The Great Computer Language Shootout
// http://shootout.alioth.debian.org/
// contributed by Jon Harrop, 2005 
// Compile: g++ -Wall -O3 -ffast-math ray.cpp -o ray

#include <vector>
#include <iostream>
#include <limits>
#include <cmath>

using namespace std;

numeric_limits<double> dbl;
double delta = sqrt(dbl.epsilon()), infinity = dbl.infinity(), pi = M_PI;

struct Vec { // 3D vector
  double x, y, z;
  Vec(double x2, double y2, double z2) : x(x2), y(y2), z(z2) {}
};
Vec operator+(const Vec &a, const Vec &b)
{ return Vec(a.x + b.x, a.y + b.y, a.z + b.z); }
Vec operator-(const Vec &a, const Vec &b)
{ return Vec(a.x - b.x, a.y - b.y, a.z - b.z); }
Vec operator*(double a, const Vec &b) { return Vec(a * b.x, a * b.y, a * b.z); }
double dot(const Vec &a, const Vec &b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
Vec unitise(const Vec &a) { return (1 / sqrt(dot(a, a))) * a; }

struct Ray { Vec orig, dir; Ray(Vec o, Vec d) : orig(o), dir(d) {} };

struct Scene { // Abstract base class representing a scene
  virtual void intersect(double &, Vec &, const Ray &) const = 0;
  virtual void del() {};
};

struct Sphere : public Scene { // Derived class representing a sphere
  Vec center;
  double radius;

  Sphere(Vec c, double r) : center(c), radius(r) {}

  double ray_sphere(const Ray &ray) const {
    Vec v = center - ray.orig;
    double b = dot(v, ray.dir), disc = b*b - dot(v, v) + radius * radius;
    if (disc < 0) return infinity;
    double d = sqrt(disc), t2 = b + d;
    if (t2 < 0) return infinity;
    double t1 = b - d;
    return (t1 > 0 ? t1 : t2);
  }

  void intersect(double &lambda, Vec &normal, const Ray &ray) const {
    double l = ray_sphere(ray);
    if (l >= lambda) return;
    lambda = l;
    normal = unitise(ray.orig + l * ray.dir - center);
  }
};

struct Group : public Scene { // Derived class representing a group of scenes
  Sphere bound;
  vector<Scene *> objs;

  Group(Sphere b) : bound(b), objs(0) {}
  virtual ~Group() {}

  void del() {
    for (vector<Scene *>::iterator it=objs.begin(); it!=objs.end(); ++it)
      delete *it;
  }

  void intersect(double &lambda, Vec &normal, const Ray &ray) const {
    double l = bound.ray_sphere(ray);
    if (l >= lambda) return;
    for (vector<Scene *>::const_iterator it=objs.begin(); it!=objs.end(); ++it)
      (*it)->intersect(lambda, normal, ray);
  }
};

double ray_trace(Vec light, const Ray &ray, const Scene *scene) {
  double lambda = infinity;
  Vec normal(0, 0, 0);
  scene->intersect(lambda, normal, ray);
  if (lambda == infinity) return 0;
  Vec o = ray.orig + lambda * ray.dir + delta * normal;
  double g = -dot(normal, light), l = infinity;
  if (g <= 0) return 0.;
  scene->intersect(l, normal, Ray(o, Vec(0, 0, 0) - light));
  return (l == infinity ? g : 0);
}

Scene *create(int level, double r, double x, double y, double z) {
  Sphere *sphere = new Sphere(Vec(x, y, z), r);
  if (level == 1) return sphere;
  Group group = Group(Sphere(Vec(x, y, z), 3*r));
  group.objs.push_back(sphere);
  double rn = 3*r/sqrt(12.);
  for (int dz=-1; dz<=1; dz+=2)
    for (int dx=-1; dx<=1; dx+=2)
      group.objs.push_back(create(level-1, r/2, x - dx*rn, y + rn, z - dz*rn));
  return (new Group(group));
}

int main(int argc, char *argv[]) {
  int level = 6, n = (argc==2 ? atoi(argv[1]) : 256), ss = 4;
  Scene *scene=create(level, 1, 0, -1, 0); // Build the scene

  cout << "P5\n" << n << " " << n << "\n255\n";
  for (int y=n-1; y>=0; --y)
    for (int x=0; x<n; ++x) {
      double g=0;
      for (int dx=0; dx<ss; ++dx)
	for (int dy=0; dy<ss; ++dy) {
	  Vec d(x+double(dx)/ss-n/2., y+double(dy)/ss-n/2., n);
	  g += ray_trace(unitise(Vec(-1, -3, 2)), Ray(Vec(0, 0, -4),
						      unitise(d)), scene);
	}
      cout << char(.5+255*g/(ss*ss));
    }

  scene->del(); // Deallocate the scene

  return 0;
}
// The Great Computer Language Shootout
// http://shootout.alioth.debian.org/
// Fastest version under 100 LOC. Contributed by Jon Harrop, 2005
// Compile: g++ -Wall -O3 -ffast-math ray.cpp -o ray

#include <list>
#include <iostream>
#include <limits>
#include <cmath>
using namespace std;
numeric_limits<double> real;
double delta = sqrt(real.epsilon()), infinity = real.infinity();
struct Vec {
  double x, y, z;
  Vec(double x2, double y2, double z2) : x(x2), y(y2), z(z2) {}
};
Vec operator+(const Vec &a, const Vec &b)
{ return Vec(a.x+b.x, a.y+b.y, a.z+b.z); }
Vec operator-(const Vec &a, const Vec &b)
{ return Vec(a.x-b.x, a.y-b.y, a.z-b.z); }
Vec operator*(double a, const Vec &b) { return Vec(a*b.x, a*b.y, a*b.z); }
double dot(const Vec &a, const Vec &b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
Vec unitise(const Vec &a) { return (1 / sqrt(dot(a, a))) * a; }
typedef pair<double, Vec> Hit;
struct Ray {
  Vec orig, dir;
  Ray(const Vec &o, const Vec &d) : orig(o), dir(d) {}
};
struct Scene {
  virtual ~Scene() {};
  virtual Hit intersect(const Hit &, const Ray &) const = 0;
};
struct Sphere : public Scene {
  Vec center;
  double radius;
  Sphere(Vec c, double r) : center(c), radius(r) {}
  ~Sphere() {}
  double ray_sphere(const Ray &ray) const {
    Vec v = center - ray.orig;
    double b = dot(v, ray.dir), disc = b*b - dot(v, v) + radius * radius;
    if (disc < 0) return infinity;
    double d = sqrt(disc), t2 = b + d;
    if (t2 < 0) return infinity;
    double t1 = b - d;
    return (t1 > 0 ? t1 : t2);
  }
  Hit intersect(const Hit &hit, const Ray &ray) const {
    double lambda = ray_sphere(ray);
    if (lambda >= hit.first) return hit;
    return Hit(lambda, unitise(ray.orig + lambda*ray.dir - center));
  }
};
typedef list<Scene *> Scenes;
struct Group : public Scene {
  Sphere bound;
  Scenes child;
  Group(Sphere b, Scenes c) : bound(b), child(c) {}
  ~Group() {
    for (Scenes::const_iterator it=child.begin(); it!=child.end(); ++it)
      delete *it;
  }
  Hit intersect(const Hit &hit, const Ray &ray) const {
    Hit hit2=hit;
    double l = bound.ray_sphere(ray);
    if (l >= hit.first) return hit;
    for (Scenes::const_iterator it=child.begin(); it!=child.end(); ++it)
      hit2 = (*it)->intersect(hit2, ray);
    return hit2;
  }
};
double ray_trace(const Vec &light, const Ray &ray, const Scene &s) {
  Hit no_hit(infinity, Vec(0, 0, 0));
  Hit hit = s.intersect(no_hit, ray);
  if (hit.first == infinity) return 0;
  double g = dot(hit.second, light);
  if (g >= 0) return 0.;
  Vec p = ray.orig + hit.first*ray.dir + delta*hit.second;
  return (s.intersect(no_hit, Ray(p, -1. * light)).first < infinity ? 0 : -g);
}
Scene *create(int level, const Vec &c, double r) {
  Scene *s = new Sphere(c, r);
  if (level == 1) return s;
  Scenes child;
  child.push_back(s);
  double rn = 3*r/sqrt(12.);
  for (int dz=-1; dz<=1; dz+=2)
    for (int dx=-1; dx<=1; dx+=2)
      child.push_back(create(level-1, c + rn*Vec(dx, 1, dz), r/2));
  return new Group(Sphere(c, 3*r), child);
}
int main(int argc, char *argv[]) {
  int level = 6, n = (argc==2 ? atoi(argv[1]) : 256), ss = 4;
  Vec light = unitise(Vec(-1, -3, 2));
  Scene *s(create(level, Vec(0, -1, 0), 1));
  cout << "P5\n" << n << " " << n << "\n255\n";
  for (int y=n-1; y>=0; --y)
    for (int x=0; x<n; ++x) {
      double g=0;
      for (int dx=0; dx<ss; ++dx)
	for (int dy=0; dy<ss; ++dy) {
	  Vec dir(unitise(Vec(x+dx*1./ss-n/2., y+dy*1./ss-n/2., n)));
	  g += ray_trace(light, Ray(Vec(0, 0, -4), dir), *s);
	}
      cout << char(.5 + 255. * g / (ss*ss));
    }
  delete s;
  return 0;
}
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// by bearophile, Jan 24 2006
// converted to C++ by Greg Buchholz
// Compile with: -O3 -fomit-frame-pointer

#include<cstdio>
#include<cstdlib>

template<class N> N Ack(N x, N y) {
   return (x == 0) ? y+1 : ((y == 0) ? Ack(x-1, 1) : Ack(x-1, Ack(x, y-1)));
}

template<class N> N Fib(N n) { return (n < 2) ? 1 : Fib(n-2) + Fib(n-1); }

template<class N> N Tak(N x, N y, N z) { 
    return (y < x) ? Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y)) : z;
}

int main(int argc, char **argv) 
{
    int n = atoi(argv[1]) - 1;
    printf("Ack(3,%d): %d\n", n+1, Ack(3, n+1));
    printf("Fib(%.1f): %.1f\n", 28.0+n, Fib(28.0+n));
    printf("Tak(%d,%d,%d): %d\n", 3*n, 2*n, n, Tak(3*n, 2*n, n));
    printf("Fib(3): %d\n", Fib(3));
    printf("Tak(3.0,2.0,1.0): %.1f\n", Tak(3.0, 2.0, 1.0));
    return 0;
}

// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// by bearophile, Jan 24 2006
// converted to C++ by Greg Buchholz
// modified by Paul Kitchin

#include <iomanip>
#include <iostream>
#include <sstream>

template < class N >
N Ack(N x, N y) __attribute__((fastcall, const, nothrow));

template < class N >
N Ack(N x, N y)
{
   return __builtin_expect(x == 0, 0) ? y + 1 : ((y == 0) ? Ack(x - 1, 1) : Ack(x - 1, Ack(x, y - 1)));
}

template < class N >
N Fib(N n) __attribute__((fastcall, const, nothrow));

template < class N >
N Fib(N n)
{
   return __builtin_expect(n < 2, 0) ? 1 : Fib(n - 2) + Fib(n - 1);
}

template < class N >
N Tak(N x, N y, N z) __attribute__((fastcall, const, nothrow));

template < class N >
N Tak(N x, N y, N z)
{
    return __builtin_expect(y < x, 0) ? Tak(Tak(x - 1, y, z), Tak(y - 1, z, x), Tak(z - 1, x, y)) : z;
}

int main(int argc, char * * argv)
{
   if (argc != 2)
   {
      std::cerr << "usage: nsieve <n>\n";
      return 1;
   }
   int n;
   {
      std::istringstream convertor(argv[1]);
      if (!(convertor >> n) || !convertor.eof())
      {
         std::cerr << "usage: nsieve <n>\n";
         std::cerr << "   n must be an integer\n";
         return 1;
      }
   }
   std::cout << std::setprecision(1) << std::setiosflags(std::ios_base::fixed);
   std::cout << "Ack(3," << n << "): " << Ack(3, n) << '\n';
   std::cout << "Fib(" << (27.0 + n) << "): " << Fib(27.0 + n) << '\n';
   --n;
   std::cout << "Tak(" << (3 * n) << ',' << (2 * n) << ',' << n << "): " << Tak(3 * n, 2 * n, n) << '\n';
   std::cout << "Fib(3): " << Fib(3) << '\n';
   std::cout << "Tak(3.0,2.0,1.0): " << Tak(3.0, 2.0, 1.0) << '\n';
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Alexey Zolotov
*/

#include <re2.h>
#include <assert.h>
#include <iostream>
#include <stdio.h>

using namespace re2;
using namespace std;

#define BUFSIZE 1024

int main(void)
{
    string str, out;
    int len1, len2;
    int read_size;
    char *buf;

    string pattern1[] = {
        "agggtaaa|tttaccct",
        "[cgt]gggtaaa|tttaccc[acg]",
        "a[act]ggtaaa|tttacc[agt]t",
        "ag[act]gtaaa|tttac[agt]ct",
        "agg[act]taaa|ttta[agt]cct",
        "aggg[acg]aaa|ttt[cgt]ccct",
        "agggt[cgt]aa|tt[acg]accct",
        "agggta[cgt]a|t[acg]taccct",
        "agggtaa[cgt]|[acg]ttaccct"
    };

    string pattern2[] = {
        "B", "(c|g|t)", "D", "(a|g|t)", "H", "(a|c|t)", "K", "(g|t)",
        "M", "(a|c)", "N", "(a|c|g|t)", "R", "(a|g)", "S", "(c|g)",
        "V", "(a|c|g)", "W", "(a|t)", "Y", "(c|t)"
    };


    fseek(stdin, 0, SEEK_END);
    read_size = ftell(stdin);
    assert(read_size > 0);

    buf = new char[read_size];
    rewind(stdin);
    read_size = fread(buf, 1, read_size, stdin);
    assert(read_size);

    str.append(buf, read_size);

    delete [] buf;

    len1 = str.length();
    RE2::GlobalReplace(&str, ">.*\n|\n", "");
    len2 = str.length();

    out = str;

    #pragma omp parallel sections
    {
        #pragma omp section
        for (int i = 0; i < (int)(sizeof(pattern1) / sizeof(string)); i++) {
            int count = 0;
            RE2 pat(pattern1[i]);
            StringPiece piece = str;

            while (RE2::FindAndConsume(&piece, pat)) {
                count++;
            }

            cout << pattern1[i] << " " << count << endl;
        }
        #pragma omp section
        for (int i = 0; i < (int)(sizeof(pattern2) / sizeof(string)); i += 2) {
            RE2::GlobalReplace(&out, pattern2[i], pattern2[i + 1]);
        }
    }

    cout << endl;
    cout << len1 << endl;
    cout << len2 << endl;
    cout << out.length() << endl;

}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by The Anh Tran

#include <omp.h>
#include <sched.h>
#include <memory.h>

#include <cassert>
#include <cstdio>

#include <iostream>
#include <vector>
#include <iterator>

#include <boost/format.hpp>
#include <boost/scoped_array.hpp>
#include <boost/xpressive/xpressive_static.hpp>


using namespace boost::xpressive;
namespace x = boost::xpressive;
using namespace std;

typedef char         Char_T;
typedef Char_T const*   PChar_T;
typedef vector<Char_T>   Data_T;

typedef Data_T::const_iterator         CIte_Data_T;
typedef back_insert_iterator<Data_T>   OIte_Data_T;

typedef basic_regex<CIte_Data_T>      Regex_Data_T;



// read all redirected data from stdin
// strip DNA headers and newline characters
size_t 
ReadInput_StripHeader(   size_t &file_size, Data_T &output )
{
   // get input size
   file_size = ftell(stdin);
   fseek(stdin, 0, SEEK_END);
   file_size = ftell(stdin) - file_size;
   fseek(stdin, 0, SEEK_SET);
   file_size /= sizeof(Char_T);


   // load content into memory
   boost::scoped_array<Char_T> p_src(new Char_T[file_size +1]);
   {
      size_t sz = fread(p_src.get(), sizeof(Char_T), file_size, stdin);
      assert(sz == file_size);
      p_src[file_size] = 0;
   }

   
   PChar_T p_src_beg = p_src.get();
   PChar_T p_src_end = p_src_beg + file_size;
   output.reserve (file_size);

   regex_replace (   OIte_Data_T(output), 
               p_src_beg, p_src_end, 

               // ">.*\n | \n"
               basic_regex<PChar_T>( as_xpr('>') >> *(~_n) >> _n | _n ),

               ""); 

   return output.size();
}



void 
Count_Patterns(Data_T const& input, string& result)
{
   typedef std::pair<PChar_T, Regex_Data_T> PReg;
   
   static PReg const ptns[] = 
   {
      PReg("agggtaaa|tttaccct",   
         as_xpr("agggtaaa") | "tttaccct"   ),

      PReg("[cgt]gggtaaa|tttaccc[acg]",   
            (x::set='c','g','t') >> "gggtaaa"
         |    "tttaccc" >> (x::set='a','c','g')   ),

      PReg("a[act]ggtaaa|tttacc[agt]t",   
            as_xpr('a') >> (x::set='a','c','t') >> "ggtaaa"
         |   "tttacc" >> (x::set='a','g','t') >> 't'   ),

      PReg("ag[act]gtaaa|tttac[agt]ct",   
            as_xpr("ag") >> (x::set='a','c','t') >> "gtaaa"
         |   "tttac" >> (x::set='a','g','t') >> "ct"   ),
         
      PReg("agg[act]taaa|ttta[agt]cct",   
            as_xpr("agg") >> (x::set='a','c','t') >> "taaa"
         |   "ttta" >> (x::set='a','g','t') >> "cct"   ),
         
      PReg("aggg[acg]aaa|ttt[cgt]ccct",   
            as_xpr("aggg") >> (x::set='a','c','g') >> "aaa"
         |   "ttt" >> (x::set='c','g','t') >> "ccct"   ),
         
      PReg("agggt[cgt]aa|tt[acg]accct",   
            as_xpr("agggt") >> (x::set='c','g','t') >> "aa"
         |   "tt" >> (x::set='a','c','g') >> "accct"   ),
         
      PReg("agggta[cgt]a|t[acg]taccct",   
            as_xpr("agggta") >> (x::set='c','g','t') >> 'a'   
         |   't' >> (x::set='a','c','g') >> "taccct"   ),
         
      PReg("agggtaa[cgt]|[acg]ttaccct",   
            as_xpr("agggtaa") >> (x::set='c','g','t')
         |   (x::set='a','c','g') >> "ttaccct"   )
   };
   static int const n_ptns = sizeof(ptns) / sizeof(ptns[0]);
   static size_t counters[n_ptns] = {0};


   #pragma omp for schedule(dynamic, 1) nowait
   for (int i = 0; i < n_ptns; ++i)
   {
      typedef regex_iterator<CIte_Data_T> RI_T;

      // static regex
      Regex_Data_T const& regex(ptns[i].second);
      counters[i] = distance(   RI_T(input.begin(), input.end(), regex), RI_T()   );
   }

   // we want the last thread, reaching this code block, to print result
   static size_t thread_passed = 0;
   if (__sync_add_and_fetch(&thread_passed, 1) == static_cast<size_t>(omp_get_num_threads()))
   {
      boost::format format("%1% %2%\n");

      for (int i = 0; i < n_ptns; ++i)
      {
         format % ptns[i].first % counters[i];
         result += format.str();
      }
      thread_passed = 0;
   }
}


struct IUB
{
   PChar_T   iub;
   int      len;
};

IUB const iub_table[] = 
{
   {0}, 
   {"(c|g|t)",   7}, 
   {0}, 
   {"(a|g|t)",   7}, 
   {0}, {0}, {0}, 
   {"(a|c|t)",   7}, 
   {0}, {0}, 
   {"(g|t)",   5}, 
   {0}, 
   {"(a|c)",   5}, 
   {"(a|c|g|t)",   9}, 
   {0}, {0}, {0}, 
   {"(a|g)",   5}, 
   {"(c|t)",   5}, 
   {0}, {0}, 
   {"(a|c|g)",   7}, 
   {"(a|t)",   5}, 
   {0}, 
   {"(c|t)",   5}
};
int const n_iub = sizeof(iub_table)/sizeof(iub_table[0]);


struct Formatter
{
   template<typename Match, typename Out>
   Out 
   operator()(Match const &m, Out o) const
   {
      IUB const &i (iub_table[ *m[0].first - 'A' ]);
      return copy(i.iub, i.iub + i.len, o);
   }
};


void Replace_Patterns(Data_T const& input, size_t &replace_len)
{
   #pragma omp single nowait
   {
      Data_T         output;
      output.reserve   (input.size() + (input.size() >> 1));   // size * 1.5

      regex_replace(   OIte_Data_T(output), 
                  input.begin(), input.end(), 

                  // "[BDHKMNRSVWY]"
                  Regex_Data_T( (x::set='B','D','H','K','M','N','R','S','V','W','Y') ), 

                  Formatter()   );

      replace_len = output.size();
   }
}



// Detect single - multi thread benchmark
int 
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < 16; ++i)
   {
      if (CPU_ISSET(i, &cs))
      ++count;
   }
   return count;
}


int 
main()
{
   size_t initial_length = 0;
   size_t striped_length = 0;
   size_t replace_length = 0;
   
   Data_T input;
   
   striped_length = ReadInput_StripHeader (initial_length, input);

   std::string match_result;
   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      Count_Patterns   (input, match_result);
      Replace_Patterns(input, replace_length);
   }

   std::cout << (   boost::format("%1%\n%2%\n%3%\n%4%\n") 
      % match_result 
      % initial_length % striped_length % replace_length );

   return 0;
}

// -*- mode: c++ -*-
// $Id: regexmatch.gpp,v 1.1 2004-11-10 06:56:53 bfulgham Exp $
// http://shootout.alioth.debian.org/
// From Bill Lear


#include <iostream>
#include <zopyra/regx>

using namespace std;

typedef pair<const char*, const char*> span;

int main(int ac, char* av[]) {
    zopyra::regx re(
	"(?x)	          # set extended flag for embedded comment fun\n"
        "(?:^|[^\\d(])    # must be preceded by non-digit\n"
        "([(])?           # match 1: possible initial left paren\n"
        "(\\d{3})         # match 2: area code is 3 digits\n"
        "(?(1)[)])        # if match1 then match right paren\n"
        "[ ]              # area code followed by one space\n"
        "(\\d{3})         # match 3: prefix of 3 digits\n"
        "[- ]             # separator is either space or dash\n"
        "(\\d{4})         # match 4: last 4 digits\n"
        "(?:\\D|\\b)      # followed by non-digit or break\n"
	);
    
    string line;
    vector<span> lines;
    while (getline(cin, line)) {
        char* phone = new char[line.size()];
        copy(line.begin(), line.end(), phone);
        lines.push_back(span(phone, phone + line.size()));
    }

    size_t ITER = (ac == 2 ? (atoi(av[1]) < 1 ? 1 : atoi(av[1])): 1);

    char num[13];
    num[0] = '(';
    num[4] = ')';
    num[5] = ' ';
    num[9] = '-';
    size_t count = 0;
    while (ITER--) {
        vector<span>::iterator end = lines.end();
        for (vector<span>::iterator i = lines.begin(); i != end; ++i) {
            zopyra::regx::iterator p = re.find(i->first, i->second);
            if (p++ != re.end()) {
                char* num_p = &num[1];
                ++p;
                copy(p->first, p->second, num_p);

                num_p = &num[6];
                ++p;
                copy(p->first, p->second, num_p);

                num_p = &num[10];
                ++p;
                copy(p->first, p->second, num_p);

                if (!ITER) {
                    cout << ++count << ": ";
                    copy(num, num + 14, ostream_iterator<char>(cout));
                    cout << '\n';
                }
            }
        }
    }
}
/* ------------------------------------------------------------------ */
/* The Computer Language Shootout                               */
/* http://shootout.alioth.debian.org/                                 */
/*                                                                    */
/* Contributed by Anthony Borla                                       */
/* Modified by Vaclav Haisman                                         */
/* Changed to match style of Perl example: Greg Buchholz              */
/* ------------------------------------------------------------------ */

#include <cctype>
#include <string>
#include <algorithm>
#include <iterator>
#include <iostream>
using namespace std;

const int LINELENGTH = 60;

typedef string Header;
typedef string Segment;

inline char complement(char element)
{
  static const char charMap[] =
    {
      'T', 'V', 'G', 'H', '\0', '\0', 'C', 'D', '\0', '\0', 'M', '\0', 'K',
      'N', '\0', '\0', '\0', 'Y', 'S', 'A', 'A', 'B', 'W', '\0', 'R', '\0'
    };

  return charMap[toupper(element) - 'A'];
}

void print_revcomp(Header const& header, Segment const& seg, ostream& out = std::cout)
{
    out << header << "\n";
    
    Segment comp(seg.rbegin(),seg.rend());
    transform(comp.begin(),comp.end(), comp.begin(), complement);
   
    size_t i = 0;
    size_t stop = comp.length()/LINELENGTH + ((comp.length()%LINELENGTH)?1:0);
    
    while(i < stop)
        out << comp.substr(i++*LINELENGTH,LINELENGTH) << "\n";
}

int main ()
{
  ios_base::sync_with_stdio(false);

  Segment line, segment; 
  Header header;

  while (getline(cin, line))
  {
      if (line[0] == '>')
      {
          if (! segment.empty())
            print_revcomp(header, segment);
          header = line;
          segment.clear();
      }
      else
          segment += line;
  }
  print_revcomp(header, segment);

  return 0;
}

/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org
*
* Contributed by Paul Kitchin
* contributed by Bob W
* OpenMP by The Anh Tran
* Compile: g++ -O3 -fomit-frame-pointer -mtune=native -msse2 reverse.cpp -o reverse -fopenmp
*/

#include <stdio.h>
#include <omp.h>

#define Z16     "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
#define V32     "\0TVGH\0\0CD\0\0M\0KN\0\0\0YSA\0BW\0R\0\0\0\0\0\0"
#define VALL    Z16 Z16 Z16 Z16 V32 V32 Z16 Z16 Z16 Z16 Z16 Z16 Z16 Z16

// char conversion table
const char complement_table[] = VALL;

template<typename T>
T min(T v1, T v2)
{
	// brand prediction
	if (v2 <= v1)
		return v2;
	return v1;
}

struct Chunk
{
	char* header;
	long header_len;
	
	char* data;
	long data_len;
	
	Chunk* next;
	Chunk* previous;

	Chunk(Chunk* pre)
	{
		header = data = 0;
		header_len = data_len = 0;
		next = 0;
		previous = pre;
	}
};

long GetInputSize()
{
	long fsz = ftell(stdin);

	fseek(stdin, 0, SEEK_END);
	fsz = ftell(stdin) - fsz;

	fseek(stdin, 0, SEEK_SET);
	return fsz;
}

char* ReadInput(long size, Chunk* &datamarker)
{
	Chunk* current_marker = 0;

	char* inp_buf = new char[size];
	char* cur_pos = inp_buf;
	long remainbytes = size - (cur_pos - inp_buf);

	// read line-by-line, according to game rule. Should be replaced by fread()
	while (fgets_unlocked(cur_pos, remainbytes, stdin) != 0)
	{
		long len = __builtin_strlen(cur_pos);

		if (cur_pos[0] != '>')
		{
			current_marker->data_len += len -1;

			cur_pos += len -1;
			remainbytes -= len -1;
		}
		else
		{
			Chunk* newmarker = new Chunk(current_marker);
			if (current_marker != 0)
				current_marker->next = newmarker;
			else
				datamarker = newmarker;
			current_marker = newmarker;

			current_marker->header = cur_pos;
			current_marker->header_len = len;
			current_marker->data = cur_pos + len;

			cur_pos += len;
			remainbytes -= len;
		}
	}

	return inp_buf;
}

void PrintOutput(const Chunk* marker)
{
	while (marker != 0)
	{
		fwrite_unlocked(marker->header, marker->header_len, 1, stdout);

		int bytetoprint = min(marker->data_len, 60L);
		char* current_position = marker->data;

		while (bytetoprint > 0)
		{
			fwrite_unlocked(current_position, bytetoprint, 1, stdout);
			fputc_unlocked('\n', stdout);

			current_position += bytetoprint;
			bytetoprint = min(marker->data_len - (current_position - marker->data), 60L);
		}

		marker = marker->next;
	}
}

void ReverseGame(Chunk* marker)
{
	#pragma omp parallel default(shared)
	{
		Chunk *m = marker;
		while (m != 0)
		{
			long half = m->data_len/2;

			#pragma omp for schedule(static) nowait
			for (long i = 0; i < half; i++)
			{
				char* c1 = m->data + i;
				char* c2 = m->data + (m->data_len -1 -i);
				
				const char rc1 = complement_table[ *c1 ];
				const char rc2 = complement_table[ *c2 ];

				*c1 = rc2;
				*c2 = rc1;
			}

			#pragma omp single nowait
			{
				// if datalen is odd
				if ((half *2) < m->data_len)
				{
					char c = m->data[half +1];
					m->data[half +1] = complement_table[c];
				}
			}

			m = m->next;
		}
	}
}

int main () 
{
	long filesize = GetInputSize ();
	
	Chunk* marker = 0;
	char* buffer = ReadInput (filesize, marker);

	ReverseGame(marker);

	PrintOutput(marker);

	delete []buffer;
	while (marker != 0)
	{
		Chunk* m = marker;
		marker = marker->next;
		delete m;
	}

	return 0;
}

// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// Contributed by Paul Kitchin

#include <iostream>
#include <iterator>
#include <vector>

std::size_t line_length = 60;

char complement(char character)
{
   static char const complement_map[] =
   {
      '\0', 'T', 'V', 'G', 'H', '\0', '\0', 'C', 'D', '\0', '\0', 'M', '\0', 'K', 'N', '\0', '\0', '\0', 'Y', 'S', 'A', 'A', 'B', 'W', '\0', 'R'
   };
   return complement_map[character & 0x1f];
}

struct chunk
{
   chunk()
      :
      previous(0),
      next(0),
      length(0)
   {
   }
   chunk(chunk * previous)
      :
      previous(previous),
      next(0),
      length(0)
   {
      previous->next = this;
   }
   chunk * previous;
   chunk * next;
   unsigned short length;
   char data[65526];
};

void write_reverse_complement(chunk * begin, chunk * end)
{
   chunk * start = begin;
   char * begin_char = begin->data;
   char * end_char = end->data + end->length - 1;
   while (begin != end || begin_char < end_char)
   {
      char temp = complement(*begin_char);
      *begin_char++ = complement(*end_char);
      *end_char-- = temp;
      if (*begin_char == '\n')
      {
         ++begin_char;
      }
      if (*end_char == '\n')
      {
         --end_char;
      }
      if (begin_char == begin->data + begin->length)
      {
         begin = begin->next;
         begin_char = begin->data;
         if (*begin_char == '\n')
         {
            ++begin_char;
         }
      }
      if (end_char == end->data - 1)
      {
         end = end->previous;
         end_char = end->data + end->length - 1;
         if (*end_char == '\n')
         {
            --end_char;
         }
      }
   }
   while (start)
   {
      std::cout.write(start->data, start->length);
      chunk * last = start;
      start = start->next;
      delete last;
   }
   std::cout.put('\n');
}

int main()
{
   std::cin.sync_with_stdio(false);
   std::cout.sync_with_stdio(false);
   while (!std::cin.eof())
   {
      std::string header;
      std::getline(std::cin, header);
      std::cout << header << '\n';
      chunk * start = new chunk();
      chunk * end = start;
      while (!std::cin.eof() && std::cin.peek() != '>')
      {
         for (int line = 0; line < 1074 && !std::cin.eof() && std::cin.peek() != '>'; ++line)
         {
            std::cin.getline(end->data + end->length, line_length + 1);
            end->length += std::cin.gcount();
            *(end->data + end->length - 1) = '\n';
         }
         if (!std::cin.eof() && std::cin.peek() != '>')
         {
            end = new chunk(end);
         }
      }
      --end->length;
      write_reverse_complement(start, end);
   }
}
/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/

Contributed by Andrew Moon
*/

#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <vector>
#include <string.h>

struct CPUs {
   CPUs() {
      cpu_set_t cs;
      CPU_ZERO( &cs );
      sched_getaffinity( 0, sizeof(cs), &cs );
      count = 0;
      for ( size_t i = 0; i < CPU_SETSIZE; i++ )
         count += CPU_ISSET( i, &cs ) ? 1 : 0;
      count = std::max( count, size_t(1) );
   }

   size_t count;
} cpus;

struct ReverseLookup {
   ReverseLookup( const char *from, const char *to ) {
      for ( int i = 0; i < 256; i++ )
         byteLookup[i] = i;
      for ( ; *from && *to; from++, to++ ) {
         byteLookup[toupper(*from)] = *to;
         byteLookup[tolower(*from)] = *to;
      }

      for ( int i = 0; i < 256; i++ )
         for ( int j = 0; j < 256; j++ )
            wordLookup[(i << 8) | j] = ( byteLookup[j] << 8 ) | byteLookup[i];
   }

   char operator[]( const char &c ) { return (char )byteLookup[(unsigned char )c]; }
   short operator[]( const short &s ) { return (short )wordLookup[(unsigned short )s]; }

protected:
   unsigned char byteLookup[256];
   unsigned short wordLookup[256*256];
} lookup( "acbdghkmnsrutwvy", "TGVHCDMKNSYAAWBR" );

template< class type >
struct vector2 : public std::vector<type> {
   type &last() { return this->operator[]( std::vector<type>::size() -1 ); }
};

struct Chunker {
   enum { lineLength = 60, chunkSize = 65536, };

   Chunker( int seq ) : id(seq) {}

   struct Chunk {
      Chunk() {}
      Chunk( char *in, size_t amt ) : data(in), size(amt) {}
      char *data;
      size_t size;
   };

   void NewChunk() {
      size_t cur = mark - chunkBase;
      chunks.push_back( Chunk( chunkBase, cur ) );
      chunkBase += ( cur + ( cur & 1 ) ); // keep it word aligned
      mark = chunkBase;
   }

   template< int N >
   struct LinePrinter {
      LinePrinter() : lineFill(0) {}
      void endofblock() { if ( lineFill ) newline(); }
      void emit( const char *str, size_t amt ) { 
         fwrite_unlocked( str, 1, amt, stdout );
      }
      void emit( char c ) { fputc_unlocked( c, stdout ); }
      void emitnewline() { emit( '\n' ); }
      void emitlines( char *data, size_t size ) {
         if ( lineFill ) {
            size_t toprint = std::min( size, lineLength - lineFill );
            emit( data, toprint );
            size -= toprint;
            data += toprint;
            lineFill += toprint;
            if ( lineFill == lineLength )
               newline();
         }

         while ( size >= lineLength ) {
            emit( data, lineLength );
            emitnewline();
            size -= lineLength;
            data += lineLength;
         }

         if ( size ) {
            lineFill = size;
            emit( data, size );
         }
      }
      void newline() { lineFill = 0; emitnewline(); }
      void reset() { lineFill = 0; }
   protected:
      size_t lineFill;
   };

   void Print() {
      int prevId = -( id - 1 );
      while ( __sync_val_compare_and_swap( &printQueue, prevId, id ) != prevId )
         sched_yield();

      fwrite_unlocked( name, 1, strlen( name ), stdout );
      static LinePrinter<65536*2> line;
      line.reset();
      for ( int i = int(chunks.size()) - 1; i >= 0; i-- )
         line.emitlines( chunks[i].data, chunks[i].size );
      line.endofblock();

      __sync_val_compare_and_swap( &printQueue, id, -id );
   }

   // fseek on stdin seems flaky so this hack. not called often
   void Backup() {
      while ( true ) {
         if ( fgetc_unlocked( stdin ) == '>' ) {
            fseek( stdin, -1, SEEK_CUR );
            return;
         }
         fseek( stdin, -2, SEEK_CUR );
      }
   }

   // input buffer can hold all of stdin, so no size checking
   size_t Read( char *data ) {
      if ( feof( stdin ) )
         return 0;

      name = data;
      fgets_unlocked( name, 128, stdin );
      mark = chunkBase = name + strlen( name ) + 1;
      mark[lineLength] = -1;

      while ( fgets_unlocked( mark, 128, stdin ) ) {
         if ( *mark == '>' ) {
            Backup();
            break;
         }

         // mark trick should keep us from calling strlen
         mark += ( mark[lineLength] != 0xa ) ? strlen( mark ) - 1 : lineLength;
         if ( mark - chunkBase > chunkSize )
            NewChunk();

         mark[lineLength] = -1;
      }

      if ( mark - chunkBase )
         NewChunk();
      return ( chunkBase - data );
   }

   struct WorkerState {
      Chunker *chunker;
      size_t offset, count;
      pthread_t handle;
   };

   static void *ReverseWorker( void *arg ) {
      WorkerState *state = (WorkerState *)arg;
      Chunker &chunker = *state->chunker;
      for ( size_t i = 0; i < state->count; i++ ) {
         Chunk &chunk = chunker[state->offset + i];
         short *w = (short *)chunk.data, *bot = w, *top = w + ( chunk.size / 2 ) - 1;
         for ( ; bot < top; bot++, top-- ) {
            short tmp = lookup[*bot];
            *bot = lookup[*top];
            *top = tmp;
         }
         // if size is odd, final byte would reverse to the start (skip it)
         if ( chunk.size & 1 )
            chunk.data++;
      }
      return 0;
   }

   void Reverse() {
      if ( !chunks.size() )
         return;

      // this takes so little time it's almost not worth parallelizing
      vector2<WorkerState> threads;
      threads.reserve( cpus.count );
      size_t divs = chunks.size() / cpus.count;
      for ( size_t i = 0, offset = 0; i < cpus.count; i++, offset += divs ) {
         threads.push_back( WorkerState() );
         WorkerState &ws = threads.last();
         ws.chunker = this;
         ws.count = ( i < cpus.count - 1 ) ? divs : chunks.size() - offset;
         ws.offset = offset;
         pthread_create( &ws.handle, 0, ReverseWorker, &ws );
      }

      for ( size_t i = 0; i < cpus.count; i++ )
         pthread_join( threads[i].handle, 0 );
   }

   Chunk &operator[] ( size_t i ) { return chunks[i]; }

protected:
   vector2<Chunk> chunks;
   char *name, *chunkBase, *mark;
   int id;
   static volatile int printQueue;
};

// used to order chunk printing
volatile int Chunker::printQueue = 0;

struct ReverseComplement {
   ReverseComplement() {
      // get stdin file size
      long start = ftell( stdin );
      fseek( stdin, 0, SEEK_END );
      size = ftell( stdin ) - start;
      fseek( stdin, start, SEEK_SET );

      data = new char[size + 3];
   }

   ~ReverseComplement() {
      delete[] data;
   }

   static void *ChunkerThread( void *arg ) {
      Chunker *chunker = (Chunker *)arg;
      chunker->Reverse();
      chunker->Print();
      return 0;
   }

   void Run() {
      vector2<Chunker *> chunkers;
      vector2<pthread_t> threads;

      size_t cur = 0;
      for ( int id = 1; true; id++ ) {
         chunkers.push_back( new Chunker( id ) );

         size_t read = chunkers.last()->Read( data + cur );
         cur += read;
         if ( !read )
            break;

         // spawn off a thread to finish this guy up while we read another chunk in
         threads.push_back( 0 );
         pthread_create( &threads.last(), 0, ChunkerThread, chunkers.last() );
      }

      for ( size_t i = 0; i < threads.size(); i++ )
         pthread_join( threads[i], 0 );

      for ( size_t i = 0; i < chunkers.size(); i++ )
         delete chunkers[i];
   }


protected:
   size_t size;
   char *data;
};


int main( int argc, const char *argv[] ) {
   ReverseComplement revcom;
   revcom.Run();
   return 0;
}
// -*- mode: c++ -*-
// $Id: reversefile.gpp-2.gpp,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/
// using Bill Lear's mmap class to allow in-memory reverse scanning.
//

#include <iostream>
#include <utility>
#include <fstream>
#include <hash_map>
#include <algorithm>
#include <iomanip>
#include <string>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>

using namespace std;

class mem_map {
public:
    mem_map(const char* file_name,
            int flags = O_RDONLY,
            int prot = PROT_READ,
            int share = MAP_SHARED,
            mode_t mode = 0,
            void* addr = 0,
            size_t length = 0,
            off_t offset = 0)
    : file_handle(0),
      buffer_size(length),
      input_buffer(0),
      ok(false)
    {
        this->file_handle = open(file_name, flags, mode);

        if (this->file_handle < 0) {
            this->sys_error = "mem_map Error: ";
            this->sys_error += string("Could not open file ");
            this->sys_error += string(file_name);
            this->sys_error += string(": ") + string(strerror(errno));
            return;
        }

        if (this->buffer_size == 0) {
            struct stat s;

            if (fstat(this->file_handle, &s) < 0) {
                this->sys_error = "mem_map Error: ";
                this->sys_error += string("Could not stat file ");
                this->sys_error += string(file_name);
                this->sys_error += string(": ") + string(strerror(errno));
                return;
            }

            this->buffer_size = s.st_size;
        }

        this->input_buffer = (char*) mmap((caddr_t)addr,
                                          this->buffer_size,
                                          prot,
                                          share,
                                          this->file_handle,
                                          offset);

        if (!this->input_buffer) {
            this->sys_error = "mem_map Error: ";
            this->sys_error += string("Could not mmap file ");
            this->sys_error += string(file_name);
            this->sys_error += string(": ") + string(strerror(errno));
            return;
        }

        ok = true;
    }

    ~mem_map() {
        munmap(this->input_buffer, this->buffer_size);
        close(this->file_handle);
    }

    char* buffer() const { return this->input_buffer; }
    size_t size() const { return this->buffer_size; }

    char* begin() const { return this->input_buffer; }
    char* end() const { return this->input_buffer + this->buffer_size; }

    int operator!() const { return !this->ok; }

    string error() const { return this->sys_error; }

private:
    int file_handle;
    size_t buffer_size;
    char* input_buffer;
    bool ok;
    string sys_error;

    mem_map(const mem_map&) {}
    mem_map& operator = (const mem_map&) { return *this; }
};


int main(int argc, char* argv[]) {
    if (argc < 1) {
        cerr << "Usage: " << argv[0] << " <file>\n";
        return 1;
    }
    mem_map in(argv[1]);
    if (!in) {
        cerr << "Could not open " << argv[1] << '\n';
        return 1;
    }
    
    //
    // reverse scanning from memory
    //
    const char* deadend = in.begin();
    const char* line_end = in.end();
    const char* line_begin = line_end-1;

    while (*line_begin == '\n' && line_begin != deadend)
	line_begin--;

    while (line_begin != deadend) {
	if (*line_begin == '\n' && line_begin < line_end) {
	    copy(line_begin+1, line_end, ostream_iterator<char>(cout));
	    line_end = line_begin+1; // to include the '\n' for the next print.
	}
	line_begin--;
    }
    if (line_begin < line_end)
	copy(line_begin, line_end, ostream_iterator<char>(cout));
}
// -*- mode: c++ -*-
// $Id: reversefile.gpp,v 1.2 2004-11-30 07:10:05 bfulgham Exp $
// http://shootout.alioth.debian.org/
// 
// Based on the C version by Alan Post <apost@recalcitrant.org>
// C++-ified by Brent Fulgham, based on an idea by Mark Fitzgerald

#include <assert.h>
#include <sys/uio.h>
#include <iostream>

using namespace std;

#if defined(__INTEL_COMPILER)
#define STDOUT_FILENO 1
#endif

//
// Note that malloc(3) seems happier with chunks of 4096
//
const int MAXREAD = (4096 - sizeof( size_t ) - sizeof( void* ));

struct buf_t
{
    char d[MAXREAD];
    size_t len;
    buf_t *next;
};

static buf_t* read_lines( buf_t* tail )
{
    buf_t* curr = tail;
    tail->next = NULL;

    while ( true )
    {
        cin.read(curr->d, MAXREAD );
	int nread = cin.gcount();
	curr->len = nread;
        if ( nread < MAXREAD ) { return curr; }
        buf_t* head = new buf_t;
        head->next = curr;
        curr = head;
    }
}

#define WRITEOUT( p_, l_ ) \
        do { \
            vec[ ivec ].iov_base = (char*) (p_); \
            vec[ ivec ].iov_len = (int) (l_); \
            ivec++; \
            if ( ivec == IOV_MAX ) \
            { \
                writev( STDOUT_FILENO, vec, ivec ); \
                ivec = 0; \
            } \
        } while (0)

#define LINEOUT \
        do { \
            WRITEOUT( pos, end - pos); \
            for (; loh != NULL; loh = loh->next ) \
                WRITEOUT( loh->d, loh->len ); \
        } while (0)

int main(int argc, char* argv[])
{
    buf_t tail;
    buf_t* head = read_lines( &tail );

    buf_t* loh = NULL;
    buf_t* curr = head;

    struct iovec vec[ IOV_MAX ];
    size_t ivec = 0;

    while ( true )
    {
        char* buf = curr->d;
        char* end = buf + curr->len;
        char* pos = end;
        for (;; pos--)
        {
            if ( pos <= buf )
            {
                buf_t* new_curr = curr->next;

                if ( new_curr == NULL )
                {
                    LINEOUT;
                    writev( STDOUT_FILENO, vec, ivec );
                    return EXIT_SUCCESS;
                }

                curr->len = end - buf;
                curr->next = loh;
                loh = curr;
                
                curr = new_curr;
                break;
            }
            if ( *(pos-1) == '\n' )
            {
                LINEOUT;
                end = pos;
            }
        }
    }
    assert( NULL == "unreachable" );
    return EXIT_FAILURE;
}

// -*- mode: c++ -*-
// $Id: sieve.gpp,v 1.1 2004-11-10 06:48:59 bfulgham Exp $
// http://shootout.alioth.debian.org/
// From Bill Lear
// with help from Stephane Lajoie

#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdlib>

using namespace std;

int main(int argc, char *argv[]) {
    size_t NUM = (argc == 2 ? (atoi(argv[1]) < 1 ? 1 : atoi(argv[1])): 1);

    vector<char> primes(8192 + 1);
    vector<char>::iterator pbegin = primes.begin();
    vector<char>::iterator begin = pbegin + 2;
    vector<char>::iterator end = primes.end();

    while (NUM--) {
        fill(begin, end, 1);
        for (vector<char>::iterator i = begin; i < end; ++i) {
            if (*i) {
                const size_t p = i - pbegin;
                for (vector<char>::iterator k = i + p; k < end; k += p) {
                    *k = 0;
                }
            }
        }
    }

    cout << "Count: " << count(begin, end, 1) << endl;
}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Original C contributed by Sebastien Loisel
// Conversion to C++ by Jon Harrop
// Compile: g++ -O3 -o spectralnorm spectralnorm.cpp


#include <stdio.h>
#include <stdlib.h>
#include <cmath>
#include <vector>
#include <iostream>
#include <iomanip>

using namespace std;

double eval_A(int i, int j) { return 1.0 / ((i+j)*(i+j+1)/2 + i + 1); }

void eval_A_times_u(const vector<double> &u, vector<double> &Au)
{
  for(int i=0; i<u.size(); i++)
    for(int j=0; j<u.size(); j++) Au[i] += eval_A(i,j) * u[j];
}

void eval_At_times_u(const vector<double> &u, vector<double> &Au)
{
  for(int i=0; i<u.size(); i++)
    for(int j=0; j<u.size(); j++) Au[i] += eval_A(j,i) * u[j];
}

void eval_AtA_times_u(const vector<double> &u, vector<double> &AtAu)
{ vector<double> v(u.size()); eval_A_times_u(u, v); eval_At_times_u(v, AtAu); }

int main(int argc, char *argv[])
{
  int N = ((argc == 2) ? atoi(argv[1]) : 2000);
  vector<double> u(N), v(N);

  fill(u.begin(), u.end(), 1);

  for(int i=0; i<10; i++) {
    eval_AtA_times_u(u, v);
    fill(u.begin(), u.end(), 0);
    eval_AtA_times_u(v, u);
  }

  double vBv=0, vv=0;
  for(int i=0; i<N; i++) { vBv += u[i]*v[i]; vv += v[i]*v[i]; }

  cout << setprecision(10) << sqrt(vBv/vv) << endl;

  return 0;
}
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Original C contributed by Sebastien Loisel
// Conversion to C++ by Jon Harrop
// OpenMP parallelize by The Anh Tran
// Add SSE by The Anh Tran
// Additional SSE optimization by Krzysztof Jakubowski

// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 ./spec.c++ -o ./spec.run

#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <sched.h>
#include <omp.h>
#include <emmintrin.h>

inline int Index(int i, int j) {
   return (((i + j) * (i + j + 1)) >> 1) + i + 1;
}

inline void MultiplyShorts(__m128i a, __m128i b, __m128i &outA, __m128i &outB) {
   __m128i lo = _mm_mullo_epi16(a, b);
   __m128i hi = _mm_mulhi_epu16(a, b);
   outA = _mm_unpacklo_epi16(lo, hi);
   outB = _mm_unpackhi_epi16(lo, hi);
}

template <bool modei>
void EvalPart(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length) __attribute((noinline));
template <bool modei>
void EvalPart(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length) {
   int i = begin;
   for(; i + 7 < end; i += 8) {
      __m128i i8 = _mm_set_epi16(i + 7, i + 6, i + 5, i + 4, i + 3, i + 2, i + 1, i + 0);
      __m128i ii8 = _mm_add_epi16(i8, _mm_set1_epi16(1));
      __m128i ai4 = _mm_set_epi32(i + 4, i + 3, i + 2, i + 1);
      __m128i bi4 = _mm_set_epi32(i + 8, i + 7, i + 6, i + 5);
      __m128d sum1 = _mm_set1_pd(0.0), sum2 = _mm_set1_pd(0.0);
      __m128d sum3 = _mm_set1_pd(0.0), sum4 = _mm_set1_pd(0.0);

      for(int j = 0; j < length; j++) {
         __m128i j8 = _mm_set1_epi16(j);
         __m128i a4, b4;
         MultiplyShorts(_mm_add_epi16(i8, j8), _mm_add_epi16(ii8, j8), a4, b4);
         if(modei) {
            a4 = _mm_add_epi32(_mm_srli_epi32(a4, 1), ai4);
            b4 = _mm_add_epi32(_mm_srli_epi32(b4, 1), bi4);
         }
         else {
            a4 = _mm_add_epi32(_mm_srli_epi32(a4, 1), _mm_set1_epi32(j + 1));
            b4 = _mm_add_epi32(_mm_srli_epi32(b4, 1), _mm_set1_epi32(j + 1));
         }

         __m128d a2 = _mm_cvtepi32_pd(a4);
         __m128d b2 = _mm_cvtepi32_pd(_mm_shuffle_epi32(a4, 2 + (3 << 2)));
         __m128d c2 = _mm_cvtepi32_pd(b4);
         __m128d d2 = _mm_cvtepi32_pd(_mm_shuffle_epi32(b4, 2 + (3 << 2)));

         __m128d uj2 = _mm_set1_pd(src[j]);
         sum1 = _mm_add_pd(sum1, _mm_div_pd(uj2, a2));
         sum2 = _mm_add_pd(sum2, _mm_div_pd(uj2, b2));
         sum3 = _mm_add_pd(sum3, _mm_div_pd(uj2, c2));
         sum4 = _mm_add_pd(sum4, _mm_div_pd(uj2, d2));
      }

      _mm_storeu_pd(dst + i + 0, sum1);
      _mm_storeu_pd(dst + i + 2, sum2);
      _mm_storeu_pd(dst + i + 4, sum3);
      _mm_storeu_pd(dst + i + 6, sum4);
   }
   for(; i < end; i++) {
      double sum = 0;
      for (int j = 0; j < length; j++)
         sum += src[j] / double(modei?Index(i, j) : Index(j, i));
      dst[i] = sum;
   }
}

// Search for appropriate number of threads to spawn
int GetThreadCount() {
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < CPU_SETSIZE; ++i) {
      if (CPU_ISSET(i, &cs))
         ++count;
   }
   return count;
}

double spectral_game(int N) {
   __attribute__((aligned(64))) double u[N];
   __attribute__((aligned(64))) double tmp[N];
   __attribute__((aligned(64))) double v[N];

   double vBv   = 0.0;
   double vv   = 0.0;

   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      // this block will be executed by NUM_THREADS
      // variable declared in this block is private for each thread
      int threadid   = omp_get_thread_num();
      int threadcount   = omp_get_num_threads();
      int chunk      = N / threadcount;

      // calculate each thread's working range [r1 .. r2) => static schedule
      int begin = threadid * chunk;
      int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;

      for(int i = begin; i < end; i++)
         u[i] = 1.0;
      #pragma omp barrier

      for (int ite = 0; ite < 10; ++ite) {
         EvalPart<1>(u, tmp, begin, end, N);
         #pragma omp barrier
         EvalPart<0>(tmp, v, begin, end, N);
         #pragma omp barrier
         EvalPart<1>(v, tmp, begin, end, N);
         #pragma omp barrier
         EvalPart<0>(tmp, u, begin, end, N);
         #pragma omp barrier
      }
   
      double sumvb = 0.0, sumvv = 0.0;
      for (int i = begin; i < end; i++) {
         sumvv += v[i] * v[i];
         sumvb += u[i] * v[i];
      }

      #pragma omp critical
      {
         vBv   += sumvb;
         vv   += sumvv;
      }
   } // parallel region

   return sqrt(vBv / vv);
}


int main(int argc, char *argv[]) {
   int N = ((argc >= 2) ? atoi(argv[1]) : 2000);

   printf("%.9f\n", spectral_game(N));
   return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Original C contributed by Sebastien Loisel
// Conversion to C++ by Jon Harrop
// OpenMP parallelize by The Anh Tran
// Add SSE by The Anh Tran
// Additional SSE optimization by Krzysztof Jakubowski

// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \
//     ./spec.c++ -o ./spec.run

#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <sched.h>
#include <omp.h>
#include <emmintrin.h>

template <bool modei> int Index(int i, int j) {
    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;
}

template <bool modei>
void EvalPart(double *__restrict__ src, double *__restrict__ dst,
                int begin, int end, int length) {
    int i = begin;

    for(; i + 1 < end; i += 2) {
        __m128d sum = _mm_set_pd(
			src[0] / double(Index<modei>(i + 1, 0)),
			src[0] / double(Index<modei>(i + 0, 0)));
    
		__m128d ti = modei?
			_mm_set_pd(i + 1, i + 0) :
			_mm_set_pd(i + 2, i + 1);	
		__m128d last = _mm_set_pd(
			Index<modei>(i + 1, 0),
			Index<modei>(i + 0, 0));

        for(int j = 1; j < length; j++) {
			__m128d idx = last + ti + _mm_set1_pd(j);
			last = idx;
            sum = sum + _mm_set1_pd(src[j]) / idx;
        }

        _mm_storeu_pd(dst + i + 0, sum);
    }
    for(; i < end; i++) {
        double sum = 0;
        for (int j = 0; j < length; j++)
            sum += src[j] / double(Index<modei>(i, j));
        dst[i] = sum;
    }

}

void EvalATimesU(double *src, double *dst, int begin, int end, int N) {
    EvalPart<1>(src, dst, begin, end, N);
}

void EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {
    EvalPart<0>(src, dst, begin, end, N);
}

void EvalAtATimesU(double *src, double *dst, double *tmp,
                   int begin, int end, int N) {
    EvalATimesU (src, tmp, begin, end, N);
    #pragma omp barrier
    EvalAtTimesU(tmp, dst, begin, end, N);
    #pragma omp barrier
}

int GetThreadCount() {
    cpu_set_t cs;
    CPU_ZERO(&cs);
    sched_getaffinity(0, sizeof(cs), &cs);

    int count = 0;
    for (int i = 0; i < CPU_SETSIZE; ++i)
        if (CPU_ISSET(i, &cs))
            ++count;

    return count;
}

double spectral_game(int N) {
    __attribute__((aligned(16))) double u[N];
    __attribute__((aligned(16))) double v[N], tmp[N];

    double vBv = 0.0;
    double vv = 0.0;

    #pragma omp parallel default(shared) num_threads(GetThreadCount())
    {
        // this block will be executed by NUM_THREADS
        // variable declared in this block is private for each thread
        int threadid = omp_get_thread_num();
        int threadcount = omp_get_num_threads();
        int chunk = N / threadcount;

        // calculate each thread's working range [r1 .. r2) => static schedule
        int begin = threadid * chunk;
        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;

        for(int i = begin; i < end; i++)
            u[i] = 1.0;
        #pragma omp barrier

        for (int ite = 0; ite < 10; ++ite) {
            EvalAtATimesU(u, v, tmp, begin, end, N);
            EvalAtATimesU(v, u, tmp, begin, end, N);
        }
    
        double sumvb = 0.0, sumvv = 0.0;
        for (int i = begin; i < end; i++) {
            sumvv += v[i] * v[i];
            sumvb += u[i] * v[i];
        }

        #pragma omp critical
        {
            vBv += sumvb;
            vv += sumvv;
        }
    }

    return sqrt(vBv / vv);
}

int main(int argc, char *argv[]) {
    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);
    printf("%.9f\n", spectral_game(N));
    return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Original C contributed by Sebastien Loisel
// Conversion to C++ by Jon Harrop
// OpenMP parallelize by The Anh Tran
// Add SSE by The Anh Tran
// Additional SSE optimization by Krzysztof Jakubowski

// g++ -pipe -O3 -march=native -fopenmp -mfpmath=sse -msse2 \
//     ./spec.c++ -o ./spec.run

#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <sched.h>
#include <omp.h>
#include <emmintrin.h>

template <bool modei> int Index(int i, int j) {
    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;
}

template <bool modei>
void EvalPart(double *__restrict__ src, double *__restrict__ dst,
                int begin, int end, int length) {
    int i = begin;

    for(; i + 7 < end; i += 8) {
        __m128d sum1 = _mm_set_pd(
            src[0] / double(Index<modei>(i + 1, 0)),
            src[0] / double(Index<modei>(i + 0, 0)));
        __m128d sum2 = _mm_set_pd(
            src[0] / double(Index<modei>(i + 3, 0)),
            src[0] / double(Index<modei>(i + 2, 0)));
        __m128d sum3 = _mm_set_pd(
            src[0] / double(Index<modei>(i + 5, 0)),
            src[0] / double(Index<modei>(i + 4, 0)));
        __m128d sum4 = _mm_set_pd(
            src[0] / double(Index<modei>(i + 7, 0)),
            src[0] / double(Index<modei>(i + 6, 0)));
    
        __m128d i1 = modei? _mm_set_pd(i + 1, i + 0) : _mm_set_pd(i + 2, i + 1);
        __m128d i2 = modei? _mm_set_pd(i + 3, i + 2) : _mm_set_pd(i + 4, i + 3);
        __m128d i3 = modei? _mm_set_pd(i + 5, i + 4) : _mm_set_pd(i + 6, i + 5);
        __m128d i4 = modei? _mm_set_pd(i + 7, i + 6) : _mm_set_pd(i + 8, i + 7);
        __m128d last1 = _mm_set_pd( Index<modei>(i + 1, 0), Index<modei>(i + 0, 0));
        __m128d last2 = _mm_set_pd( Index<modei>(i + 3, 0), Index<modei>(i + 2, 0));
        __m128d last3 = _mm_set_pd( Index<modei>(i + 5, 0), Index<modei>(i + 4, 0));
        __m128d last4 = _mm_set_pd( Index<modei>(i + 7, 0), Index<modei>(i + 6, 0));

        for(int j = 1; j < length; j++) {
            __m128d idx1 = last1 + i1 + _mm_set1_pd(j);
            __m128d idx2 = last2 + i2 + _mm_set1_pd(j);
            __m128d idx3 = last3 + i3 + _mm_set1_pd(j);
            __m128d idx4 = last4 + i4 + _mm_set1_pd(j);
            last1 = idx1;
            last2 = idx2;
            last3 = idx3;
            last4 = idx4;
            sum1 = sum1 + _mm_set1_pd(src[j]) / idx1;
            sum2 = sum2 + _mm_set1_pd(src[j]) / idx2;
            sum3 = sum3 + _mm_set1_pd(src[j]) / idx3;
            sum4 = sum4 + _mm_set1_pd(src[j]) / idx4;
        }

        _mm_storeu_pd(dst + i + 0, sum1);
        _mm_storeu_pd(dst + i + 2, sum2);
        _mm_storeu_pd(dst + i + 4, sum3);
        _mm_storeu_pd(dst + i + 6, sum4);
    }
    for(; i < end; i++) {
        double sum = 0;
        for (int j = 0; j < length; j++)
            sum += src[j] / double(Index<modei>(i, j));
        dst[i] = sum;
    }

}

void EvalATimesU(double *src, double *dst, int begin, int end, int N) {
    EvalPart<1>(src, dst, begin, end, N);
}

void EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {
    EvalPart<0>(src, dst, begin, end, N);
}

void EvalAtATimesU(double *src, double *dst, double *tmp,
                   int begin, int end, int N) {
    EvalATimesU (src, tmp, begin, end, N);
    #pragma omp barrier
    EvalAtTimesU(tmp, dst, begin, end, N);
    #pragma omp barrier
}

int GetThreadCount() {
    cpu_set_t cs;
    CPU_ZERO(&cs);
    sched_getaffinity(0, sizeof(cs), &cs);

    int count = 0;
    for (int i = 0; i < CPU_SETSIZE; ++i)
        if (CPU_ISSET(i, &cs))
            ++count;

    return count;
}

double spectral_game(int N) {
    __attribute__((aligned(16))) double u[N];
    __attribute__((aligned(16))) double v[N], tmp[N];

    double vBv = 0.0;
    double vv = 0.0;

    #pragma omp parallel default(shared) num_threads(GetThreadCount())
    {
        // this block will be executed by NUM_THREADS
        // variable declared in this block is private for each thread
        int threadid = omp_get_thread_num();
        int threadcount = omp_get_num_threads();
        int chunk = N / threadcount;

        // calculate each thread's working range [r1 .. r2) => static schedule
        int begin = threadid * chunk;
        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;

        for(int i = begin; i < end; i++)
            u[i] = 1.0;
        #pragma omp barrier

        for (int ite = 0; ite < 10; ++ite) {
            EvalAtATimesU(u, v, tmp, begin, end, N);
            EvalAtATimesU(v, u, tmp, begin, end, N);
        }
    
        double sumvb = 0.0, sumvv = 0.0;
        for (int i = begin; i < end; i++) {
            sumvv += v[i] * v[i];
            sumvb += u[i] * v[i];
        }

        #pragma omp critical
        {
            vBv += sumvb;
            vv += sumvv;
        }
    }

    return sqrt(vBv / vv);
}

int main(int argc, char *argv[]) {
    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);
    printf("%.9f\n", spectral_game(N));
    return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Original C contributed by Sebastien Loisel
// Conversion to C++ by Jon Harrop
// OpenMP parallelize by The Anh Tran
// Add SSE by The Anh Tran

// Fastest with this flag: -Os
// g++ -pipe -Os -fomit-frame-pointer -march=native -fopenmp -mfpmath=sse -msse2 ./spec.c++ -o ./spec.run

#include <cmath>
#include <cstdlib>
#include <cstdio>
#include <sched.h>
#include <omp.h>


// define SIMD data type. 2 doubles are packed in 1 XMM register
typedef double v2dt __attribute__((vector_size(16)));
v2dt const v1 = {1.0, 1.0};


struct Param
{
   union
   {
      double* u;      // source
      v2dt*   xmm_u;
   };

   union
   {
      double* tmp;   // temporary
      v2dt*   xmm_tmp;
   };

   union
   {
      double* v;         // destination
      v2dt*   xmm_v;
   };

   int    length;         // source/desti vec's length
   int    half_length;

   int    r_begin;      // working range of each thread
   int    r_end;

   double   vBv;
   double   vv;
};


// Return:   1.0 / (i + j) * (i + j +1) / 2 + i + 1;
double
eval_A(int i, int j)
{
   int d = (((i+j) * (i+j+1)) >> 1) + i+1;

   return 1.0 / d;
}


// Return: 2 doubles in xmm register [double1, double2]
//      double1 = 1.0 / (i + j) * (i + j +1) / 2 + i + 1;
//      double2 = 1.0 / (i+1 + j) * (i+1 + j +1) / 2 + i+1 + 1;
//   Or:
//      double2 = 1.0 / (i + j+1) * (i + j+1 +1) / 2 + i + 1;
template<bool inc_i>
v2dt
eval_A_xmm(int i, int j)
{
   if (inc_i)
      i <<= 1;
   else
      j <<= 1;

   int d1 = (((i+j) * (i+j+1)) >> 1) + i+1;
   int d2 = (((i+1 +j) * (i+1 +j+1)) >> 1) + i +1;

   if (inc_i)
      d2 += 1;

   v2dt r = {d1, d2};
   return v1 / r;
}


double
hz_add(v2dt x)
{
   double const* val = reinterpret_cast<double const*>(&x);
   return val[0] + val[1];
}


void
eval_A_times_u (Param const &p)
{
   for (int i = p.r_begin, ie = p.r_end; i < ie; ++i)
   {
      v2dt sum = {0, 0};

      // xmm = 2 doubles => index [0..length/2)
      int j = 0;
      for (; j < p.half_length; ++j)
         sum += eval_A_xmm<false>(i, j) * p.xmm_u[j];

      p.tmp[i] = hz_add(sum);

      // If source vector is odd size. This should be called <= 1 time
      for (j = j*2; j < p.length; ++j)
         p.tmp[i] += eval_A(i, j) * p.u[j];
   }
}

void
eval_At_times_u(Param const &p)
{
   for (int i = p.r_begin, ie = p.r_end; i < ie; ++i)
   {
      v2dt sum = {0, 0};

      int j = 0;
      for (; j < p.half_length; ++j)
         sum += eval_A_xmm<true>(j, i) * p.xmm_tmp[j];

      p.v[i] = hz_add(sum);

      for (j = j*2; j < p.length; ++j)
         p.v[i] += eval_A(j, i) * p.tmp[j];
   }
}

// Each thread modifies its portion in destination vector
// -> barrier needed to sync access
void
eval_AtA_times_u(Param const &p)
{
   eval_A_times_u( p );
   #pragma omp barrier

   eval_At_times_u( p );
   #pragma omp barrier
}

void
final_sum(Param& p)
{
   v2dt sum_vBv   = {0,0};
   v2dt sum_vv      = {0,0};

   int i = p.r_begin /2;
   int ie = p.r_end /2;

   for (; i < ie; ++i)
   {
      sum_vv   += p.xmm_v[i] * p.xmm_v[i];
      sum_vBv   += p.xmm_u[i] * p.xmm_v[i];
   }

   p.vBv   = hz_add(sum_vBv);
   p.vv   = hz_add(sum_vv);

   for (i = i*2; i < p.r_end; ++i)
   {
      p.vBv   += p.u[i] * p.v[i];
      p.vv   += p.v[i] * p.v[i];
   }
}


void
fill_10(Param const& p)
{
   int i = p.r_begin /2;
   int ie = p.r_end /2;

   for (; i < ie; ++i)
      p.xmm_u[i] = v1;

   for (i = i*2; i < p.r_end; ++i)
      p.u[i] = 1.0;
}


// Search for appropriate number of threads to spawn
int
GetThreadCount()
{
   cpu_set_t cs;
   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   int count = 0;
   for (int i = 0; i < CPU_SETSIZE; ++i)
   {
      if (CPU_ISSET(i, &cs))
         ++count;
   }
   return count;
}

double
spectral_game(int N)
{
   // Align L2 cache line
   __attribute__((aligned(64))) double u[N];
   __attribute__((aligned(64))) double tmp[N];
   __attribute__((aligned(64))) double v[N];

   double vBv   = 0.0;
   double vv   = 0.0;

   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      // this block will be executed by NUM_THREADS
      // variable declared in this block is private for each thread
      int threadid   = omp_get_thread_num();
      int threadcount   = omp_get_num_threads();
      int chunk      = N / threadcount;

      Param my_param;

      my_param.u             = u;
      my_param.tmp         = tmp;
      my_param.v             = v;

      my_param.length         = N;
      my_param.half_length   = N /2;

      // calculate each thread's working range [r1 .. r2) => static schedule
      my_param.r_begin   = threadid * chunk;
      my_param.r_end      = (threadid < (threadcount -1)) ? (my_param.r_begin + chunk) : N;


      fill_10(my_param);
      #pragma omp barrier

      // Evaluating
      for (int ite = 0; ite < 10; ++ite)
      {
         my_param.u = u;   // source is u
         my_param.v = v;   // desti is v
         eval_AtA_times_u(my_param);

         my_param.u = v; // source is v
         my_param.v = u; // desti is u
         eval_AtA_times_u(my_param);
      }

      my_param.u = u;
      my_param.v = v;
      final_sum(my_param);

      #pragma omp critical
      {
         vBv   += my_param.vBv;
         vv   += my_param.vv;
      }
   } // parallel region

   return sqrt( vBv/vv );
}


int
main(int argc, char *argv[])
{
   int N = ((argc >= 2) ? atoi(argv[1]) : 2000);

   printf("%.9f\n", spectral_game(N));
   return 0;
}

// -*- mode: c++ -*-
// $Id: spellcheck.gpp-mmap.gpp,v 1.1 2004-11-10 06:47:52 bfulgham Exp $
// http://www.bagley.org/~doug/shootout/
// STL spell checker using mmap() from Bill Lear

#include <iostream>
#include <utility>
#include <fstream>
#include <hash_map>
#include <algorithm>
#include <iomanip>
#include <string>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>

using namespace std;

class mem_map {
public:
    mem_map(const char* file_name,
            int flags = O_RDONLY,
            int prot = PROT_READ,
            int share = MAP_SHARED,
            mode_t mode = 0,
            void* addr = 0,
            size_t length = 0,
            off_t offset = 0)
    : file_handle(0),
      buffer_size(length),
      input_buffer(0),
      ok(false)
    {
        this->file_handle = open(file_name, flags, mode);

        if (this->file_handle < 0) {
            this->sys_error = "mem_map Error: ";
            this->sys_error += string("Could not open file ");
            this->sys_error += string(file_name);
            this->sys_error += string(": ") + string(strerror(errno));
            return;
        }

        if (this->buffer_size == 0) {
            struct stat s;

            if (fstat(this->file_handle, &s) < 0) {
                this->sys_error = "mem_map Error: ";
                this->sys_error += string("Could not stat file ");
                this->sys_error += string(file_name);
                this->sys_error += string(": ") + string(strerror(errno));
                return;
            }

            this->buffer_size = s.st_size;
        }

        this->input_buffer = (char*) mmap((caddr_t)addr,
                                          this->buffer_size,
                                          prot,
                                          share,
                                          this->file_handle,
                                          offset);

        if (!this->input_buffer) {
            this->sys_error = "mem_map Error: ";
            this->sys_error += string("Could not mmap file ");
            this->sys_error += string(file_name);
            this->sys_error += string(": ") + string(strerror(errno));
            return;
        }

        ok = true;
    }

    ~mem_map() {
        munmap(this->input_buffer, this->buffer_size);
        close(this->file_handle);
    }

    char* buffer() const { return this->input_buffer; }
    size_t size() const { return this->buffer_size; }

    char* begin() const { return this->input_buffer; }
    char* end() const { return this->input_buffer + this->buffer_size; }

    int operator!() const { return !this->ok; }

    string error() const { return this->sys_error; }

private:
    int file_handle;
    size_t buffer_size;
    char* input_buffer;
    bool ok;
    string sys_error;

    mem_map(const mem_map&) {}
    mem_map& operator = (const mem_map&) { return *this; }
};

typedef std::pair<const char*, const char*> span;

template<> struct hash<span> {
    inline size_t operator()(const span& s) const {
        size_t h = 0;
        const char* end = s.second;
        for (const char* begin = s.first; begin != end; ++begin) {
            h = 5 * h + *begin;
        }
        return h;
    }
};

template<> struct equal_to<span> {
    inline bool operator()(const span& s1, const span& s2) const {
        return (s1.second - s1.first) == (s2.second - s2.first) &&
            std::equal(s1.first, s1.second, s2.first);
    }
};

class spell_checker {
public:
    spell_checker() 
        : in("Usr.Dict.Words") {
        if (!in) {
            cerr << "Could not open " << "Usr.Dict.Words\n";
            exit(1);
        }
        const char* end = in.end();
        const char* line_begin = in.begin();
        const char* line_end = line_begin;
        while (true) {
            while (line_end != end && *line_end != '\n') {
                ++line_end;
            }
            if (line_end == end) {
                break;
            }
            if (dict.end() == dict.find(span(line_begin, line_end))) {
                ++dict[span(line_begin, line_end)];
            }
            line_begin = ++line_end;
         }
    }

    void process(const char* begin, const char* end) {
        const char* line_begin = begin;
        const char* line_end = line_begin;
        while (true) {
            while (line_end != end && *line_end != '\n') {
                ++line_end;
            }
            if (line_end == end) {
                break;
            }
            if (dict.end() == dict.find(span(line_begin, line_end))) {
                copy(line_begin, line_end, ostream_iterator<char>(cout));
                cout << '\n';
            }
            line_begin = ++line_end;
        }
    }

private:
    std::hash_map<span, int> dict;
    mem_map in;
};

int main(int argc, char* argv[]) {
    if (argc < 1) {
        cerr << "Usage: " << argv[0] << " <file>\n";
        return 1;
    }
    mem_map in(argv[1]);
    if (!in) {
        cerr << "Could not open " << argv[1] << '\n';
        return 1;
    }
    spell_checker spell;
    spell.process(in.begin(), in.end());
}
// -*- mode: c++ -*-
// $Id: spellcheck.gpp-2.gpp,v 1.1 2004-11-11 07:13:55 bfulgham Exp $
// http://shootout.alioth.debian.org/
// STL spell checker from Bill Lear

#include <iostream>
#include <utility>
#include <fstream>
#include <hash_map.h>
#include <algorithm>
#include <iomanip>

using namespace std;

typedef std::pair<const char*, const char*> span;

namespace std {
    template <> struct hash<span>;
    template <> struct equal_to<span>;
}

template<> struct hash<span> {
    inline size_t operator()(const span& s) const {
        size_t h = 0;
        const char* end = s.second;
        for (const char* begin = s.first; begin != end; ++begin) {
            h = 5 * h + *begin;
        }
        return h;
    }
};

template<> struct equal_to<span> {
    inline bool operator()(const span& s1, const span& s2) const {
        return (s1.second - s1.first) == (s2.second - s2.first) &&
            std::equal(s1.first, s1.second, s2.first);
    }
};

class spell_checker {
public:
    spell_checker() {
        std::ifstream in("Usr.Dict.Words");
        char line[32];
        while (in.getline(line, 32)) {
            const char* begin = line;
            const char* end = line + in.gcount() - 1;
            if (dict.end() == dict.find(span(begin, end))) {
                const size_t len = end - begin;
                char* word = new char[len];
                copy(begin, end, word);
                ++dict[span(word, word + len)];
            }
         }
    }

    void process(std::istream& in) {
        char line[32];
        while (in.getline(line, 32)) {
            if (dict.end() == dict.find(span(line, line + in.gcount() - 1))) {
                cout << line << '\n';
            }
        }
    }

private:
    std::hash_map<span, int> dict;
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    spell_checker spell;
    spell.process(cin);
}
// -*- mode: c++ -*-
// $Id: spellcheck.gpp-3.gpp,v 1.1 2004-11-11 07:13:55 bfulgham Exp $
// http://shootout.alioth.debian.org/
// STL spell checker from Bill Lear

// this version reads input from a file

#include <iostream>
#include <utility>
#include <fstream>
#include <hash_map.h>
#include <algorithm>
#include <iomanip>

using namespace std;

typedef std::pair<const char*, const char*> span;

namespace std {
    template <> struct hash<span>;
    template <> struct equal_to<span>;
}

template<> struct hash<span> {
    inline size_t operator()(const span& s) const {
        size_t h = 0;
        const char* end = s.second;
        for (const char* begin = s.first; begin != end; ++begin) {
            h = 5 * h + *begin;
        }
        return h;
    }
};

template<> struct equal_to<span> {
    inline bool operator()(const span& s1, const span& s2) const {
        return (s1.second - s1.first) == (s2.second - s2.first) &&
            std::equal(s1.first, s1.second, s2.first);
    }
};

class spell_checker {
public:
    spell_checker() {
        std::ifstream in("Usr.Dict.Words");
        char line[32];
        while (in.getline(line, 32)) {
            const char* begin = line;
            const char* end = line + in.gcount() - 1;
            if (dict.end() == dict.find(span(begin, end))) {
                const size_t len = end - begin;
                char* word = new char[len];
                copy(begin, end, word);
                ++dict[span(word, word + len)];
            }
         }
    }

    void process(std::istream& in) {
        char line[32];
        while (in.getline(line, 32)) {
            if (dict.end() == dict.find(span(line, line + in.gcount() - 1))) {
                cout << line << '\n';
            }
        }
    }

private:
    std::hash_map<span, int> dict;
};

int main(int argc, char *argv[]) {
    spell_checker spell;
    ifstream in((char *)((string("Input.") + argv[1]).c_str()));
    spell.process(in);
}
// -*- mode: c++ -*-
// $Id: spellcheck.gpp,v 1.3 2005-05-13 16:24:19 igouy-guest Exp $
// http://shootout.alioth.debian.org/ 
// STL spell checker from Bill Lear

#include <iostream>
#include <utility>
#include <fstream>
#include <ext/hash_map>
#include <algorithm>
#include <iomanip>

using namespace std;

#if defined(__INTEL_COMPILER)
#define SGI_HASH_NAMESPACE std
using std::hash;
using std::hash_map;
#else
#define SGI_HASH_NAMESPACE __gnu_cxx

namespace sgi {
    using SGI_HASH_NAMESPACE::hash;
    using SGI_HASH_NAMESPACE::hash_map;
}
#endif

typedef std::pair<const char*, const char*> span;

namespace SGI_HASH_NAMESPACE {
    template<> struct hash<span> {
        inline size_t operator()(const span& s) const {
            size_t h = 0;
            const char* end = s.second;
            for (const char* begin = s.first; begin != end; ++begin) {
                h = 5 * h + *begin;
            }
            return h;
        }
    };
}

namespace std {
    template<> struct equal_to<span> {
        inline bool operator()(const span& s1, const span& s2) const {
            return (s1.second - s1.first) == (s2.second - s2.first) &&
                equal(s1.first, s1.second, s2.first);
        }
    };

#if defined(__INTEL_COMPILER)
    struct str_hash_compare {
        enum { bucket_size = 4, min_buckets = 8 };

        bool operator()(const span& s1, const span& s2) const {
	    int len1 = s1.second - s1.first;
	    int len2 = s2.second - s2.first;

	    int min = (len1 > len2) ? len2 : len1;
	    
            return (strncmp(s1.first, s2.first, min) < 0);
	}

        inline size_t operator()(const span& s) const {
            size_t h = 0;
            const char* end = s.second;
            for (const char* begin = s.first; begin != end; ++begin) {
                h = 5 * h + *begin;
            }
            return h;
        }
     };
#endif
}
class spell_checker {
public:
    spell_checker() {
        std::ifstream in("Usr.Dict.Words");
        char line[32];
        while (in.getline(line, 32)) {
            const char* begin = line;
            const char* end = line + in.gcount() - 1;
            if (dict.end() == dict.find(span(begin, end))) {
                const size_t len = end - begin;
                char* word = new char[len];
                copy(begin, end, word);
                ++dict[span(word, word + len)];
            }
         }
    }

    void process(std::istream& in) {
        char line[32];
        while (in.getline(line, 32)) {
            if (dict.end() == dict.find(span(line, line + in.gcount() - 1))) {
                cout << line << '\n';
            }
        }
    }

private:
#if (defined(__INTEL_COMPILER))
    std::hash_map<span, int, str_hash_compare> dict;
#else
    __gnu_cxx::hash_map<span, int> dict;
#endif
};

int main() {
    spell_checker spell;
    char buff[4096];
    cin.rdbuf()->pubsetbuf(buff, 4096); // enable buffering
    spell.process(cin);
}
// -*- mode: c++ -*-
// $Id: strcat.gpp,v 1.1 2004-11-10 06:44:59 bfulgham Exp $
// http://shootout.alioth.debian.org/
// with help from PeterB

#include <iostream>
#include <string>
using namespace std;

int main(int argc, char *argv[])
{
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    string str;
    size_t capacity = 31;
    str.reserve(capacity); // as per C-string
    size_t newLength = 6;
    for (i = 0; i < n; i++)
    {
	if(newLength > capacity)
	{
	    capacity *= 2;
	    str.reserve(capacity);
	}
	str += "hello\n";
	newLength += 6;
    }
    cout << str.length() << endl;
    return 0;
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * contributed by Alex Castro
 */

#include <iostream>

int main( )
{
    std::ios_base::sync_with_stdio(false);
    int n, s = 0;

    while (std::cin >> n) {
        s += n;
    }

    std::cout << s << std::endl;
}
// The Great Computer Language Shootout
// http://shootout.alioth.debian.org/
// with help from Waldek Hebisch
// modified by Rob Stewart

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <stdio.h>

using namespace std;

#define MAXLINELEN 128

int main(int argc, char * * argv) {
    ios_base::sync_with_stdio(false);
    char line[MAXLINELEN];
    int sum = 0;
    char buff[4096];
    cin.rdbuf()->pubsetbuf(buff, 4096); // enable buffering

    while (cin.getline(line, MAXLINELEN)) {
        sum += atoi(line);
    }
    cout << sum << '\n';
}
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// by Greg Buchholz

#include<iostream>
#include<iterator>
#include<numeric>

main()
{
    std::ios_base::sync_with_stdio(false);
    std::istream_iterator<int> ii(std::cin), eos;

    std::cout << accumulate(ii,eos,0) << "\n";
}
// $Id: takfp.gpp,v 1.3 2004-12-10 08:09:21 bfulgham Exp $
// http://shootout.alioth.debian.org
// Contributed by Brent Fulgham

#include <stdlib.h>
#include <iomanip>
#include <iostream>

using namespace std;

float Tak (float x, float y, float z)
{
	if (y >= x) return z;
	return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
	int n = ((argc == 2) ? atoi(argv[1]) : 1);
	cout << std::fixed << std::setprecision(1);
	cout << Tak(n*3.0, n*2.0, n*1.0) << endl;
	return 0;
}

// vim: ts=4 ft=c
/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/

* contributed by Premysl Hruby
*/


#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <pthread.h>
#include <sched.h>

typedef unsigned int uint;

const uint NUM_THREADS   = 503;
const uint STACK_SIZE   = 16*1024;

int token = -1;

class RingThread;
RingThread* rt_arr[NUM_THREADS] = {0};

class RingThread
{
private:
   pthread_mutex_t   m_mutex;
   uint   node_id;
   uint   next_id;

public:

   RingThread( int id )
   {
      //mutex type is PTHREAD_MUTEX_NORMAL
      // we want self lock behaviour
      pthread_mutex_init( &m_mutex, 0 );

      node_id = id;
      next_id = id +1;

      if (next_id == NUM_THREADS)
         next_id = 0;
   }

   inline void AcquireLock()
   {
      // type is PTHREAD_MUTEX_NORMAL, therefore, try to lock to a locked 
      // mutex will result deadlock. However, other thread will unlock for this
      // mutex
      pthread_mutex_lock( &m_mutex );
   }
   inline void ReleaseLock()
   {
      pthread_mutex_unlock( &m_mutex );
   }

   static void* Run( void* param )
   {
      RingThread* prt = (RingThread*)param;

      while (true)
      {
         // is my turn???
         prt->AcquireLock();

         if (token != 0)
            token--;
         else // this turn is the end of token passing
         {
            std::cout << (prt->node_id +1) << std::endl;
            exit( 0 ); // a fast way to terminate :D
         }

         rt_arr[ prt->next_id ]->ReleaseLock(); // release lock for next thread
         sched_yield(); // my turn is finished. Yield cpu for next thread
      }
   }
};

int main(int argc, char** argv)
{
   token = (argc == 2) ? atoi( argv[1] ) : 1000;
   //std::cout << token;

   // must set stack size for each thread. Otherwise, can't spawn 503 threads :)
   pthread_attr_t stack_att;
   pthread_attr_init( &stack_att );
   pthread_attr_setstacksize( &stack_att, STACK_SIZE );
   pthread_t ht;

   for (uint i = 0; i < NUM_THREADS; i++)
   {
      RingThread* r =  new RingThread( i );

      rt_arr[i] = r;
      r->AcquireLock();

      pthread_create( &ht, &stack_att, &RingThread::Run, (void*)r );
   }

   // let's roll
   rt_arr[0]->ReleaseLock();

   // wait for result
   pthread_join( ht, 0 );

   return 0;
}

/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * Contributed by Premysl Hruby
 * convert to C++ by The Anh Tran
 */

#include <pthread.h>
#include <sched.h>
#include <cstdio>
#include <cstdlib>

typedef unsigned int uint;

const uint NUM_THREADS   = 503;
const uint STACK_SIZE   = 16*1024;


int   token;

pthread_mutex_t      mutex   [NUM_THREADS];
pthread_t         threadid[NUM_THREADS];
char            stacks   [NUM_THREADS][STACK_SIZE];


static
void* thread_func( void *num )
{
   size_t thisnode      = reinterpret_cast<size_t>(num);
   int nextnode      = ( thisnode + 1 ) % NUM_THREADS;

   pthread_mutex_t   *mutex_this_node = mutex + thisnode;
   pthread_mutex_t   *mutex_next_node = mutex + nextnode;

   while (true) 
   {
      pthread_mutex_lock( mutex_this_node );

      if ( token > 0 ) 
      {
         token--;
         pthread_mutex_unlock( mutex_next_node );
      }
      else 
      {
          printf( "%d\n", static_cast<int>(thisnode +1) );
          exit(0);
      }
   }

   return 0;
}


int main(int argc, char** args)
{
   if (argc >= 2)
      token = atoi(args[1]);
   else
      token = 1000; // test case

   pthread_attr_t stack_attr;
   pthread_attr_init(&stack_attr);

   for (uint i = 0; i < NUM_THREADS; i++) 
   {
      // init mutex objects
      pthread_mutex_init( &(mutex[i]), 0);
      pthread_mutex_lock( &(mutex[i]) );

      // manual set stack space & stack size for each thread
      // to reduce memory usage
      pthread_attr_setstack( &stack_attr, &(stacks[i]), STACK_SIZE );

      // create thread using specified stackspace
      pthread_create( &(threadid[i]), &stack_attr, &thread_func, reinterpret_cast<void*>(i) );
   }

   // start game
   pthread_mutex_unlock( &(mutex[0]) );

   // wait for result
   pthread_join( threadid[0], 0 );

   return 1;
}

/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
* Based on C contribution by Premysl Hruby
* Contributed by The Anh Tran
*/

/*
   This program will create 503 OS threads.
   Those threads will wait inside boost::asio::io_service.run() queue,
   if there is task in this queue, a thread will be dispatch to process it.
   Each task is a token passing run.

   asio::io_service:
      On Win:      NtIOCompletionPort
      On Linux:   kqueue
*/

#include <sched.h>
#include <pthread.h>
#include <cstdio>

#include <boost/scoped_ptr.hpp>
#include <boost/asio.hpp>
#include <boost/lexical_cast.hpp>
using namespace boost;


enum 
{   
   THREAD_COUNT   = 503,
   STACK_SIZE      = 4*1024
};


// pthread handle
pthread_t         threadid[THREAD_COUNT];
// custom stack space
char            stacks   [THREAD_COUNT][STACK_SIZE];


// Task queue:
scoped_ptr<asio::io_service> iosv;


// how many times remain to pass the token
int token;

// Rule 4: "pass the token from thread to thread N times"
// Any (real OS) thread can pick up the task inside asio::io_service.
// In order to satisfy benchmark rule, this struct encapsulates a "faked" thread 
// that handle each token passing run. 
// The real thread impersonates a faked thread, and passes token to next faked thread.
struct LogicalThread
{
   int my_id;
   int next_id;
   
   void operator()() const;
};
LogicalThread   threads[THREAD_COUNT];


void 
LogicalThread::operator()() const
{
   if (token > 0)
   {
      --token;
      // pass token to next
      iosv->post( threads[next_id] );
   }
   else
      printf("%d\n", my_id);   // done, print who is the final
}


static
void* 
thread_func( void* )
{
   // gather at task queue, waiting for job
   // this run() func will return when queue is empty
   iosv->run();   
   return 0;
}

static
void
SetSingleCPU()
{
   cpu_set_t   aff_set;
   CPU_ZERO(&aff_set);
   
   sched_getaffinity(0, sizeof(aff_set), &aff_set);
   
   int cpu_aff = 0, cpu_count = 0;
   for (int i = 0; i < 64; ++i)
   {
      if (CPU_ISSET(i, &aff_set))
      {
         cpu_aff = i;
         ++cpu_count;
      }
   }

   if (cpu_count > 1)
   {
      CPU_ZERO(&aff_set);
      CPU_SET(cpu_aff, &aff_set);
      sched_setaffinity(0, sizeof(aff_set), &aff_set);
   }
}


int 
main(int argc, char** args)
{
   // set process affinity to 1 cpu,
   // to avoid spreading thread context on all CPUs
   SetSingleCPU();
   
   // create task queue
   iosv.reset( new asio::io_service );

   // parse input
   if (argc >= 2)
      token = lexical_cast<int>(args[1]);
   else
      token = 1000;


   // Rule 2: "thread 503 should be linked to thread 1, forming an unbroken ring"
   for (int i = 0; i < THREAD_COUNT; i++) 
   {
      threads[i].my_id = i +1;
      threads[i].next_id = i +1;
   }
   threads[THREAD_COUNT -1].next_id = 0;


   // Rule 3: "pass a token to thread 1"
   // post first task to queue, so that task queue is not empty
   // this task will be handled by "thread 0"
   iosv->post( threads[0] );
   

   // Rule 1: "create 503 linked threads (named 1 to 503)"
   // cannot use boost::thread here, b/c creating 503 threads with default 
   // stack size will overflow process's working set
   {
      pthread_attr_t stack_attr;
      pthread_attr_init( &stack_attr );

      for (int i = 0; i < THREAD_COUNT; i++) 
      {
         // manually set stack space & stack size for each thread 
         // to reduce virtual memory cost
         pthread_attr_setstack( &stack_attr, &stacks[i], STACK_SIZE );

         // create thread using customized stack space
         pthread_create( &threadid[i], &stack_attr, &thread_func, 0 );
      }
   }
   
   // waiting
   iosv->run();

   return 0;
}

/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
* Based on C contribution by Premysl Hruby
* Contributed by The Anh Tran
*/

/*
   This program will create 503 OS threads.
   Those threads will wait inside boost::asio::io_service.run() queue,
   if there is task in this queue, a thread will be dispatch to process it.
   Each task is a token passing run.

   asio::io_service:
      On Win:      NtIOCompletionPort
      On Linux:   kqueue
*/

#include <sched.h>
#include <pthread.h>
#include <cstdio>

#include <boost/scoped_ptr.hpp>
#include <boost/asio.hpp>
#include <boost/lexical_cast.hpp>
using namespace boost;


enum 
{   
   THREAD_COUNT   = 503,
   STACK_SIZE      = 4*1024
};


// pthread handle
pthread_t         threadid[THREAD_COUNT];
// custom stack space
char            stacks   [THREAD_COUNT][STACK_SIZE];


// Task queue:
scoped_ptr<asio::io_service> iosv;


// how many times remain to pass the token
int token;

// Rule 4: "pass the token from thread to thread N times"
// Any (real OS) thread can pick up the task inside asio::io_service.
// In order to satisfy benchmark rule, this struct encapsulates a "faked" thread 
// that handle each token passing run. 
// The real thread impersonates a faked thread, and passes token to next faked thread.
struct LogicalThread
{
   int my_id;
   int next_id;
   
   void operator()() const;
};
LogicalThread   threads[THREAD_COUNT];


void 
LogicalThread::operator()() const
{
   if (token > 0)
   {
      --token;
      // pass token to next
      iosv->post( threads[next_id] );
   }
   else
      printf("%d\n", my_id);   // done, print who is the final
}


static
void* 
thread_func( void* )
{
   // gather at task queue, waiting for job
   // this run() func will return when queue is empty
   iosv->run();   
   return 0;
}
/*
static
void
SetSingleCPU()
{
   cpu_set_t   aff_set;
   CPU_ZERO(&aff_set);
   
   sched_getaffinity(0, sizeof(aff_set), &aff_set);
   
   int cpu_aff = 0, cpu_count = 0;
   for (int i = 0; i < 64; ++i)
   {
      if (CPU_ISSET(i, &aff_set))
      {
         cpu_aff = i;
         ++cpu_count;
      }
   }

   if (cpu_count > 1)
   {
      CPU_ZERO(&aff_set);
      CPU_SET(cpu_aff, &aff_set);
      sched_setaffinity(0, sizeof(aff_set), &aff_set);
   }
}
*/

int 
main(int argc, char** args)
{
   // set process affinity to 1 cpu,
   // to avoid spreading thread context on all CPUs
//   SetSingleCPU();
   
   // create task queue
   iosv.reset( new asio::io_service );

   // parse input
   if (argc >= 2)
      token = lexical_cast<int>(args[1]);
   else
      token = 1000;


   // Rule 2: "thread 503 should be linked to thread 1, forming an unbroken ring"
   for (int i = 0; i < THREAD_COUNT; i++) 
   {
      threads[i].my_id = i +1;
      threads[i].next_id = i +1;
   }
   threads[THREAD_COUNT -1].next_id = 0;


   // Rule 3: "pass a token to thread 1"
   // post first task to queue, so that task queue is not empty
   // this task will be handled by "thread 0"
   iosv->post( threads[0] );
   

   // Rule 1: "create 503 linked threads (named 1 to 503)"
   // cannot use boost::thread here, b/c creating 503 threads with default 
   // stack size will overflow process's working set
   {
      pthread_attr_t stack_attr;
      pthread_attr_init( &stack_attr );

      for (int i = 0; i < THREAD_COUNT; i++) 
      {
         // manually set stack space & stack size for each thread 
         // to reduce virtual memory cost
         pthread_attr_setstack( &stack_attr, &stacks[i], STACK_SIZE );

         // create thread using customized stack space
         pthread_create( &threadid[i], &stack_attr, &thread_func, 0 );
      }
   }
   
   // waiting
   iosv->run();

   return 0;
}

// -*- mode: c++ -*-
// $Id: wc.gpp,v 1.1 2004-11-10 06:42:03 bfulgham Exp $
// http://shootout.alioth.debian.org/
// with help from Tom Widmer

#include <iostream>
#include <vector>

using namespace std;

enum {
    OUT,			/* outside a word */
    IN				/* inside a word */
};

int
main(int argc, char *argv[]) {
    char c;
    int nl, nw, nc, state;
    char buff[4096];
    cin.rdbuf()->pubsetbuf(buff, 4096); // enable buffering

    state = OUT;
    nl = nw = nc = 0;
    int intc;
    streambuf* sbuf = cin.rdbuf();
    while ((intc = sbuf->sbumpc()) != EOF) {
        c = (char)intc;
	++nc;
	if (c == '\n')
	    ++nl;
	if (c == ' ' || c == '\n' || c == '\t')
	    state = OUT;
	else if (state == OUT) {
	    state = IN;
	    ++nw;
	}
    }
    cout << nl << " " << nw << " " << nc << endl;
}
/* The Great Computer Language Shootout 
 * http://shootout.alioth.debian.org
 *
 * C++ 'wc' reimplentation, using a more similar algorithm to the current C
 * implementation.
 * 
 * Also supports memory mapped IO, if available (e.g. if executed with a file
 * redirected to stdin).
 *
 * Contributor: Julian Hall <jh-misc@dsf.org.uk>
 */
#include <sys/stat.h>
#include <sys/mman.h>
#include <stdint.h>

#include <iostream>

/* functions for scanning 64 bits and 32 bits at a time to see if there are any
 * bytes in the group that we need to examine individually */
inline bool need_to_check (uint64_t w) { return (~w & 0xD0D0D0D0D0D0D0D0ULL) != 0; }
inline bool need_to_check (uint32_t w) { return (~w & 0xD0D0D0D0L) != 0; }

/* statically initialise tables */
#define B    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
#define M    0x10001
#define P    M, M, M, M, M, M, M, M,  M, M, M, M, M, M, M, M,
uint32_t data[] = {
    0, 0, 0, 0, 0, 0, 0, 0,  0, 1, M, 0, 0, 0, 0, 0, B
    1, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
    B  B B B B  B B B B  B B B B };
uint32_t mask[] = {
    M, M, M, M, M, M, M, M,  M, M-1, M-1, M, M, M, M, M, P
    M-1, M, M, M, M, M, M, M,  M, M, M, M, M, M, M, M,
    P  P P P P  P P P P  P P P P };

typedef unsigned char uchar;

class wordcounter
{
    unsigned int words, lines, bytecount;
    uchar last_char;
public:
    wordcounter () { words = lines = bytecount = 0; last_char = ' '; }

    static const size_t maxscan = 128*1024 - 4;

    void scan_block (const uchar * start, const uchar * end)
    {
	bytecount += end - start;
	uint32_t block_total = 0;
	while (start < end - 7) {
	    if (need_to_check (* (uint64_t *) start))
	    {
		if (need_to_check (* (uint32_t *) start))
		{
		    block_total += (data[start[0]] & mask[last_char])
			+ (data[start[1]] & mask[start[0]])
			+ (data[start[2]] & mask[start[1]])
			+ (data[start[3]] & mask[start[2]]);
		    last_char = start[3];
		}
		if (need_to_check (* (uint32_t *) (start + 4)))
		{
		    block_total += (data[start[4]] & mask[last_char])
			+ (data[start[5]] & mask[start[1]])
			+ (data[start[6]] & mask[start[2]])
			+ (data[start[7]] & mask[start[3]]);
		    last_char = start[7];
		}
	    }
	    start += 8;
	}
	while (start < end)
	{
	    block_total += data[*(start)] & mask[last_char];
	    last_char = *(start++);
	}
	words += block_total & 0xFFFF;
	lines += block_total >> 16;
    }
    void printresults () { std::cout << lines << " " << words << " " << bytecount << "\n"; }
};

class mapping_failed
{
public:
    mapping_failed() { /* std::cout << "Mapping failed: " << errno << "\n"; */ }
};

template<class T>
class memory_mapping
{
private:
    size_t len;
    T * data;
public:
    memory_mapping (int fd)
    {
	struct stat st;
	data = NULL;
	if (fstat (fd, &st)) throw mapping_failed();
	len = st.st_size;
	if (len == 0) throw mapping_failed(); // probably a pipe
	// std::cout << "File is " << len << " bytes long\n";
	data = (T *) mmap (NULL, len, PROT_READ, MAP_SHARED, fd, 0);
	if (!data) throw mapping_failed();
	// std::cout << "Memory mapping succeeded!\n";
    }
    ~memory_mapping ()
    {
	if (data)
	    munmap (data, len);
    }
    size_t getlength () { return len; }
    T * getdata () { return data; }
};

int main(void)
{
    wordcounter wc;
    try
    {
	memory_mapping<uchar> map(0);
	size_t s = map.getlength ();
	uchar * d = map.getdata ();
	while (s > wc.maxscan)
	{
	    wc.scan_block (d, d + wc.maxscan);
	    s -= wc.maxscan;
	    d += wc.maxscan;
	}
	wc.scan_block (d, d + s);
    }
    catch (mapping_failed f)
    {
	size_t s;
	uchar buf[32768];
	while ((s = read(0, buf, 32768)))
	{
	    wc.scan_block(buf, buf + s);
	}
    }
    wc.printresults();
}
// -*- mode: c++ -*-
/* $Id: wordfreq.gpp-2.gpp,v 1.1 2004-11-10 06:40:32 bfulgham Exp $ */
/* http://www.bagley.org/~doug/shootout/ */

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <map>

using namespace std;

void wf();

int
main() {
    wf();
    return 0;
}

void
wf() {
    typedef map<string, long, greater<string> > WC;
    typedef multimap<int, string, greater<int> > REV_WC;

    WC count;
    char buf[512];
    char *first, *last;
    while (cin >> buf) {
	first = last = buf;
	while (last<(buf+sizeof(buf)) && *last) {
	    if (isalpha(*last)) {
		*last++ = tolower(*last);
	    } else {
		*last = 0;
		if (first < last) count[first]++;
		first = ++last;
	    }
	}
	if (first < last) count[first]++;
    }

    REV_WC rcount;
    for (WC::iterator it = count.begin(); it != count.end(); it++) {
	rcount.insert(make_pair(it->second, it->first));
    }

    for (REV_WC::iterator it = rcount.begin(); it != rcount.end(); it++) {
	cout << setw(7) << it->first << "\t" << it->second << endl;
    }
}
/* $Id: wordfreq.gpp-3.gpp,v 1.1 2004-11-10 06:40:32 bfulgham Exp $ */
/* http://www.bagley.org/~doug/shootout/ */

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <map>
#include <vector>

using namespace std;

void wf();

int
main() {
    wf();
    return 0;
}

void
wf() {
    typedef map<string, long, greater<string> > WC;
    typedef vector<string> WL;
    typedef map<long, WL, greater<long> > BUCKET;

    WC count;
    char buf[512];
    char *first, *last;
    while (cin >> buf) {
	for (first = last = buf; (last<(buf+sizeof(buf)) && *last) ; last++) {
	    if (isalpha(*last)) {
		*last = tolower(*last);
	    } else {
		*last = 0;
		if (first < last) count[first]++;
		first = last + 1;
	    }
	}
	if (first < last) count[first]++;
    }

    BUCKET bucket;
    for (WC::iterator it = count.begin(); it != count.end(); it++) {
	long cnt = it->second;
	string word = it->first;
	bucket[cnt].insert(bucket[cnt].end(), word);
    }

    for (BUCKET::iterator i = bucket.begin(); i != bucket.end(); i++) {
	long cnt = i->first;
	vector<string> v = i->second;
	for (WL::iterator j = v.begin(); j != v.end(); j++) {
	    cout << setw(7) << cnt << "\t" << (*j) << endl;
	}
    }
}
// -*- mode: c++ -*-
// $Id: wordfreq.gpp,v 1.2 2004-11-30 07:10:05 bfulgham Exp $
// http://shootout.alioth.debian.org/
// By Tamás Benkõ
// Extended for Intel's C++ compiler by Brent Fulgham
// Many thanks to the posters at GameDev.net for help puzzling through
//   Dinkumware's strange STL.

#include <cstdio>
#include <cctype>
#include <cstring>
#include <ext/hash_map>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <iostream>

#if (defined (__INTEL_COMPILER))
namespace Sgi = std;
#else
namespace Sgi = ::__gnu_cxx;
#endif
using namespace std;

int const bufsize = 4096;
int const wsize = 64;

class word_reader
{
    int ws;
    char buf[bufsize+1], *bptr, *word;
    FILE *input;

    bool fill();

public:
    word_reader(FILE *i): ws(wsize), bptr(buf), word(new char[ws+1]), input(i)
	{*bptr = *word = '\0';}
    int operator()(char const **);
};

inline bool word_reader::fill()
{
    int nread = fread(buf, sizeof(char), bufsize, input);
    buf[nread] = '\0';
    bptr = buf;
    return nread > 0;
}

int word_reader::operator()(char const **w)
{
    int len = 0;
    char c;
    while (*bptr || fill()) {
	if (isalpha(c = *bptr++)) {
	    word[len] = tolower(c);
	    if (++len == ws) {
		char *nword = new char[(ws *= 2)+1];
		memcpy(nword, word, len);
		delete[] word;
		word = nword;
	    }
	}
	else if (len > 0) break;
    }
    *w = word;
    word[len] = '\0';
    return len;
}

typedef pair<char const *, int> hpair;

namespace std
{
    inline bool operator<(hpair const &lhs, hpair const &rhs)
    {
	return lhs.second != rhs.second ? lhs.second > rhs.second
	    : strcmp(lhs.first, rhs.first) > 0;
    }

    template<> struct equal_to<char const *>
    {
	bool operator()(char const *s1, char const *s2) const
	    {return strcmp(s1, s2) == 0;}
    };

    struct str_hash_compare
    {
        enum { bucket_size = 4, min_buckets = 8 };
	
	bool operator()(char const *s1, char const *s2) const
	    {return strcmp(s1, s2) < 0;}

	size_t operator() (const char* s) const
	{
	    size_t h = 0;
	    for (; *s; ++s)
	        h = 5 * h + *s;
	    return h;
	}
     };
}

#if (defined (__INTEL_COMPILER))
typedef std::hash_map<char const *, int, str_hash_compare> counter;
#else
typedef Sgi::hash_map<char const *, int> counter;
#endif

int main()
{
    int len;
    const char *w;
    counter hist;
    word_reader wr(stdin);

    while ((len = wr(&w)) > 0) {
	counter::iterator i = hist.find(w);
	if (i == hist.end()) hist[strcpy(new char[len+1], w)] = 1;
	else ++i->second;
    }

    vector<hpair> v(hist.begin(), hist.end());
    sort(v.begin(), v.end());
    for (size_t i = 0; i < v.size(); ++i)
    {
        cout << setw(7) << v[i].second << ' ' << v[i].first << endl;
    }

    return 0;
}
