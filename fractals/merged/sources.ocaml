(*
 * $Id: ackermann.ocaml,v 1.2 2004-09-29 06:24:25 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * with help from Markus Mottl
 *
 * Made more idiomatic by Pierre Etchemaite
 *)

let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1));;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)
(*
 * $Id: ackermann.ocaml-2.ocaml,v 1.1 2004-11-10 06:09:46 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

(* uncurried form *)
let rec ack(m, n) =
  if m = 0 then n + 1
  else if n = 0 then ack(m-1, 1)
  else ack(m-1, ack(m, n-1))

let _ =
  let arg =
    try int_of_string Sys.argv.(1)
    with Invalid_argument _ -> 1 in
  Printf.printf "Ack(3,%d): %d\n" arg (ack(3, arg))
(*
 * $Id: ary.ocaml,v 1.2 2004-05-22 07:25:00 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let _ =
  let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
  let lix = n - 1 and x = Array.make n 0 and y = Array.make n 0 in
  for i = 0 to lix do x.(i) <- i + 1 done;
  for k = 0 to 999 do for i = lix downto 0 do y.(i) <- x.(i) + y.(i) done done;
  Printf.printf "%d %d\n" y.(0) y.(lix)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * Modified by Fabrice Le Fessant for
 *  - tree type more compact
 *  - better GC parameters
 *  - loops replaced by recursive functions
 *)

type 'a tree = Leaf of 'a | Node of 'a tree * 'a * 'a tree

let rec make d i =
  if d = 0 then Leaf i
  else
    let l = make (d-1) (2*i - 1) in
    let r = make (d-1) (2*i) in
      Node(l, i, r)

let rec check = function Leaf i -> i | Node(l, i, r) ->
  let i = i + check l in
    i - check r

let min_depth = 4
let n = if Array.length Sys.argv <> 2 then 0 else int_of_string Sys.argv.(1)
let max_depth = max (min_depth + 2) n
let stretch_depth = max_depth + 1

let _ =
  let gc = Gc.get () in
    gc.Gc.max_overhead <- 1000000;
    gc.Gc.space_overhead <- 500;
    gc.Gc.major_heap_increment <- 10_000_000;
    gc.Gc.minor_heap_size <- 10_000_000;
    Gc.set gc

let () =
  let c = check (make stretch_depth 0) in
  Printf.printf "stretch tree of depth %i\t check: %i\n" stretch_depth c

let long_lived_tree = make max_depth 0


let rec iter i niter c d =
  if i <= niter then
    let c = c + check(make d i) in
    let c = c + check(make d (-i)) in
    iter (i+1) niter c d
  else
    Printf.printf "%i\t trees of depth %i\t check: %i\n" (2 * niter) d c


let rec loop_depths d =
  let niter = 1 lsl (max_depth - d + min_depth) in
    iter 1 niter 0 d;
    if d < max_depth then
      loop_depths (d+2)

let () =
  flush stdout;
  loop_depths min_depth;
  Printf.printf "long lived tree of depth %i\t check: %i\n"
    max_depth (check long_lived_tree)

(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * Rough parallelization by Mauricio Fernandez
 *)

type 'a tree = Empty | Node of 'a tree * 'a * 'a tree

let rec make i d =
(* if d = 0 then Empty *)
  if d = 0 then Node(Empty, i, Empty)
  else let i2 = 2 * i and d = d - 1 in Node(make (i2 - 1) d, i, make i2 d)

let rec check = function Empty -> 0 | Node(l, i, r) -> i + check l - check r

let min_depth = 4
let max_depth = (let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10 in
                 max (min_depth + 2) n)
let stretch_depth = max_depth + 1

let () =
  (* Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024; max_overhead = -1; }; *)
  let c = check (make 0 stretch_depth) in
  Printf.printf "stretch tree of depth %i\t check: %i\n" stretch_depth c

let long_lived_tree = make 0 max_depth

let rec loop_depths d =
  let worker d =
    let niter = 1 lsl (max_depth - d + min_depth) and c = ref 0 in
    for i = 1 to niter do c := !c + check(make i d) + check(make (-i) d) done;
    (niter, !c) in
  let workers = Array.init ((max_depth - d) / 2 + 1)
                  (fun i -> let d = d + i * 2 in (d, invoke worker d))
  in Array.iter
       (fun (d, w) ->
          let niter, c = w () in
          Printf.printf "%i\t trees of depth %i\t check: %i\n" (2 * niter) d c)
       workers

(* function originally due to Jon D. Harrop *)
and invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
      Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
      close_out output;
      exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in
      fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with
        | `Res x -> x
        | `Exn e -> raise e

let () =
  flush stdout;
  loop_depths min_depth;
  Printf.printf "long lived tree of depth %i\t check: %i\n"
    max_depth (check long_lived_tree)

(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * Modified by Fabrice Le Fessant
 *)

type 'a tree = Empty | Node of 'a tree * 'a * 'a tree

let rec make i d =
(* if d = 0 then Empty *)
  if d = 0 then Node(Empty, i, Empty)
  else let i2 = 2 * i and d = d - 1 in Node(make (i2 - 1) d, i, make i2 d)

let rec check = function Empty -> 0 | Node(l, i, r) -> i + check l - check r

let min_depth = 4
let max_depth = (let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10 in
                 max (min_depth + 2) n)
let stretch_depth = max_depth + 1

let () =
  (* Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024; max_overhead = -1; }; *)
  let c = check (make 0 stretch_depth) in
  Printf.printf "stretch tree of depth %i\t check: %i\n" stretch_depth c

let long_lived_tree = make 0 max_depth

let rec loop_depths d =
  for i = 0 to  ((max_depth - d) / 2 + 1) - 1 do
    let d = d + i * 2 in
    let niter = 1 lsl (max_depth - d + min_depth) in
    let c = ref 0 in
      for i = 1 to niter do c := !c + check(make i d) + check(make (-i) d) done;
      Printf.printf "%i\t trees of depth %i\t check: %i\n" (2 * niter) d !c;
  done

let () =
  flush stdout;
  loop_depths min_depth;
  Printf.printf "long lived tree of depth %i\t check: %i\n"
    max_depth (check long_lived_tree)

(*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Vladimir Silyaev
 *)

type color = B | R | Y | Faded
    
let compl c1 c2 = match c1,c2 with
  B,R | R,B -> Y
  | Y,R | R,Y -> B
| B,Y | Y,B -> R
| c,_ -> c

let n = ref (try int_of_string (Array.get Sys.argv 1) with _ -> 10)

let meet = 
  let first = ref None in
    fun creature cont ->
      if !n <= 0 then (cont Faded)
      else match !first with
	  None -> 
	    first := Some (creature, cont)
	| Some (creature',cont') -> 
	    decr n;
	    first := None;
	    cont creature';
	    cont' creature
	  
let wait,step = 
  let q = ref [] in
  (fun cont -> q := cont :: !q),
  (fun _ -> let q' = !q in q := [] ;
     match q' with
	 [] -> false
       | _ -> List.iter (fun c -> c ()) q';true)
    
      
let rec creature stop color =
  let rec body n color = 
    meet color 
      (function Faded -> stop n
	 | color' ->
	     let color = compl color color' in      
	       wait (fun _ -> body (succ n) color)
      )
  in
    body 0 color

let _ =     
  let met = ref 0 in
    List.iter (creature (fun n -> met := !met + n))  [B;R;Y;B;];
    while step () do () done;
    Printf.printf "%i\n" !met
      
(* chameneos.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

open Printf

type color = B | R | Y | Faded

let compl c1 c2 = match c1, c2 with
  | Faded, _ | _, Faded -> Faded | B, B -> B | R, R -> R | Y, Y -> Y
  | B, R | R, B -> Y   | B, Y | Y, B -> R   | R, Y | Y, R -> B


let enter = Mutex.create() (* protect thr following vars *)
let nmeetings = ref 0
let is_first = ref true
let color1 = ref B and color2 = ref B
let second_done = Condition.create()

let meet c =
  Mutex.lock enter;
  if !nmeetings > 0 then (
    if !is_first then (
      color1 := c;
      is_first := false;
      Condition.wait second_done enter;
      let other_color = !color2 in
      Mutex.unlock enter;
      other_color
    )
    else (
      is_first := true;
      color2 := c;
      decr nmeetings;
      let other_color = !color1 in
      Condition.signal second_done;  Mutex.unlock enter;
      other_color
    ))
  else (Mutex.unlock enter;  Faded)


let rec creature meetings = function
  | Faded -> decr meetings
  | c -> let c' = meet c in incr meetings; creature meetings (compl c c')

let () =
  nmeetings := (try int_of_string (Array.get Sys.argv 1) with _ -> 1);
  let create c = let n = ref 0 in (Thread.create (creature n) c, n) in
  let cr = List.map create [B; R; Y; B] in
  printf "%i\n" (List.fold_left (fun s (t,i) -> Thread.join t; s + !i) 0 cr)

(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Milan Stanojevic, Jul 12 2009
*)

module List = ListLabels
module String = StringLabels

open Printf

module Color = struct 
  type t =
  | Blue
  | Red
  | Yellow

  let complement t t' =
  match t, t' with 
    | Blue, Blue -> Blue
    | Blue, Red -> Yellow
    | Blue, Yellow -> Red
    | Red, Blue -> Yellow
    | Red, Red -> Red
    | Red, Yellow -> Blue
    | Yellow, Blue -> Red
    | Yellow, Red -> Blue
    | Yellow, Yellow -> Yellow

  let to_string = function
    | Blue -> "blue"
    | Red -> "red"
    | Yellow -> "yellow"

  let all = [ Blue; Red; Yellow ]
end

module Meeting_place = struct

  type 'chameneos t = {
    mutable state : [ `Empty | `First of 'chameneos | `Second of 'chameneos ];
    mutable meetings_left : int;
    mutex : Mutex.t;
    wait_for_second : Condition.t;
    wait_for_empty : Condition.t;
  }

  let create n = {
    state = `Empty;
    meetings_left = n;
    mutex = Mutex.create ();
    wait_for_second = Condition.create ();
    wait_for_empty = Condition.create ();
  }

  let meet t c = 
    let rec loop () = 
      if t.meetings_left = 0 then begin
        Condition.broadcast t.wait_for_empty;
        None
      end
      else
	match t.state with 
	| `Empty -> 
	    t.state <- `First c;
	    Condition.wait t.wait_for_second t.mutex;
	    begin
	      match t.state with 
	      | `Empty
	      | `First _ -> 
		  assert false
	      | `Second c -> 
		  t.state <- `Empty;
                  Condition.signal t.wait_for_empty;
                  Condition.signal t.wait_for_empty;
		  Some c
	    end
	| `First c1 ->
	    t.state <- `Second c;
	    t.meetings_left <- t.meetings_left - 1;
	    Condition.signal t.wait_for_second;
	    Some c1
	| `Second _ ->
	    Condition.wait t.wait_for_empty t.mutex;
	    loop ()
    in
    Mutex.lock t.mutex;
    let res = loop () in
    Mutex.unlock t.mutex;
    res
  ;;
end

module Chameneos = struct 
  
  type t = {
    id : int;
    mutable color : Color.t;
    mutable meetings : int;
    mutable meetings_with_self : int;
  }

  let create = 
    let id = ref 0 in
    let new_id () = 
      let r = !id in
      id := r + 1;
      r
    in
    fun color -> 
      { id = new_id ();
	color = color;
	meetings = 0;
	meetings_with_self = 0;
      }

  let run t place =
    let rec loop () =
      match Meeting_place.meet place t with 
      | None -> ()
      | Some other -> 
	  t.meetings <- t.meetings + 1;
	  if t.id = other.id then t.meetings_with_self <- t.meetings_with_self + 1;
	  t.color <- Color.complement t.color other.color;
	  loop () 
    in
    Thread.create loop ()
end

let print_complements () = 
  List.iter Color.all ~f:(fun c1 -> 
    List.iter Color.all ~f:(fun c2 ->
      printf "%s + %s -> %s\n" 
	(Color.to_string c1)
	(Color.to_string c2)
	(Color.to_string (Color.complement c1 c2))));
  printf "\n";
;;

let spell_int i = 
  let spell_char = function 
    | '0' -> "zero"
    | '1' -> "one"
    | '2' -> "two"
    | '3' -> "three"
    | '4' -> "four"
    | '5' -> "five"
    | '6' -> "six"
    | '7' -> "seven"
    | '8' -> "eight"
    | '9' -> "nine"
    | x -> failwith "unexpected char"
  in
  let s = string_of_int i in
  String.iter s ~f:(fun c -> printf " %s" (spell_char c));
;;
  
let work colors n = 
  let module C = Chameneos in
  List.iter colors ~f:(fun c -> printf " %s" (Color.to_string c)); printf "\n";
  let place = Meeting_place.create n in
  let cs = List.map colors ~f:Chameneos.create in
  let threads = List.map cs ~f:(fun c -> Chameneos.run c place) in
  List.iter threads ~f:Thread.join;
  let sum_meets = ref 0 in
  List.iter cs ~f:(fun c ->
    printf "%d" c.C.meetings; spell_int c.C.meetings_with_self; printf "\n";
    sum_meets := !sum_meets + c.C.meetings);
  spell_int !sum_meets; printf "\n";
;;


let main () = 
  let n = 
    try 
      int_of_string (Sys.argv.(1))
    with
    | _ -> 600
  in
  print_complements ();
  let module C = Color in
  work [ C.Blue; C.Red; C.Yellow ] n;
  printf "\n";
  work [ C.Blue; C.Red; C.Yellow; C.Red; C.Yellow; C.Blue; C.Red; C.Yellow; C.Red; C.Blue ] n;
  printf "\n";
;;

let () = main ()
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Milan Stanojevic, Jul 12 2009
   modified to use event channels by Otto Bommer
*)

open Printf

let str2list s = let l=ref [] in String.iter (fun c -> l:=!l@[c]) s; !l

let spell_char = function
  | '0' -> "zero"
  | '1' -> "one"
  | '2' -> "two"
  | '3' -> "three"
  | '4' -> "four"
  | '5' -> "five"
  | '6' -> "six"
  | '7' -> "seven"
  | '8' -> "eight"
  | '9' -> "nine"
  | x -> failwith "unexpected char"

let spell_int i = String.concat " " (List.map spell_char (str2list (string_of_int i)))

module Color = struct
type t = B | R | Y

let complement a b =
match a, b with
  | B, B -> B
  | B, R -> Y
  | B, Y -> R
  | R, B -> Y
  | R, R -> R
  | R, Y -> B
  | Y, B -> R
  | Y, R -> B
  | Y, Y -> Y

let to_string = function B -> "blue" | R -> "red" | Y -> "yellow"

let all = [ B; R; Y ]
end

module Game = struct
type place = {
  mutable meetings_left : int;
  meet : (chameneos Event.channel)
}

and chameneos = {
  mutable color : Color.t;
  mutable meetings : int;
  mutable self_meetings : int;
  morph : ((chameneos * bool) Event.channel);
}

let create_place n = { meetings_left=n; meet=Event.new_channel () }

let create_chameneos color =
  { color=color; meetings=0; self_meetings=0; morph=Event.new_channel () }

let send chn v = Event.sync (Event.send chn v)
let receive chn = Event.sync (Event.receive chn)

let rec run_place place players () = 
  if place.meetings_left > 0 then 
    begin 
    let ch1 = receive place.meet in
    let ch2 = receive place.meet in
    send ch1.morph (ch2, true);
    send ch2.morph (ch1, true);
    place.meetings_left <- place.meetings_left - 1; 
    run_place place players ()
    end
  else
    for i = 0 to players-1 do
      let ch = receive place.meet in 
      send ch.morph (ch, false)
    done

let rec run_chameneos ch place () =
  send place.meet ch;
  let (other, continue) = receive ch.morph in
  if continue then 
    begin
    ch.meetings <- ch.meetings + 1;
    if ch == other then ch.self_meetings <- ch.self_meetings + 1;
    ch.color <- Color.complement ch.color other.color;
    run_chameneos ch place ()
    end

let play colors max_meetings =
  List.iter (fun c -> printf " %s" (Color.to_string c)) colors; printf "\n%!";

  let place = create_place max_meetings in
  let pthread = Thread.create (run_place place (List.length colors)) () in

  let chs = List.map create_chameneos colors in
  let chthreads = List.map (fun ch -> Thread.create (run_chameneos ch place) ()) chs in

  List.iter (fun cht -> Thread.join cht) (pthread::chthreads);

  List.iter (fun ch -> printf "%d %s\n" ch.meetings (spell_int ch.self_meetings)) chs;
  let meetings = List.fold_left (+) 0 (List.map (fun chs -> chs.meetings) chs) in 
  printf " %s\n\n%!" (spell_int meetings)
end

open Color

let print_complements () = List.iter (fun c1 -> List.iter (fun c2 ->
  printf "%s + %s -> %s\n" (to_string c1) (to_string c2)
    (to_string (complement c1 c2)) ) all) all;
  printf "\n"

let _ =
  let max_meetings = try int_of_string Sys.argv.(1) with _ -> 600 in
  print_complements ();
  Game.play [B; R; Y] max_meetings;
  Game.play [B; R; Y; R; Y; B; R; Y; R; B] max_meetings;

(*
 * $Id: echo.ocaml,v 1.1 2004-05-19 18:09:37 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

open Unix

let data = "Hello there sailor\n"

let rec sock_write sock buf offset = function
  | 0 -> ()
  | len ->
      let nwritten = write sock buf offset len in
      sock_write sock buf (offset + nwritten) (len - nwritten)

let sock_readline buf sock =
  let offset = ref (read sock buf 0 64) in
  while buf.[!offset - 1] <> '\n' do
    offset := !offset + read sock buf !offset 64
  done;
  !offset

let rec buf_ok buf n = n <= 0 || buf.[n] = data.[n] && buf_ok buf (n - 1)

let echo_client n port =
  let sock = socket PF_INET SOCK_STREAM 0 in
  connect sock (ADDR_INET (inet_addr_of_string "127.0.0.1", port));
  let len = String.length data and buf = String.create 64 in
  for i = 1 to n do
    sock_write sock data 0 len;
    let ans_len = sock_readline buf sock in
    if ans_len <> len || not (buf_ok buf (len - 1)) then
      failwith ("client got bad data: " ^ String.sub buf 0 ans_len)
  done;
  close sock

let ssock =
  let ssock = socket PF_INET SOCK_STREAM 0
  and addr = inet_addr_of_string "127.0.0.1" in
  bind ssock (ADDR_INET (addr, 0));
  setsockopt ssock SO_REUSEADDR true;
  listen ssock 2;
  ssock

let get_port sock =
  match getsockname sock with
  | ADDR_INET (_, port) -> port
  | ADDR_UNIX _ -> failwith "getsockname"

let echo_server n =
  let port = get_port ssock and pid = fork() in
  if pid <> 0 then begin
    let csock, addr = accept ssock
    and buf = String.create 64 and len = ref 0 and nread = ref 1 in
    while !nread > 0 do
      nread := read csock buf 0 64;
      sock_write csock buf 0 !nread;
      len := !len + !nread
    done;
    ignore (wait ());
    Printf.printf "server processed %d bytes\n" !len end
  else echo_client n port

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
echo_server n
(*
 * $Id: except.ocaml,v 1.1 2004-05-19 18:09:43 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 * and Mark Baker
 *)

exception HiException of int
exception LoException of int

let hi = ref 0
let lo = ref 0

let blowup n =
  if n mod 2 = 0 then raise (LoException n)
  else raise (HiException n)

let lo_fun n = try blowup n with LoException _ -> incr lo
let hi_fun n = try lo_fun n with HiException _ -> incr hi

let some_fun n =
  try hi_fun n with exc -> print_endline "Should not get here."; raise exc

let _ =
  let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
  for i = 1 to n do some_fun i done;
  Printf.printf "Exceptions: HI=%d / LO=%d\n" !hi !lo
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Christophe Papazian
   Decembre 2005
*)

(* please compile with -unsafe to optimize speed *)

open Array open Printf

(*global variables*)
let n = try if length Sys.argv>1 then int_of_string Sys.argv.(1)else 7  with _->7
let r = init(n+2)(fun x -> x-1) and p=init n((+)1) and s=create n 0

(*pretty printing function*)
let q() = iter print_int p;print_newline()

(*counting permutations*)
let rec a n = r.(n)<-(r.(n)+1); 
  if r.(n)=n-1 then a(n+1) 
  else (if r.(n)=n then r.(n)<-0;n)

(*swapping arrays*)
let w m= let rec a i=i=n||(p.(i)<>(i+1)&&a(i+1))in
if a 0 then
  (for i=0 to n-1 do s.(i)<-p.(i)done;
   let rec y m= let x=s.(0)-1 in 
   if x=0 then m 
   else (for i=0 to((x-1) lsr 1)do
	   let t=s.(i)in let o = x-i in s.(i)<-s.(o);
	   s.(o)<-t done;y(m+1)) 
   in y m) else 0
  
(*building new permutations*)
let x n = 
  for i=1 to n-1 do let t=p.(0)in 
  for j=0 to i-1 do p.(j)<-p.(j+1) done; p.(i)<-t done

(* main *)
let _ = let rec f i m z= (* printing loop *)
  if i <=n && z>0 
  then(q();x i;f(a 2)(max m(w 0))(z-1))
  else (if z>0 then q();g i m)
	and g i m= if i <=n (* non printing loop *)
	then(x i; g(a 2)(max m(w 0)))
	else m in
printf "Pfannkuchen(%i) = %i\n" n (f (a 2) 0 30)
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Based on Ocaml contribution of
       Christophe Papazian (Decembre 2005)

   Parallelized by Alfredos-Panagiotis Damkalis
       with the help of Jon Harrop's functions 
*)

(* please compile with -unsafe to optimize speed *)

open Array open Printf


let threads_num = 4

(* semi-standard function for process-based parallelism *)
let invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with `Res x -> x | `Exn e -> raise e

let ( |> ) x f = f x

let map_JonH (f : 'a -> 'b) a : 'b array =
  map (invoke f) a |>
    map (fun f -> f())

(*global variables*)
let n = try if length Sys.argv>1 then int_of_string Sys.argv.(1)else 7  with _->7
let r = init(n+2)(fun x -> x-1) and p=init n((+)1) and s=create n 0

let init_f i = (i,create n i,create (n+2) i)
let parray = init threads_num (init_f)

(*pretty printing function*)
let q p = iter print_int p;print_newline()

(*counting permutations*)
let rec a n r = r.(n)<-(r.(n)+1);
  if r.(n)=n-1 then a (n+1) r
  else (if r.(n)=n then r.(n)<-0;n)

(*swapping arrays*)
let w m p=
  let rec a i=i=n||(p.(i)<>(i+1)&&a(i+1))in
   if a 0
   then (for i=0 to n-1 do s.(i)<-p.(i)done;
         let rec y m=
          let x=s.(0)-1
           in if x=0 then m
              else (for i=0 to((x-1) lsr 1)do
                     let t=s.(i)in
                     let o = x-i in
                       s.(i)<-s.(o); s.(o)<-t
                    done;y(m+1))
         in y m)
   else 0

(*building new permutations*)
let x n p=
  for i=1 to n-1 do let t=p.(0)in
  for j=0 to i-1 do p.(j)<-p.(j+1) done; p.(i)<-t done

(*jump <threads_num-1> permutations so the current thread
  check its part of permutations*)
let rec inder i z p r = x i p;
                        let c = (a 2 r) in
                          if (c<=n) && (z < (threads_num-1))
                          then (inder c (z+1) p r)
                          else ((c,p,r))
(*initialize starting permutation for each thread*)
let rec initp i z= parray.(z) <- (i,copy p,copy r); x i p;
                   let c = (a 2 r) in
                       if (c<=n) && (z < (threads_num-2))
                       then (initp c (z+1))
                       else parray.(z+1) <- (c,copy p,copy r)

(* main *)
let _ = let rec f i m z= (* printing loop *)
          if i <=n && z>0
          then(q p;x i p;f(a 2 r)(max m(w 0 p))(z-1))
          else (if z>0
                then (q p;m)
                else (initp i 0; fold_left max m (map_JonH (g m) parray))) (*start threads*)
        and g m (i,p,r) = if i <=n (* non printing loop *)
                          then(g (max m(w 0 p)) (inder i 0 p r))
                          else (m) in
printf "Pfannkuchen(%i) = %i\n" n (f (a 2 r) 0 30)
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   from Scala version by Otto Bommer, August 2010
*)

let fannkuch n =
   begin
   let perm1 = Array.create n 0 in for i = 0 to (n-1) do perm1.(i) <- i done;
   let perm = Array.create n 0 in
   let count = Array.create n 0 in
   let flips = ref 0 
   and maxflips = ref 0 
   and checksum = ref 0 
   and nperm = ref 0
   and r = ref n in
   while !r > 0 do 
(*      Printf.printf "perm="; i := 0; while !i < n do Printf.printf "%d " perm1.(!i); i := !i +1; done; Printf.printf "\n"; *)
      for i = 0 to n-1 do perm.(i) <- perm1.(i) done;

      while !r != 1 do count.(!r-1) <- !r; r := !r - 1; done;

      flips := 0;
      let k = ref perm.(0) in
      while !k != 0 do
         let t = ref 0 in
         for i = 0 to !k / 2 do
            t := perm.(i);
            perm.(i) <- perm.(!k - i);
            perm.(!k - i) <- !t;
            done;
            
         k := perm.(0);
         flips := !flips + 1;
         done;

      maxflips := max !maxflips !flips;
      checksum := !checksum + !flips * (1 - (!nperm land 1) lsl 1);
      
      let go = ref true in
      let t = ref 0 in
      while !go do
         if !r == n then begin go := false; r := 0; end
         else
            begin
            t := perm1.(0);
            for i = 0 to !r - 1 do perm1.(i) <- perm1.(i+1) done;
            perm1.(!r) <- !t;

            count.(!r) <- count.(!r) - 1;
            if count.(!r) > 0 then go := false
            else r := !r + 1;
            end
         done;

      nperm := !nperm + 1;
      done;

   (!maxflips, !checksum);
   end

let _ =
        let n = try int_of_string(Sys.argv.(1)) with _ -> 7 in
        let (maxflips, checksum) = fannkuch n in
        Printf.printf "%d\nPfannkuchen(%d) = %d\n" checksum n maxflips

(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Ethan Burns
*)


(** Flip the front [n] pancakes of [a]. *)
let flip n (a : int array) =
  for i = 0 to n / 2 do
    let t = a.(i) in
    let k = n - i in
      a.(i) <- a.(k);
      a.(k) <- t;
  done

(** Count the number of flips so that pancake 0 is at index 0. *)
let rec count c ary =
  let z = ary.(0) in
    if z <> 0 then begin
      flip z ary;
      count (c + 1) ary
    end else
      c

(** Rotate the first [n] pancakes of [a]. *)
let rotate n (a : int array) =
  let t = a.(0) in
  let m = n - 1 in
    for i = 1 to m do
      a.(i - 1) <- a.(i);
    done;
    a.(m) <- t

(** Call [f] on each permutation of [n] numbers in order. *)
let iter_perms n f =
  let rec do_iter num perm copy f ht =
    if ht = 1 then begin
      for i = 0 to n - 1 do copy.(i) <- perm.(i) done;
      f !num copy;
      incr num;
    end else
      for i = 1 to ht do
	do_iter num perm copy f (ht - 1);
	rotate ht perm;
      done
  in
  let perm = Array.init n (fun i -> i) in
  let copy = Array.create n 0 in
  let num = ref 0 in
    do_iter num perm copy f n

let _ =
  let n = int_of_string Sys.argv.(1) in
  let csum = ref 0 and m = ref 0 in
    iter_perms n (fun num a ->
		    let c = count 0 a in
		      (* csum update from Otto Bommer's Scala ver. *)
		      csum := !csum + c * (1 - (num land 1) lsl 1);
		      if c > !m then m := c;);
    Printf.printf "%d\nPfannkuchen(%d) = %d\n" !csum n !m
(* fasta.ml
 *
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 *)

(* Random number generator *)
let im = 139968
and ia = 3877
and ic = 29573

let last = ref 42 and inv_im = 1. /. float im
let gen_random  max =
  let n = (!last * ia + ic) mod im in
    last := n;
    max *. float n *. inv_im

module Cumul_tbl =
struct
  type t = { probs : float array; chars : char array }

  let make a = let p = ref 0.0 in
    {
      probs = Array.map (fun (_, p1) -> p := !p +. p1; !p) a;
      chars = Array.map fst a;
    }

  let rand_char t =
    let p = gen_random 1.0 in
    let i = ref 0 and ps = t.probs in
      while p >= ps.(!i) do incr i done;
      t.chars.(!i)
end

let width = 60

let make_random_fasta id desc table n =
  Printf.printf ">%s %s\n" id desc;
  let table = Cumul_tbl.make table in
  let line = String.make (width+1) '\n' in
  for i = 1 to n / width do
    for j = 0 to width - 1 do line.[j] <- Cumul_tbl.rand_char table done;
    print_string line;
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do print_char(Cumul_tbl.rand_char table); done;
    print_char '\n'
  )

(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then (output stdout s i0 w; print_char '\n'; i0 + w)
  else (output stdout s i0 len; write s 0 l (w - len))

let make_repeat_fasta id desc src n =
  Printf.printf ">%s %s\n" id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)


let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

let iub = [| ('a', 0.27);  ('c', 0.12);  ('g', 0.12);  ('t', 0.27);
	     ('B', 0.02);  ('D', 0.02);  ('H', 0.02);  ('K', 0.02);
	     ('M', 0.02);  ('N', 0.02);  ('R', 0.02);  ('S', 0.02);
	     ('V', 0.02);  ('W', 0.02);  ('Y', 0.02);  |]

let homosapiens = [| ('a', 0.3029549426680);    ('c', 0.1979883004921);
		     ('g', 0.1975473066391);    ('t', 0.3015094502008);  |]

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
  make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
  make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5)

(* fasta.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

(* Random number generator (Shootout version) *)
let im = 139968
and ia = 3877
and ic = 29573

let last = ref 42 and inv_im = 1. /. float im
let gen_random  max =
  last := (!last * ia + ic) mod im;
  max *. float !last *. inv_im


let make_cumulative table =
  let prob = ref 0.0 in
  Array.map (fun (c, p) -> prob := !prob +. p; (c, !prob)) table

let rand_char cumul =
  let prob = gen_random 1.0 in
  let i = ref 0 in
  while prob >= snd cumul.(!i) do incr i done;
  fst cumul.(!i)


let width = 60

let make_random_fasta id desc table n =
  Printf.printf ">%s %s\n" id desc;
  let table = make_cumulative table in
  let line = String.make (width+1) '\n' in
  for i = 1 to n / width do
    for j = 0 to width - 1 do line.[j] <- rand_char table done;
    print_string line;
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do print_char(rand_char table); done;
    print_char '\n'
  )

(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then (output stdout s i0 w; print_char '\n'; i0 + w)
  else (output stdout s i0 len; write s 0 l (w - len))

let make_repeat_fasta id desc src n =
  Printf.printf ">%s %s\n" id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)


let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

let iub = [| ('a', 0.27);  ('c', 0.12);  ('g', 0.12);  ('t', 0.27);
	     ('B', 0.02);  ('D', 0.02);  ('H', 0.02);  ('K', 0.02);
	     ('M', 0.02);  ('N', 0.02);  ('R', 0.02);  ('S', 0.02);
	     ('V', 0.02);  ('W', 0.02);  ('Y', 0.02);  |]

let homosapiens = [| ('a', 0.3029549426680);    ('c', 0.1979883004921);
		     ('g', 0.1975473066391);    ('t', 0.3015094502008);  |]

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
  make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
  make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 *)

(* Random number generator *)
let im = 139968
and ia = 3877
and ic = 29573

let last = ref 42 and im_f = float im
let gen_random  max =
  let n = (!last * ia + ic) mod im in
    last := n;
    max *. float n /. im_f

module Cumul_tbl =
struct
  type t = { probs : float array; chars : char array }

  let make a = let p = ref 0.0 in
    {
      probs = Array.map (fun (_, p1) -> p := !p +. p1; !p) a;
      chars = Array.map fst a;
    }

  let rand_char t =
    let p = gen_random 1.0 in
    let i = ref 0 and ps = t.probs in
      while p >= ps.(!i) do incr i done;
      t.chars.(!i)
end

let width = 60

let make_random_fasta id desc table n =
  Printf.printf ">%s %s\n" id desc;
  let table = Cumul_tbl.make table in
  let line = String.make (width+1) '\n' in
  for i = 1 to n / width do
    for j = 0 to width - 1 do line.[j] <- Cumul_tbl.rand_char table done;
    print_string line;
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do print_char(Cumul_tbl.rand_char table); done;
    print_char '\n'
  )

(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then (output stdout s i0 w; print_char '\n'; i0 + w)
  else (output stdout s i0 len; write s 0 l (w - len))

let make_repeat_fasta id desc src n =
  Printf.printf ">%s %s\n" id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)


let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

let iub = [| ('a', 0.27);  ('c', 0.12);  ('g', 0.12);  ('t', 0.27);
	     ('B', 0.02);  ('D', 0.02);  ('H', 0.02);  ('K', 0.02);
	     ('M', 0.02);  ('N', 0.02);  ('R', 0.02);  ('S', 0.02);
	     ('V', 0.02);  ('W', 0.02);  ('Y', 0.02);  |]

let homosapiens = [| ('a', 0.3029549426680);    ('c', 0.1979883004921);
		     ('g', 0.1975473066391);    ('t', 0.3015094502008);  |]

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
  make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
  make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 * modified by Fabrice Le Fessant
 *)

let arch64 =
  match Sys.word_size with
      32 -> false
    | 64 -> true
    | _ -> assert false

module Spawner : sig

  val spawn : bool -> (unit -> unit) -> (unit -> unit) -> unit

 end = struct

let inbuf = String.create 1

let wait_for = ref None
let spawn spawn prelude postlude =
  begin
  end;
  if spawn then begin
    let (ix, ox) = Unix.pipe () in
      match Unix.fork () with
	  -1 -> assert false
	| 0 ->
	    prelude ();
	    begin
	      match !wait_for with
		  None -> ()
		| Some ix ->
		    ignore (Unix.read ix inbuf 0 1)
	    end;
	    postlude ();
	    ignore (Unix.write ox "X" 0 1);
	    Unix.close ox;
	    exit 0
	| _ ->
	    wait_for := Some ix;
  end else begin
    prelude ();
    begin
      match !wait_for with
	  None -> ()
	| Some ix ->
	    ignore (Unix.read ix inbuf 0 1);
    end;
    postlude ();
  end


end

let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

let iub = [| ('a', 0.27);  ('c', 0.12);  ('g', 0.12);  ('t', 0.27);
	     ('B', 0.02);  ('D', 0.02);  ('H', 0.02);  ('K', 0.02);
	     ('M', 0.02);  ('N', 0.02);  ('R', 0.02);  ('S', 0.02);
	     ('V', 0.02);  ('W', 0.02);  ('Y', 0.02);  |]

let homosapiens = [| ('a', 0.3029549426680);    ('c', 0.1979883004921);
		     ('g', 0.1975473066391);    ('t', 0.3015094502008);  |]


(* Random number generator *)
let im = 139968
and ia = 3877
and ic = 29573

let last = ref 42 and im_f = float im


let cache =
  let im = 139968
  and ia = 3877
  and ic = 29573 in
  Array.init im  (fun i ->  (i * ia + ic) mod im)

let gen_random  () =
  let n = cache.(!last) in
    last := n;
    n

module Cumul_tbl =
struct
  type t = { probs : float array;
	     chars : char array;
	     cache : char array; }

  let make a =
    let len = Array.length a in
    let chars = Array.create len 'x' in
    let probs = Array.create len 0. in
    let p = ref 0.0 in
      for i = 0 to len-1 do
	let (c, p1) = a.(i) in
	  chars.(i) <- c;
	  let p0 = !p +. p1 in
	    p := p0;
	    probs.(i) <- p0
      done;
    {
      probs = probs;
      chars = chars;
      cache = Array.create im '\000';
    }

(* Dichotomy is actually slower than linear search on small tables. *)
  let find t p =
    let ps = t.probs in
    let i = ref 0 in
      while p >= ps.(!i) do incr i done;
      !i

  let rand_char t =
    let n = gen_random () in
    let c =  t.cache.(n) in
      if c = '\000' then
	let p = 1. *. float n /. im_f in
	let i = find t p in
	  let c = t.chars.(i) in
	    t.cache.(n) <- c;
	    c
      else
	c
end

let width = 60

module IMPLEMENTATION32 = struct

module Buffer : sig

  val add_substring : string -> int -> int -> unit
  val add_string : string -> unit
  val add_char : char -> unit

  val clear : unit -> unit
  val print : unit -> unit

end = struct

  let buffer_len = 1_000_000
  let buffers = Array.init 150 (fun _ -> String.create buffer_len)
  let nbuffer = ref 0
  let buffer_pos = ref 0
  let current_buffer = ref buffers.(0)

  let add_substring s pos len =
    let rem = buffer_len - !buffer_pos in
      if rem >= len then begin
	String.blit s pos !current_buffer !buffer_pos len;
	buffer_pos := !buffer_pos + len
      end else
	if rem = 0 then begin
	  incr nbuffer;
	  current_buffer := buffers.(!nbuffer);
	    String.blit s pos !current_buffer 0 len;
	    buffer_pos := len;
	end else begin
	  String.blit s pos !current_buffer !buffer_pos rem;
	  incr nbuffer;
	  current_buffer := buffers.(!nbuffer);
	  let len2 = len - rem in
	    String.blit s (pos+rem) !current_buffer 0 len2;
	    buffer_pos := len2;
	end

  let add_string s =
    add_substring s 0 (String.length s)

  let add_char c =
    if !buffer_pos < buffer_len then begin
      !current_buffer.[!buffer_pos] <- c;
      incr buffer_pos
    end else begin
      incr nbuffer;
      current_buffer := buffers.(!nbuffer);
      !current_buffer.[0] <- c;
      buffer_pos := 1;
    end

  let clear () =
    buffer_pos := 0;
    nbuffer := 0;
    current_buffer := buffers.(0)

  let print () =
    let rec iter buffer i len =
      if len > 0 then begin
	let nw = Unix.write Unix.stdout buffer i  len in
	  iter buffer (i+nw) (len-nw)
      end
    in
      for i = 0 to !nbuffer - 1 do
	iter buffers.(i) 0 buffer_len
      done;
      iter buffers.(!nbuffer) 0 !buffer_pos;
      clear ()

end

let add_header id desc =
  Buffer.add_char '>';
  Buffer.add_string id;
  Buffer.add_char ' ';
  Buffer.add_string desc;
  Buffer.add_char '\n'

let make_random_fasta id desc table n =
  add_header id desc;
  let table = Cumul_tbl.make table in
  for i = 1 to n / width do
    for j = 0 to width-1 do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  )

(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then begin
    Buffer.add_substring s i0 w;
    Buffer.add_char '\n'; i0 + w
  end
  else begin
    Buffer.add_substring s i0 len;
    write s 0 l (w - len);
  end

let make_repeat_fasta id desc src n =
  add_header id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)


let main n =
      Spawner.spawn true (fun _ ->
			  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
			  ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
      Spawner.spawn true (fun _ -> ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5);
      Spawner.spawn false (fun _ -> ()) Buffer.print;
      Buffer.clear ();


end

module IMPLEMENTATION64 = struct

module Buffer : sig

  val add_substring : string -> int -> int -> unit
  val add_string : string -> unit
  val add_char : char -> unit
  val add_copy : int -> int -> unit

  val length : unit -> int

  val clear : unit -> unit
  val print : unit -> unit

  val check_char : char -> unit
  val check_copy : int -> int -> unit


end = struct

  let buffer_len = if arch64 then 150_000_000 else 1
  let buffer = String.create buffer_len
  let buffer_pos = ref 0

  let length () = !buffer_pos

  let add_substring s pos len =
    String.blit s pos buffer !buffer_pos len;
    buffer_pos := !buffer_pos + len

  let add_string s =
    add_substring s 0 (String.length s)

  let add_char c =
    buffer.[!buffer_pos] <- c;
    incr buffer_pos

  let check_char c =
    if buffer.[!buffer_pos] <> c then begin
      Printf.fprintf stderr "check_char [%d]\n%!" !buffer_pos;
      exit 2;
    end;
    incr buffer_pos

  let clear () = buffer_pos := 0

  let print () =
    let rec iter i len =
      if len > 0 then begin
	let nw = Unix.write Unix.stdout buffer i  len in
	  iter (i+nw) (len-nw)
      end

    in
      iter 0 !buffer_pos;
      buffer_pos := 0

  let add_copy src len =
    add_substring buffer src len

  let rec check_copy src len =
    if len > 0 then begin
      assert (buffer.[src] = buffer.[!buffer_pos]);
      incr buffer_pos;
      check_copy (src+1) (len-1);
    end

end

let add_header id desc =
  Buffer.add_char '>';
  Buffer.add_string id;
  Buffer.add_char ' ';
  Buffer.add_string desc;
  Buffer.add_char '\n'

let make_random_fasta id desc table n =
  add_header id desc;
  let table = Cumul_tbl.make table in
  for i = 1 to n / width do
    for j = 0 to width-1 do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  )


(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then begin
    Buffer.add_substring s i0 w;
    Buffer.add_char '\n'; i0 + w
  end
  else begin
    Buffer.add_substring s i0 len;
    write s 0 l (w - len);
  end


let make_repeat_fasta1 id desc src n =
  add_header id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)

(* This version keeps a cache of starting positions of the string in the buffer modulo 61.
 After 61 misses, it fills the buffer at exponential speed. Unfortunately, it is useless
 as the speed-up for the short computation time is neglectible.

let make_repeat_fasta2 id desc src n =
  Buffer.clear ();
  add_header id desc;
  let cache = Array.create 61 None in
  let len_src = String.length src in

  let rec iter i n =
    if i < n then
      let x = i mod 61 in
	match cache.(x) with
	    Some pos ->
(*	      Printf.fprintf stderr "Hit at %d (%d)\n%!" i x; *)
	      let len = Buffer.length () - pos in
(*		Printf.fprintf stderr "copy %d\n%!" len; *)
	      let len = if len > n-i then n-i else len in
		Buffer.add_copy pos len;
		iter (i+len) n
	  | None ->
(*	      Printf.fprintf stderr "Miss at %d (%d)\n%!" i x; *)
	      cache.(x) <- Some (Buffer.length ());
	      let len = if len_src > n-i then n-i else len_src in
	      iter2 0 len i x

  and iter2 j len i imod =
    if j < len then
      if imod = 60 then begin
	Buffer.add_char '\n';
	iter2 j len (i+1) 0
      end else begin
	Buffer.add_char src.[j];
	iter2 (j+1) len (i+1) (imod+1)
      end
    else
      iter i n
  in
  let n = n + (n / 60) in
    iter 0 n;
    if n mod 61 <> 0 then
      Buffer.add_char '\n'
*)

let make_repeat_fasta id desc src n =
  make_repeat_fasta1 id desc src n;
(*    make_repeat_fasta2 id desc src n; *)
    ()

let main n =
      Spawner.spawn true (fun _ ->
			  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
			  ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
      Spawner.spawn true (fun _ -> ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5);
      Spawner.spawn false (fun _ -> ()) Buffer.print;
      Buffer.clear ();

end


let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  if arch64 then
    IMPLEMENTATION64.main n
  else
    IMPLEMENTATION32.main n
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez

 * modified by Fabrice Le Fessant (submitted as Ocaml #4)
    * speedup from 16.65sec to 4.31sec on x64
    * distinct implementation on 32bits and 64bits
    * cache of random generator
    * parallelization

 * modified by Fabrice Le Fessant
    * use chunks for random too
 *)

let arch64 =
  match Sys.word_size with
      32 -> false
    | 64 -> true
    | _ -> assert false

module Spawner : sig

  val spawn : bool -> (unit -> unit) -> (unit -> unit) -> unit

 end = struct

let inbuf = String.create 1

let wait_for = ref None
let spawn spawn prelude postlude =
  begin
  end;
  if spawn then begin
    let (ix, ox) = Unix.pipe () in
      match Unix.fork () with
	  -1 -> assert false
	| 0 ->
	    prelude ();
	    begin
	      match !wait_for with
		  None -> ()
		| Some ix ->
		    ignore (Unix.read ix inbuf 0 1)
	    end;
	    postlude ();
	    ignore (Unix.write ox "X" 0 1);
	    Unix.close ox;
	    exit 0
	| _ ->
	    wait_for := Some ix;
  end else begin
    prelude ();
    begin
      match !wait_for with
	  None -> ()
	| Some ix ->
	    ignore (Unix.read ix inbuf 0 1);
    end;
    postlude ();
  end


end

let alu = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

let iub = [| ('a', 0.27);  ('c', 0.12);  ('g', 0.12);  ('t', 0.27);
	     ('B', 0.02);  ('D', 0.02);  ('H', 0.02);  ('K', 0.02);
	     ('M', 0.02);  ('N', 0.02);  ('R', 0.02);  ('S', 0.02);
	     ('V', 0.02);  ('W', 0.02);  ('Y', 0.02);  |]

let homosapiens = [| ('a', 0.3029549426680);    ('c', 0.1979883004921);
		     ('g', 0.1975473066391);    ('t', 0.3015094502008);  |]

(* Random number generator *)
let im = 139968
and ia = 3877
and ic = 29573

let last = ref 42 and im_f = float im


let cache =
  let im = 139968
  and ia = 3877
  and ic = 29573 in
  Array.init im  (fun i ->  (i * ia + ic) mod im)

let gen_random  () =
  let n = cache.(!last) in
    last := n;
    n

module Cumul_tbl : sig
   val make : (char * float) array -> string * int array
end =
struct
  type t = { probs : float array;
	     chars : char array;
	     cache : char array; }

(* Dichotomy is actually slower than linear search on small tables. *)
  let find t p =
    let ps = t.probs in
    let i = ref 0 in
      while p >= ps.(!i) do incr i done;
      !i

  let rand_char t =
    let n = gen_random () in
    let c =  t.cache.(n) in
      if c = '\000' then
	let p = 1. *. float n /. im_f in
	let i = find t p in
	  let c = t.chars.(i) in
	    t.cache.(n) <- c;
	    c
      else
	c

  let rand_char2 t =
    let n = gen_random () in
    let c =  t.cache.(n) in
      if c = '\000' then
	let p = 1. *. float n /. im_f in
	let i = find t p in
	  let c = t.chars.(i) in
	    t.cache.(n) <- c;
	    (c,n)
      else
	(c,n)


  let make a =
    let len = Array.length a in
    let chars = Array.create len 'x' in
    let probs = Array.create len 0. in
    let p = ref 0.0 in
      for i = 0 to len-1 do
	let (c, p1) = a.(i) in
	  chars.(i) <- c;
	  let p0 = !p +. p1 in
	    p := p0;
	    probs.(i) <- p0
      done;
      let t =
	{
	  probs = probs;
	  chars = chars;
	  cache = Array.create im '\000';
	}
      in
      let s = String.create im in
      let ns = Array.create im 0 in
	for i = 0 to im-1 do
	  let (c,n) = rand_char2 t in
	    s.[i] <- c;
	    ns.(i) <- n
	done;
	(s, ns)

end

let width = 60

module IMPLEMENTATION32 = struct

module Buffer : sig

  val add_substring : string -> int -> int -> unit
  val add_string : string -> unit
  val add_char : char -> unit

  val clear : unit -> unit
  val print : unit -> unit

end = struct

  let buffer_len = 1_000_000
  let buffers = Array.init 150 (fun _ -> String.create buffer_len)
  let nbuffer = ref 0
  let buffer_pos = ref 0
  let current_buffer = ref buffers.(0)

  let add_substring s pos len =
    let rem = buffer_len - !buffer_pos in
      if rem >= len then begin
	String.blit s pos !current_buffer !buffer_pos len;
	buffer_pos := !buffer_pos + len
      end else
	if rem = 0 then begin
	  incr nbuffer;
	  current_buffer := buffers.(!nbuffer);
	    String.blit s pos !current_buffer 0 len;
	    buffer_pos := len;
	end else begin
	  String.blit s pos !current_buffer !buffer_pos rem;
	  incr nbuffer;
	  current_buffer := buffers.(!nbuffer);
	  let len2 = len - rem in
	    String.blit s (pos+rem) !current_buffer 0 len2;
	    buffer_pos := len2;
	end

  let add_string s =
    add_substring s 0 (String.length s)

  let add_char c =
    if !buffer_pos < buffer_len then begin
       !current_buffer.[!buffer_pos] <- c;
      incr buffer_pos
    end else begin
      incr nbuffer;
      current_buffer := buffers.(!nbuffer);
      !current_buffer.[0] <- c;
      buffer_pos := 1;
    end

  let clear () =
    buffer_pos := 0;
    nbuffer := 0;
    current_buffer := buffers.(0)

  let print () =
    let rec iter buffer i len =
      if len > 0 then begin
	let nw = Unix.write Unix.stdout buffer i  len in
	  iter buffer (i+nw) (len-nw)
      end
    in
      for i = 0 to !nbuffer - 1 do
	iter buffers.(i) 0 buffer_len
      done;
      iter buffers.(!nbuffer) 0 !buffer_pos;
      clear ()

end

let add_header id desc =
  Buffer.add_char '>';
  Buffer.add_string id;
  Buffer.add_char ' ';
  Buffer.add_string desc;
  Buffer.add_char '\n'


let make_random_fasta id desc table n =
  add_header id desc;
  let (s, ns) = Cumul_tbl.make table in
  let curpos = ref 0 in
  let write_cached width =
    let maxlen = im - !curpos in
      if maxlen >= width then begin
	Buffer.add_substring s !curpos width;
	curpos := !curpos + width
      end else begin
	Buffer.add_substring s !curpos maxlen;
	let rem = width - maxlen in
	Buffer.add_substring s 0 rem;
	curpos := rem;
      end
  in
  for i = 1 to n / width do
    write_cached width;
    Buffer.add_char '\n'
  done;
  let w = n mod width in
  if w > 0 then begin
    write_cached w;
    Buffer.add_char '\n'
  end;
    if !curpos = 0 then curpos := im;
    last := ns.(!curpos-1)


(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then begin
    Buffer.add_substring s i0 w;
    Buffer.add_char '\n'; i0 + w
  end
  else begin
    Buffer.add_substring s i0 len;
    write s 0 l (w - len);
  end

let make_repeat_fasta id desc src n =
  add_header id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)


(* This version keeps a cache of starting positions of the string in the buffer modulo 61.
 After 61 misses, it fills the buffer at exponential speed. Unfortunately, it is useless
 as the speed-up for the short computation time is neglectible.
*)

(*
let make_repeat_fasta2 id desc src n =
  Buffer.clear ();
  add_header id desc;
  let cache = Array.create 61 None in
  let len_src = String.length src in

  let rec iter i n =
    if i < n then
      let x = i mod 61 in
	match cache.(x) with
	    Some pos ->
(*	      Printf.fprintf stderr "Hit at %d (%d)\n%!" i x; *)
	      let len = Buffer.length () - pos in
(*		Printf.fprintf stderr "copy %d\n%!" len; *)
	      let len = if len > n-i then n-i else len in
		Buffer.add_copy pos len;
		iter (i+len) n
	  | None ->
(*	      Printf.fprintf stderr "Miss at %d (%d)\n%!" i x; *)
	      cache.(x) <- Some (Buffer.length ());
	      let len = if len_src > n-i then n-i else len_src in
	      iter2 0 len i x

  and iter2 j len i imod =
    if j < len then
      if imod = 60 then begin
	Buffer.add_char '\n';
	iter2 j len (i+1) 0
      end else begin
	Buffer.add_char src.[j];
	iter2 (j+1) len (i+1) (imod+1)
      end
    else
      iter i n
  in
  let n = n + (n / 60) in
    iter 0 n;
    if n mod 61 <> 0 then
      Buffer.add_char '\n'
*)

let main n =
      Spawner.spawn true (fun _ ->
			  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
			  ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
      Spawner.spawn true (fun _ -> ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5);
      Spawner.spawn false (fun _ -> ()) Buffer.print;
      Buffer.clear ();


end

module IMPLEMENTATION64 = struct

module Buffer : sig

  val add_substring : string -> int -> int -> unit
  val add_string : string -> unit
  val add_char : char -> unit
  val add_copy : int -> int -> unit

  val length : unit -> int

  val clear : unit -> unit
  val print : unit -> unit

  val check_char : char -> unit
  val check_copy : int -> int -> unit


end = struct

  let buffer_len = if arch64 then 150_000_000 else 1
  let buffer = String.create buffer_len
  let buffer_pos = ref 0

  let length () = !buffer_pos

  let add_substring s pos len =
    String.blit s pos buffer !buffer_pos len;
    buffer_pos := !buffer_pos + len

  let add_string s =
    add_substring s 0 (String.length s)

  let add_char c =
    buffer.[!buffer_pos] <- c;
    incr buffer_pos

  let check_char c =
    if buffer.[!buffer_pos] <> c then begin
      Printf.fprintf stderr "check_char [%d]\n%!" !buffer_pos;
      exit 2;
    end;
    incr buffer_pos

  let clear () = buffer_pos := 0

  let print () =
    let rec iter i len =
      if len > 0 then begin
	let nw = Unix.write Unix.stdout buffer i  len in
	  iter (i+nw) (len-nw)
      end

    in
      iter 0 !buffer_pos;
      buffer_pos := 0

  let add_copy src len =
    add_substring buffer src len

  let rec check_copy src len =
    if len > 0 then begin
      assert (buffer.[src] = buffer.[!buffer_pos]);
      incr buffer_pos;
      check_copy (src+1) (len-1);
    end

end

let add_header id desc =
  Buffer.add_char '>';
  Buffer.add_string id;
  Buffer.add_char ' ';
  Buffer.add_string desc;
  Buffer.add_char '\n'



let make_random_fasta id desc table n =
(*  Printf.fprintf stderr "make_random_fasta BEGIN: last = %d\n%!" !last; *)
  add_header id desc;
  let (s, ns) = Cumul_tbl.make table in
  let curpos = ref 0 in
  let write_cached width =
(*
    if !curpos > 0 then
    Printf.fprintf stderr "last[%d] = {%d}%d{%d}\n%!" !curpos ns.(!curpos-1) ns.(!curpos) ns.(!curpos+1);
*)
    let maxlen = im - !curpos in
      if maxlen >= width then begin
	Buffer.add_substring s !curpos width;
	curpos := !curpos + width
      end else begin
	Buffer.add_substring s !curpos maxlen;
	let rem = width - maxlen in
	Buffer.add_substring s 0 rem;
	curpos := rem;
      end
  in
  for i = 1 to n / width do
    write_cached width;
    Buffer.add_char '\n'
  done;
  let w = n mod width in
  if w > 0 then begin
    write_cached w;
    Buffer.add_char '\n'
  end;
    if !curpos = 0 then curpos := im;
    last := ns.(!curpos-1);
(*    Printf.fprintf stderr "make_random_fasta END: last = %d\n%!" !last; *)
    ()

(*
let make_random_fasta id desc table n =
  add_header id desc;
  let table = Cumul_tbl.make table in
  for i = 1 to n / width do
    for j = 0 to width-1 do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  done;
  let w = n mod width in
  if w > 0 then (
    for j = 1 to w do Buffer.add_char(Cumul_tbl.rand_char table); done;
    Buffer.add_char '\n'
  )
*)


(* [write s i0 l w] outputs [w] chars of [s.[0 .. l]], followed by a
   newline, starting with [s.[i0]] and considering the substring [s.[0
   .. l]] as a "circle".
   One assumes [0 <= i0 <= l <= String.length s].
   @return [i0] needed for subsequent writes.  *)
let rec write s i0 l w =
  let len = l - i0 in
  if w <= len then begin
    Buffer.add_substring s i0 w;
    Buffer.add_char '\n'; i0 + w
  end
  else begin
    Buffer.add_substring s i0 len;
    write s 0 l (w - len);
  end


let make_repeat_fasta1 id desc src n =
  add_header id desc;
  let l = String.length src
  and i0 = ref 0 in
  for i = 1 to n / width do
    i0 := write src !i0 l width;
  done;
  let w = n mod width in
  if w > 0 then ignore(write src !i0 l w)

(* This version keeps a cache of starting positions of the string in the buffer modulo 61.
 After 61 misses, it fills the buffer at exponential speed. Unfortunately, it is useless
 as the speed-up for the short computation time is neglectible.

let make_repeat_fasta2 id desc src n =
  Buffer.clear ();
  add_header id desc;
  let cache = Array.create 61 None in
  let len_src = String.length src in

  let rec iter i n =
    if i < n then
      let x = i mod 61 in
	match cache.(x) with
	    Some pos ->
(*	      Printf.fprintf stderr "Hit at %d (%d)\n%!" i x; *)
	      let len = Buffer.length () - pos in
(*		Printf.fprintf stderr "copy %d\n%!" len; *)
	      let len = if len > n-i then n-i else len in
		Buffer.add_copy pos len;
		iter (i+len) n
	  | None ->
(*	      Printf.fprintf stderr "Miss at %d (%d)\n%!" i x; *)
	      cache.(x) <- Some (Buffer.length ());
	      let len = if len_src > n-i then n-i else len_src in
	      iter2 0 len i x

  and iter2 j len i imod =
    if j < len then
      if imod = 60 then begin
	Buffer.add_char '\n';
	iter2 j len (i+1) 0
      end else begin
	Buffer.add_char src.[j];
	iter2 (j+1) len (i+1) (imod+1)
      end
    else
      iter i n
  in
  let n = n + (n / 60) in
    iter 0 n;
    if n mod 61 <> 0 then
      Buffer.add_char '\n'
*)

let make_repeat_fasta id desc src n =
  make_repeat_fasta1 id desc src n;
(*    make_repeat_fasta2 id desc src n; *)
    ()

let main n =
      Spawner.spawn true (fun _ ->
			  make_repeat_fasta "ONE" "Homo sapiens alu" alu (n*2);
			  ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "TWO" "IUB ambiguity codes" iub (n*3);
      Spawner.spawn true (fun _ -> ()) Buffer.print;
      Buffer.clear ();
      make_random_fasta "THREE" "Homo sapiens frequency" homosapiens (n*5);
      Spawner.spawn false (fun _ -> ()) Buffer.print;
      Buffer.clear ();

end

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  if arch64 then
    IMPLEMENTATION64.main n
  else
    IMPLEMENTATION32.main n
(* from: Benedikt Rosenau
 * Computation of Fibonacci numbers as presented by Pettorossi and
 * Proietti. Adapted to arbitrary precision arithmetic from code 
 * provided by Markus Mottl.
 *
 * Compile it with ocamlopt nums.cmxa fibo.ml
 *)

open Num

let zero = num_of_int 0
let one = num_of_int 1
let two = num_of_int 2

let rec fibo_aux n =
  if n =/ zero then one, zero
  else if n =/ one then zero, one
  else
    let k = quo_num n two in
    let a, b = fibo_aux k in
    let aa = a */ a
    and bb = b */ b
    and ab2 = two */a */ b in
    let ab2bb = ab2 +/ bb in
    if two */ k =/ n then aa +/ bb, ab2bb
    else ab2bb, ab2bb +/ aa +/ bb

let fibo n =
  if n <=/ one then one
  else
    let k = quo_num n two in
    let a, b = fibo_aux k in
    let ab = a +/ b in
    if two */ k =/ n then ab */ ab +/ b */ b
    else ab */ ab +/ two */ b */ ab;;

let n =
  try int_of_string Sys.argv.(1)
  with Invalid_argument _ -> 1000 in
let n = num_of_int n in
print_endline (string_of_num (fibo n))
(*
 * $Id: fibo.ocaml-3.ocaml,v 1.1 2004-11-10 06:28:00 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * from Tom Burt
 *)

let rec fib1 a b n =
   if n < 2 then a
   else fib1 (a + b) a (n - 1)

let fib n = fib1 1 1 n

let _ =
  let n =
    try int_of_string Sys.argv.(1)
    with Invalid_argument _ -> 1 in
  Printf.printf "%d\n" (fib n)
(*
 * $Id: fibo.ocaml,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
 * http://shootout.alioth.debian.org/
 *
 * Revised per the Lisp versions, by Dan Weber
 * Revised back by Brent to match specification of problem.
 *)

let rec fib n =
   if n < 2 then 1 else fib (n - 2) + fib (n - 1);;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
Printf.printf "%d\n" (fib n)

(* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Will M. Farr
 * Tweaked by Jon Harrop
 *)

let sum_harmonic4 n =
  let sum = ref 1.0 and ifloat = ref 2.0 in
  for i = 2 to n do
    sum := !sum +. 1.0 /. !ifloat;
    ifloat := !ifloat +. 1.0
  done;
  !sum

let () = Printf.printf "%0.9f\n" (sum_harmonic4 (int_of_string (Sys.argv.(1))))
(*
 * $Id: hash.ocaml,v 1.1 2004-05-19 18:09:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let hexdigits =  [| '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9';
                    'a'; 'b'; 'c'; 'd'; 'e'; 'f'; |]

let buf = String.create 32

let rec hexstring_of_int idx len = function
  | n when n <= 0 -> String.sub buf idx len
  | n ->
      let new_idx = idx - 1 in
      buf.[new_idx] <- hexdigits.(n land 15);
      hexstring_of_int new_idx (len + 1) (n lsr 4);;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
let hx = Hashtbl.create n and c = ref 0 in
for i = 1 to n do Hashtbl.add hx (hexstring_of_int 32 0 i) true done;
for i = n downto 1 do if Hashtbl.mem hx (string_of_int i) then incr c done;
Printf.printf "%d\n" !c
(*
 * $Id: hash2.ocaml,v 1.1 2004-05-19 18:10:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
and hash1 = Hashtbl.create 10000 and hash2 = Hashtbl.create 10000 in
let update_hash2 k v =
  try let valref = Hashtbl.find hash2 k in valref := !valref + !v
  with Not_found -> Hashtbl.add hash2 k (ref !v) in
for i = 0 to 9999 do Hashtbl.add hash1 ("foo_" ^ string_of_int i) (ref i) done;
for i = 1 to n do Hashtbl.iter update_hash2 hash1 done;
Printf.printf "%d %d %d %d\n"
  !(Hashtbl.find hash1 "foo_1") !(Hashtbl.find hash1 "foo_9999")
  !(Hashtbl.find hash2 "foo_1") !(Hashtbl.find hash2 "foo_9999")
(* health.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * $Id: health.ocaml,v 1.9 2005-05-23 07:46:49 chris00-guest Exp $
 *)

(* Adjust GC behavior *)
let () = Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024 }

(* Mutable single linked lists.  Useful interface only. *)
(* module type Lsig =
sig
  type 'a t
  val make : unit -> 'a t
  val add : 'a -> 'a t -> unit
  val iter : ('a -> unit) -> 'a t -> unit
  val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a
  val filter : ('a -> bool) -> 'a t -> unit  (** filter in place *)
  val clear_and_copy : 'a t -> 'a t
   (** [clear_and_copy l] clears [l] and return a copy of it. *)
end *)
module L (* : Lsig *) =
struct
  (* The standard solution is to define a special termination "symbol"
     for the list, e.g. [None] as in

     type 'a list = 'a node option
     and 'a node = { data : 'a; mutable next : 'a list }

     but that introduce an additional indirection, so here we use
     a "last node" and physical equality to avoid it. *)
  type 'a t = { mutable first : 'a list;  mutable last : 'a list }
  and 'a list = { mutable data : 'a;  mutable next : 'a list }

  let make () =
    let rec node = { data = Obj.magic 0;  next = node } in
    { first = node;  last = node }

  (* The element [e] must be added to the end of [l]. *)
  let add e l =
    l.last.data <- e;
    let rec node = { data = Obj.magic 0;  next = node } in
    l.last.next <- node;
    l.last <- node


  let rec iter_node f node last =
    if node != last then (f node.data; iter_node f node.next last)
  let iter f l = iter_node f l.first l.last

  let rec fold_node f a node last =
    if node == last then a else fold_node f (f a node.data) node.next last
  let fold_left f a l = fold_node f a l.first l.last


  let rec keep_node f node0 last =
    let node = node0.next in
    if node != last (* otherwise: nothing to do *) then
      if f node.data then keep_node f node last (* keep node *)
      else skip_node f node0 node.next last
  and skip_node f node0 node last =
    if node == last then node0.next <- last (* close the modified list *)
    else if f node.data then (node0.next <- node; keep_node f node last)
    else skip_node f node0 node.next last

  let rec filter_1st f l node =
    if node == l.last then l.first <- l.last (* none selected, empty list *)
    else if f node.data then (l.first <- node; keep_node f node l.last)
    else filter_1st f l node.next (* skip node *)

  let filter f l = filter_1st f l l.first

  let clear_and_copy l =
    let node0 = l.first and node1 = l.last in
    let rec node = { data = Obj.magic 0;  next = node } in
    l.first <- node; l.last <- node;
    { first = node0;  last = node1 }
end


type patient = {
  mutable remaining_time : int;
  mutable hospital_time : int;
  mutable hospital_visits : int;
}


let patient_stay p s =
  p.remaining_time <- s;  p.hospital_time <- p.hospital_time + s

type totals = int * int * int (* patients, hospital time, hospital visits *)

let add_patient (n, t, v) p =
  (n + 1, t + p.hospital_time, v + p.hospital_visits)

let ( ++ ) (n0, t0, v0) (n1, t1, v1) = (n0 + n1, t0 + t1, v0 + v1)


module Hospital =
struct
  (* Hospital.t is mutable *)
  type t = {
    triage : patient L.t;
    examination : patient L.t;
    treatement : patient L.t;
    mutable discharged : totals;

    mutable available_staff : int;
    mutable seed : int;
    has_no_regional_hospital : bool; (* i.e. "top" one *)
    transfers : patient L.t;
  }

  (* Shootout random generator, but with hospital seed *)
  let im = 139968 and ia = 3877 and ic = 29573
  let inv_im = 1. /. float im

  let random h max =
    h.seed <- (h.seed * ia + ic) mod im;
    max *. float h.seed *. inv_im

  let make has_no_regional_hospital level seed =
    { triage = L.make();  examination = L.make();  treatement = L.make();
      discharged = (0,0,0);  available_staff = 1 lsl (level - 1);
      seed = seed;  has_no_regional_hospital = has_no_regional_hospital;
      transfers = L.make(); }

  let totals h =
    let tot = L.fold_left add_patient (0,0,0) h.triage in
    let tot = L.fold_left add_patient tot h.examination in
    let tot = L.fold_left add_patient tot h.treatement in
    tot ++ h.discharged

  let new_arrival h p =
    p.hospital_visits <- p.hospital_visits + 1;
    if h.available_staff > 0 then (
      h.available_staff <- h.available_staff - 1;
      L.add p h.examination;
      patient_stay p 3
    )
    else L.add p h.triage

  let discharge_patients h =
    let treat p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	h.available_staff <- h.available_staff + 1;
	h.discharged <- add_patient h.discharged p;
	false
      ) in
    L.filter treat h.treatement

  let treat_or_transfer_patients h =
    let examine p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	if random h 1.0 > 0.1 || h.has_no_regional_hospital then (
	  (* Treat patient -- no transfer *)
	  L.add p h.treatement;
	  patient_stay p 10;
	)
	else (
	  (* Transfer to regional hospital *)
	  h.available_staff <- h.available_staff + 1;
	  L.add p h.transfers;
	);
	false
      ) in
    L.filter examine h.examination

  let triage_patients h =
    let triage p =
      if h.available_staff > 0 then (
	h.available_staff <- h.available_staff - 1;
	L.add p h.examination;
	patient_stay p 3;
	false
      )
      else (p.hospital_time <- p.hospital_time + 1;  true) in
    L.filter triage h.triage

  let triage_examination_treatment h =
    discharge_patients h;
    treat_or_transfer_patients h;
    triage_patients h;
    if random h 1.0 > 0.7 then new_arrival h {
      remaining_time = 0; hospital_time = 0; hospital_visits = 0 }
end


(* Hierarchical health care: a region consisting of a hospital and
   (possibly) some districts. *)
type health_care = Region of Hospital.t * (health_care array)

let levels = 5
let districts = 4

let rec create_health_care level seed1 seed2 =
  let create i = create_health_care (level - 1) (4 * seed1 + i + 1) seed2 in
  Region(Hospital.make (level = levels) level (seed1 * seed2),
	 Array.init (if level <= 1 then 0 else districts) create)

let rec transfer_patients (Region(h, districts)) =
  let transfer d =
    L.iter (fun p -> Hospital.new_arrival h p) (transfer_patients d) in
  Array.iter transfer districts;
  Hospital.triage_examination_treatment h;
  (* Return the transfer queue -- leaving the one of [h] empty. *)
  L.clear_and_copy h.Hospital.transfers

let rec accumulate_totals (Region(h, districts)) =
  Array.fold_left (fun tot d -> tot ++ accumulate_totals d) (0,0,0) districts
  ++ Hospital.totals h

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 100 in
  let Region(lh,_) as hc = create_health_care levels 0 42 in
  for i = 1 to n do ignore(transfer_patients hc) done;
  let (pat, time, visits) = accumulate_totals hc in
  Printf.printf "Patients: %i\nTime:     %i\nVisits:   %i\n" pat time visits;
  Printf.printf "\nTreatment Queue - Remaining Treatment Time\n";
  L.iter (fun p -> Printf.printf "%i\tanonymous patient\n" p.remaining_time)
    lh.Hospital.treatement
(*
 * $Id: heapsort.ocaml,v 1.1 2004-05-19 18:10:10 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let im = 139968 and ia = 3877 and ic = 29573 and last_ref = ref 42

let gen_random max =
  let new_last = (!last_ref * ia + ic) mod im in
  last_ref := new_last;
  max *. float_of_int new_last /. float im


let heapsort n ra =
  let l = ref ((n lsr 1) + 1)
  and rra = ref 0.0 and i = ref 0 and j = ref 0 and ir = ref n in
  try
    while true do
      if !l > 1 then begin
        decr l;
        rra := ra.(!l)
      end
      else begin
        rra := ra.(!ir);
        ra.(!ir) <- ra.(1);
        decr ir;
        if !ir = 1 then begin
          ra.(1) <- !rra;
          raise Exit
        end
      end;
      i := !l;
      j := !l lsl 1;
      while !j <= !ir do
        if !j < !ir && ra.(!j) < ra.(!j+1) then incr j;
        if !rra < ra.(!j) then begin
          ra.(!i) <- ra.(!j);
          i := !j;
          j := !j + !i
        end
        else j := !ir + 1;
      done;
      ra.(!i) <- !rra;
    done
  with Exit -> ()

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
let ary = Array.init (n + 1) (fun _ -> gen_random 1.0) in
heapsort n ary;
Printf.printf "%.10f\n" ary.(n)
(*
 * $Id: hello.ocaml,v 1.1 2004-05-19 18:10:16 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

print_endline "hello world"
(* implicitode.ml                                           -*-tuareg-*-
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Cleaned up and made more idiomatic by Christophe Troestler
 *)

module type SCALAR = sig
  type t
  val ( + ) : t -> t -> t
  val ( - ) : t -> t -> t
  val ( * ) : t -> t -> t
  val ( / ) : t -> t -> t
  val mk : int -> t
  val mf : float -> t
  val pr : t -> string
end

module FL64 : SCALAR = struct
  type t = float
  let ( + ) x y = x +. y
  let ( - ) x y = x -. y
  let ( * ) x y = x *. y
  let ( / ) x y = x /. y
  let mk = float
  let mf x = x
  let pr x = Printf.sprintf "%.12e" x
end

(* Low precision floating point type. *)
module FL : SCALAR = struct
  type t = float
  let pr x = Printf.sprintf "%.2e" x
  let mf x =
    if x = 0.0 then 0.0 else
      let k = truncate(log(abs_float x)) in
      let x' = exp(6. -. float k) in floor(x *. x' +. 0.5) /. x'
  let mk x = mf (float x)
  let ( + ) x y = mf (x +. y)
  let ( - ) x y = mf (x -. y)
  let ( * ) x y = mf (x *. y)
  let ( / ) x y = mf (x /. y)
end

(* Complex numbers on the field [F].  Overflow is not handled. *)
module C(F : SCALAR) = struct
  type t = { re: F.t; im: F.t }
  let mk a = { re = F.mk a;  im = F.mk 0 }
  let mf a = { re = F.mf a;  im = F.mk 0 }
  let mc a b = { re = a; im = b }
  let pr a = F.pr a.re ^ " " ^ F.pr a.im

  open F
  let ( + ) a b = { re = a.re + b.re;  im = a.im + b.im }
  and ( - ) a b = { re = a.re - b.re;  im = a.im - b.im }
  and ( * ) a b = { re = a.re * b.re - a.im * b.im;
		    im = a.re * b.im + a.im * b.re }
  and ( / ) a b =
    let mag = b.re * b.re + b.im * b.im in
    { re = (a.re * b.re + a.im * b.im) / mag;
      im = (a.im * b.re - a.re * b.im) / mag }
end

module Functions(F : SCALAR) = struct
  let f0 = F.mk 0 and f1 = F.mk 1 and f2 = F.mk 2 and f3 = F.mk 3
  let f5 = F.mk 5 and f6 = F.mk 6 and f7 = F.mk 7
  let sqr x = F.( * ) x x
  let rec ( ** ) x k =
    if k = 0 then f1
    else if k mod 2 = 0 then sqr(x**(k/2)) else F.( * ) x (x**(k-1))

  open F
  let rat x = ((f2 * x + f3 * x**2 + f7 * x**6 + f5 * x**11 + f1)
	       / (f5 * x - f6 * x**3 - f3 * x**7 + f2))

  (* Automatic differentiation type on the field [F]. *)
  module AD = struct
    type t = { x : F.t; dx : F.t }
    let mk i = { x = F.mk i; dx = f0 }
    let mf x = { x = F.mf x; dx = f0 }
    let pr a = pr a.x ^ " " ^ pr a.dx
    let vr y dy = { x = y; dx = dy }
    let ( + ) a b = { x = a.x + b.x;  dx = a.dx + b.dx }
    and ( - ) a b = { x = a.x - b.x;  dx = a.dx - b.dx }
    and ( * ) a b = { x = a.x * b.x;  dx = a.dx * b.x + a.x * b.dx }
    and ( / ) a b = { x = a.x/b.x; dx = (a.dx*b.x-a.x*b.dx)/(b.x*b.x) }

    let newton x0 n g =
      let x = ref x0 in
      for i = 1 to n do
	let v = g(vr !x f1) in
	x := F.(-) !x (F.(/) v.x v.dx)
      done; !x

    let trapezoid_method_rooter gad gf y0 t0 t1 =
      let vt1 = vr t1 f0
      and dt2 = vr (F.(/) (F.(-) t1 t0) f2) f0
      and vy0 = vr y0 f0
      and vg0 = vr (gf t0 y0) f0 in
      fun y1 -> (gad vt1 y1 + vg0) * dt2 + vy0 - y1

    let trapezoid_method t0 dt y0 gad gf numsteps =
      let y = ref y0 and t = ref t0 in
      for i = 1 to numsteps do
	y := newton !y 10 (trapezoid_method_rooter gad gf !y !t (F.(+) !t dt));
	t := F.(+) !t dt;
      done; !y
  end
end

module Integrate_functions(F : SCALAR) = struct
  module Funs = Functions(F)
  module AD = Funs.AD
  module ADFuns = Functions(AD)
  open F

  let sqrintegrandad t y = ADFuns.sqr y
  let sqrintegrandf t y = Funs.sqr y
  let ratintegrandad t y = AD.(-) (ADFuns.rat y) t
  let ratintegrandf t y = Funs.rat y -  t
  let integrate_functions x0 n =
    let integ f df = AD.trapezoid_method (mk 1) (mk 1 / mk n) x0 f df n in
    print_string ("i1 " ^ (pr (integ sqrintegrandad sqrintegrandf)) ^"\n");
    print_string ("i2 " ^ (pr (integ ratintegrandad ratintegrandf)) ^"\n")
  end

module Funs = Functions(FL64)
module AD = Funs.AD
module ADFuns = Functions(AD)

let mysqrt x = AD.(-) (ADFuns.sqr x) (AD.mk 2)
let () =
  let f1 = FL64.mk 1 in
  print_string("rational_taylor_series: " ^
		 (AD.pr (ADFuns.rat (AD.vr (FL64.mf 0.25) f1))) ^ "\n");
  print_string("newton-sqrt_2: " ^ (FL64.pr (AD.newton f1 10 mysqrt)) ^ "\n");
  print_string("newton-rat: " ^
		 (FL64.pr (AD.newton (FL64.mk (-1)) 6 ADFuns.rat)) ^ "\n")

let n = int_of_string(Array.get Sys.argv 1)
let pfl64 = FL64.mf 0.02
let pfl = FL.mf 0.02
module I1 = Integrate_functions(FL64)
module I2 = Integrate_functions(FL)
let () =
  I1.integrate_functions pfl64 (n*4);
  I2.integrate_functions pfl n

module CFL64 = C(FL64)
module CFL = C(FL)
module I3 = Integrate_functions(CFL64)
module I4 = Integrate_functions(CFL)
let () =
  I3.integrate_functions (CFL64.mc pfl64 pfl64) n;
  I4.integrate_functions (CFL.mc pfl pfl) n
(* knucleotide.ml
 *
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 *)

module S = struct
  type t = string

  let size = 0x40000

  let equal (s1:string) s2 = (s1 = s2)

  let hash s =
    let h = ref 0 in
    for i = 0 to String.length s - 1 do h := !h * 5 + Char.code s.[i] done;
    !h
end

module H = Hashtbl.Make(S)

(* [counts k dna] fills and return the hashtable [count] of
   k-nucleotide keys and count values for a particular reading-frame
   of length [k] of the string [dna].  Keys point to mutable values
   for speed (to avoid looking twice the same key to reinsert the
   value). *)
let count = H.create S.size
let counts k dna =
  H.clear count;
  let key = String.create k in
    for i = 0 to String.length dna - k do
      String.unsafe_blit dna i key 0 k;
      try incr(H.find count key) with Not_found -> H.add count (String.copy key) (ref 1)
    done;
    count

(* [write_frequencies k dna] writes the frequencies for a
   reading-frame of length [k] sorted by descending frequency and then
   ascending k-nucleotide key. *)
let compare_freq ((k1:string),(f1:float)) (k2, f2) =
  if f1 > f2 then -1 else if f1 < f2 then 1 else compare k1 k2

let write_frequencies k dna =
  let cnt = counts k dna in
  let tot = float(H.fold (fun _ n t -> !n + t) cnt 0) in
  let frq = H.fold (fun k n l -> (k, 100. *. float !n /. tot) :: l) cnt [] in
  let frq = List.sort compare_freq frq in
  List.iter (fun (k,f) -> Printf.printf "%s %.3f\n" k f) frq;
  print_string "\n"

let write_count seq dna =
  let cnt = counts (String.length seq) dna in
  Printf.printf "%d\t%s\n" (try !(H.find cnt seq) with Not_found -> 0) seq

(* Extract DNA sequence "THREE" from stdin *)
let dna_three =
  let is_not_three s = try String.sub s 0 6 <> ">THREE" with _ -> true in
  while is_not_three(input_line stdin) do () done;
  let buf = Buffer.create 1000 in
  (* Skip possible comment *)
  (try while true do
     let line = input_line stdin in
     if line.[0] <> ';' then
       (Buffer.add_string buf (String.uppercase line); raise Exit)
   done with _ -> ());
  (* Read the DNA sequence *)
  (try while true do
       let line = input_line stdin in
       if line.[0] = '>' then raise End_of_file;
       Buffer.add_string buf (String.uppercase line)
   done with End_of_file -> ());
  Buffer.contents buf

let () = Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 2048 }

let () =
  List.iter (fun i -> write_frequencies i dna_three) [1; 2];
  List.iter (fun k -> write_count k dna_three)
    ["GGT"; "GGTA"; "GGTATT"; "GGTATTTTAATT"; "GGTATTTTAATTTATAGT"]
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 *)

module C(S : sig
           val k : int
           val dna : string
         end) =
struct
  let dna, k = S.dna, S.k

  module K = struct
    type t = int
    let equal k1 k2 =
      let rec cmp n ka kb =
        if n = 0 then true
        else if dna.[ka] = dna.[kb] then cmp (n - 1) (ka + 1) (kb + 1)
        else false
      in cmp k k1 k2

    let hash n =
      let h = ref 0 in
        for i = n to n + k - 1 do h := !h * 5 + Char.code dna.[i] done;
        !h
  end

  let c = 0x40000
  include Hashtbl.Make(K)
  let h = create c

  let count () = 
    for i = 0 to String.length dna - k - 1 do
      try incr (find h i) with Not_found -> add h i (ref 1)
    done

  let compare_freq ((k1:string),(f1:float)) (k2, f2) =
    if f1 > f2 then -1 else if f1 < f2 then 1 else String.compare k1 k2

  let write_frequencies () =
    count ();
    let tot = float(fold (fun _ n t -> !n + t) h 0) in
    let frq =
      fold (fun off n l -> 
              (String.sub dna off k, 100. *. float !n /. tot) :: l) h [] in
    let frq = List.sort compare_freq frq in
      String.concat "" 
        (List.map (fun (k,f) -> Printf.sprintf "%s %.3f\n" k f) frq)

  let write_count seq =
    assert (String.length seq = k);
    count ();
    String.blit seq 0 dna 0 k;
    Printf.sprintf "%d\t%s" (try !(find h 0) with Not_found -> 0) seq
end

(* Extract DNA sequence "THREE" from stdin *)
let dna_three =
  let is_not_three s = try String.sub s 0 6 <> ">THREE" with _ -> true in
  while is_not_three(input_line stdin) do () done;
  let buf = Buffer.create 1000 in
  (* Skip possible comment *)
  (try while true do
     let line = input_line stdin in
     if line.[0] <> ';' then
       (Buffer.add_string buf (String.uppercase line); raise Exit)
   done with _ -> ());
  (* Read the DNA sequence *)
  (try while true do
       let line = input_line stdin in
       if line.[0] = '>' then raise End_of_file;
       Buffer.add_string buf (String.uppercase line)
   done with End_of_file -> ());
  Buffer.contents buf

let invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with `Res x -> x | `Exn e -> raise e

let parallelize f l =
  List.iter (fun g -> print_endline (g ())) (List.map (invoke f) l)

let () =
  parallelize
    (fun i -> 
       let module M = C(struct let k = i let dna = dna_three end) in
         M.write_frequencies ()) [1; 2];
  parallelize
    (fun k -> 
       let module M = C(struct let k = String.length k let dna = dna_three end) in
         M.write_count k)
    ["GGT"; "GGTA"; "GGTATT"; "GGTATTTTAATT"; "GGTATTTTAATTTATAGT"]
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Troestler Christophe
 * modified by Mauricio Fernandez
 * optimized by Fabrice Le Fessant
 *)

let tab = Array.create 256 0
let _ =
  tab.(Char.code 'A') <- 0;
  tab.(Char.code 'a') <- 0;
  tab.(Char.code 'T') <- 1;
  tab.(Char.code 't') <- 1;
  tab.(Char.code 'C') <- 2;
  tab.(Char.code 'c') <- 2;
  tab.(Char.code 'g') <- 3;
  tab.(Char.code 'G') <- 3

let uppercase line =
  let len = String.length line in
    for i = 0 to len- 1 do
      let c =  line.[i] in
	line.[i] <- Char.unsafe_chr tab.(Char.code c)
    done

    (* Extract DNA sequence "THREE" from stdin *)
    let dna =
      let is_not_three s = String.length s < 6 || String.sub s 0 6 <> ">THREE" in
	while is_not_three(input_line stdin) do () done;
	let buf = Buffer.create 130_000_000 in
	  (* Skip possible comment *)
	  (try
	     while true do
	       let line = input_line stdin in
		 if line.[0] <> ';' then begin
		   uppercase line;
		   Buffer.add_string buf line;
		   raise Exit
		 end
	     done with _ -> ());
	  (* Read the DNA sequence *)
	  (try while true do
	     let line = input_line stdin in
	       if line.[0] = '>' then raise End_of_file;
	       uppercase line;
	       Buffer.add_string buf line
	   done with End_of_file -> ());
	  Buffer.contents buf


    module K15 = struct
      type t = int
      let equal k1 k2 = k1 = k2
      let hash n = n
    end

    module K16 = struct
      type t = int * int
      let equal (a1,a2) (b1,b2) = a1 = b1 && a2 = b2
      let hash (a1, _) = a1
    end

    type entry = {
      mutable count : int;
    }

    let threshold15 =
      match Sys.word_size with
	  32 -> 15
	| 64 -> 31
	| _ -> assert false
    let threshold16 = threshold15 + 1

    let c = 0x40000-1
    module H15 = Hashtbl.Make(K15)
    module H16 = Hashtbl.Make(K16)
    let h15 = H15.create c
    let h16 = H16.create c

    let rec pack_word n k h =
      let b = Char.code dna.[n] in
      let h = h * 4 + b in
	if k > 1 then
	  pack_word (n+1) (k-1) h
	else h

    let pack15 k n =
      pack_word n k 0

    let pack16 k n =
      let h1 = pack_word n threshold15 0 in
      let h2 = pack_word (n+ threshold15) (k- threshold15) 0 in
	(h1, h2)

    let rec pack_word_in dna n k h =
      let b = dna.[n] in
      let b = tab.(Char.code b) in
      let h = h * 4 + b in
	if k > 1 then
	  pack_word_in dna (n+1) (k-1) h
	else h

    let pack_key15 seq =
      let k = String.length seq in
	pack_word_in seq 0 k 0

    let pack_key16 seq =
      let k = String.length seq in
      let h1 = pack_word_in seq 0 threshold15 0 in
      let h2 = pack_word_in seq threshold15 (k- threshold15) 0 in
	(h1, h2)

    let char = [| 'A'; 'T'; 'C'; 'G' |]

    let rec unpack h s pos k =
      let pos = pos - 1 in
	s.[pos] <- char.(h land 3);
	if k > 1 then
	  unpack (h lsr 2) s pos (k-1)

    let unpack15 k h1 =
      let s = String.create k in
	unpack h1 s k k;
	s

    let unpack16 k (h1, h2) =
      let s = String.create k in
	unpack h1 s threshold15 threshold15;
	unpack h2 s k (k- threshold15);
	s

    let count15 k =
      for i = 0 to String.length dna - k - 1 do
	let packed = pack15 k i in
	  try
	    let key = H15.find h15 packed in
	      key.count <- key.count + 1
	  with Not_found ->
	    H15.add h15 packed { count = 1 }
      done

    let count16 k =
      for i = 0 to String.length dna - k - 1 do
	let packed = pack16 k i in
	  try
	    let key = H16.find h16 packed in
	      key.count <- key.count + 1
	  with Not_found ->
	    H16.add h16 packed { count = 1 }
      done

    let count k =
      if k < threshold16 then count15 k else count16 k

    let compare_freq ((k1:string),(f1:float)) (k2, f2) =
      if f1 > f2 then -1 else if f1 < f2 then 1 else String.compare k1 k2

    let write_frequencies15 k =
      count15 k;
      let tot = float(H15.fold (fun _ n t -> n.count + t) h15 0) in
      let frq =
	H15.fold (fun h n l ->
		  (unpack15 k h, 100. *. float n.count /. tot) :: l) h15 [] in
      let frq = List.sort compare_freq frq in
	String.concat ""
	  (List.map (fun (k,f) -> Printf.sprintf "%s %.3f\n" k f) frq)

    let write_frequencies16 k =
      count16 k;
      let tot = float(H16.fold (fun _ n t -> n.count + t) h16 0) in
      let frq =
	H16.fold (fun h n l ->
		  (unpack16 k h, 100. *. float n.count /. tot) :: l) h16 [] in
      let frq = List.sort compare_freq frq in
	String.concat ""
	  (List.map (fun (k,f) -> Printf.sprintf "%s %.3f\n" k f) frq)

    let write_count15 k seq =
	count15 k;
	Printf.sprintf "%d\t%s" (try (H15.find h15 (pack_key15 seq)).count with Not_found -> 0) seq

    let write_count16 k seq =
	count16 k;
	Printf.sprintf "%d\t%s" (try (H16.find h16 (pack_key16 seq)).count with Not_found -> 0) seq

    let write_frequencies k =
	if k < threshold16 then write_frequencies15 k
	else write_frequencies16 k

    let write_count seq =
      let k = String.length seq in
	if k < threshold16 then write_count15 k seq
	else write_count16 k seq

    type t = Size of int | Dna of string

let invoke (f : t -> string) x : unit -> string =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (f x) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
	v

let parallelize f l =
  let list = List.map (invoke f) (List.rev l) in
  List.iter (fun g -> print_endline (g ())) (List.rev list)

let () =
  parallelize
    (fun i ->
       match i with
	   Size i ->
             write_frequencies i
	 | Dna k ->
             write_count k
    ) [Size 1;
       Size 2;
       Dna "GGT";
       Dna "GGTA";
       Dna "GGTATT";
       Dna "GGTATTTTAATT";
       Dna "GGTATTTTAATTTATAGT"]
(*
 * $Id: lists.ocaml,v 1.1 2004-05-19 18:10:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Benedict Rosenau
 * improved by Jean-Christophe Filliatre
 *)

module Deque = struct
  type t = { size: int; mutable first: int; mutable last: int; fld: int array }

  exception Empty
  exception Full

  let empty n =
    let n = max (succ n) 1 in
    { size = n; first = 0; last = 0; fld = Array.make n 0 }

  let iota n =
    let size = succ n in
    { size = size; first = 0; last = n; fld = Array.init size succ }

  let up n s = if n < 0 then n + s else n
  let down n s = if n >= s then n - s else n
  let one_up n s = if n == s - 1 then 0 else n + 1
  let one_down n s = if n == 0 then s - 1 else n - 1

  let length q = up (q.last - q.first) q.size

  let rec array_eq q1 off1 q2 off2 n =
    n == 0 ||
      q1.fld.(off1) == q2.fld.(off2) &&
      (array_eq q1 (one_up off1 q1.size) q2 (one_up off2 q2.size) (n - 1))

  let equal q1 q2 =
    let len1 = length q1 in
    len1 == length q2 && array_eq q1 q1.first q2 q2.first len1

  let nth q n =
    if n < 0 or n >= length q then failwith "nth";
    q.fld.(down (q.first + n) q.size)

  let push_back q elem =
    let last' = one_up q.last q.size in
    if last' == q.first then raise Full;
    q.fld.(q.last) <- elem;
    q.last <- last'

  let take_front q =
    if q.first == q.last then raise Empty;
    let old_first = q.first in
    q.first <- one_up q.first q.size;
    q.fld.(old_first)

  let take_back q =
    if q.first == q.last then raise Empty;
    let new_last = one_down q.last q.size in
    q.last <- new_last;
    q.fld.(new_last)

  let copy q =
    { size = q.size; first = q.first; last = q.last; fld = Array.copy q.fld }

  let reverse q =
    let w = length q in
    for i = 0 to (w lsr 1) - 1 do
      let i1 = down (q.first + i) q.size and i2 = up (q.last - 1 - i) q.size in
      let v1 = q.fld.(i1) in
      q.fld.(i1) <- q.fld.(i2);
      q.fld.(i2) <- v1
    done
end

let test_lists () =
  let size = 10000 in
  let d1 = Deque.iota size in
  let d2 = Deque.copy d1
  and d3 = Deque.empty size in
  for i = 1 to Deque.length d2 do Deque.push_back d3 (Deque.take_front d2) done;
  for i = 1 to Deque.length d3 do Deque.push_back d2 (Deque.take_back d3) done;
  Deque.reverse d1;
  if size <> Deque.nth d1 0 then failwith "First test failed";
  if Deque.length d1 <> Deque.length d2 then failwith "Second test failed";
  if not (Deque.equal d1 d2) then failwith "Third test failed";
  Deque.length d1

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
for i = 2 to n do ignore (test_lists ()) done;
Printf.printf "%d\n" (test_lists ())
(*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Paolo Ribeca
 *
 * (Very loosely based on previous version Ocaml #3,
 *  which had been contributed by
 *   Christophe TROESTLER
 *  and enhanced by
 *   Christian Szegedy and Yaron Minsky)
 *)

let niter = 50
let limit = 4.
let workers = 64

let worker w h_lo h_hi =
  let buf =
    String.create ((w / 8 + (if w mod 8 > 0 then 1 else 0)) * (h_hi - h_lo))
  and ptr = ref 0 in
  let fw = float w /. 2. in
  let fh = fw in
  let red_w = w - 1 and red_h_hi = h_hi - 1 and byte = ref 0 in
  for y = h_lo to red_h_hi do
    let ci = float y /. fh -. 1. in
    for x = 0 to red_w do
      let cr = float x /. fw -. 1.5
      and zr = ref 0. and zi = ref 0. and trmti = ref 0. and n = ref 0 in
      begin try
	while true do
	  zi := 2. *. !zr *. !zi +. ci;
	  zr := !trmti +. cr;
	  let tr = !zr *. !zr and ti = !zi *. !zi in
	  if tr +. ti > limit then begin
	    byte := !byte lsl 1;
	    raise Exit
	  end else if incr n; !n = niter then begin
	    byte := (!byte lsl 1) lor 0x01;
	    raise Exit
	  end else
	    trmti := tr -. ti
	done
      with Exit -> ()
      end;
      if x mod 8 = 7 then begin
	buf.[!ptr] <- (Char.chr !byte);
	incr ptr;
	byte := 0
      end
    done;
    let rem = w mod 8 in
    if rem != 0 then begin
      buf.[!ptr] <- (Char.chr (!byte lsl (8 - rem)));
      incr ptr;
      byte := 0
    end
  done;
  buf

let _ =
  let w = int_of_string (Array.get Sys.argv 1) in
  let rows = w / workers and rem = w mod workers in
  Printf.printf "P4\n%i %i\n%!" w w;
  let rec spawn i =
    if i > 0 then
      let red_i = i - 1 in
      match Unix.fork () with
      | 0 -> spawn red_i
      | pid ->
	  let buf =
	    worker w (red_i * rows + min red_i rem) (i * rows + min i rem) in
	  match Unix.waitpid [] pid with
	  | _, Unix.WEXITED 0 ->
	      Printf.printf "%s%!" buf;
	      exit 0
	  | _ -> assert false
    else
      exit 0 in
  spawn workers
(*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Paolo Ribeca
 *
 * (Very loosely based on previous version Ocaml #3,
 *  which had been contributed by
 *   Christophe TROESTLER
 *  and enhanced by
 *   Christian Szegedy and Yaron Minsky)
 *)

let niter = 50
let limit = 4.

let () =
  let w = int_of_string (Array.get Sys.argv 1) in
  let h = w in
  let fw = float w /. 2. and fh = float h /. 2. in
  Printf.printf "P4\n%i %i\n" w h;
  let red_h = h - 1 and red_w = w - 1 and byte = ref 0 in
  for y = 0 to red_h do
    let ci = float y /. fh -. 1. in
    for x = 0 to red_w do
      let cr = float x /. fw -. 1.5
      and zr = ref 0. and zi = ref 0. and trmti = ref 0. and n = ref 0 in
      begin try
	while true do
	  zi := 2. *. !zr *. !zi +. ci;
	  zr := !trmti +. cr;
	  let tr = !zr *. !zr and ti = !zi *. !zi in
	  if tr +. ti > limit then begin
	    byte := !byte lsl 1;
	    raise Exit
	  end else if incr n; !n = niter then begin
	    byte := (!byte lsl 1) lor 0x01;
	    raise Exit
	  end else
	    trmti := tr -. ti
	done
      with Exit -> ()
      end;
      if x mod 8 = 7 then output_byte stdout !byte
    done;
    let rem = w mod 8 in
    if rem != 0 then (* the row doesnt divide evenly by 8 *)
      output_byte stdout (!byte lsl (8 - rem)) (* output last few bits *)
  done
(*
 * $Id: matrix.ocaml,v 1.1 2004-05-19 18:10:34 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let mkmatrix rows cols =
  let count = ref 1 and last_col = cols - 1
  and m = Array.make_matrix rows cols 0 in
  for i = 0 to rows - 1 do
    let mi = m.(i) in
    for j = 0 to last_col do mi.(j) <- !count; incr count done;
  done;
  m

let rec inner_loop k v m1i m2 j =
  if k < 0 then v
  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j

let mmult rows cols m1 m2 m3 =
  let last_col = cols - 1 and last_row = rows - 1 in
  for i = 0 to last_row do
    let m1i = m1.(i) and m3i = m3.(i) in
    for j = 0 to last_col do m3i.(j) <- inner_loop last_row 0 m1i m2 j done;
  done

let size = 30
let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let m1 = mkmatrix size size and m2 = mkmatrix size size
let m3 = Array.make_matrix size size 0;;
for i = 2 to n do mmult size size m1 m2 m3 done;
mmult size size m1 m2 m3;
Printf.printf "%d %d %d %d\n" m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)
(* message.ml

   The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by Troestler Christophe
   Based on Scheme Chicken implementation
*)

(* Channel to communicate safely between threads (no buffering). *)
type channel = { write: Mutex.t; mutable v: int; read: Mutex.t }

let make () =
  let r = Mutex.create() in Mutex.lock r; { write=Mutex.create(); v=0; read=r }

let read ch = Mutex.lock ch.read; let v = ch.v in Mutex.unlock ch.write; v

let write ch v = Mutex.lock ch.write; ch.v <- v; Mutex.unlock ch.read

(* Looping utility *)
let rec repeat n f x = if n <= 0 then x else repeat (n-1) f (f x)


let make_node out_ch =
  let in_ch = make() in
  let node () = while true do write out_ch (1 + read in_ch) done in
  ignore(Thread.create node ()); in_ch

let () =
  let n = try int_of_string Sys.argv.(1) with _ -> 10 in
  let e = make() in let b = repeat 500 (* 380 ok *) make_node e in
  Printf.printf "%i\n" (repeat n (fun i -> write b 0; i + read e) 0)
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/
   Contributed by Vladimir Silyaev
*)

let last () =
  let v = ref 0 in
  let recv n =
    v := !v + n
  and get () =
    let r = !v in
    v := 0; r
  in
  recv,get

let worker next =
  let recv n =
    next (succ n) in
    recv

let rec repeat n f x = if n<=0 then x else repeat (pred n) f (f x)

let run threads times =
  let last,result = last () in
  let first = repeat threads worker  last in
  repeat times (fun n -> first 0; n + result ()) 0


let _ = 
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10 in
  print_int (run 500 n);print_newline()
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by Micky Latowicki
*)

module type CHANNEL = 
sig
  type 'a t
  val create : unit -> 'a t
  val send : 'a t -> 'a -> unit
  val receive : 'a t -> ('a -> unit) -> unit
end

module Channel : CHANNEL = 
struct
  type 'a t = {
    (* One of these queues is always empty. Sometimes both are. *)
    waiters : ('a->unit) Queue.t;
    values : 'a Queue.t
  }  

  let create () = { waiters = Queue.create (); 
                    values = Queue.create ()}

  let send {waiters=waiters; values=values} value = 
    if Queue.is_empty waiters then
      Queue.add value values
    else
      let waiter = Queue.take waiters in waiter value

  let receive {waiters=waiters; values=values} waiter = 
    if Queue.is_empty values then
      Queue.add waiter waiters 
    else
      let value = Queue.take values in waiter value
end

let rec repeat n f x = if n<=0 then x else repeat (pred n) f (f x)

let increamentor (input, output) =
  let rec loop () = Channel.receive input cont
  and cont x      = Channel.send output (x+1);
                    loop ()
  in loop 

let increamentor_chain n input0 = 
  let make_link input = 
    let output = Channel.create () in
      increamentor (input, output) ();
      output
  in repeat n make_link input0

let process first last n =
  let total       = ref 0 in
  let rec step () = Channel.send first 0;
                    Channel.receive last add
  and add x       = total := !total+x in
    repeat n step ();
    !total

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10
  and first_channel = Channel.create () in
  let last_channel  = increamentor_chain 500 first_channel in
  print_int(process first_channel last_channel n); print_newline()
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   Contributed by David Teller 
*)

(** Extremely light-weight threads, aka purely functional coroutines*)
type 'a coroutine =  'a * (unit -> 'a coroutine)  (**Intermediate result and continuation*)

(** Initialise the chain of coroutines, then start feeding 0s*)
let create_coroutine ~depth = 
  let rec aux = function                                             (*Main creation loop*)
    | 0 ->                       (*I'm the last one, I'll feed 0s, but only so many times*)
	let rec loop () = 
	  (0, fun () -> loop ())
	in
	  loop ()
    | n ->  
	let rec loop (r,co) =
	  ( (r + 1), fun () -> loop (co ()) ) 
	in loop (aux (n - 1))
  in
    aux depth

(** Listen for a given number of messages*)
let sum channel_end ~iterations =
  let rec aux total (r, co) = function
    | 0 -> total
    | n -> aux (total + r) ( co () ) (n - 1)
  in
    aux 0 channel_end  iterations

let () =
  let n  = try int_of_string(Array.get Sys.argv 1) with _ -> 10
  in
    print_int(sum ~iterations:n (create_coroutine ~depth:500));
    print_newline()
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Otto Bommer
*)

open Printf

let rec range i j = 
  if i<j then i::(range (i+1) j) 
  else if i=j then [i] else i::(range (i-1) j)
 
module Board = struct
let rows = 10
let cols = 5
let size = rows*cols
let empty = Char.chr(0xe)
let filled = Char.chr(0xf)

let create () = let s = String.create size in String.fill s 0 size empty; s
let copy b = String.copy b
let get b n = b.[n]
let set b n v = b.[n] <- v

let cset dst cells v = for i = 0 to 4 do set dst (Array.get cells i) v done
let cdel dst cells = for i = 0 to 4 do set dst (Array.get cells i) empty done

let compare s1 s2 = String.compare s1 s2

let find_empty b = try String.index b empty with _ -> size-1
let rotate a steps = (a+60*steps) mod 360
let flip a = (540-a) mod 360 

let print b =  List.iter (fun i -> 
    printf "%x " (Char.code (get b i)); 
    if (i+1) mod cols==0 then printf "\n"; 
    if (i+cols+1) mod (cols*2)==0 then printf " "
  ) (range 0 (size-1)); 
  printf "\n"

let invert b =
  let bflip = String.create size in
  for i = 0 to (size-1) do set bflip (size-1-i) (get b i) done;
  bflip

let dont_intersect b1 c =
  if get b1 (Array.get c 0) != empty then false
  else if get b1 (Array.get c 1) != empty then false
  else if get b1 (Array.get c 2) != empty then false
  else if get b1 (Array.get c 3) != empty then false
  else if get b1 (Array.get c 4) != empty then false
  else true

let shift idx a =
   match a with
    |   0 ->  idx-cols*2
    |  30 ->  idx-cols+(idx/cols) mod 2
    |  60 ->  idx-cols+1+(idx/cols) mod 2
    |  90 ->  idx+1
    | 120 ->  idx+cols+1+(idx/cols) mod 2 
    | 150 ->  idx+cols+(idx/cols) mod 2
    | 180 ->  idx+cols*2
    | 210 ->  idx+cols-1+(idx/cols) mod 2
    | 240 ->  idx+cols-2+(idx/cols) mod 2
    | 270 ->  idx-1
    | 300 ->  idx-cols-2+(idx/cols) mod 2
    | 330 ->  idx-cols-1+(idx/cols) mod 2
    |   _ ->  idx

let inside idx a =
  if idx >= 0 && idx < size then
  match a with
    |   0 ->  idx >= cols*2
    |  30 ->  idx mod (cols*2) != (cols*2-1) && idx >= cols
    |  60 ->  let i = idx mod (cols*2) in 
              i!=(cols-1) && i!=(cols*2-2) && i!=(cols*2-1) && idx>=cols
    |  90 ->  idx mod cols != (cols-1)
    | 120 ->  let i = idx mod (cols*2) in 
              i!=(cols-1) && i!=(cols*2-2) && i!=(cols*2-1) && idx<(size-cols)
    | 150 ->  idx mod (cols*2) != (cols*2-1) && idx<(size-cols)
    | 180 ->  idx < size-2*cols
    | 210 ->  idx mod (cols*2) != 0 && idx < (size-cols)
    | 240 ->  let i = idx mod (cols*2) in 
              i!=0 && i!=1 && i!=cols && idx < (size-cols)
    | 270 ->  idx mod 5 != 0
    | 300 ->  let i = idx mod (cols*2) in i!=0 && i!=1 && i!=cols && idx >= cols
    | 330 ->  idx mod (cols*2) != 0 && idx >= cols
    |   _ ->  false
  else false

let cell_peers = List.map (fun idx -> let peers = ref [] in
  List.iter (fun a -> if inside idx a then peers:=!peers @ [(shift idx a)]) 
  [30; 90; 150; 210; 270; 330]; !peers) (range 0 (size-1))

let rec fill_island b idx =
  let n = ref 0 in
  if (get b idx) == empty then begin set b idx filled; n:=!n+1 end;
  let peers = List.nth cell_peers idx in List.iter (fun i -> 
    if (get b i) == empty then begin set b i filled; n:=!n+1+fill_island b i end
  ) peers; !n

let is_fillable b pn =
  let i = find_empty b in
  let tmp = copy b in
  let s = fill_island tmp i in
  s mod 5 == 0
end

module Piece = struct
let defs = [
   [| 90;  90;  90; 150|];
   [|150;  90;  30;  90|];
   [| 90;  90; 150; 210|];
   [| 90;  90; 210; 150|];
   [|150;  90;  30; 180|];
   [| 90;  90; 210;  90|];
   [| 90; 150; 150;  30|];
   [| 90; 150; 150; 270|];
   [| 90; 150;  90;  90|];
   [| 90;  90;  90; 210|]
]

let count = List.length defs
let rotate p steps =  Array.map (fun j ->  Board.rotate j steps) p
let flip p =  Array.map (fun i ->  Board.flip i) p
end;;

module Cell = struct
let min cells =  Array.fold_left min Board.size cells

let from_piece p idx = 
  let a = Board.shift idx (Array.get p 0) in
  let b = Board.shift a (Array.get p 1) in
  let c = Board.shift b (Array.get p 2) in
  let d = Board.shift c (Array.get p 3) in
  [|idx; a; b; c; d|]

let fits_on_board cells p =
  Board.inside (Array.get cells 0) (Array.get p 0) &&
  Board.inside (Array.get cells 1) (Array.get p 1) &&
  Board.inside (Array.get cells 2) (Array.get p 2) &&
  Board.inside (Array.get cells 3) (Array.get p 3) &&
  (Array.get cells 4) >= 0 && (Array.get cells 4) < Board.size

let to_board cells pn = 
  let b = Board.create () in let chr = Char.chr pn in
  Board.set b (Array.get cells 0) chr;
  Board.set b (Array.get cells 1) chr;
  Board.set b (Array.get cells 2) chr;
  Board.set b (Array.get cells 3) chr;
  Board.set b (Array.get cells 4) chr;
  b
end;;

let permutations =
  let permutations = List.map (fun pn -> ref (List.map (fun l -> ref []) 
                       (range 0 (Board.size-1)))) (range 0 (Piece.count-1)) in
  let calc_piece_rotations pn idx =
    let calc_rots piece =
      let pieceperms = List.nth permutations pn in
      for i = 0 to 5 do
        if pn != 3 || i < 3 then
          let rotp = Piece.rotate piece i in
          let c = Cell.from_piece rotp idx in
          if Cell.fits_on_board c rotp then
            let pboard = Cell.to_board c pn in
            if Board.is_fillable pboard pn then
              let minimum = Cell.min c in
              let rotperms = List.nth !pieceperms minimum in
              rotperms := !rotperms @ [(rotp, pn, c, pboard)];
      done 
    in
    let p = List.nth Piece.defs pn in
    calc_rots p;
    calc_rots (Piece.flip p);
  in
  List.iter (fun pn -> List.iter (fun idx -> calc_piece_rotations pn idx) 
    (range 0 (Board.size-1))) (range 0 (Piece.count-1));
  permutations

module Solution = struct
exception Max_solutions
let rec solve max board solutions depth usedmask = 
  for ipn = 0 to Piece.count-1 do
    if usedmask land (1 lsl ipn) == 0 then 
      begin
      let emptycell = Board.find_empty board in
      let piece_perms = !(List.nth permutations ipn) in
      let cell_perms = !(List.nth piece_perms emptycell) in

      List.iter (fun perm ->
        let (p, pn, c, pboard) = perm in
        if Board.dont_intersect board c then
          begin
          Board.cset board c (Char.chr pn); 

          if depth == 9 then 
            begin
            solutions := !solutions @ [Board.copy board] @ [Board.invert board];
            if (List.length !solutions) >= max then raise Max_solutions
            end
          else
              solve max board solutions (depth+1) (usedmask lor (1 lsl pn));

          Board.cdel board c
          end 
        ) cell_perms
      end;
  done;
  if depth == 0 then raise Max_solutions

end
let _ = 
  let max = try int_of_string (Sys.argv.(1)) with _ -> 2100 in
  let solutions = ref [] in
  let board = Board.create () in
  try Solution.solve max board solutions 0 0 with _ -> ();
  let sorted_solutions = List.sort Board.compare !solutions in
  printf "%d solutions found\n\n" (List.length sorted_solutions); 

  if List.length sorted_solutions > 0 then
    begin
    Board.print (List.nth sorted_solutions 0);
    Board.print (List.nth sorted_solutions (List.length sorted_solutions - 1))
    end;

(*
 * $Id: methcall.ocaml,v 1.1 2004-05-19 18:10:41 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 * with contributions from Markus Mottl
 *)

class toggle start_state = object (self)
  val mutable state = start_state

  method value = state
  method activate = state <- not state; self
end

class nth_toggle start_state max_counter = object (self)
  inherit toggle start_state

  val count_max = max_counter
  val mutable counter = 0

  method activate =
    counter <- counter + 1;
    if counter >= count_max then begin state <- not state; counter <- 0 end;
    self
end

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let tog = new toggle true;;
for i = 2 to n do ignore tog#activate#value done;
Printf.printf "%b\n" tog#activate#value;
let ntog = new nth_toggle true 3 in
for i = 2 to n do ignore ntog#activate#value done;
Printf.printf "%b\n" ntog#activate#value
(* objinst.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * This version is similar to the one of languages without object features
 * (e.g. objinst.gcc, objinst.mlton).
 *)

type toggle = { mutable r : bool; a : toggle -> unit }
let new_toggle b = { r = b; a = (fun o -> o.r <- not(o.r)) }
let toggle_value o = o.r
let toggle_activate o = o.a o; o

type nth_toggle = { mutable r : bool; count_max : int; mutable counter : int;
		    a : nth_toggle -> unit }
let new_nth_toggle b m =
  let act o =
    o.counter <- o.counter + 1;
    if o.counter >= o.count_max then (o.r <- not o.r; o.counter <- 0) in
  { r = b; count_max = m; counter = 0; a = act }
let nth_toggle_value o = o.r
let nth_toggle_activate o = o.a o; o


let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1 in
  let tog = new_toggle true in
  for i = 2 to n do ignore(toggle_value(toggle_activate tog)) done;
  Printf.printf "%b\n" (toggle_value(toggle_activate tog));
  let ntog = new_nth_toggle true 3 in
  for i = 2 to n do ignore(nth_toggle_value(nth_toggle_activate ntog)) done;
  Printf.printf "%b\n" (nth_toggle_value(nth_toggle_activate ntog))
(*
 * $Id: moments.ocaml-2.ocaml,v 1.1 2004-11-10 07:07:16 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * with help from Markus Mottl
 *)

let _ =
  let n = ref 0
  and num = ref 0.0
  and sum = ref 0.0
  and mean = ref 0.0
  and average_deviation = ref 0.0
  and standard_deviation = ref 0.0
  and variance = ref 0.0
  and skew = ref 0.0
  and kurtosis = ref 0.0
  and deviation = ref 0.0
  and size = ref 4096 in
  let nums_in = ref (Array.create !size 0.0) in

  try
    while true do
      num := read_float ();
      !nums_in.(!n) <- !num;
      sum := !sum +. !num;
      incr n;
      if !n = !size then begin
	nums_in := Array.append !nums_in (Array.create !size 0.0);
	size := !size * 2
      end
    done
  with End_of_file -> ();

  let nums = Array.create !n 0.0 in
  Array.blit !nums_in 0 nums 0 !n;

  let n_float = float_of_int !n in
  mean := !sum /. n_float;

  for i = 0 to !n - 1 do
    deviation := nums.(i) -. !mean;
    average_deviation := !average_deviation +. abs_float !deviation;
    let dev2 = !deviation *. !deviation in
    variance := !variance +. dev2;
    let dev3 = dev2 *. !deviation in
    skew := !skew +. dev3;
    let dev4 = dev3 *. !deviation in
    kurtosis := !kurtosis +. dev4;
  done;

  average_deviation := !average_deviation /. n_float;
  variance := !variance /. float_of_int (!n - 1);
  standard_deviation := sqrt !variance;

  if !variance > 0.0 then begin
    skew := !skew /. n_float /. !variance /. !standard_deviation;
    kurtosis := !kurtosis /. n_float /. !variance /. !variance -. 3.0;
  end;

  Array.stable_sort compare nums;

  let mid = !n lsr 1 in

  let median =
    if !n mod 2 = 1 then nums.(mid)
    else (nums.(mid) +. nums.(mid - 1)) /. 2.0 in

  Printf.printf "n:                  %d\n" !n;
  Printf.printf "median:             %f\n" median;
  Printf.printf "mean:               %f\n" !mean;
  Printf.printf "average_deviation:  %f\n" !average_deviation;
  Printf.printf "standard_deviation: %f\n" !standard_deviation;
  Printf.printf "variance:           %f\n" !variance;
  Printf.printf "skew:               %f\n" !skew;
  Printf.printf "kurtosis:           %f\n" !kurtosis
(*
 * $Id: moments.ocaml2.ocaml,v 1.1 2004-05-19 18:10:50 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let _ =
  let n = ref 0
  and num = ref 0.0
  and sum = ref 0.0
  and mean = ref 0.0
  and average_deviation = ref 0.0
  and standard_deviation = ref 0.0
  and variance = ref 0.0
  and skew = ref 0.0
  and kurtosis = ref 0.0
  and deviation = ref 0.0
  and size = ref 4096 in
  let nums_in = ref (Array.create !size 0.0) in

  try
    while true do
      num := read_float ();
      !nums_in.(!n) <- !num;
      sum := !sum +. !num;
      incr n;
      if !n = !size then begin
	nums_in := Array.append !nums_in (Array.create !size 0.0);
	size := !size * 2
      end
    done
  with End_of_file -> ();

  let nums = Array.create !n 0.0 in
  Array.blit !nums_in 0 nums 0 !n;

  let n_float = float_of_int !n in
  mean := !sum /. n_float;

  for i = 0 to !n - 1 do
    deviation := nums.(i) -. !mean;
    average_deviation := !average_deviation +. abs_float !deviation;
    let dev2 = !deviation *. !deviation in
    variance := !variance +. dev2;
    let dev3 = dev2 *. !deviation in
    skew := !skew +. dev3;
    let dev4 = dev3 *. !deviation in
    kurtosis := !kurtosis +. dev4;
  done;

  average_deviation := !average_deviation /. n_float;
  variance := !variance /. float_of_int (!n - 1);
  standard_deviation := sqrt !variance;

  if !variance > 0.0 then begin
    skew := !skew /. n_float /. !variance /. !standard_deviation;
    kurtosis := !kurtosis /. n_float /. !variance /. !variance -. 3.0;
  end;

  Array.stable_sort compare nums;

  let mid = !n lsr 1 in

  let median =
    if !n mod 2 = 1 then nums.(mid)
    else (nums.(mid) +. nums.(mid - 1)) /. 2.0 in

  Printf.printf "n:                  %d\n" !n;
  Printf.printf "median:             %f\n" median;
  Printf.printf "mean:               %f\n" !mean;
  Printf.printf "average_deviation:  %f\n" !average_deviation;
  Printf.printf "standard_deviation: %f\n" !standard_deviation;
  Printf.printf "variance:           %f\n" !variance;
  Printf.printf "skew:               %f\n" !skew;
  Printf.printf "kurtosis:           %f\n" !kurtosis
(*
 * $Id: moments.ocaml,v 1.1 2004-05-19 18:10:48 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let cutoff = 5

(* Unscrupulously stolen from Array.stable_sort (OCaml standard distribution) *)
let sort_floats len (ar : float array) =
  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =
    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in
    let rec loop i1 s1 i2 s2 d =
      if s1 <= s2 then begin
        dst.(d) <- s1;
        let i1 = i1 + 1 in
        if i1 < src1r then loop i1 ar.(i1) i2 s2 (d + 1)
        else Array.blit src2 i2 dst (d + 1) (src2r - i2)
      end else begin
        dst.(d) <- s2;
        let i2 = i2 + 1 in
        if i2 < src2r then loop i1 s1 i2 src2.(i2) (d + 1)
        else Array.blit ar i1 dst (d + 1) (src1r - i1)
      end in
    loop src1ofs ar.(src1ofs) src2ofs src2.(src2ofs) dstofs in
  let isortto srcofs dst dstofs len =
    for i = 0 to len - 1 do
      let e = ar.(srcofs + i) and j = ref (dstofs + i - 1) in
      while !j >= dstofs && e <= dst.(!j) do
        dst.(!j + 1) <- dst.(!j);
        decr j;
      done;
      dst.(!j + 1) <- e
    done in
  let rec sortto srcofs dst dstofs len =
    if len <= cutoff then isortto srcofs dst dstofs len else begin
      let l1 = len / 2 in
      let l2 = len - l1 in
      sortto (srcofs + l1) dst (dstofs + l1) l2;
      sortto srcofs ar (srcofs + l2) l1;
      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs
    end in
  if len <= cutoff then isortto 0 ar 0 len else begin
    let l1 = len / 2 in
    let l2 = len - l1 in
    let t = Array.make l2 ar.(0) in
    sortto l1 t 0 l2;
    sortto 0 ar l2 l1;
    merge l2 l1 t 0 l2 ar 0
  end

let n_ref = ref 0 and sum_ref = ref 0.0 and size_ref = ref 4096
let nums_ref = ref (Array.create !size_ref 0.0);;

try
  while true do
    let num = float_of_string (input_line stdin) in
    !nums_ref.(!n_ref) <- num;
    sum_ref := !sum_ref +. num;
    incr n_ref;
    let size = !size_ref in
    if !n_ref = size then begin
      let new_size = size lsl 2 in
      size_ref := new_size;
      let new_ar = Array.create new_size 0.0 in
      Array.blit !nums_ref 0 new_ar 0 size;
      nums_ref := new_ar
    end
  done
with End_of_file -> ();

let n = !n_ref and nums = !nums_ref in
let n_float = float n in
let mean = !sum_ref /. n_float
and avg_dev_ref = ref 0.0 and std_dev_ref = ref 0.0 and var_ref = ref 0.0
and skew_ref = ref 0.0 and kurt_ref = ref 0.0 in

for i = 0 to n - 1 do
  let dev = nums.(i) -. mean in
  avg_dev_ref := !avg_dev_ref +. abs_float dev;
  let dev2 = dev *. dev in
  var_ref := !var_ref +. dev2;
  let dev3 = dev2 *. dev in
  skew_ref := !skew_ref +. dev3;
  kurt_ref := !kurt_ref +. dev3 *. dev
done;

let avg_dev = !avg_dev_ref /. n_float and var = !var_ref /. float (n - 1) in
let std_dev = sqrt var in

if var > 0.0 then begin
  skew_ref := !skew_ref /. n_float /. var /. std_dev;
  kurt_ref := !kurt_ref /. n_float /. var /. var -. 3.0
end;

sort_floats n nums;

let median =
  let mid = n lsr 1 in
  if n mod 2 = 1 then nums.(mid)
  else (nums.(mid) +. nums.(mid - 1)) /. 2.0 in

Printf.printf "n:                  %d\n" n;
Printf.printf "median:             %f\n" median;
Printf.printf "mean:               %f\n" mean;
Printf.printf "average_deviation:  %f\n" avg_dev;
Printf.printf "standard_deviation: %f\n" std_dev;
Printf.printf "variance:           %f\n" var;
Printf.printf "skew:               %f\n" !skew_ref;
Printf.printf "kurtosis:           %f\n" !kurt_ref
(* nbody.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)


let pi = 3.141592653589793
let solar_mass = 4. *. pi *. pi
let days_per_year = 365.24

type planet = { mutable x : float;  mutable y : float;  mutable z : float;
                mutable vx: float;  mutable vy: float;  mutable vz: float;
                mass : float }

let advance bodies dt =
  let n = Array.length bodies - 1 in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let dist2 = dx *. dx +. dy *. dy +. dz *. dz in
      let mag = dt /. (dist2 *. sqrt(dist2)) in

      b.vx <- b.vx -. dx *. b'.mass *. mag;
      b.vy <- b.vy -. dy *. b'.mass *. mag;
      b.vz <- b.vz -. dz *. b'.mass *. mag;

      b'.vx <- b'.vx +. dx *. b.mass *. mag;
      b'.vy <- b'.vy +. dy *. b.mass *. mag;
      b'.vz <- b'.vz +. dz *. b.mass *. mag;
    done
  done;
  for i = 0 to n do
    let b = bodies.(i) in
    b.x <- b.x +. dt *. b.vx;
    b.y <- b.y +. dt *. b.vy;
    b.z <- b.z +. dt *. b.vz;
  done


let energy bodies =
  let e = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    e := !e +. 0.5 *. b.mass *. (b.vx *. b.vx +. b.vy *. b.vy +. b.vz *. b.vz);
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let distance = sqrt(dx *. dx +. dy *. dy +. dz *. dz) in
      e := !e -. (b.mass *. b'.mass) /. distance
    done
  done;
  !e


let offset_momentum bodies =
  let px = ref 0. and py = ref 0. and pz = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    px := !px +. bodies.(i).vx *. bodies.(i).mass;
    py := !py +. bodies.(i).vy *. bodies.(i).mass;
    pz := !pz +. bodies.(i).vz *. bodies.(i).mass;
  done;
  bodies.(0).vx <- -. !px /. solar_mass;
  bodies.(0).vy <- -. !py /. solar_mass;
  bodies.(0).vz <- -. !pz /. solar_mass


let jupiter = { x = 4.84143144246472090e+00;
                y = -1.16032004402742839e+00;
                z = -1.03622044471123109e-01;
                vx = 1.66007664274403694e-03 *. days_per_year;
                vy = 7.69901118419740425e-03 *. days_per_year;
                vz = -6.90460016972063023e-05 *. days_per_year;
                mass = 9.54791938424326609e-04 *. solar_mass;    }

let saturn = { x = 8.34336671824457987e+00;
               y = 4.12479856412430479e+00;
               z = -4.03523417114321381e-01;
               vx = -2.76742510726862411e-03 *. days_per_year;
               vy = 4.99852801234917238e-03 *. days_per_year;
               vz = 2.30417297573763929e-05 *. days_per_year;
               mass = 2.85885980666130812e-04 *. solar_mass;     }

let uranus = { x = 1.28943695621391310e+01;
               y = -1.51111514016986312e+01;
               z = -2.23307578892655734e-01;
               vx = 2.96460137564761618e-03 *. days_per_year;
               vy = 2.37847173959480950e-03 *. days_per_year;
               vz = -2.96589568540237556e-05 *. days_per_year;
               mass = 4.36624404335156298e-05 *. solar_mass;     }

let neptune = { x = 1.53796971148509165e+01;
                y = -2.59193146099879641e+01;
                z = 1.79258772950371181e-01;
                vx = 2.68067772490389322e-03 *. days_per_year;
                vy = 1.62824170038242295e-03 *. days_per_year;
                vz = -9.51592254519715870e-05 *. days_per_year;
                mass = 5.15138902046611451e-05 *. solar_mass;   }

let sun = { x = 0.;  y = 0.;  z = 0.;  vx = 0.;  vy = 0.; vz = 0.;
            mass = solar_mass; }

let bodies = [| sun; jupiter; saturn; uranus; neptune |]

let () =
  let n = int_of_string(Sys.argv.(1)) in
  offset_momentum bodies;
  Printf.printf "%.9f\n" (energy bodies);
  for i = 1 to n do advance bodies 0.01 done;
  Printf.printf "%.9f\n" (energy bodies)
(*
 * $Id: nestedloop.ocaml2.ocaml,v 1.1 2004-05-19 18:10:57 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let _ =
  let n =
    try int_of_string Sys.argv.(1)
    with Invalid_argument _ -> 1 in
  let x = ref 0 in
  for a = 1 to n do
    for b = 1 to n do
      for c = 1 to n do
        for d = 1 to n do
          for e = 1 to n do
            for f = 1 to n do
              incr x
            done;
          done;
        done;
      done;
    done;
  done;
  Printf.printf "%d\n" !x
(*
 * $Id: nestedloop.ocaml,v 1.1 2004-05-19 18:10:56 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code from Florian Hars and Markus Mottl
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let rec loopF x = function 0 -> x | i -> loopF (x+1) (i-1)
let rec loopE x = function 0 -> x | i -> loopE (loopF x n) (i-1)
let rec loopD x = function 0 -> x | i -> loopD (loopE x n) (i-1)
let rec loopC x = function 0 -> x | i -> loopC (loopD x n) (i-1)
let rec loopB x = function 0 -> x | i -> loopB (loopC x n) (i-1)
let rec loopA x = function 0 -> x | i -> loopA (loopB x n) (i-1);;
Printf.printf "%d\n" (loopA 0 n)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * Modified by Vladimir Silyaev
 * Modified by Leonard Schneider
 *)

open Bigarray

let nsieve m =
  let a = Array1.create Bigarray.int8_unsigned Bigarray.c_layout m in
  Array1.fill a 1;
  let count = ref 0 in
  for i = 2 to m - 1 do
      if a.{i} = 1 then (
      incr count;
      let j = ref(i lsl 1) in
      while !j < m do
        a.{!j} <- 0;
        j := !j+i
      done;
    )
  done;
  Printf.printf "Primes up to %8u %8u\n" m !count


let () =
  (* Use [Array.get] so it raises an exception even if compiled with -unsafe *)
  let n = try int_of_string (Array.get Sys.argv 1) with _ -> 2 in
  for i = 0 to 2 do nsieve(10000 lsl (n-i)) done

(* nsieve.ml -- nave Sieve of Eratosthenes
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * Modified by Vladimir Silyaev
 *)

let max_array_length = 16*(4194303/16)

let array_make_true n =
  (Array.create (min n max_array_length) true),(Array.create (max 0 (n - max_array_length)) true)

let clear (a1,a2) n = 
  if n < max_array_length then (if a1.(n) then a1.(n) <- false)
  else if a2.(n-max_array_length) then a2.(n-max_array_length) <- false

let get (a1,a2) n :bool = 
  if n < max_array_length then a1.(n) else a2.(n-max_array_length) 
    

let nsieve m =
  let a = array_make_true m in
  let count = ref 0 in
  for i = 2 to m - 1 do
    if get a i then (
      incr count;
      let j = ref(i lsl 1) in while !j < m do clear a !j ; j := !j+i done;
    )
  done;
  Printf.printf "Primes up to %8u %8u\n" m !count


let () =
  (* Use [Array.get] so it raises an exception even if compiled with -unsafe *)
  let n = try int_of_string (Array.get Sys.argv 1) with _ -> 2 in
  for i = 0 to 2 do nsieve(10000 lsl (n-i)) done
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * modified by Mario Pernici
 * modified by Vladimir Silyaev
 * modified by Stefan Kral
 *)

open Char

let set_false a i =
  let ic = i lsr 3 in
  let v = code a.[ic] in
  let bit = v land lnot(1 lsl (i land 0x7)) in
    if v <> bit then a.[ic] <- unsafe_chr bit

let nsieve m =
  let a = String.make ((m lsr 3) + 1) '\255' in
  let count = ref 0 in
  for i = 2 to m - 1 do
    if (code a.[i lsr 3]) land (1 lsl (i land 7)) > 0 then (
      incr count;
      let j = ref(i+i) in
      while !j < m do set_false a !j; j := !j+i done;
    )
  done;
  !count

let test n =
  let m = 10000 lsl n in
  Printf.printf "Primes up to %8i %8i\n" m (nsieve m)

let () =
  let n =
    try int_of_string(Array.get Sys.argv 1)
    with _ -> (Printf.printf "usage: %s N\n" Sys.argv.(0); exit 2) in
  test n;
  if n >= 1 then test(n-1);
  if n >= 2 then test(n-2)

(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * modified by Mario Pernici
 * modified by Vladimir Silyaev
 * modified by Edgar Friendly and Nicolas Cannasse
 *)

module BitSet = struct

  type intern
    
  let bcreate : int -> intern = Obj.magic String.create
  external fast_get : intern -> int -> int = "%string_unsafe_get"
  external fast_set : intern -> int -> int -> unit = "%string_unsafe_set"
  external fast_bool : int -> bool = "%identity"
  let fast_fill : intern -> int -> int -> int -> unit = Obj.magic String.fill
  let fast_length : intern -> int= Obj.magic String.length
    
  let int_size = 7 (* value used to round up index *)
  let log_int_size = 3 (* number of shifts *)
    
  let create n =
    let size = (n+int_size) lsr log_int_size in
    let b = bcreate size in
      fast_fill b 0 size 0xFF;
      b
	
(*  let set t x =
    let pos = x lsr log_int_size and delta = x land int_size in
      fast_set t pos ((fast_get t pos) lor (1 lsl delta))
*)

  let unset t x =
    let pos = x lsr log_int_size and delta = x land int_size in
	fast_set t pos ((fast_get t pos) land (0xFF lxor (1 lsl delta)))
	  
  let is_set t x =
    let pos = x lsr log_int_size and delta = x land int_size in
      fast_bool (((fast_get t pos) lsr delta) land 1)
	  
end
  
let nsieve m =
  let a = BitSet.create m in
  let count = ref 0 in
  for i = 2 to m - 1 do
    if BitSet.is_set a i then
      (let j = ref(2*i) in
      while !j < m do BitSet.unset a !j;  j := !j + i done;
      incr count)
  done;
  !count


let test n =
  let m = 10000 lsl n in
  Printf.printf "Primes up to %8i %8i\n" m (nsieve m)

let () =
  let n =
    try int_of_string(Array.get Sys.argv 1)
    with _ -> (Printf.printf "usage: %s N\n" Sys.argv.(0); exit 2) in
  test n;
  if n >= 1 then test(n-1);
  if n >= 2 then test(n-2)
(* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * modified by Mario Pernici
 * modified by Vladimir Silyaev
 *)

open Bigarray

let set_false (a:(int, int8_unsigned_elt, c_layout) Array1.t) i =
  let ic = i lsr 3 in
  let v = a.{ic} in
  let bit = v land lnot(1 lsl (i land 0x7)) in
    if v <> bit then a.{ic} <- bit

let nsieve m =
  let a =  Array1.create int8_unsigned c_layout ((m lsr 3) + 1) in
  Array1.fill a 0xFF;
  let count = ref 0 in
  for i = 2 to m - 1 do
    if a.{i lsr 3} land (1 lsl (i land 0x7)) > 0 then
      (let j = ref(2*i) in
      while !j < m do set_false a !j;  j := !j + i done;
      incr count)
  done;
  !count


let test n =
  let m = 10000 lsl n in
  Printf.printf "Primes up to %8i %8i\n" m (nsieve m)

let () =
  let n =
    try int_of_string(Array.get Sys.argv 1)
    with _ -> (Printf.printf "usage: %s N\n" Sys.argv.(0); exit 2) in
  test n;
  if n >= 1 then test(n-1);
  if n >= 2 then test(n-2)
(*
 * $Id: objinst.ocaml,v 1.1 2004-05-19 18:11:03 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 * with contributions from Markus Mottl
 *)

class toggle start_state = object (self)
  val mutable state = start_state

  method value = state
  method activate = state <- not state; self
end

class nth_toggle start_state max_counter = object (self)
  inherit toggle start_state

  val count_max = max_counter
  val mutable counter = 0

  method activate =
    counter <- counter + 1;
    if counter >= count_max then begin
      state <- not state;
      counter <- 0
    end;
    self
end

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let tog = new toggle true;;
for i = 1 to 5 do Printf.printf "%b\n" tog#activate#value done;
for i = 1 to n do ignore (new toggle true) done;
print_newline ();
let ntog = new nth_toggle true 3 in
for i = 1 to 8 do Printf.printf "%b\n" ntog#activate#value done;
for i = 1 to n do ignore (new nth_toggle true 3) done
(* objinst.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * This version is similar to languages without object features
 * (e.g. objinst.gcc, objinst.mlton).
 *)

type toggle = { mutable r : bool; a : toggle -> unit }
let new_toggle b = { r = b; a = (fun o -> o.r <- not(o.r)) }
let toggle_value o = o.r
let toggle_activate o = o.a o; o

type nth_toggle = { mutable r : bool; count_max : int; mutable counter : int;
		    a : nth_toggle -> unit }
let new_nth_toggle b m =
  let act o =
    o.counter <- o.counter + 1;
    if o.counter >= o.count_max then (o.r <- not o.r; o.counter <- 0) in
  { r = b; count_max = m; counter = 0; a = act }
let nth_toggle_value o = o.r
let nth_toggle_activate o = o.a o; o


let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1 in
  let tog = new_toggle true in
  for i = 1 to 5 do
    Printf.printf "%b\n" (toggle_value(toggle_activate tog))
  done;
  for i = 1 to n do ignore(new_toggle true) done;
  print_newline();
  let ntog = new_nth_toggle true 3 in
  for i = 1 to 8 do
    Printf.printf "%b\n" (nth_toggle_value(nth_toggle_activate ntog))
  done;
  for i = 1 to n do ignore(new_nth_toggle true 3) done

(* partialsums.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

let n = try int_of_string (Array.get Sys.argv 1) with _ -> 25000

let () =
  let sum = ref 0.0 in
  for k = 0 to n do sum := !sum +. (2. /. 3.)**(float k) done;
  Printf.printf "%.9f\t(2/3)^k\n" !sum;

  sum := 0.0;
  for k = 1 to n do sum := !sum +. 1. /. sqrt(float k) done;
  Printf.printf "%.9f\tk^-0.5\n" !sum;

  sum := 0.0;
  for k = 1 to n do let k = float k in sum := !sum +. 1.0/.(k*.(k+.1.0)) done;
  Printf.printf "%.9f\t1/k(k+1)\n" !sum;

  sum := 0.0;
  for k = 1 to n do
    let k = float k in let  sk = sin(k) in
    sum := !sum +. 1.0 /. (k *. k *. k *. sk *. sk)
  done;
  Printf.printf "%.9f\tFlint Hills\n" !sum;

  sum := 0.0;
  for k = 1 to n do
    let k = float k in let ck = cos(k) in
    sum := !sum +. 1.0 /. (k *. k *. k *. ck *. ck)
  done;
  Printf.printf "%.9f\tCookson Hills\n" !sum;

  sum := 0.0;
  for k = 1 to n do sum := !sum +. 1. /. float k done;
  Printf.printf "%.9f\tHarmonic\n" !sum;

  sum := 0.0;
  for k = 1 to n do let k = float k in sum := !sum +. 1. /. (k *. k) done;
  Printf.printf "%.9f\tRiemann Zeta\n" !sum;

  sum := 0.0;  let a = ref(-1.0) in
  for k = 1 to n do a := -. !a; sum := !sum +. !a /. float k done;
  Printf.printf "%.9f\tAlternating Harmonic\n" !sum;

  sum := 0.0;  a := -1.0;
  for k = 1 to n do a := -. !a; sum := !sum +. !a /. (2. *. float k -. 1.) done;
  Printf.printf "%.9f\tGregory\n" !sum
(* partialsums.ml
 *
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * modified by Edgar Friendly for speed (using
 *   algorithm from "partial-sums C++ g++ #3")
 *)

let n = try int_of_string (Array.get Sys.argv 1) with _ -> 25000

type sums = {mutable r1: float; mutable r2: float; mutable r3: float;
	     mutable r4: float; mutable r5: float; mutable r6: float;
	     mutable r7: float; mutable r8: float; mutable r9: float;
	    mutable pot: float}
    
let acc = {r1=1.; r2=0.; r3=0.; r4=0.; r5=0.; r6=0.; r7=0.; r8=0.; r9=0.; pot=1.}

let () =
  let dt = 2.0 /. 3.0 in
  for k = 1 to n do
    let kd = float k in
    let kd2 = kd *. kd in
    let kd3 = kd2 *. kd in

    let sink = sin kd
    and cosk = cos kd in
    
    acc.r1 <- acc.r1 +. dt ** kd;
    acc.r2 <- acc.r2 +. 1. /. sqrt kd;
    acc.r3 <- acc.r3 +. 1. /. (kd2 +. kd);
    acc.r4 <- acc.r4 +. 1. /. (kd3 *. sink *. sink);
    acc.r5 <- acc.r5 +. 1. /. (kd3 *. cosk *. cosk);
    acc.r6 <- acc.r6 +. 1. /. kd;
    acc.r7 <- acc.r7 +. 1. /. kd2;
    acc.r8 <- acc.r8 +. acc.pot /. kd;
    acc.r9 <- acc.r9 +. acc.pot /. (2.0 *. kd -. 1.0);

    acc.pot <- ~-. (acc.pot);
  done;

  Printf.printf "%.9f\t(2/3)^k\n" acc.r1;
  Printf.printf "%.9f\tk^-0.5\n" acc.r2;
  Printf.printf "%.9f\t1/k(k+1)\n" acc.r3;
  Printf.printf "%.9f\tFlint Hills\n" acc.r4;
  Printf.printf "%.9f\tCookson Hills\n" acc.r5;
  Printf.printf "%.9f\tHarmonic\n" acc.r6;
  Printf.printf "%.9f\tRiemann Zeta\n" acc.r7;
  Printf.printf "%.9f\tAlternating Harmonic\n" acc.r8;
  Printf.printf "%.9f\tGregory\n" acc.r9
(*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christophe TROESTLER
 * modified by Matthias Giovannini?
 * ported to Gmp by David Teller
 *)
open Printf
open Gmp.Z2
open Gmp.Z.Infixes

let big_0      = Gmp.Z.zero
let big_1      = Gmp.Z.one
let big_3      = Gmp.Z.of_int 3
let big_4      = Gmp.Z.of_int 4
let big_10     = Gmp.Z.of_int 10
let big_10_neg = Gmp.Z.of_int (-10)

let q = Gmp.Z.of_int 1 
and r = Gmp.Z.of_int 0
and s = Gmp.Z.of_int 0
and t = Gmp.Z.of_int 1

let u = create () and v = create () and w = create ()

let k = ref 0 and digit = create ()

(* Entier part of the linear fractional transform qrst of x *)
let extract x ~out:item= 
  mul u q x;
  add u u r;
  mul v s x;
  add v v t;
  tdiv_q item u v

let next () = extract big_3 ~out:digit
and safe () = extract big_4 ~out:w; Gmp.Z.equal w digit
and produce () = 
  mul r r big_10;
  mul w big_10_neg digit;
  mul v t w;
  add r r v;
  mul q q big_10;  
and consume () =
  incr k;
  let big_k = Gmp.Z.of_int !k in
  let den = Gmp.Z.of_int (2 * !k + 1) in
  let den2 = Gmp.Z.mul_2exp den 1 in
  mul r r den;
  mul u q den2;
  add r r u;
  mul t t den;
  mul v s den2;
  add t t v;
  mul s s big_k;
  mul q q big_k

let digits n = 
  for i = 1 to n do
    next ();
    while not (safe ()) do
      consume ();
      next ();
    done;
    produce ();
    print_string (Gmp.Z.to_string digit);
    if i mod 10 = 0 then 
      printf "\t:%i\n" i;
  done;
  if n mod 10 != 0 then 
    printf "%*s\t:%i\n" (10- n mod 10) "" n

let () = digits (try int_of_string (Array.get Sys.argv 1) with _ -> 27)
(*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christophe TROESTLER
 * modified by Matas Giovannini
 *)
open Printf
open Big_int

let ( +$ ) = add_big_int
let ( *$ ) = mult_int_big_int
let ( /$ ) = div_big_int

(* Entier part of the linear fractional transform qrst of x *)
let ext (q,r,s,t) x = int_of_big_int ((x *$ q +$ r) /$ (x *$ s +$ t))

(* Multiply small int matrix qrst by big int matrix qrst' (small on left) *)
let mml (q,r,s,t) (q',r',s',t') =
  q *$ q'  +$  r *$ s',  q *$ r'  +$  r *$ t',
  s *$ q'  +$  t *$ s',  s *$ r'  +$  t *$ t'

(* Multiply big int matrix qrst by small int matrix qrst' (small on right) *)
let mmr (q,r,s,t) (q',r',s',t') =
  q' *$ q  +$  s' *$ r,  r' *$ q  +$  t' *$ r,
  q' *$ s  +$  s' *$ t,  r' *$ s  +$  t' *$ t

let unit = (unit_big_int,zero_big_int,zero_big_int,unit_big_int)

let next z   = ext z 3
and safe z n = ext z 4 == n
and prod z n = mml (10, -10*n, 0, 1) z
and cons z k =
  let den = 2*k + 1 in
  mmr z (k, 2*den, 0, den)

let rec digit k z n row col =
  if n == 0 then printf "%*s\t:%i\n" (10-col) "" (row+col) else
  let d = next z in
  if safe z d then
    if col = 10 then begin
      let row = row + 10 in
      printf "\t:%i\n%i" row d;
      digit k (prod z d) (n-1) row 1
    end else begin
      print_int d;
      digit k (prod z d) (n-1) row (col+1)
    end
  else digit (k+1) (cons z k) n row col

let digits n = digit 1 unit n 0 0

let () = digits (try int_of_string (Array.get Sys.argv 1) with _ -> 27)
(*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christophe TROESTLER
 * modified by Matas Giovannini
 * modified by Ethan Burns
 *)

open Big_int

type lft = big_int * big_int * big_int * big_int
type lft_ints = int * int * int * int

let unit:lft = (unit_big_int, zero_big_int, zero_big_int, unit_big_int)

(* Attempt to avoid the (apparently slow) Big_int module in some
   simple cases... seems to improve performance 30%. *)

let ( */ ) a b =
  if b = 0 then
    zero_big_int
  else if b = 1 then
    a
  else if b = 2 then
    add_big_int a a
  else
    mult_int_big_int b a

let ( +/ ) a b =
  if eq_big_int a zero_big_int then
    b
  else if eq_big_int b zero_big_int then
    a
  else
    add_big_int a b

let ( // ) a b =
  if lt_big_int a b then
    zero_big_int
  else if eq_big_int a b then
    unit_big_int
  else
    div_big_int a b

let extr (q, r, s, t) x =
  int_of_big_int ((q */ x +/ r) // (s */ x +/ t))

let comp ((q, r, s, t) : lft) ((u, v, w, x) : lft_ints) : lft =
  q */ u +/ r */ w,
  q */ v +/ r */ x,
  s */ u +/ t */ w,
  s */ v +/ t */ x

let comp' ((q, r, s, t) : lft_ints) ((u, v, w, x) : lft) : lft =
  u */ q +/ w */ r,
  v */ q +/ x */ r,
  u */ s +/ w */ t,
  v */ s +/ x */ t

let stream next safe prod cons ith_x z_0 i_0 num =
  let buf = Buffer.create (num * 2) in
  let col = ref 0 in
  let z_int = int_of_char '0' in
  let end_row left =
    col := 0;
    Buffer.add_string buf "\t:";
    Buffer.add_string buf (string_of_int (num - left));
    Buffer.add_char buf '\n'; in
  let next_digit left d =
    Buffer.add_char buf (char_of_int (d + z_int));
    incr col;
    if (!col = 10) then end_row left in
  let rec do_stream z i left =
    if left > 0 then
      let y = next z in
	if safe z y then begin
	  let left' = left - 1 in
	    next_digit left' y;
	    do_stream (prod z y) i left'
	end else begin
	  do_stream (cons z (ith_x i)) (i + 1) left
	end
  in
    do_stream z_0 i_0 num;
    if !col <> 0 then begin
      Buffer.add_string buf (String.make (10 - !col) ' ');
      end_row 0;
    end;
    print_string (Buffer.contents buf);
    print_newline

let pi num =
  let init = unit in
  let lfts k = let x = 2 * k + 1 in k, 2 * x, 0, x in
  let next z = extr z 3 in
  let safe z n = n = (extr z 4) in
  let prod z n = comp' (10, ~-10 * n, 0, 1) z in
  let cons z z' = comp z z' in
    stream next safe prod cons lfts init 1 num

let main () =
  let num =
    if Array.length Sys.argv < 2 then
      27
    else
      try int_of_string Sys.argv.(1) with _ -> 27
  in
    pi num

let _ = main ()
(* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by David Teller (D.O.Teller@sussex.ac.uk)
*)

let adder_thread (incoming, outgoing) =
  Event.sync(Event.send outgoing (Event.sync(Event.receive incoming) + 1))

let rec make_chain n cur =
  if n = 0 then cur else
    let next = Event.new_channel() in
    let _ = Thread.create adder_thread (cur, next) in
    make_chain (n-1) next

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1
  and first_channel = Event.new_channel() in
  let last_channel  = make_chain n first_channel in
  Event.sync(Event.send first_channel 0);
  print_int(Event.sync(Event.receive last_channel))
(*
 * $Id: prodcons.ocaml,v 1.1 2004-05-19 18:11:10 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * ocamlopt -thread unix.cmxa threads.cmxa prodcons.ml -o prodcons
 *  or
 * ocamlc -thread unix.cma threads.cma prodcons.ml -o prodcons
 *)

let count = ref 0
let data = ref 0
let produced = ref 0
let consumed = ref 0
let m = Mutex.create ()
let c = Condition.create ()

let producer n =
  for i = 1 to n do
    Mutex.lock m;
    while !count = 1 do Condition.wait c m done;
    data := i;
    incr count;
    Condition.signal c;
    Mutex.unlock m;
    incr produced
  done

let consumer n =
  let i = ref 0 in
  while !i <> n do
    Mutex.lock m;
    while !count = 0 do Condition.wait c m done;
    i := !data;
    decr count;
    Condition.signal c;
    Mutex.unlock m;
    incr consumed
  done

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let p = Thread.create producer n and c = Thread.create consumer n;;
Thread.join p; Thread.join c;
Printf.printf "%d %d\n" !produced !consumed
(* random.ml
 *
 * $Id: random.ocaml,v 1.4 2005-05-12 12:52:50 chris00-guest Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let im = 139968
and ia = 3877
and ic = 29573

let rec gen_random n seed rand inv_im max =
  if n = 0 then rand else
    let new_seed = (seed * ia + ic) mod im in
    gen_random (n-1) new_seed (max *. float new_seed *. inv_im) inv_im max

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  Printf.printf "%.9f\n" (gen_random n 42 0.0 (1. /. float im) 100.0)
(* 
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Jon Harrop, 2005
 * Compile: ocamlopt -ffast-math -inline 100 raytracer.ocaml -o raytracer 
 *)

let delta = sqrt epsilon_float and pi = 4. *. atan 1.

type vec = {x:float; y:float; z:float}
let ( *| ) s r = {x = s *. r.x; y = s *. r.y; z = s *. r.z}
let ( +| ) a b = {x = a.x +. b.x; y = a.y +. b.y; z = a.z +. b.z}
let ( -| ) a b = {x = a.x -. b.x; y = a.y -. b.y; z = a.z -. b.z}
let dot a b = a.x *. b.x +. a.y *. b.y +. a.z *. b.z
let unitise r = (1. /. sqrt (dot r r)) *| r

type ray = { orig: vec; dir: vec }

type scene = Sphere of vec * float | Group of vec * float * scene array

let ray_sphere ray center radius =
  let v = center -| ray.orig in
  let b = dot v ray.dir in
  let disc = b *. b -. dot v v +. radius *. radius in
  if disc < 0. then infinity else
    let disc = sqrt disc in
    (fun t2 -> if t2 < 0. then infinity else
       ((fun t1 -> if t1 > 0. then t1 else t2) (b -. disc))) (b +. disc)

let intersect ray scene =
  let rec of_scene ((l, _) as first) = function
      Sphere (center, radius) ->
	let l' = ray_sphere ray center radius in
	if l' >= l then first else
	  l', unitise (ray.orig +| l' *| ray.dir -| center)
    | Group (center, radius, scenes) ->
	let l' = ray_sphere ray center radius in
	if l' >= l then first else Array.fold_left of_scene first scenes in
  of_scene (infinity, {x=0.; y=0.; z=0.}) scene

let rec ray_trace light ray scene =
  let lambda, n = intersect ray scene in
  if lambda = infinity then 0. else
    let g = -. dot n light in
    if g <= 0. then 0. else
      match intersect { orig = ray.orig +| lambda *| ray.dir +| delta *| n;
			dir = {x=0.; y=0.; z=0.} -| light } scene with
	l, _ when l = infinity -> g | _ -> 0.

let rec create level r (x, y, z) =
  let obj = Sphere ({x=x; y=y; z=z}, r) in
  if level = 1 then obj else
    let aux l (x', y', z') =
      create (level-1) (0.5 *. r) (x -. x', y +. y', z +. z') :: l in
    let objs = let r' = 3. *. r /. sqrt 12. in
    Array.fold_left aux [obj]
      [|-.r', r', -.r'; r', r', -.r'; -.r', r', r'; r', r', r'|] in
    Group ({x=x; y=y; z=z}, 3. *. r, Array.of_list objs)

let () =
  let level = 6 and ss = 4 in
  let n = match Sys.argv with [| _; l |] -> int_of_string l | _ -> 256 in
  let scene = create level 1. (0., -1., 0.) in

  Printf.printf "P5\n%d %d\n255\n" n n;
  for y = n - 1 downto 0 do
    for x = 0 to n - 1 do
      let g = ref 0. in
      for dx = 0 to ss - 1 do
	for dy = 0 to ss - 1 do
	  let x, y, dx, dy, n = float x, float y, float dx, float dy, float n in
	  let ray =
	    {orig = {x=0.; y=0.; z= -4.};
	     dir = unitise {x = x -. n /. 2. +. dx /. float ss;
			    y = y -. n /. 2. +. dy /. float ss;
			    z = n } } in
	  g := !g +. ray_trace (unitise {x= -1.; y= -3.; z=2.}) ray scene;
	done;
      done;
      let g = 0.5 +. 255. *. !g /. float (ss*ss) in
      Printf.printf "%c" (char_of_int (int_of_float g));
    done;
  done;
(* 
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Mini version. Contributed by Jon Harrop, 2005
 * Compile: ocamlopt -ffast-math -inline 100 raytracer.ocaml -o raytracer 
 *)

let delta = sqrt epsilon_float
type vec = { x: float; y: float; z: float }
let ( *| ) s r = {x = s *. r.x; y = s *. r.y; z = s *. r.z}
let ( +| ) a b = {x = a.x +. b.x; y = a.y +. b.y; z = a.z +. b.z}
let ( -| ) a b = {x = a.x -. b.x; y = a.y -. b.y; z = a.z -. b.z}
let dot a b = a.x *. b.x +. a.y *. b.y +. a.z *. b.z
let unitise r = (1. /. sqrt (dot r r)) *| r
type scene = Sphere of vec * float | Group of vec * float * scene list
let ray_sphere orig dir center radius =
  let v = center -| orig in
  let b = dot v dir in
  let disc = b *. b -. dot v v +. radius *. radius in
  if disc < 0. then infinity else
    let disc = sqrt disc in
    (fun t2 -> if t2 < 0. then infinity else
       ((fun t1 -> if t1 > 0. then t1 else t2) (b -. disc))) (b +. disc)
let intersect orig dir =
  let rec aux ((l, _) as first) = function
      Sphere (center, radius) ->
	let l' = ray_sphere orig dir center radius in
	if l' >= l then first else l', unitise (orig +| l' *| dir -| center)
    | Group (center, radius, scenes) ->
	let l' = ray_sphere orig dir center radius in
	if l' >= l then first else List.fold_left aux first scenes in
  aux (infinity, {x=0.; y=0.; z=0.})
let rec ray_trace light orig dir scene =
  let lambda, normal = intersect orig dir scene in
  if lambda = infinity then 0. else
    let g = dot normal light in
    if g >= 0. then 0. else
      let p = orig +| lambda *| dir +| delta *| normal in
      if fst (intersect p (-1. *| light) scene) < infinity then 0. else -. g
let rec create level c r =
  let obj = Sphere (c, r) in
  if level = 1 then obj else
    let a = 3. *. r /. sqrt 12. in
    let aux x' z' = create (level - 1) (c +| {x=x'; y=a; z=z'}) (0.5 *. r) in
    Group (c, 3.*.r, [obj; aux (-.a) (-.a); aux a (-.a); aux (-.a) a; aux a a])
let () =
  let level = 6 and n = int_of_string Sys.argv.(1) in
  let scene = create level { x = 0.; y = -1.; z = 0. } 1. in
  let light = unitise {x= -1.; y= -3.; z=2.} and ss = 4 in
  Printf.printf "P5\n%d %d\n255\n" n n;
  for y = n - 1 downto 0 do
    for x = 0 to n - 1 do
      let g = ref 0. in
      for dx = 0 to ss - 1 do
	for dy = 0 to ss - 1 do
	  let aux x d = float x -. float n /. 2. +. float d /. float ss in
	  let dir = unitise {x = aux x dx; y = aux y dy; z = float n } in
	  g := !g +. ray_trace light {x=0.; y=0.; z= -4.} dir scene
	done
      done;
      let g = 0.5 +. 255. *. !g /. float (ss*ss) in
      Printf.printf "%c" (char_of_int (int_of_float g))
    done
  done
(* 
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Fast version. Contributed by Jon Harrop, 2005
 * Compile: ocamlopt -ffast-math -inline 100 raytracer.ocaml -o raytracer 
 *)

let delta = sqrt epsilon_float
type vec = {x:float; y:float; z:float}
let ( *| ) s r = {x = s *. r.x; y = s *. r.y; z = s *. r.z}
let ( +| ) a b = {x = a.x +. b.x; y = a.y +. b.y; z = a.z +. b.z}
let ( -| ) a b = {x = a.x -. b.x; y = a.y -. b.y; z = a.z -. b.z}
let dot a b = a.x *. b.x +. a.y *. b.y +. a.z *. b.z
let unitise r = (1. /. sqrt (dot r r)) *| r and length r = sqrt(dot r r)
type scene = Sphere of vec * float | Group of vec * float * scene list
let ray_sphere orig dir center radius =
  let v = center -| orig in
  let b = dot v dir in
  let disc = b *. b -. dot v v +. radius *. radius in
  if disc < 0. then infinity else
    let disc = sqrt disc in
    (fun t2 -> if t2 < 0. then infinity else
       ((fun t1 -> if t1 > 0. then t1 else t2) (b -. disc))) (b +. disc)
let ray_sphere' orig dir center radius =
  let v = center -| orig in
  let b = dot v dir in
  let disc = b *. b -. dot v v +. radius *. radius in
  if disc < 0. then false else b +. sqrt disc >= 0.
let intersect orig dir =
  let rec aux ((l, _) as first) = function
      Sphere (center, radius) ->
	let l' = ray_sphere orig dir center radius in
	if l' >= l then first else l', unitise (orig +| l' *| dir -| center)
    | Group (center, radius, scenes) ->
	let l' = ray_sphere orig dir center radius in
	if l' >= l then first else List.fold_left aux first scenes in
  aux (infinity, {x=0.; y=0.; z=0.})
let intersect' orig dir =
  let rec aux = function
      Sphere (center, radius) -> ray_sphere' orig dir center radius
    | Group (center, radius, scenes) ->
	ray_sphere' orig dir center radius && List.exists aux scenes in
  aux
let rec ray_trace light orig dir scene =
  let lambda, normal = intersect orig dir scene in
  if lambda = infinity then 0. else
    let g = dot normal light in
    if g >= 0. then 0. else
      let p = orig +| lambda *| dir +| delta *| normal in
      if intersect' p (-1. *| light) scene then 0. else -. g
let rec create level c r =
  let obj = Sphere (c, r) in
  if level = 1 then obj else
    let a = 3. *. r /. sqrt 12. in
    let rec bound (c, r) = function
	Sphere (c', r') -> (c, max r (length (c -| c') +. r'))
      | Group (_, _, l) -> List.fold_left bound (c, r) l in
    let aux x' z' = create (level - 1) (c +| {x=x'; y=a; z=z'}) (0.5 *. r) in
    let l = [obj; aux (-.a) (-.a); aux a (-.a); aux (-.a) a; aux a a] in
    let c, r = List.fold_left bound (c +| {x=0.; y=r; z=0.}, 0.) l in
    Group (c, r, l)
let () =
  let level = 6 and n = int_of_string Sys.argv.(1) in
  let scene = create level { x = 0.; y = -1.; z = 0. } 1. in
  let light = unitise {x= -1.; y= -3.; z=2.} and ss = 4 in
  Printf.printf "P5\n%d %d\n255\n" n n;
  for y = n - 1 downto 0 do
    for x = 0 to n - 1 do
      let g = ref 0. in
      for dx = 0 to ss - 1 do
	for dy = 0 to ss - 1 do
	  let aux x d = float x -. float n /. 2. +. float d /. float ss in
	  let dir = unitise {x = aux x dx; y = aux y dy; z = float n } in
	  g := !g +. ray_trace light {x=0.; y=0.; z= -4.} dir scene
	done
      done;
      let g = 0.5 +. 255. *. !g /. float (ss*ss) in
      Printf.printf "%c" (char_of_int (int_of_float g))
    done
  done
(* recursive.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

let rec ack x y =
  if x = 0 then y + 1
  else if y = 0 then ack (x-1) 1
  else ack (x-1) (ack x (y-1))

let rec fib n = if n < 2 then 1 else fib(n-2) + fib(n-1)

let rec fib_fp n =
 if n = 0. || n = 1. then 1. else fib_fp(n -. 2.) +. fib_fp(n -. 1.)

let rec tak x y z =
  if y < x then tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y) else z

let rec tak_fp x y z =
  if y >= x then z else
    tak_fp (tak_fp (x -. 1.) y z) (tak_fp (y -. 1.) z x) (tak_fp (z -. 1.) x y)


let () =
  let n = int_of_string(Array.get Sys.argv 1) - 1 in
  Printf.printf "Ack(3,%d): %d\n" (n+1) (ack 3 (n+1));
  Printf.printf "Fib(%.1f): %.1f\n" (28. +. float n) (fib_fp (28. +. float n));
  Printf.printf "Tak(%d,%d,%d): %d\n" (3*n) (2*n) n (tak (3*n) (2*n) n);
  Printf.printf "Fib(3): %d\n" (fib 3);
  Printf.printf "Tak(3.0,2.0,1.0): %.1f\n" (tak_fp 3.0 2.0 1.0)
(* regexdna.ml
 *
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * Parallelized by Jon Harrop
 * Modified by Mauricio Fernandez
 *)

open Printf

(* semi-standard function for process-based parallelism *)
let invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with `Res x -> x | `Exn e -> raise e

(* This module is a workaround for a bug in the Str library from the Ocaml
 * distribution used in the Computer Language Benchmarks Game. It can be removed
 * altogether when using OCaml 3.11 *)
module Str =
struct
  include Str

  let substitute_first expr repl_fun text =
    try
      let pos = Str.search_forward expr text 0 in
      String.concat "" [Str.string_before text pos;
                        repl_fun text;
                        Str.string_after text (Str.match_end())]
    with Not_found ->
      text

  let opt_search_forward re s pos =
    try Some(Str.search_forward re s pos) with Not_found -> None

  let global_substitute expr repl_fun text =
    let rec replace accu start last_was_empty =
      let startpos = if last_was_empty then start + 1 else start in
      if startpos > String.length text then
        Str.string_after text start :: accu
      else
        match opt_search_forward expr text startpos with
        | None ->
            Str.string_after text start :: accu
        | Some pos ->
            let end_pos = Str.match_end() in
            let repl_text = repl_fun text in
            replace (repl_text :: String.sub text start (pos-start) :: accu)
                    end_pos (end_pos = pos)
    in
      String.concat "" (List.rev (replace [] 0 false))

  let global_replace expr repl text =
    global_substitute expr (Str.replace_matched repl) text
  and replace_first expr repl text =
    substitute_first expr (Str.replace_matched repl) text
end

let variants = ["agggtaaa\\|tttaccct";          "[cgt]gggtaaa\\|tttaccc[acg]";
                "a[act]ggtaaa\\|tttacc[agt]t";  "ag[act]gtaaa\\|tttac[agt]ct";
                "agg[act]taaa\\|ttta[agt]cct";  "aggg[acg]aaa\\|ttt[cgt]ccct";
                "agggt[cgt]aa\\|tt[acg]accct";  "agggta[cgt]a\\|t[acg]taccct";
                "agggtaa[cgt]\\|[acg]ttaccct"]

(* Remove the "\\" which is mandatory in OCaml regex. *)
let re_bs = Str.regexp_string "\\"
let to_string = Str.global_replace re_bs ""

let subst = ["B", "(c|g|t)"; "D", "(a|g|t)";   "H", "(a|c|t)"; "K", "(g|t)";
             "M", "(a|c)";   "N", "(a|c|g|t)"; "R", "(a|g)";   "S", "(c|g)";
             "V", "(a|c|g)"; "W", "(a|t)";     "Y", "(c|t)"]

(* Read all of a redirected FASTA format file from stdin. *)
let file_data, file_length =
  let b = Buffer.create 0xFFFF and s = String.create 0xFFF and r = ref 1 in
  while !r > 0 do
    r := input stdin s 0 0xFFF;   Buffer.add_substring b s 0 !r
  done;
  Buffer.contents b, Buffer.length b

(* Remove FASTA sequence descriptions and all linefeed characters.  *)
let dna = Str.global_replace (Str.regexp "^>.*$\\|\n") "" file_data
let code_length = String.length dna

(* Count matches of [re]. *)
let count re s =
  let re = Str.regexp_case_fold re and i = ref 0 and n = ref 0 in
  try
    while true do i := 1 + Str.search_forward re s !i; incr n done; assert false
  with Not_found -> !n


let () =
  List.iter (fun f -> print_endline(f()))
    (List.map
       (invoke
	  (fun re -> sprintf "%s %i" (to_string re) (count re dna)))
       variants);
  let b = ref dna in
  List.iter (fun (re, s) ->
               b := Str.global_replace (Str.regexp_case_fold re) s !b) subst;
  printf "\n%i\n%i\n%i\n" file_length code_length (String.length !b)
(* regexdna.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

open Printf

let variants = ["agggtaaa\\|tttaccct";          "[cgt]gggtaaa\\|tttaccc[acg]";
                "a[act]ggtaaa\\|tttacc[agt]t";  "ag[act]gtaaa\\|tttac[agt]ct";
                "agg[act]taaa\\|ttta[agt]cct";  "aggg[acg]aaa\\|ttt[cgt]ccct";
                "agggt[cgt]aa\\|tt[acg]accct";  "agggta[cgt]a\\|t[acg]taccct";
                "agggtaa[cgt]\\|[acg]ttaccct"]

(* Remove the "\\" which is mandatory in OCaml regex. *)
let re_bs = Str.regexp_string "\\"
let to_string = Str.global_replace re_bs ""

let subst = ["B", "(c|g|t)"; "D", "(a|g|t)";   "H", "(a|c|t)"; "K", "(g|t)";
             "M", "(a|c)";   "N", "(a|c|g|t)"; "R", "(a|g)";   "S", "(c|g)";
             "V", "(a|c|g)"; "W", "(a|t)";     "Y", "(c|t)"]

(* Read all of a redirected FASTA format file from stdin. *)
let file_data, file_length =
  let b = Buffer.create 0xFFFF and s = String.create 0xFFF and r = ref 1 in
  while !r > 0 do
    r := input stdin s 0 0xFFF;   Buffer.add_substring b s 0 !r
  done;
  Buffer.contents b, Buffer.length b

(* Remove FASTA sequence descriptions and all linefeed characters.  *)
let dna = Str.global_replace (Str.regexp "^>.*$\\|\n") "" file_data
let code_length = String.length dna

(* Count matches of [re]. *)
let count re s =
  let re = Str.regexp_case_fold re and i = ref 0 and n = ref 0 in
  try
    while true do i := 1 + Str.search_forward re s !i; incr n done; assert false
  with Not_found -> !n


let () =
  List.iter (fun re -> printf "%s %i\n" (to_string re) (count re dna)) variants;
  let b = ref dna in
  List.iter (fun (re, s) ->
               b := Str.global_replace (Str.regexp_case_fold re) s !b) subst;
  printf "\n%i\n%i\n%i\n" file_length code_length (String.length !b)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * Parallelized by Jon Harrop
 * Modified by Mauricio Fernandez
 *)

open Printf

(* semi-standard function for process-based parallelism *)
let invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with `Res x -> x | `Exn e -> raise e

let variants = ["agggtaaa\\|tttaccct";          "[cgt]gggtaaa\\|tttaccc[acg]";
                "a[act]ggtaaa\\|tttacc[agt]t";  "ag[act]gtaaa\\|tttac[agt]ct";
                "agg[act]taaa\\|ttta[agt]cct";  "aggg[acg]aaa\\|ttt[cgt]ccct";
                "agggt[cgt]aa\\|tt[acg]accct";  "agggta[cgt]a\\|t[acg]taccct";
                "agggtaa[cgt]\\|[acg]ttaccct"]

(* Remove the "\\" which is mandatory in OCaml regex. *)
let re_bs = Str.regexp_string "\\"
let to_string = Str.global_replace re_bs ""

let subst = ["B", "(c|g|t)"; "D", "(a|g|t)";   "H", "(a|c|t)"; "K", "(g|t)";
             "M", "(a|c)";   "N", "(a|c|g|t)"; "R", "(a|g)";   "S", "(c|g)";
             "V", "(a|c|g)"; "W", "(a|t)";     "Y", "(c|t)"]

(* Read all of a redirected FASTA format file from stdin. *)
let file_data, file_length =
  let b = Buffer.create 0xFFFF and s = String.create 0xFFF and r = ref 1 in
  while !r > 0 do
    r := input stdin s 0 0xFFF;   Buffer.add_substring b s 0 !r
  done;
  Buffer.contents b, Buffer.length b

(* Remove FASTA sequence descriptions and all linefeed characters.  *)
let dna = Str.global_replace (Str.regexp "^>.*$\\|\n") "" file_data
let code_length = String.length dna

(* Count matches of [re]. *)
let count re s =
  let re = Str.regexp_case_fold re and i = ref 0 and n = ref 0 in
  try
    while true do i := 1 + Str.search_forward re s !i; incr n done; assert false
  with Not_found -> !n


let () =
  List.iter (fun f -> print_endline(f()))
    (List.map
       (invoke
	  (fun re -> sprintf "%s %i" (to_string re) (count re dna)))
       variants);
  let b = ref dna in
  List.iter (fun (re, s) ->
               b := Str.global_replace (Str.regexp_case_fold re) s !b) subst;
  printf "\n%i\n%i\n%i\n" file_length code_length (String.length !b)
(* regexmatch.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * This program uses the Str module that comes with OCaml standard
 * distribution.
 *)

open Printf

let re = Str.regexp (
  "[^0-9(]*" (* must be preceded by non-digit *)
  ^ "\\(([0-9][0-9][0-9])\\|[0-9][0-9][0-9]\\)" (* match1: area code *)
  ^ " \\([0-9][0-9][0-9]\\)[ -]" (* space, prefix=3 digits, separator *)
  ^ "\\([0-9][0-9][0-9][0-9]\\)\\([^0-9]\\|$\\)" (* 4 digits, non-digit *)
)

(* Read all the lines from stdin *)
let phones =
  let lines = ref [] in
  try  while true do lines := (input_line stdin) :: !lines done; assert(false)
  with End_of_file -> List.rev !lines

let check_phone must_print count line =
  if Str.string_match re line 0 then (
    let area = Str.matched_group 1 line
    and prefix = Str.matched_group 2 line
    and digits = Str.matched_group 3 line in
    let num = (if area.[0] = '(' then sprintf "%s %s-%s"
	       else sprintf "(%s) %s-%s") area prefix digits in
    if must_print then (incr count; printf "%i: %s\n" !count num)
  )

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1 in
  List.iter (check_phone true (ref 0)) phones;
  for i = 2 to n do List.iter (check_phone false (ref 0)) phones done

(*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Paolo Ribeca
 *)

let chars_per_line = 60
and lines_per_worker =
  match Sys.word_size with
  | 32 -> 200000
  | 64 -> 500000
  | _ -> assert false

let rc_table = String.make 256 '\000'
let _ =
  rc_table.[Char.code 'A'] <- 'T'; rc_table.[Char.code 'T'] <- 'A';
  rc_table.[Char.code 'w'] <- 'W'; rc_table.[Char.code 's'] <- 'S';
  rc_table.[Char.code 'a'] <- 'T'; rc_table.[Char.code 't'] <- 'A';
  rc_table.[Char.code 'C'] <- 'G'; rc_table.[Char.code 'G'] <- 'C';
  rc_table.[Char.code 'c'] <- 'G'; rc_table.[Char.code 'g'] <- 'C';
  rc_table.[Char.code 'U'] <- 'A'; rc_table.[Char.code 'u'] <- 'A';
  rc_table.[Char.code 'M'] <- 'K'; rc_table.[Char.code 'K'] <- 'M';
  rc_table.[Char.code 'm'] <- 'K'; rc_table.[Char.code 'k'] <- 'M';
  rc_table.[Char.code 'R'] <- 'Y'; rc_table.[Char.code 'Y'] <- 'R';
  rc_table.[Char.code 'r'] <- 'Y'; rc_table.[Char.code 'y'] <- 'R';
  rc_table.[Char.code 'W'] <- 'W'; rc_table.[Char.code 'S'] <- 'S';
  rc_table.[Char.code 'w'] <- 'W'; rc_table.[Char.code 's'] <- 'S';
  rc_table.[Char.code 'V'] <- 'B'; rc_table.[Char.code 'B'] <- 'V';
  rc_table.[Char.code 'v'] <- 'B'; rc_table.[Char.code 'b'] <- 'V';
  rc_table.[Char.code 'H'] <- 'D'; rc_table.[Char.code 'D'] <- 'H';
  rc_table.[Char.code 'h'] <- 'D'; rc_table.[Char.code 'd'] <- 'H';
  rc_table.[Char.code 'N'] <- 'N'; rc_table.[Char.code 'n'] <- 'N'

let _ =
  let in_ack, out_ack = Unix.pipe () and in_end, out_end = Unix.pipe ()
  and put out_pipe () =
    if Unix.write out_pipe " " 0 1 <> 1 then
      failwith "Pipe problem"
  and get in_pipe () =
    let res = " " in
    if Unix.read in_pipe res 0 1 <> 1 then
      failwith "Pipe problem" in
  let put_ack = put out_ack and get_ack = get in_ack
  and put_end_ack = put out_end and get_end_ack = get in_end in
  let rec spawn tag first =
    let output_tag () =
      print_string tag;
      print_char '\n';
      flush stdout
    and buf = Buffer.create (lines_per_worker * chars_per_line) in
    let process_buffer () =
      let seq = Buffer.contents buf in
      let red_len = String.length seq - 1 in
      let mid_point = red_len / 2 in
      for i = 0 to mid_point do
	let ri = red_len - i and tmp = seq.[i] in
	seq.[i] <- rc_table.[Char.code seq.[ri]];
	seq.[ri] <- rc_table.[Char.code tmp]
      done;
      seq
    and write_by_cols seq rem eol =
      let len = String.length seq and beg = ref 0 in
      if rem > 0 then begin
	let to_do = min rem len in
	print_string (String.sub seq !beg to_do);
	print_char '\n';
	beg := !beg + to_do
      end;
      while len - !beg >= chars_per_line do
	print_string (String.sub seq !beg chars_per_line);
	print_char '\n';
	beg := !beg + chars_per_line
      done;
      let rem = len - !beg in
      if rem > 0 then begin
	print_string (String.sub seq !beg rem);
	if eol then
	  print_char '\n'
      end;
      flush stdout;
      if eol then
	0
      else
	rem in
    try
      for i = 1 to lines_per_worker do
	let line = read_line () in
	if line.[0] = '>' then begin
	  match Unix.fork () with
	  | 0 -> spawn line true
	  | _ ->
	      get_ack ();
	      output_tag ();
	      let rem = (write_by_cols (process_buffer ()) 0 first) in
	      if first then
		put_ack ();
	      exit rem
	end;
	Buffer.add_string buf line
      done;
      match Unix.fork () with
      | 0 -> spawn tag false
      | pid ->
	  let seq = process_buffer () in
	  match Unix.waitpid [] pid with
	  | _, Unix.WEXITED rem ->
	      let rem = (write_by_cols seq (chars_per_line - rem) first) in
	      if first then
		put_ack ();
	      exit rem
	  | _ -> assert false
    with End_of_file ->
      get_ack ();
      put_end_ack ();
      output_tag ();
      let rem = (write_by_cols (process_buffer ()) 0 first) in
      if first then
	put_ack ();
      exit rem in
  match Unix.fork () with
  | 0 ->
      put_ack ();
      spawn (read_line ()) true
  | _ ->
      get_end_ack ();
      get_ack ();
      exit 0
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Ingo Bormuth <ibormuth@efil.de>
*)

open String;;

let t, b, bi = make 256 ' ', make 61 '\n', ref 1;;
blit "TVGHEFCDIJMLKNOPQYSAABWXRZ" 0 t 65 26; blit t 65 t 97 26;

let rec rd ls =
  let l, q = try input_line stdin, false with _ -> "", true in
  if l <> "" && l.[0] <> '>' then rd (l::ls)
  else (
    let rec wr = function
      s::ss ->
          for si = length s - 1 downto 0 do
            b.[!bi] <- t.[Char.code s.[si]];
            if !bi<60 then bi:=!bi+1 else ( print_string b; bi:=1 )
          done;
          wr ss
      | [] ->
          if !bi>1 then output stdout b 0 !bi;
          bi:=1 in
    wr ls;
    print_string ( if ls<>[] then ("\n"^l) else l );
    q || rd []
  ) in
rd []
(*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Paolo Ribeca
 *)

let chars_per_line = 60
and lines_per_worker =
  match Sys.word_size with
  | 32 -> 200000
  | 64 -> 500000
  | _ -> assert false

let rc_table = String.make 256 '\000'
let _ =
  rc_table.[Char.code 'A'] <- 'T'; rc_table.[Char.code 'T'] <- 'A';
  rc_table.[Char.code 'w'] <- 'W'; rc_table.[Char.code 's'] <- 'S';
  rc_table.[Char.code 'a'] <- 'T'; rc_table.[Char.code 't'] <- 'A';
  rc_table.[Char.code 'C'] <- 'G'; rc_table.[Char.code 'G'] <- 'C';
  rc_table.[Char.code 'c'] <- 'G'; rc_table.[Char.code 'g'] <- 'C';
  rc_table.[Char.code 'U'] <- 'A'; rc_table.[Char.code 'u'] <- 'A';
  rc_table.[Char.code 'M'] <- 'K'; rc_table.[Char.code 'K'] <- 'M';
  rc_table.[Char.code 'm'] <- 'K'; rc_table.[Char.code 'k'] <- 'M';
  rc_table.[Char.code 'R'] <- 'Y'; rc_table.[Char.code 'Y'] <- 'R';
  rc_table.[Char.code 'r'] <- 'Y'; rc_table.[Char.code 'y'] <- 'R';
  rc_table.[Char.code 'W'] <- 'W'; rc_table.[Char.code 'S'] <- 'S';
  rc_table.[Char.code 'w'] <- 'W'; rc_table.[Char.code 's'] <- 'S';
  rc_table.[Char.code 'V'] <- 'B'; rc_table.[Char.code 'B'] <- 'V';
  rc_table.[Char.code 'v'] <- 'B'; rc_table.[Char.code 'b'] <- 'V';
  rc_table.[Char.code 'H'] <- 'D'; rc_table.[Char.code 'D'] <- 'H';
  rc_table.[Char.code 'h'] <- 'D'; rc_table.[Char.code 'd'] <- 'H';
  rc_table.[Char.code 'N'] <- 'N'; rc_table.[Char.code 'n'] <- 'N'

let _ =
  let aug_chars_per_line = chars_per_line + 1
  and in_ack, out_ack = Unix.pipe () and in_end, out_end = Unix.pipe ()
  and put out_pipe () =
    if Unix.write out_pipe " " 0 1 <> 1 then
      failwith "Pipe problem"
  and get in_pipe () =
    let res = " " in
    if Unix.read in_pipe res 0 1 <> 1 then
      failwith "Pipe problem" in
  let put_ack = put out_ack and get_ack = get in_ack
  and put_end_ack = put out_end and get_end_ack = get in_end in
  let rec spawn tag beg first =
    let output_tag () =
      print_string tag;
      print_char '\n';
      flush stdout
    and buf = String.create (lines_per_worker * chars_per_line + 2)
    and len = ref (String.length beg) in
    String.blit beg 0 buf 0 !len;
    let process_buffer () =
      let red_len = !len - 1 in
      let mid_point = red_len / 2 in
      for i = 0 to mid_point do
	let ri = red_len - i and tmp = buf.[i] in
	buf.[i] <- rc_table.[Char.code buf.[ri]];
	buf.[ri] <- rc_table.[Char.code tmp]
      done
    and write_by_cols rem eol =
      let len = !len and dne = ref 0 in
      if rem > 0 then begin
	let to_do = min rem (len - !dne) in
	output stdout buf !dne to_do;
	output_char stdout '\n';
	dne := !dne + to_do
      end;
      while len - !dne >= chars_per_line do
	output stdout buf !dne chars_per_line;
	output_char stdout '\n';
	dne := !dne + chars_per_line
      done;
      let rem = len - !dne in
      if rem > 0 then begin
	output stdout buf !dne rem;
	if eol then
	  output_char stdout '\n'
      end;
      flush stdout;
      if eol then
	0
      else
	rem in
    try
      for i = 2 to lines_per_worker do
	really_input stdin buf !len aug_chars_per_line;
	let new_len = ref (!len + chars_per_line) in
	if buf.[!len] = '>' || buf.[!new_len] <> '\n' then begin
	  while buf.[!len] <> '>' do
	    incr len
	  done;
	  let ptr = ref !len in
	  (* Needed to patch the hideous bug in the output of the C program *)
	  if buf.[!len - 1] <> '\n' then begin
	    String.blit buf !len buf (!len + 1) aug_chars_per_line;
	    buf.[!len] <- '\n';
	    incr new_len;
	    incr ptr
	  end else
	    decr len;
	  while !ptr < !new_len && buf.[!ptr] <> '\n' do
	    incr ptr
	  done;
	  match Unix.fork () with
	  | 0 ->
	      let aug_len = !len + 1 in
	      if !ptr = !new_len then
		spawn
		  (String.sub buf
		    aug_len (!new_len - aug_len) ^ input_line stdin)
		  "" true
	      else
		let aug_ptr = !ptr + 1 in
		spawn
		  (String.sub buf aug_len (!ptr - aug_len))
		  (String.sub buf aug_ptr (!new_len - !ptr) ^ input_line stdin)
		  true
	  | _ ->
	      get_ack ();
	      output_tag ();
	      process_buffer ();
	      let rem = write_by_cols 0 first in
	      if first then
		put_ack ();
	      exit rem
	end;
	len := !new_len
      done;
      match Unix.fork () with
      | 0 -> spawn tag "" false
      | pid ->
	  process_buffer ();
	  match Unix.waitpid [] pid with
	  | _, Unix.WEXITED rem ->
	      let rem = write_by_cols (chars_per_line - rem) first in
	      if first then
		put_ack ();
	      exit rem
	  | _ -> assert false
    with End_of_file ->
      while buf.[!len] <> '\n' do
	incr len
      done;
      get_ack ();
      put_end_ack ();
      output_tag ();
      process_buffer ();
      let rem = write_by_cols 0 first in
      if first then
	put_ack ();
      exit rem in
  match Unix.fork () with
  | 0 ->
      put_ack ();
      spawn (read_line ()) "" true
  | _ ->
      get_end_ack ();
      get_ack ();
      exit 0
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Ingo Bormuth
   modified by Fabrice Le Fessant 
*)

let verbose = false

let rec print_args list =
  match list with
      [] -> ()
    | x :: tail ->
	Printf.fprintf stderr " %d" x;
	print_args tail

let enter name list =
  if verbose then begin
    Printf.fprintf stderr "%s:" name;
    print_args list;
    Printf.fprintf stderr "\n%!"
  end

let arch64 =
  match Sys.word_size with
      32 -> false
    | 64 -> true
    | _ -> assert false


module LineReader : sig

  (* read all non empty lines *)
  val read :
    (* from : *) Unix.file_descr ->
    (* max_line_length : *) int ->
    (* handler : *) (string -> int -> int -> unit) -> unit

end = struct

  let read ic maxlen handler =
    let s = String.create maxlen in

    let rec iter begin_pos pos =
      let to_read = maxlen - pos in
	if to_read < 32000 then begin
	  let len = pos - begin_pos in
	    String.blit s begin_pos s 0 len;
	    iter 0 len
	end else
	  let nread = Unix.read ic s pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	iter2 begin_pos pos end_pos

    and iter2 begin_pos pos end_pos =
      if pos = end_pos then
	iter begin_pos end_pos
      else
	match s.[pos] with
	    '\n' | '\r' ->
	      if pos > begin_pos then
		handler s begin_pos (pos - begin_pos);
	      iter2 (pos+1) (pos+1) end_pos
	  | _ ->
	      iter2 begin_pos (pos+1) end_pos

    in
      iter 0 0

end

let t = String.make 256 ' '
let b = String.make 61 '\n'
let bi = ref 1
let _ =
  String.blit "TVGHEFCDIJMLKNOPQYSAABWXRZ" 0 t 65 26;
  String.blit t 65 t 97 26
;;

let t =
  let s = Array.create 256 ' ' in
    for i = 0 to 255 do
      s.(i) <- t.[i]
    done;
    s
;;

module Fasta : sig

  val clear : unit -> unit
  val flush : unit -> unit
  val print : string -> int -> int -> unit

end = struct

  let printed = ref 0

  let clear () = printed := 0
  let flush () =
    if !printed > 0 then print_newline ();
    printed := 0

  let rec print s pos len =
    if len > 60 then begin
      output stdout s pos 60;
      output_char stdout '\n';
      print s (pos + 60) (len-60)
    end else
      if len > 0 then
	begin
	  output stdout s pos len;
	  printed := len
	end

  let print s pos len =
    let to_print = 60 - !printed in
      if len < to_print then begin
	output stdout s pos len;
	printed := !printed + len
      end else begin
	output stdout s pos to_print;
	output_char stdout '\n';
	printed := 0;
	print s (pos + to_print) (len - to_print);
      end

end

module IMPLEMENTATION32 : sig
  val main : unit -> unit
end = struct

module BigRevBuffer : sig

  val clear : unit -> unit
  val length : unit -> int
  val add : string -> int -> int -> unit
(*  val iter : (string -> int -> int -> unit) -> unit *)
  val reverse_iter : unit -> unit

end = struct

(* don't allocate any buffers on x64 *)
  let nbuffers = if arch64 then 0 else 256


  let buffer_len = 1_000_000

  let buffers = Array.init nbuffers (fun _ -> String.create buffer_len)
  let buffer_pos = Array.create nbuffers buffer_len
  let last_buffer = ref 0

  let clear () =
    last_buffer := 0;
    for i = 0 to 255 do
      buffer_pos.(i) <- buffer_len;
    done

  let length () =
    !last_buffer * buffer_len + (buffer_len - buffer_pos.(!last_buffer))

  let rec blit_rev src end_pos dst dpos len =
    if len > 0 then begin
      dst.[dpos] <- t.(Char.code  src.[end_pos]);
      blit_rev src (end_pos-1) dst (dpos+1) (len-1)
    end

  let blit_rev src spos dst dpos len =
    let end_pos = spos + len - 1 in
    blit_rev src end_pos dst dpos len

  let rec add s pos len =
    if len > 0 then
      let b = buffers.(!last_buffer) in
      let bpos = buffer_pos.(!last_buffer) in
	if bpos > len then begin
	  let new_pos = bpos - len in
	    blit_rev s pos b new_pos len;
	    buffer_pos.(!last_buffer) <- new_pos
	end else begin
	  blit_rev s pos b 0 bpos;
	  buffer_pos.(!last_buffer) <- 0;
	  incr last_buffer;
	  add s (pos + bpos) (len - bpos)
	end

(*

  let iter f =
    let rec iter f i last_buffer =
      if i < last_buffer then begin
	f  buffers.(i) 0 buffer_len;
	iter f (i+1) last_buffer
      end
      else
	let pos = buffer_pos.(last_buffer) in
	  f buffers.(last_buffer) pos (buffer_len - pos)
    in
      iter f 0 !last_buffer

  let rev_iter f =
    let rec iter f i =
      if i >= 0 then begin
	f  buffers.(i) 0 buffer_len;
	iter f (i-1)
      end
    in
    let pos = buffer_pos.(!last_buffer) in
      f buffers.(!last_buffer) pos (buffer_len - pos);
      iter f (!last_buffer-1)
*)

  let reverse_iter f =
    let rec iter i =
      if i >= 0 then begin
	Fasta.print  buffers.(i) 0 buffer_len;
	iter (i-1)
      end
    in
    let pos = buffer_pos.(!last_buffer) in
      if pos < buffer_len then
	Fasta.print buffers.(!last_buffer) pos (buffer_len - pos);
      iter (!last_buffer-1)

end

let reverse () =
  if BigRevBuffer.length () > 0 then begin
    Fasta.clear ();
    BigRevBuffer.reverse_iter ();
    BigRevBuffer.clear ();
    Fasta.flush ()
  end

let main () =
  try
    LineReader.read Unix.stdin 1_000_000
      (fun s pos len ->
	 if s.[pos] = '>' then begin
	   reverse ();
	   output stdout s pos len;
	   output_char stdout '\n';
	 end else
	   BigRevBuffer.add s pos len
      )
  with End_of_file -> reverse ()
    | e ->
	Printf.fprintf stderr "exception %s\n%!" (Printexc.to_string e);
	exit 2

end

module IMPLEMENTATION64 : sig

  val main : unit -> unit

end = struct

  let buffer_len = 150_000_000

  let buffer = if arch64 then String.create buffer_len else ""
  let buffer_pos = ref buffer_len

  let wait_for = ref None

  let reverse () =
    begin
      match !wait_for with
	  None -> ()
	| Some ix ->
	    let s = String.create 1 in
	    ignore (Unix.read ix s 0 1)
    end;
    let len = buffer_len - !buffer_pos in
      if len > 0 then begin
	Fasta.clear ();
	Fasta.print buffer !buffer_pos len;
	Fasta.flush ();
	buffer_pos := buffer_len;
      end

    let maxlen = 10_000_000
    let inbuf = String.create maxlen

let rec iter1 begin_pos () pos =
  let to_read = maxlen - pos in
    if to_read < 32_000 then begin
      let len = pos - begin_pos in
	String.blit inbuf begin_pos inbuf 0 len;
	iter1 0 () len
    end else
      let nread = Unix.read Unix.stdin inbuf pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	  iter2 begin_pos pos end_pos

and iter2 begin_pos pos end_pos =
  if pos = end_pos then
    iter1 begin_pos () end_pos
  else
    match inbuf.[pos] with
	'\n' ->
	  iter2 (pos+1) (pos+1) end_pos
      | '>' ->
	  iter4 begin_pos (pos+1) end_pos
      | c ->
	  let c = t.(Char.code c) in
	    decr buffer_pos;
	    buffer.[!buffer_pos] <- c;
	    iter2 begin_pos (pos+1) end_pos

and iter3 begin_pos () pos =
  let to_read = maxlen - pos in
    if to_read < 32000 then begin
      let len = pos - begin_pos in
	String.blit inbuf begin_pos inbuf 0 len;
	iter3 0 () len
    end else
      let nread = Unix.read Unix.stdin inbuf pos to_read in
	if nread = 0 then raise End_of_file;
	let end_pos = pos + nread in
	  iter4 begin_pos pos end_pos

and iter4 begin_pos pos end_pos =
  if pos = end_pos then
    iter3 begin_pos () end_pos
  else
    match inbuf.[pos] with
	'\n' | '\r' ->
	  if pos > begin_pos then begin
	    if !buffer_pos < buffer_len then begin
	      let (ix, ox) = Unix.pipe () in
		match Unix.fork () with
		  | -1 -> assert false
		  | 0 ->
		      reverse ();
		      output stdout inbuf begin_pos (pos - begin_pos);
		      output_char stdout '\n';
		      ignore (Unix.write ox "X" 0 1);
		      Unix.close ox;
		      exit 0;
		  | _ ->
		      wait_for := Some ix;
		      buffer_pos := buffer_len;
	    end else begin
	      output stdout inbuf begin_pos (pos - begin_pos);
	      output_char stdout '\n';
	      flush stdout;
	    end
	  end;
	  iter2 (pos+1) (pos+1) end_pos
      | _ ->
	  iter4 begin_pos (pos+1) end_pos

let read () =
    iter1 0 () 0

let main () =
  enter "main64" [];
  try
    read ()
  with End_of_file -> reverse ()
    | e ->
	Printf.fprintf stderr "exception %s\n%!" (Printexc.to_string e);
	exit 2

end

let _ =
  if arch64 then
    IMPLEMENTATION64.main ()
  else
    IMPLEMENTATION32.main ()
(*
 * $Id: reversefile.ocaml-2.ocaml,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let _ =
  let lines = ref [] in
  let rec loop l =
    l := read_line () :: !l;
    loop l in
  try loop lines with End_of_file -> List.iter print_endline !lines
(*
 * $Id: reversefile.ocaml-3.ocaml,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let rec rev_file acc =
  match try Some (read_line ()) with End_of_file -> None with
  | Some line -> rev_file (line :: acc)
  | None -> acc

let _ = List.iter print_endline (rev_file [])
(*
 * $Id: reversefile.ocaml-4.ocaml,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 *)

let rev_file_to_slist file =
  let rec my_rev_file_to_slist file accu =
    match
      try Some (input_line file)
      with End_of_file -> None
    with
      Some line -> my_rev_file_to_slist file (line :: accu)
    | None -> accu in
  my_rev_file_to_slist file [];;

List.iter print_endline (rev_file_to_slist stdin);;
exit 0;;
(*
 * $Id: reversefile.ocaml-5.ocaml,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Pierre Weis
 *)

let _ =
  let i = ref 0
  and nlines = ref 100 in
  let lines = ref (Array.make !nlines "") in

  let rec loop j =
    let line = read_line () in
    if j >= !nlines then begin
      nlines := 2 * !nlines;
      lines := Array.append !lines !lines
    end;
    !lines.(j) <- line;
    incr i;
    loop (j + 1) in

  try loop 0 with
  | End_of_file ->
      for j = !i - 1 downto 0 do print_endline !lines.(j) done
(*
 * $Id: reversefile.ocaml,v 1.1 2004-05-19 18:12:18 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * author: Jean-Francois Monin
 * date: Thu Jan 27 00:28:51 CET 2001
 * France Telecom R & D, Lannion
 * ocamlopt -noassert -unsafe -ccopt -O3 rev.ml -o rev
 *)

let size = 10000

let rec lect stack buf pos free =
  let nrd = input stdin buf pos free in
  if nrd = 0 then stack, buf, pos (* buf filled only until pos *)
  else if nrd = free then lect (buf :: stack) (String.create size) 0 size
  else lect stack buf (pos + nrd) (free - nrd)

let output_buf (buf, len) = output stdout buf 0 len

let rec rev_write tail stack buf len pos =
  if pos = 0 then
    match stack with
    | [] -> output stdout buf 0 len; List.iter output_buf tail
    | topbuf :: stack ->
        let toplen = String.length topbuf in
        rev_write ((buf, len) :: tail) stack topbuf toplen toplen
  else if buf.[pos - 1] = '\n' then
    begin
      output stdout buf pos (len - pos);
      List.iter output_buf tail;
      rev_write [] stack buf pos (pos - 1)
    end
  else rev_write tail stack buf len (pos - 1);;

let stack, buf, length = lect [] (String.create size) 0 size;;
rev_write [] stack buf length length
(*
 * $Id: sieve.ocaml,v 1.1 2004-05-19 18:12:27 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code from Markus Mottl
 * slightly improved by Claude Marche and Jean-Christophe Filliatre
 *)

let init_flags = String.make 8193 't'
let flags = String.make 8193 't'

let rec inner_loop f i k =
  if k < 8193 then begin f.[k] <- 'f'; inner_loop f i (k + i) end

let rec middle_loop f i cnt =
  if i < 8193 then
    if f.[i] = 't' then begin
      inner_loop f i (i + i);
      middle_loop f (i + 1) (cnt + 1) end
    else middle_loop f (i + 1) cnt
  else cnt

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
for iter = 2 to n do
  String.blit init_flags 0 flags 0 8193;
  ignore (middle_loop flags 2 0);
done;
Printf.printf "Count: %d\n" (middle_loop flags 2 0)
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Cleanup by Troestler Christophe
 * Modified by Mauricio Fernandez
 *)

let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

let eval_A_times_u u v =
  let n = Array.length v - 1 in
  for i = 0 to  n do
    let vi = ref 0. in
      for j = 0 to n do vi := !vi +. eval_A i j *. u.(j) done;
      v.(i) <- !vi
  done

let eval_At_times_u u v =
  let n = Array.length v -1 in
  for i = 0 to n do
    let vi = ref 0. in
      for j = 0 to n do vi := !vi +. eval_A j i *. u.(j) done;
      v.(i) <- !vi
  done

let eval_AtA_times_u u v =
  let w = Array.make (Array.length u) 0.0 in
  eval_A_times_u u w; eval_At_times_u w v


let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ ->  2000 in
  let u = Array.make n 1.0  and  v = Array.make n 0.0 in
  for i = 0 to 9 do
    eval_AtA_times_u u v; eval_AtA_times_u v u
  done;

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  done;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Cleanup by Troestler Christophe
 * Parallelized by Mauricio Fernandez
 *)

open Bigarray
type v = (float, float64_elt, c_layout) Array1.t

let max_workers = 8

let map_chunks f low hi =
  let step = (hi - low) / max_workers in
  let rec loop acc n =
    if n < hi then
      let n' = n + step in loop (f (n, (min hi n')) :: acc) n'
    else acc
  in loop [] low

let wait_for = List.iter (fun f -> f())

(* original function due to Jon D. Harrop *)
let invoke (f : 'a -> 'b) x : unit -> 'b =
  let input, output = Unix.pipe() in
  match Unix.fork() with
  | -1 -> Unix.close input; Unix.close output; (let v = f x in fun () -> v)
  | 0 ->
      Unix.close input;
      let output = Unix.out_channel_of_descr output in
        Marshal.to_channel output (try `Res(f x) with e -> `Exn e) [];
        close_out output;
        exit 0
  | pid ->
      Unix.close output;
      let input = Unix.in_channel_of_descr input in fun () ->
        let v = Marshal.from_channel input in
        ignore (Unix.waitpid [] pid);
        close_in input;
        match v with `Res x -> x | `Exn e -> raise e

let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

let eval_A_times_u (u : v) (v : v) =
  let n = Array1.dim v - 1 in
  let compute (p, q) =
    for i = p to q do
      let vi = ref 0. in
        for j = 0 to n do vi := !vi +. eval_A i j *. u.{j} done;
        v.{i} <- !vi
    done
  in wait_for (map_chunks (invoke compute) 0 n)

let eval_At_times_u (u : v) (v : v) =
  let n = Array1.dim v - 1 in
  let compute (p, q) =
    for i = p to q do
      let vi = ref 0. in
        for j = 0 to n do vi := !vi +. eval_A j i *. u.{j} done;
        v.{i} <- !vi
    done
  in wait_for (map_chunks (invoke compute) 0 n)

let make_array n x =
  let v = Array1.map_file
            (Unix.openfile "/dev/zero" [Unix.O_RDWR] 0o755)
            float64 c_layout true n in
    for i = 0 to n - 1 do v.{i} <- x done;
    v

let eval_AtA_times_u u v =
  let w = make_array (Array1.dim u) 0.0 in
  eval_A_times_u u w; eval_At_times_u w v

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ ->  2000 in
  let u = make_array n 1.0  and  v = make_array n 0.0 in
  for i = 0 to 9 do
    eval_AtA_times_u u v; eval_AtA_times_u v u
  done;

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.{i} *. v.{i};
    vBv := !vBv +. u.{i} *. v.{i}
  done;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))

(*
 * $Id: spellcheck.ocaml-2.ocaml,v 1.1 2004-11-10 06:47:52 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let main () =
  let n = 
     try int_of_string Sys.argv.(1)
     with Invalid_argument _ -> 1 in
  let dict = Hashtbl.create n in

  let ic = open_in "Usr.Dict.Words" in
  let rec read_dict() =
    Hashtbl.add dict (input_line ic) true;
    read_dict() in
  try read_dict()
  with End_of_file -> close_in ic;
  
  let rec read_input() =
    let word = read_line() in
    try
      ignore(Hashtbl.find dict word); read_input()
    with Not_found ->
      ignore(print_endline(word); read_input()) in
  try read_input()
  with End_of_file -> ignore ();
  exit 0;;

main ();;
(*
 * $Id: spellcheck.ocaml,v 1.1 2004-05-19 18:13:26 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let dict = Hashtbl.create 40000 and ic = open_in "Usr.Dict.Words" in
try while true do Hashtbl.add dict (input_line ic) true done
with End_of_file -> close_in ic;
let rec loop () =
  let word = input_line stdin in
  if not (Hashtbl.mem dict word) then print_endline word;
  loop () in
try loop () with End_of_file -> ()
(*
 * $Id: strcat.ocaml,v 1.1 2004-05-19 18:13:35 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let buf = Buffer.create 0;;
for i = 1 to n do Buffer.add_string buf "hello\n" done;
Printf.printf "%d\n" (Buffer.length buf); Unix.sleep(1)
(*
 * $Id: strcat.ocaml-2.ocaml,v 1.1 2004-11-10 06:44:59 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 *)

let _ =
  let n =
    try int_of_string Sys.argv.(1)
    with Invalid_argument _ -> 1 in
  let str = ref "" in
  for i = 1 to n do
    str := !str ^ "hello\n"
  done;
  Printf.printf "%d\n" (String.length !str)

(*
 * $Id: sumcol.ocaml,v 1.1 2004-05-19 18:13:44 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let sum = ref 0
let rec loop () = sum := !sum + int_of_string (input_line stdin); loop ();;
try loop () with End_of_file -> Printf.printf "%d\n" !sum
(* takfp.ml                                                 -*-tuareg-*-
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by William Douglas Neumann
 *)

let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = try float_of_string(Array.get Sys.argv 1) with _ -> 7. in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)
(* tcp-request-reply.ml / tcp-echo.ml / tcp-stream.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

let m = 6400 and reply_size = 64  (* tcp-echo *)

let request_size = 64
let buffer_size  = 4096
let port	 = 11000

let reply   = String.create reply_size
let request = String.create request_size

(* Monomorphic version for speed *)
let min i j = if (i:int) < j then i else j

(* Return [false] if EOF is reached *)
let rec read sock buf n =
  n <= 0 || (let r = Unix.read sock buf 0 (min n buffer_size) in
	     r > 0 && read sock buf (n - r))

let server sock =
  let b = String.create buffer_size in
  let (s, _) = Unix.accept sock in
  while read s b request_size do ignore(Unix.write s reply 0 reply_size) done;
  Unix.close s;
  Unix.close sock

let client n =
  let b = String.create buffer_size
  and replies = ref 0 and bytes = ref 0 in (* useless but mandated by spec *)
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.connect sock (Unix.ADDR_INET(Unix.inet_addr_loopback, port));
  for i = 1 to n do
    ignore(Unix.write sock request 0 request_size);
    ignore(read sock b reply_size);
    bytes := !bytes + reply_size;
    incr replies
  done;
  Unix.close sock;
  Printf.printf "replies: %i\tbytes: %i\n" !replies !bytes; flush stdout


let () =
  let n = m * (try int_of_string Sys.argv.(1) with _ -> 10) in
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.setsockopt sock Unix.SO_REUSEADDR true;
  Unix.bind sock (Unix.ADDR_INET(Unix.inet_addr_any, port));
  Unix.listen sock 1;
  match Unix.fork() with
  | 0 ->   server sock
  | pid -> client n; ignore(Unix.wait())

(* tcp-request-reply.ml / tcp-echo.ml / tcp-stream.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

let m = 100 and reply_size = 4096 (* tcp-request-reply *)

let request_size = 64
let buffer_size  = 4096
let port	 = 11000

let reply   = String.create reply_size
let request = String.create request_size

(* Monomorphic version for speed *)
let min i j = if (i:int) < j then i else j

(* Return [false] if EOF is reached *)
let rec read sock buf n =
  n <= 0 || (let r = Unix.read sock buf 0 (min n buffer_size) in
	     r > 0 && read sock buf (n - r))

let server sock =
  let b = String.create buffer_size in
  let (s, _) = Unix.accept sock in
  while read s b request_size do ignore(Unix.write s reply 0 reply_size) done;
  Unix.close s;
  Unix.close sock

let client n =
  let b = String.create buffer_size
  and replies = ref 0 and bytes = ref 0 in (* useless but mandated by spec *)
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.connect sock (Unix.ADDR_INET(Unix.inet_addr_loopback, port));
  for i = 1 to n do
    ignore(Unix.write sock request 0 request_size);
    ignore(read sock b reply_size);
    bytes := !bytes + reply_size;
    incr replies
  done;
  Unix.close sock;
  Printf.printf "replies: %i\tbytes: %i\n" !replies !bytes; flush stdout


let () =
  let n = m * (try int_of_string Sys.argv.(1) with _ -> 10) in
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.setsockopt sock Unix.SO_REUSEADDR true;
  Unix.bind sock (Unix.ADDR_INET(Unix.inet_addr_any, port));
  Unix.listen sock 1;
  match Unix.fork() with
  | 0 ->   server sock
  | pid -> client n; ignore(Unix.wait())

(* tcp-request-reply.ml / tcp-echo.ml / tcp-stream.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

let m = 1 and reply_size = 409600 (* tcp-stream *)

let request_size = 64
let buffer_size  = 4096
let port	 = 11000

let reply   = String.create reply_size
let request = String.create request_size

(* Monomorphic version for speed *)
let min i j = if (i:int) < j then i else j

(* Return [false] if EOF is reached *)
let rec read sock buf n =
  n <= 0 || (let r = Unix.read sock buf 0 (min n buffer_size) in
	     r > 0 && read sock buf (n - r))

let server sock =
  let b = String.create buffer_size in
  let (s, _) = Unix.accept sock in
  while read s b request_size do ignore(Unix.write s reply 0 reply_size) done;
  Unix.close s;
  Unix.close sock

let client n =
  let b = String.create buffer_size
  and replies = ref 0 and bytes = ref 0 in (* useless but mandated by spec *)
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.connect sock (Unix.ADDR_INET(Unix.inet_addr_loopback, port));
  for i = 1 to n do
    ignore(Unix.write sock request 0 request_size);
    ignore(read sock b reply_size);
    bytes := !bytes + reply_size;
    incr replies
  done;
  Unix.close sock;
  Printf.printf "replies: %i\tbytes: %i\n" !replies !bytes; flush stdout


let () =
  let n = m * (try int_of_string Sys.argv.(1) with _ -> 10) in
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.setsockopt sock Unix.SO_REUSEADDR true;
  Unix.bind sock (Unix.ADDR_INET(Unix.inet_addr_any, port));
  Unix.listen sock 1;
  match Unix.fork() with
  | 0 ->   server sock
  | pid -> client n; ignore(Unix.wait())

(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   Contributed by Charles Martin. *)

let size = 503

let n = int_of_string Sys.argv.(1)

let run id ichan ochan =
  let rec loop () =
    let token = Event.sync (Event.receive ichan) in
    if token = n then (print_int id; print_newline (); exit 0)
    else (Event.sync (Event.send ochan (token + 1)); loop ())
  in Thread.create loop ()

let () =
  let channels =
    Array.init size
      (fun _ -> Event.new_channel ()) in
  let threads =
    Array.init size
      (fun i -> run (i + 1) channels.(i) channels.((i + 1) mod size)) in
  Event.sync (Event.send channels.(0) 0);
  Thread.join threads.(0)
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Tomasz bla Fortuna *)

let size = 503
and n = int_of_string Sys.argv.(1)

type channel = { m : Mutex.t; d : int ref }
let channel () =
  let mx = Mutex.create () in Mutex.lock mx;
  { m = mx; d = ref 0}

let rec spawn id i o loop () =
  let rec thread () =
    Mutex.lock i.m;
    if !(i.d) = n then (
      print_int (size-id+1); print_newline (); exit 0;
    );
    o.d := !(i.d) + 1;  (* Forward token *)
    Mutex.unlock o.m;
    thread ()
  in
  if id > 1 then (
    let new_o = if id = 2 then loop else channel () in
    let f = spawn (id-1) o new_o loop in
    ignore (Thread.create f ())
  );
  thread ()

let _ =
  let loop, o = channel (), channel () in
  Mutex.unlock loop.m;
  Thread.join (Thread.create (spawn size loop o loop) ())
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Tomasz bla Fortuna *)

let size, n = 503, int_of_string Sys.argv.(1)
let mutex = 
  let f _ = let m = Mutex.create () in Mutex.lock m; m in
  Array.init size f
and data = Array.create size 0

let run id idata odata =
  let rec loop () =
    Mutex.lock mutex.(idata);
    if data.(idata) = n then (
      print_int id; print_newline (); exit 0;
    ) else (
      data.(odata) <- data.(idata) + 1;
      Mutex.unlock mutex.(odata);
      loop ();
    )
  in Thread.create loop ()

let _ =
  let thread =
    Array.init size
      (fun i -> run (i + 1) i ((i + 1) mod size)) in
  Mutex.unlock mutex.(0);
  Thread.join thread.(0)



(*
 * $Id: wc.ocaml,v 1.1 2004-05-19 18:13:51 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code by Cuihtlauac ALVARADO and Markus Mottl
 *)

let nl = ref 0 and nw = ref 0 and nc = ref 0 and max = 4096
let buf = String.create max

let readblock scanfun =
  let nread = input stdin buf 0 max in
  if nread = 0 then ()
  else begin nc := !nc + nread; scanfun 0 nread end

let rec scan_out_of_word i n =
  if i < n then
    match buf.[i] with
    | '\n' -> incr nl; scan_out_of_word (i + 1) n
    | ' ' | '\t' -> scan_out_of_word (i + 1) n
    | _ -> incr nw; scan_in_word (i+1) n
  else readblock scan_out_of_word

and scan_in_word i n =
  if i < n then
    match buf.[i] with
    | '\n' -> incr nl; scan_out_of_word (i + 1) n
    | ' '|'\t' -> scan_out_of_word (i + 1) n
    | _ -> scan_in_word (i + 1) n
  else readblock scan_in_word;;

scan_out_of_word 0 0;
Printf.printf "%d %d %d\n" !nl !nw !nc
(*
 * $Id: wordfreq.ocaml2.ocaml,v 1.1 2004-05-19 18:14:24 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let max = 4096
let buf = String.create max
let wc = Hashtbl.create 75000
let wbuf = Buffer.create 64


let read_block () = 
  let nread = input stdin buf 0 max in
  if nread = 0 then raise End_of_file
  else nread


let is_alpha i =
  let c = buf.[i] in
  if 'a' <= c && c <= 'z' then begin
    Buffer.add_char wbuf c;
    true
  end
  else
    if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr(Char.code c + 32));
      true
    end
    else
      false


let rec scan_word i n =
  if i < n then
    if is_alpha i then scan_word (i+1) n
    else begin
      let word = Buffer.contents wbuf in
      begin try incr (Hashtbl.find wc word)
      with Not_found -> Hashtbl.add wc word (ref 1) end;
      Buffer.clear wbuf;
      scan_non_word (i+1) n
    end
  else
    scan_word 0 (read_block ())

and scan_non_word i n =
  if i < n then
    if is_alpha i then scan_word (i+1) n
    else scan_non_word (i+1) n
  else
    scan_non_word 0 (read_block ())


let cmp_pairs (c1, w1) (c2, w2) =
  let cmp_c = compare c2 c1 in
  if cmp_c = 0 then compare w2 w1
  else cmp_c

let print (c, w) = Printf.printf "%7d\t%s\n" c w
let to_assoc wcpairs w c = wcpairs := (!c, w) :: !wcpairs

let _ =
  begin try scan_non_word 0 0
  with End_of_file -> () end;
  let wcpairs = ref [] in
  Hashtbl.iter (to_assoc wcpairs) wc;
  List.iter print (List.sort cmp_pairs !wcpairs)
(*
 * $Id: wordfreq.ocaml3.ocaml,v 1.1 2004-05-19 18:14:24 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let max = 4096
let buf = String.create max
let wc = Hashtbl.create 75000
let wbuf = Buffer.create 64

type state = Inside | Outside

let read_block () = 
  let nread = input stdin buf 0 max in
  if nread = 0 then raise End_of_file
  else nread


let rec scan_words i n w =
  if i < n then
    let c = buf.[i] in
    match c with
      'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z' ->
	begin
	  Buffer.add_char wbuf c;
	  scan_words (i+1) n Inside
	end
	  
      'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z' ->
	begin
	  Buffer.add_char wbuf (Char.unsafe_chr(Char.code c + 32));
	  scan_words (i+1) n Inside
	end

	  _ ->
	begin
	  if w = Inside then
	    begin
	      let word = Buffer.contents wbuf in
	      begin try incr (Hashtbl.find wc word)
	      with Not_found -> Hashtbl.add wc word (ref 1) end;
	      Buffer.clear wbuf
	    end
	      scan_words (i+1) n Outside
	end
  else
    scan_words 0 (read_block ()) w

let cmp_pairs (c1, w1) (c2, w2) =
  let cmp_c = compare c2 c1 in
  if cmp_c = 0 then compare w2 w1
  else cmp_c

let print (c, w) = Printf.printf "%7d\t%s\n" c w
let to_assoc wcpairs w c = wcpairs := (!c, w) :: !wcpairs

let _ =
  begin try scan_non_word 0 0
  with End_of_file -> () end;
  let wcpairs = ref [] in
  Hashtbl.iter (to_assoc wcpairs) wc;
  List.iter print (List.sort cmp_pairs !wcpairs)
(*
 * $Id: wordfreq.ocaml5.ocaml,v 1.1 2004-05-19 18:14:24 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let max = 4096
let buf = String.create max
let count = Hashtbl.create 75000
let wbuf = Buffer.create 64

type state = Inside | Outside

let rec scan_words i n w =
  if i < n then
    let c = buf.[i] in
    if 'a' <= c && c <= 'z' then begin
      Buffer.add_char wbuf c;
      scan_words (i+1) n Inside
    end
    else if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr(Char.code c + 32));
      scan_words (i+1) n Inside
    end
    else if w = Inside then begin
      let word = Buffer.contents wbuf in
      begin try incr (Hashtbl.find count word)
      with Not_found -> Hashtbl.add count word (ref 1) end;
      Buffer.clear wbuf;
      scan_words (i+1) n Outside
    end else
      scan_words (i+1) n Outside
  else
    match input stdin buf 0 max with
      0     -> raise End_of_file
    | nread -> scan_words 0 nread w

let to_list l w c =
  l := (Printf.sprintf "%7d\t%s" !c w) :: !l

let _ =
  begin try scan_words 0 0 Outside
  with End_of_file -> () end;
  let outputlist = ref [] in
  Hashtbl.iter (to_list outputlist) count;
  List.iter print_endline (List.sort
			    (fun a b -> compare b a)
			    !outputlist)
(*
 * $Id: wordfreq.ocaml6.ocaml,v 1.1 2004-05-19 18:14:24 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

let max = 4096
let buf = String.create max
let count = Hashtbl.create 75000
let wbuf = Buffer.create 64
let cnt = ref 0

let readblock scanfun =
  let nread = input stdin buf 0 max in
  if nread = 0 then () else scanfun 0 nread


let rec scan_out_word i n =
  if i < n then
    let c = buf.[i] in
    if 'a' <= c && c <= 'z' then begin
      Buffer.add_char wbuf c;
      scan_in_word (i+1) n
    end
    else if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr(Char.code c + 32));
      scan_in_word (i+1) n
    end
    else
      scan_out_word (i+1) n
  else
    readblock scan_out_word

and scan_in_word i n =
  if i < n then
    let c = buf.[i] in
    if 'a' <= c && c <= 'z' then begin
      Buffer.add_char wbuf c;
      scan_in_word (i+1) n
    end
    else if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr(Char.code c + 32));
      scan_in_word (i+1) n
    end
    else begin
      let word = Buffer.contents wbuf in
      begin try incr (Hashtbl.find count word)
      with Not_found -> incr cnt; Hashtbl.add count word (ref 1) end;
      Buffer.clear wbuf;
      scan_out_word (i+1) n
    end
  else
    readblock scan_in_word

let _ =
  scan_out_word 0 0;
  let outputlines = Array.make !cnt "" in
  let i = ref 0 in
  let stringify a w c =
    a.(!i) <- Printf.sprintf "%7d\t%s\n" !c w;
    incr i in
  Hashtbl.iter (stringify outputlines) count;
  Array.stable_sort (fun a b -> compare b a) outputlines;
  Array.iter print_string outputlines
(*
 * $Id: wordfreq.ocaml,v 1.3 2004-09-29 06:24:32 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * with help from Markus Mottl
 *)

let max = 4096
let buf = String.create max
let count = Hashtbl.create 75000 and wbuf = Buffer.create 64
let to_list w c l = Printf.sprintf "%7d %s" !c w :: l

let rec scan_words i n inword =
  if i < n then
    let c = buf.[i] in
    if 'a' <= c && c <= 'z' then begin
      Buffer.add_char wbuf c;
      scan_words (i + 1) n true
    end
    else if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr (Char.code c + 32));
      scan_words (i + 1) n true
    end
    else if inword then begin
      let word = Buffer.contents wbuf in
      begin try incr (Hashtbl.find count word)
      with Not_found -> Hashtbl.add count word (ref 1) end;
      Buffer.clear wbuf;
      scan_words (i + 1) n false
    end
    else scan_words (i + 1) n false
  else
    let nread = input stdin buf 0 max in
    if nread <> 0 then scan_words 0 nread inword;;

scan_words 0 0 false;

let out_lines = Hashtbl.fold (fun k d l -> (k, !d) :: l) count [] in
List.iter (fun (k, d) -> Printf.printf "%7d %s\n" d k)
  (List.sort (fun (ka, da) (kb, db) -> 
                let c = compare db da in
                if c <> 0 then c
                else String.compare kb ka) out_lines)

