// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Minor modification by Don Syme & Jomo Fisher to use null as representation
// of Empty node.
// Based on F# version by Robert Pickering
// Based on ocaml version by Troestler Christophe & Isaac Gouy


[<CompilationRepresentation(CompilationRepresentationFlags
  .UseNullAsTrueValue)>]
type Tree<'T> = 
    | Empty 
    | Node of Tree<'T> * 'T * Tree<'T>

let rec make i d =
    if d = 0 then 
        Node(Empty, i, Empty)
    else
        let i2 = 2 * i
        let d = d - 1
        Node(make (i2 - 1) d, i, make i2 d)

let rec check x = 
    match x with 
    | Empty -> 0 
    | Node(l, i, r) -> i + check l - check r

let rec loopDepths maxDepth minDepth d =
    if d <= maxDepth then
        let niter = 1 <<< (maxDepth - d + minDepth)
        let mutable c = 0
        for i = 1 to niter do 
            c <- c + check (make i d) + check (make (-i) d)
        printf "%i\t trees of depth %i\t check: %i\n" (2 * niter) d c
        loopDepths maxDepth minDepth (d + 2)

[<EntryPoint>]
let main args =
    let minDepth = 4
    let maxDepth =
        let n = if args.Length > 0 then int args.[0] else 10
        max (minDepth + 2) n
    let stretchDepth = maxDepth + 1

    let c = check (make 0 stretchDepth)
    printf "stretch tree of depth %i\t check: %i\n" stretchDepth c
    let longLivedTree = make 0 maxDepth
    loopDepths maxDepth minDepth minDepth
    printf "long lived tree of depth %i\t check: %i\n" 
           maxDepth 
           (check longLivedTree)
    0

﻿// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Modification by Don Syme & Jomo Fisher to use null as representation
// of Empty node and to use a single Next element.
// Based on F# version by Robert Pickering
// Based on ocaml version by Troestler Christophe & Isaac Gouy

open System
open Unchecked

type Next = { Left: Tree; Right: Tree }
and [<Struct>] Tree(next:Next,item:int) =
    member t.Check() =
        match box next with 
        | null -> item
        | _ -> item + next.Left.Check() - next.Right.Check()

let rec make item depth =
    if depth > 0 then Tree({Left = make (2*item-1) (depth-1); Right=make (2*item) (depth-1)}, item)
    else Tree(defaultof<_>,item)

let inline check (tree:Tree) = tree.Check()

let rec loopDepths maxDepth minDepth d =
    if d <= maxDepth then
        let niter = 1 <<< (maxDepth - d + minDepth)
        let mutable c = 0
        for i = 1 to niter do
            c <- c + check (make i d) + check (make (-i) d)
        Console.WriteLine("{0}\t trees of depth {1}\t check: {2}",2 * niter,d,c)
        loopDepths maxDepth minDepth (d + 2)

[<EntryPoint>]
let main args =
    let minDepth = 4
    let maxDepth =
        let n = if args.Length > 0 then int args.[0] else 10
        max (minDepth + 2) n
    let stretchDepth = maxDepth + 1

    let c = check (make 0 stretchDepth)
    Console.WriteLine("stretch tree of depth {0}\t check: {1}",stretchDepth,c)
    let longLivedTree = make 0 maxDepth
    loopDepths maxDepth minDepth minDepth
    Console.WriteLine("long lived tree of depth {0}\t check: {1}",maxDepth,(check longLivedTree))
    exit 0
﻿(*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
*
* Based on contribution of Isaac Gouy
* Based on contribution of Eckehard Berns
* Based on code by Heiner Marxen
* and the ATS version by Hongwei Xi
* convert to C# by The Anh Tran
* convert to F# by Jomo Fisher
*)
open System
open System.Threading

let mutable n = 0
let mutable flip_max_arr : int array = null
let remain_task = ref -1
let threads = Environment.ProcessorCount

// Return next permut, by rotating elements [0 - position] one 'step'
// next_perm('1234', 2) -> '2314'
let next_perm(permutation:int array, position) = 
    let perm0 = permutation.[0]
    for i in 0..position-1 do 
        permutation.[i] <- permutation.[i + 1]
    permutation.[position] <- perm0

// In order to divide tasks 'equally' for many threads, permut generation
// strategy is different than that of original single thread.
// this function will 'correctly' print first 30 permutations
let print_30_permut() = 

    // declare and initialize
    let permutation : int array = Array.init n (fun i-> Console.Write(i+1);i)
    Console.WriteLine();

    let perm_remain = Array.init n (fun i->i+1)

    let mutable numPermutationsPrinted = 1
    let mutable finished = false
    let mutable pos_right = 2 

    while not finished && pos_right<=n do
        let mutable pos_left = pos_right - 1;
        while not finished && pos_left < pos_right do 

            // rotate down perm[0..prev] by one
            next_perm(permutation, pos_left)

            perm_remain.[pos_left] <- perm_remain.[pos_left] - 1 
            if perm_remain.[pos_left] > 0 then
                numPermutationsPrinted<-numPermutationsPrinted+1
                if numPermutationsPrinted < 31 then
                    for i in 0..n-1 do 
                        Console.Write("{0}", (1 + permutation.[i]))
                    Console.WriteLine()
                else
                    finished<-true
                    pos_right<-n

                if not finished then 
                    while pos_left <> 1 do
                        perm_remain.[pos_left - 1] <- pos_left
                        pos_left <- pos_left - 1
            else
                pos_left <- pos_left + 1
        pos_right <- pos_right + 1

// Take a permut array, continuously flipping until first element is '1'
// Return flipping times
let public count_flip (perm_flip:int array) = 
    // cache first element, avoid swapping perm[0] and perm[k]
    let mutable v0 = perm_flip.[0]
    let mutable tmp = 0
    let mutable flip_count = 0
    let mutable finished = false
    while not finished do
        let mutable i = 1
        let mutable j = v0 - 1 
        while i<j do 
            tmp <- perm_flip.[i]
            perm_flip.[i] <- perm_flip.[j]
            perm_flip.[j] <- tmp
            i <- i + 1
            j <- j - 1

        tmp <- perm_flip.[v0]
        perm_flip.[v0] <- v0
        v0 <- tmp;

        flip_count <- flip_count + 1
        finished <- v0 = 0 // first element == '1'

    flip_count

let worker() =
    let permutation = Array.zeroCreate n
    let perm_remain = Array.zeroCreate n
    let perm_flip = Array.zeroCreate n

    let mutable pos_right = Interlocked.Increment(&remain_task.contents)
    while (pos_right < n - 1) do
        let mutable flip_max = 0

        for i in 0..n-2 do 
            permutation.[i] <- i

        permutation.[pos_right] <- n - 1
        permutation.[n - 1] <- pos_right

        for i in 1..n do 
            perm_remain.[i - 1] <- i

        let mutable pos_left = n - 2
        while pos_left < n - 1 do
            // rotate down perm[0..r] by one
            next_perm(permutation, pos_left)

            perm_remain.[pos_left]<-perm_remain.[pos_left] - 1

            if perm_remain.[pos_left] > 0 then 
                while pos_left<>1 do
                    perm_remain.[pos_left - 1] <- pos_left
                    pos_left <- pos_left - 1

                if permutation.[0] <> 0 && permutation.[n-1]<>n-1 then 
                    for ip in 0..n-1 do
                        perm_flip.[ip] <- permutation.[ip]
                    let flipcount = count_flip(perm_flip)
                    if flip_max < flipcount then
                        flip_max <- flipcount
            else
                pos_left<-pos_left+1


        // update max_flip foreach flipping position
        flip_max_arr.[pos_right] <- flip_max

        pos_right <- Interlocked.Increment(&remain_task.contents)

        

let fank_game() = 
    let th : Thread array = Array.init threads (fun i->
                                                    let th=Thread(worker)
                                                    th.Start()
                                                    th)
    print_30_permut()

    for t in th do t.Join()

    let mutable mx = 0
    for i in flip_max_arr do
        if (mx < i) then
            mx <- i
    mx


[<EntryPoint>]
let main args = 
    n <- if args.Length > 0 then int args.[0] else 7
    // hold flip_count result for each swapping index
    flip_max_arr <- Array.zeroCreate n
    Console.WriteLine("Pfannkuchen({0}) = {1}", n, fank_game())
    0
(* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * contributed by Alex Peake
 * Literal translation of Andrei Formiga's Scala solution
*)

#light

[<EntryPoint>]
let main(args) =
    let n = if args.Length > 0 then int args.[0] else 7
    //printfn "Pfannkuchen(%d) = %d" x (fannkuch x)

    let mutable maxFlips = 0
    let mutable permN = 0
    let mutable j = 0
    let mutable k = 0
    let mutable temp = 0
    let mutable first = 0
    let mutable flips = 0
    let mutable perm0 = Array.create n 0
    let mutable perm = Array.create n 0
    let mutable rot = Array.create n 0

    while (k < n) do
        perm.[k] <- k + 1
        rot.[k] <- 0
        k <- k + 1
    while (rot.[n - 1] < n) do
        if (permN < 30) then
            k <- 0
            while (k < n) do
                printf "%d" perm.[k]
                k <- k + 1
            printf "\n"
            permN <- permN + 1

        flips <- 0
        k <- 0
        while (k < n) do
            perm0.[k] <- perm.[k]
            k <- k + 1
        first <- perm0.[0]
        while (first <> 1) do
            k <- 0
            while (k < (first >>> 1)) do
                temp <- perm0.[k]
                perm0.[k] <- perm0.[first - 1 - k]
                perm0.[first - 1 - k] <- temp;
                k <- k + 1

            first <- perm0.[0]
            flips <- flips + 1

        if (flips > maxFlips) then maxFlips <- flips

        temp <- perm.[0]
        perm.[0] <- perm.[1]
        perm.[1] <- temp
        rot.[1] <- rot.[1] + 1
        j <- 1
        while (j < n - 1 && rot.[j] > j) do
            rot.[j] <- 0
            j <- j + 1

            k <- 0
            while (k < j) do
                temp <- perm.[k]
                perm.[k] <- perm.[k + 1]
                perm.[k + 1] <- temp
                k <- k + 1

            rot.[j] <- rot.[j] + 1

    printfn "Pfannkuchen(%d) = %d" n maxFlips
    0
(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   from Scala version by Otto Bommer, August 2010
*)

let fannkuch n =
  begin
  let perm1 = Array.create n 0 in for i = 0 to (n-1) do perm1.[i] <- i done;
  let perm = Array.create n 0
  let count = Array.create n 0
  let mutable flips = 0 
  let mutable maxflips = 0 
  let mutable checksum = 0 
  let mutable nperm = 0
  let mutable r = n
  while r > 0 do 
    for i = 0 to n-1 do perm.[i] <- perm1.[i] done;

    while r <> 1 do count.[r-1] <- r; r <- r - 1; done;

    flips <- 0;
    let k = ref perm.[0] in
    while !k <> 0 do
      let t = ref 0 in
      for i = 0 to !k / 2 do
        t := perm.[i];
        perm.[i] <- perm.[!k - i];
        perm.[!k - i] <- !t;
        done;
        
      k := perm.[0];
      flips <- flips + 1;
      done;

    maxflips <- max maxflips flips;
    if nperm &&& 1 = 0 then checksum <- checksum + flips else checksum <- checksum - flips
    
    let mutable go = true in
    let mutable t = 0 in
    while go do
      if r = n then begin go <- false; r <- 0; end
      else
        begin
        t <- perm1.[0];
        for i = 0 to r - 1 do perm1.[i] <- perm1.[i+1] done;
        perm1.[r] <- t;

        count.[r] <- count.[r] - 1;
        if count.[r] > 0 then go <- false
        else r <- r + 1;
        end
      done;

    nperm <- nperm + 1;
    done;

  (maxflips, checksum);
  end

let _ =
  let n = try int((System.Environment.GetCommandLineArgs()).[1]) with _ -> 7
  let (maxflips, checksum) = fannkuch n
  Printf.printf "%d\nPfannkuchen(%d) = %d\n" checksum n maxflips

﻿(* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   from Scala version by Otto Bommer, August 2010
   Modified by Faisal Waris by remvoing ref's and using mutable variables, April 25, 2011
*)

let fannkuch n =
  begin
  let perm1 = Array.create n 0 in for i = 0 to (n-1) do perm1.[i] <- i done;
  let perm = Array.create n 0
  let count = Array.create n 0
  let mutable flips = 0 
  let mutable maxflips = 0 
  let mutable checksum = 0 
  let mutable nperm = 0
  let mutable r = n
  while r > 0 do 
    for i = 0 to n-1 do perm.[i] <- perm1.[i] done;

    while r <> 1 do count.[r-1] <- r; r <- r - 1; done;

    flips <- 0;
    let mutable k = perm.[0] in
    while k <> 0 do
      let mutable t = 0 in
      for i = 0 to k / 2 do
        t <- perm.[i];
        perm.[i] <- perm.[k - i];
        perm.[k - i] <- t;
        done;
        
      k <- perm.[0];
      flips <- flips + 1;
      done;

    maxflips <- max maxflips flips;
    if nperm &&& 1 = 0 then checksum <- checksum + flips else checksum <- checksum - flips
    
    let mutable go = true in
    let mutable t = 0 in
    while go do
      if r = n then begin go <- false; r <- 0; end
      else
        begin
        t <- perm1.[0];
        for i = 0 to r - 1 do perm1.[i] <- perm1.[i+1] done;
        perm1.[r] <- t;

        count.[r] <- count.[r] - 1;
        if count.[r] > 0 then go <- false
        else r <- r + 1;
        end
      done;

    nperm <- nperm + 1;
    done;

  (maxflips, checksum);
  end

let _ =
  let n = try int((System.Environment.GetCommandLineArgs()).[1]) with _ -> 7
  let (maxflips, checksum) = fannkuch n
  Printf.printf "%d\nPfannkuchen(%d) = %d\n" checksum n maxflips
﻿// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

let im = 139968
let ia = 3877
let ic = 29573
let mutable seed = 42;

let inline random max =
    seed <- (seed * ia + ic) % im
    max * float seed / float im

let alu =
    "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
     GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
     CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
     ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
     GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
     AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
     AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"B

let makeCumulative = 
    List.fold (fun (cp, res) (c, p) -> cp + p, (c, cp + p) :: res) (0.0, []) 
    >> snd >> List.toArray

let homoSapiens = 
    makeCumulative
        ['a'B, 0.3029549426680
         'c'B, 0.1979883004921
         'g'B, 0.1975473066391
         't'B, 0.3015094502008]
     
let iub = 
    makeCumulative 
        ['a'B, 0.27; 'c'B, 0.12; 'g'B, 0.12
         't'B, 0.27; 'B'B, 0.02; 'D'B, 0.02
         'H'B, 0.02; 'K'B, 0.02; 'M'B, 0.02
         'N'B, 0.02; 'R'B, 0.02; 'S'B, 0.02
         'V'B, 0.02; 'W'B, 0.02; 'Y'B, 0.02]

let inline selectRandom (f: _ [])  =     
    let r = random 1.0 
    let rec find = function
        | 0 -> fst f.[0]
        | n when r < snd f.[n] -> fst f.[n]
        | n -> find (n - 1)
    find <| f.Length - 1
   
let width = 60 
let stream = System.Console.OpenStandardOutput ()
let buffer = Array.create 1024 0uy
let mutable index = 0
let inline flush () =    
    stream.Write (buffer, 0, index)
    index <- 0
let inline write b = 
    buffer.[index] <- b
    index <- index + 1
    if index = buffer.Length then flush ()        
    
let randomFasta desc table n =
    Array.iter write desc
    for i in 1 .. n do
        write <| selectRandom table
        if i % width = 0 then write '\n'B
    if n % width <> 0 then write '\n'B

let repeatFasta desc (table : byte []) n =
    Array.iter write desc 
    for i in 1 .. n do
        write <| table.[(i - 1) % table.Length]
        if i % width = 0 then write '\n'B
    if n % width <> 0 then write '\n'B
        
[<EntryPoint>]
let main args =
    let n = try int args.[0] with _ -> 1000
    repeatFasta ">ONE Homo sapiens alu\n"B alu (2 * n)
    randomFasta ">TWO IUB ambiguity codes\n"B iub (3 * n)
    randomFasta ">THREE Homo sapiens frequency\n"B homoSapiens  (5 * n)
    flush ()
    0
(* The Computer Language Benchmarks Game 
   http://shootout.alioth.debian.org/
   contributed by Isaac Gouy! *)

printf "hello world\n"
﻿(*   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Adapted by Antti Lankila from the earlier Isaac Gouy's implementation
   Add multithread & tweaks from C++ by The Anh Tran
   Ported to F# by Don Syme
   Add memory reduction and performance tweaks by Jomo Fisher
*)

open System
open System.Threading
open System.IO

let out = Console.OpenStandardOutput()

// Helper type to accumulate a bit array
type BitAccumulator(n) = 
    let numBytes = (n+7)/8
    let numBits = n &&& 7
    let mutable byteCount = 0
    let mutable bitNum = 0
    let mutable byteAcc = 0
    let mutable pdata : byte array = Array.zeroCreate numBytes

    member x.Reinit() = 
        byteCount <- 0
        bitNum <- 0
        byteAcc <- 0       

    member x.Add b =     
        byteAcc <- (byteAcc <<< 1) ||| (if b then 1 else 0);

        bitNum <- bitNum + 1
        if bitNum = 8 then 
           pdata.[byteCount] <- byte byteAcc;
           byteCount <- byteCount + 1;
           byteAcc <- 0;
           bitNum <- 0;

    member x.Close() =     
        // write left over bits
        if bitNum <> 0 then
            byteAcc <- byteAcc <<< (8 - numBits)
            pdata.[byteCount] <- byte byteAcc
            byteCount <- byteCount+1

    member x.Data = pdata
    member x.ByteCount = byteCount

type ThreadState(n) = 
    let ba = BitAccumulator(n)
    let mutable finishedLine = -1
    member ts.BitAccumulator = ba
    member ts.IsReadyToWork = finishedLine = -1
    member ts.SetFinishedLine(lineNumber) =
        finishedLine <- lineNumber
    member ts.TryWriteLine(nextLine) = 
        if finishedLine = nextLine then
            out.Write( ba.Data, 0, ba.ByteCount);
            finishedLine <- -1
            ba.Reinit()
            true
        else false

// Initialize an array by a parallel init using all available processors
let parallelArrayInit n f = 
    let currentLine = ref -1
    let lastWritten = ref -1
    let rec loop (ts:ThreadState) = 
        if ts.IsReadyToWork then 
            let y = Interlocked.Increment(&currentLine.contents)
            if y < n then 
                f ts.BitAccumulator y
                ts.SetFinishedLine(y)
                loop(ts)
        elif ts.TryWriteLine(!lastWritten + 1) then
            Interlocked.Increment(&lastWritten.contents) |> ignore
            loop(ts)
        else loop(ts)

    Async.Parallel [ for i in 1 .. Environment.ProcessorCount -> async {do loop(ThreadState(n)) } ] 
       |> Async.Ignore 
       |> Async.RunSynchronously

[<EntryPoint>]
let main args =
    let start = System.DateTime.Now
    let numLines = if (args.Length > 0) then int args.[0] else 200 
    Console.Out.Write("P4\n{0} {0}\n", numLines);
    let inversen = 2.0 / float numLines;

    parallelArrayInit numLines (fun ba y -> 

        let civ = float y * inversen - 1.0;

        for x = 0 to numLines - 1 do 
            let crv = float x * inversen - 1.5;

            let rec innerLoop i zrv ziv trv tiv = 
               let ziv = (zrv*ziv) + (zrv*ziv) + civ;
               let zrv = trv - tiv + crv;

               let trv = zrv * zrv;
               let tiv = ziv * ziv;
               if ((trv + tiv) <= 4.0) && (i > 0) then 
                   innerLoop (i-1) zrv ziv trv tiv
               else
                   i

            let i = innerLoop 49 crv civ (crv * crv) (civ * civ)
            ba.Add ((i = 0))
        ba.Close())

    0

﻿(*   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Adapted by Antti Lankila from the earlier Isaac Gouy's implementation
   Add multithread & tweaks from C++ by The Anh Tran
   Translate to F# by Jomo Fisher
*)

open System
open System.Threading
open System.IO

let mutable N = 200;
let mutable width_bytes = 0
let mutable data : byte array array = null
let mutable nbyte_each_line : int array = null
let current_line = ref -1 


let Calculate() = 
    let inverse_n = 2.0 / float N

    let mutable y = Interlocked.Increment(&current_line.contents)
    while y < N do // fetch a line
        let pdata = data.[y]

        let mutable byte_count = 0
        let mutable bit_num = 0
        let mutable byte_acc = 0

        let Civ = float y * inverse_n - 1.0

        for x in 0..N-1 do 
            let Crv = float x * inverse_n - 1.5

            let mutable Zrv = Crv
            let mutable Ziv = Civ
            let mutable Trv = Crv * Crv
            let mutable Tiv = Civ * Civ

            let mutable i = 49;
            let mutable more = true
            while more do
                Ziv <- (Zrv * Ziv) + (Zrv * Ziv) + Civ
                Zrv <- Trv - Tiv + Crv

                Trv <- Zrv * Zrv
                Tiv <- Ziv * Ziv
                
                more <- (Trv + Tiv) <= 4.0 
                if more then
                    i <- i - 1
                    more <- i > 0
                    
            byte_acc <- byte_acc <<< 1
            byte_acc <- byte_acc ||| (if i = 0 then 1 else 0)

            bit_num <- bit_num + 1
            if bit_num = 8 then
                pdata.[byte_count] <- byte byte_acc
                byte_count <- byte_count + 1
                bit_num <- 0
                byte_acc <- 0

        if bit_num <> 0 then  // write left over bits
            byte_acc <- byte_acc <<< (8 - (N &&& 7))
            pdata.[byte_count] <- byte byte_acc
            byte_count<-byte_count + 1

        nbyte_each_line.[y] <- byte_count
        y <- Interlocked.Increment(&current_line.contents)


[<EntryPoint>]
let main args = 
    if args.Length > 0 then
        N <- int args.[0]
    Console.Out.WriteLine("P4\n{0} {0}", N);

    width_bytes <- N / 8
    if width_bytes * 8 < N then
        width_bytes <- width_bytes + 1

    nbyte_each_line <- Array.zeroCreate N

    data <- Array.zeroCreate N 
    for i in 0..N-1 do 
        data.[i] <- Array.zeroCreate width_bytes 

    let threads = Array.init (Environment.ProcessorCount-1) (fun i->new Thread(Calculate))
    for thread in threads do thread.Start()
    Calculate()
    for thread in threads do thread.Join()
            
    let s = Console.OpenStandardOutput();
    for y in 0..N-1 do 
        s.Write(data.[y], 0, nbyte_each_line.[y])
    0
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

let pi = 3.141592653589793
let daysPerYear = 365.24
let solarMass = 4.0 * pi ** 2.0

type Planet =
    {mutable X: float; mutable Y: float; mutable Z: float
     mutable VX: float; mutable VY: float; mutable VZ: float
     Mass: float}

let jupiter =
    {X = 4.84143144246472090e+00
     Y = -1.16032004402742839e+00
     Z = -1.03622044471123109e-01
     VX = 1.66007664274403694e-03 * daysPerYear
     VY = 7.69901118419740425e-03 * daysPerYear
     VZ = -6.90460016972063023e-05 * daysPerYear
     Mass = 9.54791938424326609e-04 * solarMass}

let saturn =
    {X = 8.34336671824457987e+00
     Y = 4.12479856412430479e+00
     Z = -4.03523417114321381e-01
     VX = -2.76742510726862411e-03 * daysPerYear
     VY = 4.99852801234917238e-03 * daysPerYear
     VZ = 2.30417297573763929e-05 * daysPerYear
     Mass = 2.85885980666130812e-04 * solarMass}

let uranus =
    {X = 1.28943695621391310e+01
     Y = -1.51111514016986312e+01
     Z = -2.23307578892655734e-01
     VX = 2.96460137564761618e-03 * daysPerYear
     VY = 2.37847173959480950e-03 * daysPerYear
     VZ = -2.96589568540237556e-05 * daysPerYear
     Mass = 4.36624404335156298e-05 * solarMass}

let neptune =
    {X = 1.53796971148509165e+01
     Y = -2.59193146099879641e+01
     Z = 1.79258772950371181e-01
     VX = 2.68067772490389322e-03 * daysPerYear
     VY = 1.62824170038242295e-03 * daysPerYear
     VZ = -9.51592254519715870e-05 * daysPerYear
     Mass = 5.15138902046611451e-05 * solarMass}

let sun =
    {X = 0.0; Y = 0.0; Z = 0.0
     VX = 0.0; VY = 0.0; VZ = 0.0
     Mass = solarMass}

let offsetMomentum a =
    let x, y, z =
        Array.fold (fun (x, y, z) body ->
            let c = body.Mass / solarMass
            (x + c * body.VX, y + c * body.VY, z + c * body.VZ))
            (0.0, 0.0, 0.0) a
    a.[0].VX <- - x
    a.[0].VY <- - y
    a.[0].VZ <- - z

let move t =
    Array.iter (fun body ->
        body.X <- body.X + t * body.VX
        body.Y <- body.Y + t * body.VY
        body.Z <- body.Z + t * body.VZ)

let advance a t =
    for i in 0..Array.length a - 2 do
        let b1 = a.[i]
        for j in i + 1..Array.length a - 1 do
            let b2 = a.[j]
            let dx, dy, dz = b1.X - b2.X, b1.Y - b2.Y, b1.Z - b2.Z
            let dist = sqrt (dx * dx + dy * dy + dz * dz)
            let mag = t / (dist * dist * dist)
            b1.VX <- b1.VX - b2.Mass * mag * dx
            b1.VY <- b1.VY - b2.Mass * mag * dy
            b1.VZ <- b1.VZ - b2.Mass * mag * dz
            b2.VX <- b2.VX + b1.Mass * mag * dx
            b2.VY <- b2.VY + b1.Mass * mag * dy
            b2.VZ <- b2.VZ + b1.Mass * mag * dz
    move t a

let rec energy i e a =
    if i < Array.length a
        then let b1 = a.[i]
             let rec energy' a j e =
                if j < Array.length a
                then let b2 = a.[j]
                     let dx, dy, dz = b1.X - b2.X, b1.Y - b2.Y, b1.Z - b2.Z
                     let dist = sqrt (dx * dx + dy * dy + dz * dz)
                     energy' a (j + 1)
                        (e - b1.Mass * b2.Mass / dist )
                else e

             let sq = b1.VX * b1.VX + b1.VY * b1.VY + b1.VZ * b1.VZ
             energy (i + 1)
                (energy' a (i + 1)
                    (e + 0.5 * b1.Mass * sq)) a
        else e

let planets = [|sun; jupiter; saturn; uranus; neptune|]
offsetMomentum planets

let print = energy 0 0.0 >> printf "%.9f\n"

[<EntryPoint>]
let main args =
    let n = try int args.[0] with _ -> 20000000
    print planets
    for i in 1..n do advance planets 0.01
    print planets
    0
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

#light 

open Array

let rec loop' a n m =
    if n < length a
        then a.[n] <- false
             loop' a (n + m) m      
                       
let rec loop i c a = 
    if i < length a  
        then if a.[i] 
                then loop' a (2 * i) i
                     loop (i + 1) (c + 1) a
                else loop (i + 1) c a
        else c
        
let print = printf "Primes up to %8i %8i\n"           

let run n = create (n + 1) true |> loop 2 0 |> print n
  
let n = try int_of_string Sys.argv.[1] with _ -> 9
    
map (( + ) n >> ( <<< ) 1 >> ( * ) 10000 >> run) [|0; -1; -2|]
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

#light

open System.Collections

let rec loop' n m (a : BitArray) =
    if n < a.Length
        then a.[n] <- false
             loop' (n + m) m a
                       
let rec loop i c (a : BitArray) = 
    if i < a.Length  
        then if a.[i] 
                then loop' (2 * i) i a
                     loop (i + 1) (c + 1) a
                else loop (i + 1) c a
        else c
        
let print = printf "Primes up to %8i %8i\n"           

let run n = new BitArray (n + 1, true) |> loop 2 0 |> print n
  
let n = try int_of_string Sys.argv.[1] with _ -> 11
    
List.map (( + ) n >> ( <<< ) 1 >> ( * ) 10000 >> run) [0; -1; -2]
// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

#light

open List

let n = try int_of_string Sys.argv.[1] with _ -> 2500000

let rec sum f a = function
    | k when k <= n -> sum f (f (float k) + a) (k + 1)
    | _ -> a

let mutable alt1, alt2 = -1.0, -1.0;

let funs = 
    [fun k -> (2.0 / 3.0) ** (k - 1.0); 
     fun k -> 1.0 / (sqrt k);
     fun k -> 1.0 / (k * (k + 1.0));
     fun k -> 1.0 / (k * k * k * (sin k) * (sin k));
     fun k -> 1.0 / (k * k * k * (cos k) * (cos k));
     fun k -> 1.0 / k;
     fun k -> 1.0 / (k * k);
     fun k -> alt1 <- - alt1
              alt1 / k;
     fun k -> alt2 <- - alt2
              alt2 / (2.0 * k - 1.0)]

let names =
    ["(2/3)^k";
     "k^-0.5";
     "1/k(k+1)";
     "Flint Hills";
     "Cookson Hills";
     "Harmonic";
     "Riemann Zeta";
     "Alternating Harmonic";
     "Gregory"]
     
let print s f = printf "%.9f\t%s\n" f s

zip funs names |> map (fun (f, s) -> sum f 0.0 1 |> print s) 
﻿// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// contributed by Valentin Kraevskiy
// fixed by Joel Mueller

#light
    
let id = 1I, 0I, 0I, 1I

let comp (q, r, s, t) (u, v, x) =
    (q * u, q * v + r * x, s * u, s * v + t * x)

let div x y = 
    let rec next w n =        
        if w > x then n else next (w + y) (n + 1I)
    next y 0I
let extr (q, r, s, t) x = div (q * x + r) (s * x + t)   
    
let next z = extr z 3I
let safe z = (=) (extr z 4I)
let prod (u, v, w, x) n =
    let neg = -10I * n
    (10I * u + neg * w, 10I * v + neg * x, w, x)

let digits = 
    let z = ref id    
    let lfts = 
        let n = ref 0I
        fun () -> n := !n + 1I
                  !n, 4I * !n + 2I, 2I * !n + 1I
    let rec digits () =
            let y = next !z 
            if safe !z y 
                then z := (prod !z y)
                     y
                else z := (comp !z <| lfts ())
                     digits ()
    digits

let rec loop n s total = 
    if total = 0 
        then for _ in 1 .. n do printf " "
             printf ("\t:%i\n") (s + 10 - n)
        else if n = 0 
            then printf "\t:%i\n" <| s + 10
                 loop 10 (s + 10) total
            else printf "%i" <| int (digits ()) 
                 loop (n - 1) s (total - 1)

loop 10 0 <| try int (System.Environment.GetCommandLineArgs().[1]) with _ -> 27

 
﻿(**
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Port to F# by Jomo Fisher of the C# port that uses native GMP:
 * 	contributed by Mike Pall
 * 	java port by Stefan Krause
 *  C# port by Miguel de Icaza
*)
module PiDigits
open System
open System.Runtime.InteropServices

[<StructLayout (LayoutKind.Sequential)>]
[<Struct>]
type mpz_t =
   val _mp_alloc:int
   val _mp_size:int
   val ptr:IntPtr

[<DllImport ("gmp", EntryPoint="__gmpz_init")>]
let mpz_init(value : mpz_t byref) : unit = failwith ""

[<DllImport ("gmp", EntryPoint="__gmpz_mul_si")>]
let mpz_mul_si(dest : mpz_t byref, src : mpz_t byref, value : int) : unit = failwith ""

[<DllImport ("gmp", EntryPoint="__gmpz_add")>]
let mpz_add(dest : mpz_t byref, src : mpz_t byref, src2 : mpz_t byref) : unit = failwith ""

[<DllImport ("gmp", EntryPoint="__gmpz_tdiv_q")>]
let mpz_tdiv_q(dest : mpz_t byref, src : mpz_t byref, src2 : mpz_t byref) : unit = failwith ""

[<DllImport ("gmp", EntryPoint="__gmpz_set_si")>]
let mpz_set_si(src : mpz_t byref, value : int) : unit = failwith ""

[<DllImport ("gmp", EntryPoint="__gmpz_get_si")>] 
let mpz_get_si(src : mpz_t byref) : int = 0

let init() = 
    let mutable result = mpz_t()
    mpz_init(&result)
    result

let mutable q,r,s,t,u,v,w = init(),init(),init(),init(),init(),init(),init()

let mutable i = 0
let mutable c = 0
let ch = Array.zeroCreate 10
let args = System.Environment.GetCommandLineArgs()
let n = Int32.Parse args.[1]
let intZero = int '0'

let inline compose_r(bq, br, bs, bt) = 
    mpz_mul_si(&u, &r, bs)
    mpz_mul_si(&r, &r, bq)
    mpz_mul_si(&v, &t, br)
    mpz_add(&r, &r, &v)
    mpz_mul_si(&t, &t, bt)
    mpz_add(&t, &t, &u)
    mpz_mul_si(&s, &s, bt)
    mpz_mul_si(&u, &q, bs)
    mpz_add(&s, &s, &u)
    mpz_mul_si(&q, &q, bq)

// Compose matrix with numbers on the left.
let inline compose_l(bq, br, bs, bt) =
    mpz_mul_si(&r, &r, bt)
    mpz_mul_si(&u, &q, br)
    mpz_add(&r, &r, &u)
    mpz_mul_si(&u, &t, bs)
    mpz_mul_si(&t, &t, bt)
    mpz_mul_si(&v, &s, br)
    mpz_add(&t, &t, &v)
    mpz_mul_si(&s, &s, bq)
    mpz_add(&s, &s, &u)
    mpz_mul_si(&q, &q, bq)

// Extract one digit.
let inline extract(j) = 
    mpz_mul_si(&u, &q, j)
    mpz_add(&u, &u, &r)
    mpz_mul_si(&v, &s, j)
    mpz_add(&v, &v, &t)
    mpz_tdiv_q(&w, &u, &v)
    mpz_get_si(&w)


// Print one digit. Returns 1 for the last digit. 
let inline prdigit(y:int) = 
    ch.[c] <- char (intZero + y)
    c <- c + 1
    i <- i + 1
    if (i%10=0 || i = n) then
        while c<>ch.Length do
            ch.[c] <- ' '
            c<-c+1
        c <- 0
        Console.Write(ch)
        Console.Write("\t:")
        Console.WriteLine(i)
    i = n

// Generate successive digits of PI. 
let mutable k = 1
i <- 0
mpz_set_si(&q, 1)
mpz_set_si(&r, 0)
mpz_set_si(&s, 0)
mpz_set_si(&t, 1)
let mutable more = true
while more do
    let y = extract 3
    if y = extract 4 then
        if prdigit y then more<-false
        else compose_r(10, -10*y, 0, 1)
    else
        compose_l(k, 4*k+2, 0, 2*k+1);
        k<-k+1


// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

#light

let rec fib n = if n < 2 then 1 else fib (n - 1) + (fib (n - 2))

let rec rfib n = if n < 2.0 then 1.0 else rfib (n - 1.0) + (rfib (n - 2.0))
    
let rec ack x y = 
    if x = 0 
        then y + 1
        else if y = 0 
            then ack (x - 1) 1
            else ack (x - 1) (ack x (y - 1))

let rec tak x y z =
    if y < x
        then tak (tak (x - 1) y z) 
                 (tak (y - 1) z x)
                 (tak (z - 1) x y) 
        else z 

let rec rtak x y z =
    if y < x
        then rtak (rtak (x - 1.0) y z) 
                  (rtak (y - 1.0) z x)
                  (rtak (z - 1.0) x y) 
        else z  

let n = try int_of_string Sys.argv.[1] with _ -> 11
let m = n - 1
let x = float n + 27.0
printf "Ack(3,%i): %i\n" n (ack 3 n)
printf "Fib(%.1f): %.1f\n" x (rfib x)
printf "Tak(%i,%i,%i): %i\n" (3 * m) (2 * m) m (tak (3 * m) (2 * m) m)
printf "Fib(3): %i\n" (fib 3)
printf "Tak(3.0,2.0,1.0): %.1f\n" (rtak 3.0 2.0 1.0)
﻿// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Contributed by Valentin Kraevskiy

open System.Text.RegularExpressions

let regex s = Regex (s, RegexOptions.Compiled)
let input = stdin.ReadToEnd ()
let text = (regex ">.*\n|\n").Replace (input, "")

["agggtaaa|tttaccct"
 "[cgt]gggtaaa|tttaccc[acg]"
 "a[act]ggtaaa|tttacc[agt]t"
 "ag[act]gtaaa|tttac[agt]ct"
 "agg[act]taaa|ttta[agt]cct"
 "aggg[acg]aaa|ttt[cgt]ccct"
 "agggt[cgt]aa|tt[acg]accct"
 "agggta[cgt]a|t[acg]taccct"
 "agggtaa[cgt]|[acg]ttaccct"]
|> List.iter (fun s ->
         printf "%s %i\n" s ((regex s).Matches text).Count)

let newText =
    ["B", "(c|g|t)"
     "D", "(a|g|t)"
     "H", "(a|c|t)"
     "K", "(g|t)"
     "M", "(a|c)"
     "N", "(a|c|g|t)"
     "R", "(a|g)"
     "S", "(c|g)"
     "V", "(a|c|g)"
     "W", "(a|t)"
     "Y", "(c|t)"]
     |> List.fold (fun s (code, alt) -> 
            (regex code).Replace (s, alt)) text

printf "\n%i\n%i\n%i\n" input.Length text.Length newText.Length
﻿// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Based on C# version by Isaac Gouy, The Anh Tran, Alan McGovern
// Contributed by Don Syme

open System
open System.Threading

type BarrierHandle(threads:int) = 
    let mutable current = threads
    let mutable handle = new ManualResetEvent(false)

    member x.WaitOne() =
        let h = handle
        if Interlocked.Decrement(&current) > 0 then 
            h.WaitOne() |> ignore;
        else
            handle <- new ManualResetEvent(false);
            Interlocked.Exchange(&current, threads) |> ignore;
            h.Set() |> ignore;
            h.Close();

let Approximate(u:double[], v:double[], tmp:double[], rbegin, rend, barrier: BarrierHandle) =

    let mutable vBv = 0.0
    let mutable vv = 0.0

    // return element i,j of infinite matrix A 
    let A i j = 1.0 / float((i + j) * (i + j + 1) / 2 + i + 1)

    // multiply vector v by matrix A 
    let multiplyAv(v:double[], Av:double[]) =
        for i = rbegin to rend - 1 do 
            let mutable sum = 0.0;
            for j = 0 to v.Length - 1 do 
                sum <- sum + A i j * v.[j];
            Av.[i] <- sum

    // multiply vector v by matrix A transposed 
    let multiplyAtv(v:double[], atv:double[]) =
        for i = rbegin to rend - 1 do
            let mutable sum = 0.0
            for j = 0 to v.Length - 1 do 
                sum <- sum + A j i * v.[j];
            atv.[i] <- sum;

    // multiply vector v by matrix A and then by matrix A transposed 
    let multiplyatAv(v:double[], tmp:double[], atAv:double[]) =
        multiplyAv(v, tmp);
        barrier.WaitOne();

        multiplyAtv(tmp, atAv);
        barrier.WaitOne();

    for i = 0 to 9 do 
        multiplyatAv(u, tmp, v);
        multiplyatAv(v, tmp, u);

    for i = rbegin to rend - 1 do
        vBv <- vBv + u.[i] * v.[i];
        vv <- vv + v.[i] * v.[i];

    (vBv, vv)


let RunGame n = 
    // create unit vector
    let u = Array.create n 1.0
    let tmp = Array.zeroCreate n 
    let v = Array.zeroCreate n 

    let nthread = Environment.ProcessorCount;

    let barrier = new BarrierHandle(nthread);
        // create thread and hand out tasks
    let chunk = n / nthread;
        // objects contain result of each thread
    let aps = 
        Async.Parallel 
          [ for i in 0 .. nthread - 1 do
                let r1 = i * chunk;
                let r2 = if (i < (nthread - 1)) then r1 + chunk else n
                yield async { return Approximate(u, v, tmp, r1, r2, barrier) } ]
         |> Async.RunSynchronously

    let vBv = aps |> Array.sumBy fst
    let vv = aps |> Array.sumBy snd

    Math.Sqrt(vBv / vv);

[<EntryPoint>]
let main args =
    let n = try int <| args.[0] with _ -> 2500

    System.Console.WriteLine("{0:f9}", RunGame n);
    0

﻿(*  The Computer Language Benchmarks Game
    http://shootout.alioth.debian.org/

    Contributed by Dmitry Lomov & Jomo Fisher

    Uses F# asyncs (lightweight threads) with customized auto reset cell 
    as semaphore.
*)

let ringLength = 503

type AutoResetCell() =
    let mutable value = -1
    let mutable run = None
    
    member this.RegisterResult res =
        let grabbed = 
            lock this (fun () ->
                match run with
                | None -> value <- res; None
                | grabbed -> run <- None; grabbed)
        match grabbed with
        | None -> ()
        | Some run -> run res

    member this.AsyncResult = 
        Async.FromContinuations(fun (success,_,_) -> 
            let runNow = 
                lock this (fun () ->
                    if value = -1 then
                        run <- Some success
                        false                        
                    else true)                        
            if runNow then 
                let r = value
                value <- -1 // Autoreset
                success r) 

let createCell _ = AutoResetCell()

let createThread (cells:AutoResetCell array) i =
    let next = if i = ringLength-1 then 0 else i + 1
    async {
            let more = ref true
            while !more do
                let! msg = cells.[i].AsyncResult 
                cells.[next].RegisterResult(msg-1)           
                more := msg>0
                if msg = 0 then                    
                    printfn "%d" (i+1) }

[<EntryPoint>]
let main args = 
    let count = if args.Length>0 then int args.[0] else 50000000
    
    let cells = Array.init ringLength createCell

    let threads = Array.init ringLength (createThread cells)

    cells.[0].RegisterResult(count) 

    threads
        |> Async.Parallel // Run all the asyncs at once
        |> Async.Ignore // Ignore the results
        |> Async.RunSynchronously // Block the main thread until work is done
    
    0
﻿(*  The Computer Language Benchmarks Game
    http://shootout.alioth.debian.org/

    Contributed by Jomo Fisher

    Uses F# asyncs. Asyncs are triggered by tailcall in sequence as progress is 
    made around the ring. 
*)
let ringLength = 503

let cells = Array.zeroCreate ringLength
let threads = Array.zeroCreate ringLength
let answer = ref -1

let createWorker i = 
    let next = (i+1)%ringLength
    async { let value = cells.[i]
            if false then () 
            match value with
            | 0 -> answer := i+1
            | _ -> 
                cells.[next] <- value - 1 
                return! threads.[next] }
    
[<EntryPoint>]
let main args = 
    cells.[0] <- if args.Length>0 then int args.[0] else 50000000
    for i in 0..ringLength-1 do 
        threads.[i]<-createWorker i

    let result = Async.StartImmediate(threads.[0])
    printfn "%d" !answer
    0


