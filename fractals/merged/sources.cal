/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Binarytrees;

import Cal.Core.Prelude using
    typeConstructor = Int, String;
    function = eager, max, seq, stringToInt;
    ;

import Cal.Core.Bits using
    function = shiftL;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Core.Debug using
    function = show;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

data public Tree =
    Empty |
    Node
        value :: !Int
        leftChild :: !Tree
        rightChild :: !Tree
    ;

/** Traverses tree and returns a checksum on the values in the nodes.*/
check :: Tree -> Int;
check !tree =
    case tree of
    Empty -> 0;
    Node value left right -> value + check left - check right;
    ;

/** builds a tree of depth */
make :: Int -> Int -> Tree;
make !i !depth =
    if depth == 1 then
        Node
            i
            (Node (2 * i - 1) Empty Empty)
            (Node (2 * i) Empty Empty)
    else
        Node
            i
            (make (2 * i - 1) (depth - 1))
            (make (2 * i) (depth - 1))
    ;

/** 
 * Test different numbers of trees at different depths and
 * writes the number and checksum to stdout.
 */
testTrees :: Int -> Int -> Int -> ();
testTrees !depth !minDepth !maxDepth =
    let
        //allocates and checks 2i trees, each of depth depth
        testFixedDepth :: Int -> Int -> Int -> Int;
        testFixedDepth !i !depth !checksum =
            if i == 0 then
                checksum
            else
                testFixedDepth
                    (i - 1)
                    depth
                    (
                        checksum + check (make i depth)
                        + check (make (-i) depth)
                    )
            ;
    in
        if depth > maxDepth then
            ()
        else
            let
                i :: Int;
                i = eager $ shiftL 1 (maxDepth - depth + minDepth);
            in
                printLine
                    (
                        show (i * 2)
                        ++ "\t trees of depth "
                        ++ show depth
                        ++ "\t check: "
                        ++ show (testFixedDepth i depth 0)
                    )
                `seq`
                testTrees (depth + 2) minDepth maxDepth
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        minDepth :: Int;
        minDepth = 4;

        maxDepth :: Int;
        maxDepth = max (minDepth + 2) n;

        stretchDepth :: Int;
        stretchDepth = maxDepth + 1;

        longLivedTree :: Tree;
        longLivedTree = make 0 maxDepth;
    in
        printLine
            (
                "stretch tree of depth "
                ++ show stretchDepth
                ++ "\t check: "
                ++ show (check (make 0 stretchDepth))
            )
        `seq`
        longLivedTree
        `seq`
        testTrees minDepth minDepth maxDepth
        `seq`
        printLine
            (
                "long lived tree of depth "
                ++ show maxDepth
                ++ "\t check: "
                ++ show (check longLivedTree)
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Chameneos;

import Cal.Core.Prelude using
    typeClass = Eq, Inputable, Outputable;
    typeConstructor = Int, String, CalValue, JObject, Boolean;
    function =
        eager, input, output, seq, stringToInt, add, toCalValue, unsafeCoerce,
        unsafeFromCalValue, error;
    ;

import Cal.Core.Debug using
    function = show;
    ;

import Cal.Collections.List using
    function = map, head, strictList, foldLeft1Strict;
    ;

import Cal.Experimental.Concurrent.Parallel using
    function = parallelMap;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

import Cal.Core.System using
    function = concurrentRuntime;
    ;

data Color =
    Blue |
    Red |
    Yellow |
    Faded
    deriving Inputable, Outputable, Eq
    ;

/**
 * A meeting room is a place where Chameneos meet. The meeting room can either
 * be empty or occupied. The meeting room has a count of the number of meetings
 * can take place. This is decremented every time a meeting occurs.
 */
data MeetingRoom =
    Empty n :: !Int |
    Occupied
        n :: !Int
        other :: !Color
    deriving Inputable, Outputable, Eq
    ;

/** get new color based on the color of two meeting Chameneos */
complement :: Color -> Color -> Color;
complement !color1 !color2 =
    if (color1 == color2) then
        color1
    else
        (
            case color1 of
            Blue ->
                if (color2 == Red) then
                    Yellow
                else
                    Red
                ;
            Red ->
                if (color2 == Blue) then
                    Yellow
                else
                    Blue
                ;
            Yellow ->
                if (color2 == Blue) then
                    Red
                else
                    Blue
                ;
        )
    ;

/**
 * This function implements the behaviour of each chameneo. It keeps trying to
 * enter the meeting room until it's colour is faded, and then returns the
 * number of meetings.
 */
chameneos ::
    Color
    -> MutableVariable MeetingRoom
    -> MutableVariable Color
    -> Int
    -> Int;
chameneos !color !meeting !occupant !meetingCount =
    let
        meetingRoom :: MeetingRoom;
        meetingRoom = eager $ takeMutableVariable meeting;
    in
        if (color == Faded) then
            meetingCount
        else
            (
                case meetingRoom of
                Empty n ->
                    if (n == 0) then
                        putMutableVariable meeting (Empty 0)
                        `seq`
                        chameneos Faded meeting occupant meetingCount
                    else
                        putMutableVariable meeting (Occupied n color)
                        `seq`
                        chameneos
                            (complement (takeMutableVariable occupant) color)
                            meeting
                            occupant
                            (meetingCount + 1)
                    ;
                Occupied n otherColor ->
                    putMutableVariable occupant color
                    `seq`
                    putMutableVariable meeting (Empty (n - 1))
                    `seq`
                    chameneos
                        (complement otherColor color)
                        meeting
                        occupant
                        (meetingCount + 1)
                    ;
            )
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        meetingRoom :: MutableVariable MeetingRoom;
        meetingRoom = eager $ makeMutableVariable ();

        occupant :: MutableVariable Color;
        occupant = eager $ makeMutableVariable ();
    in
        (
            if concurrentRuntime then
                ()
            else
                error
                    "You must define the VM arg org.openquark.cal.machine.lecc.concurrent_runtime to run this program"
        )
        `seq`
        putMutableVariable meetingRoom (Empty n)
        `seq`
        printLine
            (show
                (foldLeft1Strict
                    add
                    (parallelMap
                        (\colour -> chameneos colour meetingRoom occupant 0)
                        [Red, Blue, Yellow]
                    )
                )
            )
    ;

//////////////////////////////////////////////////////////////////////
// This implements MutableVariable, similar to m-structures in Id.

/**
 * MutableVariable represent a value that can be passed between threads using
 * put and take. It has the same semantics as a BlockableQueue of length 1.
 */
data public MutableVariable a =
    private MutableVariable atomicRef :: !AtomicReference
    ;

/** make a new mutable variable */
makeMutableVariable :: () -> MutableVariable a;
public makeMutableVariable !unused = MutableVariable createAtomicReference;

/**
 * Put a value into a mutable variable. If the variable is not empty this
 * function will block.
 */
putMutableVariable :: MutableVariable a -> a -> ();
public putMutableVariable !mutable !value =
    let
        put :: AtomicReference -> JObject -> ();
        put !ref !value =
            if compareAndSet ref null value then
                ()
            else
                yield
                `seq`
                put ref value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            put atomicRef (output (toCalValue value));
    ;

/**
 * take a value from a mutable variable, if the there is no value in the
 * variable this will block.
 */
takeMutableVariable :: MutableVariable a -> a;
public takeMutableVariable !mutable =
    let
        take :: AtomicReference -> JObject;
        take !atomicRef =
            let
                value = eager $ getAndSet atomicRef null;
            in
                if isNull value then
                    yield
                    `seq`
                    take atomicRef
                else
                    value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            unsafeFromCalValue $ input $ take atomicRef;
    ;

data foreign unsafe import jvm "java.util.concurrent.atomic.AtomicReference"
    private AtomicReference;

foreign unsafe import jvm "constructor"
    private createAtomicReference :: AtomicReference;

foreign unsafe import jvm "method weakCompareAndSet"
    private compareAndSet :: AtomicReference -> JObject -> JObject -> Boolean;

foreign unsafe import jvm "method getAndSet"
    private getAndSet :: AtomicReference -> JObject -> JObject;

foreign unsafe import jvm "static method java.lang.Thread.yield"
    private yield :: ();

foreign unsafe import jvm "isNull" private isNull :: JObject -> Boolean;

foreign unsafe import jvm "null" private null :: JObject;
/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Chameneos;

import Cal.Core.Prelude using
    typeClass = Eq, Inputable, Outputable;
    typeConstructor = Int, String, CalValue, JObject, Boolean;
    function =
        eager, input, output, seq, stringToInt, add, toCalValue, unsafeCoerce,
        unsafeFromCalValue, error;
    ;

import Cal.Core.Debug using
    function = show;
    ;

import Cal.Collections.List using
    function = map, head, strictList, foldLeft1Strict;
    ;

import Cal.Experimental.Concurrent.Parallel using
    function = parallelMap;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

import Cal.Core.System using
    function = concurrentRuntime;
    ;

data Color =
    Blue |
    Red |
    Yellow |
    Faded
    deriving Inputable, Outputable, Eq
    ;

/**
 * A meeting room is a place where Chameneos meet. The meeting room can either
 * be empty or occupied. The meeting room has a count of the number of meetings
 * can take place. This is decremented every time a meeting occurs.
 */
data MeetingRoom =
    Empty n :: !Int |
    Occupied
        n :: !Int
        other :: !Color
    deriving Inputable, Outputable, Eq
    ;

/** get new color based on the color of two meeting Chameneos */
complement :: Color -> Color -> Color;
complement !color1 !color2 =
    if (color1 == color2) then
        color1
    else
        (
            case color1 of
            Blue ->
                if (color2 == Red) then
                    Yellow
                else
                    Red
                ;
            Red ->
                if (color2 == Blue) then
                    Yellow
                else
                    Blue
                ;
            Yellow ->
                if (color2 == Blue) then
                    Red
                else
                    Blue
                ;
        )
    ;

/**
 * This function implements the behaviour of each chameneo. It keeps trying to
 * enter the meeting room until it's colour is faded, and then returns the
 * number of meetings.
 */
chameneos ::
    Color
    -> MutableVariable MeetingRoom
    -> MutableVariable Color
    -> Int
    -> Int;
chameneos !color !meeting !occupant !meetingCount =
    let
        meetingRoom :: MeetingRoom;
        meetingRoom = eager $ takeMutableVariable meeting;
    in
        if (color == Faded) then
            meetingCount
        else
            (
                case meetingRoom of
                Empty n ->
                    if (n == 0) then
                        putMutableVariable meeting (Empty 0)
                        `seq`
                        chameneos Faded meeting occupant meetingCount
                    else
                        putMutableVariable meeting (Occupied n color)
                        `seq`
                        chameneos
                            (complement (takeMutableVariable occupant) color)
                            meeting
                            occupant
                            (meetingCount + 1)
                    ;
                Occupied n otherColor ->
                    putMutableVariable occupant color
                    `seq`
                    putMutableVariable meeting (Empty (n - 1))
                    `seq`
                    chameneos
                        (complement otherColor color)
                        meeting
                        occupant
                        (meetingCount + 1)
                    ;
            )
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        meetingRoom :: MutableVariable MeetingRoom;
        meetingRoom = eager $ makeMutableVariable ();

        occupant :: MutableVariable Color;
        occupant = eager $ makeMutableVariable ();
    in
        (
            if concurrentRuntime then
                ()
            else
                error
                    "You must define the VM arg org.openquark.cal.machine.lecc.concurrent_runtime to run this program"
        )
        `seq`
        putMutableVariable meetingRoom (Empty n)
        `seq`
        printLine
            (show
                (foldLeft1Strict
                    add
                    (parallelMap
                        (\colour -> chameneos colour meetingRoom occupant 0)
                        [Blue, Red, Yellow, Blue]
                    )
                )
            )
    ;

//////////////////////////////////////////////////////////////////////
// This implements MutableVariable, similar to m-structures in Id.

/**
 * MutableVariable represent a value that can be passed between threads using
 * put and take. It has the same semantics as a BlockableQueue of length 1.
 */
data public MutableVariable a =
    private MutableVariable atomicRef :: !AtomicReference
    ;

/** make a new mutable variable */
makeMutableVariable :: () -> MutableVariable a;
public makeMutableVariable !unused = MutableVariable createAtomicReference;

/**
 * Put a value into a mutable variable. If the variable is not empty this
 * function will block.
 */
putMutableVariable :: MutableVariable a -> a -> ();
public putMutableVariable !mutable !value =
    let
        put :: AtomicReference -> JObject -> ();
        put !ref !value =
            if compareAndSet ref null value then
                ()
            else
                yield
                `seq`
                put ref value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            put atomicRef (output (toCalValue value));
    ;

/**
 * take a value from a mutable variable, if the there is no value in the
 * variable this will block.
 */
takeMutableVariable :: MutableVariable a -> a;
public takeMutableVariable !mutable =
    let
        take :: AtomicReference -> JObject;
        take !atomicRef =
            let
                value = eager $ getAndSet atomicRef null;
            in
                if isNull value then
                    yield
                    `seq`
                    take atomicRef
                else
                    value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            unsafeFromCalValue $ input $ take atomicRef;
    ;

data foreign unsafe import jvm "java.util.concurrent.atomic.AtomicReference"
    private AtomicReference;

foreign unsafe import jvm "constructor"
    private createAtomicReference :: AtomicReference;

foreign unsafe import jvm "method weakCompareAndSet"
    private compareAndSet :: AtomicReference -> JObject -> JObject -> Boolean;

foreign unsafe import jvm "method getAndSet"
    private getAndSet :: AtomicReference -> JObject -> JObject;

foreign unsafe import jvm "static method java.lang.Thread.yield"
    private yield :: ();

foreign unsafe import jvm "isNull" private isNull :: JObject -> Boolean;

foreign unsafe import jvm "null" private null :: JObject;
/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Fannkuch;

import Cal.Core.Prelude using
    typeConstructor = Int, String;
    function = eager, max, seq, stringToInt;
    ;
import Cal.Core.Debug using
    function = show;
    ;
import Cal.Collections.List using
    function = head;
    ;
import Cal.IO.Console using
    function = print;
    ;

data foreign unsafe import jvm "int[]" JIntArray;

foreign unsafe import jvm "newArray" newArray :: Int -> JIntArray;

foreign unsafe import jvm "subscriptArray" subscript :: JIntArray -> Int -> Int;

foreign unsafe import jvm "updateArray" update :: JIntArray -> Int -> Int -> Int;

/** creates an initial sequence, 0 1 2 3 ...*/
initSeq :: Int -> JIntArray;
initSeq !size =
    let
        go :: JIntArray -> Int -> JIntArray;
        go !array !i =
            if i == size then
                array
            else
                update array i i
                `seq`
                go array (i + 1)
            ;
    in
        go (newArray size) 0
    ;

/** prints a sequence*/
printSeq :: JIntArray -> Int -> Int -> ();
printSeq !array !start !end =
    if start == end then
        print "\n"
    else
        print (show (array `subscript` start + 1))
        `seq`
        printSeq array (start + 1) end
    ;

/** rotate elements of array left by one place,
 * e.g. 1 2 3 -> 2 3 1.
 */
rotateL :: JIntArray -> Int -> Int;
rotateL !array !length =
    let
        elem0 :: Int;
        elem0 = eager $ array `subscript` 0;

        go :: Int -> ();
        go !i =
            if i == length then
                ()
            else
                update array i (array `subscript` (i + 1))
                `seq`
                go (i + 1)
            ;
    in
        elem0
        `seq`
        go 0
        `seq`
        update array length elem0
    ;

/** copy an array*/
copyArray :: Int -> Int -> JIntArray -> JIntArray -> JIntArray;
copyArray !start !end !to !from =
    if start == end then
        to
    else
        update to start (from `subscript` start)
        `seq`
        copyArray (start + 1) end to from
    ;

/** reverse elements of an array between start and end (inclusive)*/
reverse :: JIntArray -> Int -> Int -> ();
reverse !array !start !end =
    let
        swapHelper :: JIntArray -> Int -> Int -> Int -> Int -> Int;
        swapHelper !array !i !j !iValue !jValue =
            update array i jValue
            `seq`
            update array j iValue
            ;
    in
        if start < end then
            swapHelper
                array
                start
                end
                (array `subscript` start)
                (array `subscript` end)
            `seq`
            reverse array (start + 1) (end - 1)
        else
            ()
    ;

/** count the 'flips' until 1 is at the head of the array*/
countFlips :: JIntArray -> Int -> Int -> Int;
countFlips !array !count !m =
    if subscript array 0 == 0 then
        count
    else
        reverse array 0 (array `subscript` 0)
        `seq`
        countFlips array (count + 1) m
    ;

/** set counts for controlling next permutations*/
setCount :: JIntArray -> Int -> Int;
setCount !array !r =
    if r == 1 then
        r
    else
        update array (r - 1) r
        `seq`
        setCount array (r - 1)
    ;

/** compute the next permuation - return -1 if there are no more*/
nextPerm :: JIntArray -> JIntArray -> Int -> Int -> Int;
nextPerm !perm !counts !r !n =
    if r == n then
        -1
    else
        rotateL perm r
        `seq`
        (
            if update counts r (counts `subscript` r - 1) > 0 then
                r
            else
                nextPerm perm counts (r + 1) n
        )
    ;

fannkuch :: Int -> Int;
fannkuch !n =
    let
        loop ::
            JIntArray -> JIntArray -> JIntArray -> Int -> Int -> Int -> Int;
        loop !perm !permCopy !count !r !maxFlips !dispCount =
            if r == -1 then
                maxFlips
            else
                copyArray 0 n permCopy perm
                `seq`
                (
                    //we want to display the first 30 sequences
                    if dispCount < (30 :: Int) then
                        printSeq perm 0 n
                        `seq`
                        loop
                            perm
                            permCopy
                            count
                            (nextPerm perm count (setCount count r) n)
                            (max maxFlips (countFlips permCopy 0 (n - 1)))
                            (dispCount + 1)
                    else

                        loop
                            perm
                            permCopy
                            count
                            (nextPerm perm count (setCount count r) n)
                            (max maxFlips (countFlips permCopy 0 (n - 1)))
                            dispCount
                )
            ;
    in
        loop (initSeq n) (newArray n) (newArray n) n 0 0
    ;

main :: [String] -> ();
public main !args =
    let
        n = eager $ stringToInt (head args);
    in
        print
            (
                "Pfannkuchen("
                ++ show n
                ++ ") = "
                ++ show (fannkuch n)
                ++ "\n"
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Fasta;

import Cal.Core.Prelude using
    typeClass = Inputable, Outputable;
    typeConstructor = Byte, Char, Double, Int, String;
    function = eager, fromInt, fst, min, seq, snd, stringToInt, toByte;
    ;

import Cal.Core.Char;

import Cal.Collections.List using
    function = foldLeftStrict, head, length;
    ;

import Cal.Collections.Array;


data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

data foreign unsafe import jvm "byte[]"
    JByteArray deriving Inputable, Outputable;

foreign unsafe import jvm "lengthArray" byteArray_length :: JByteArray -> Int;

foreign unsafe import jvm "newArray" byteArray_new :: Int -> JByteArray;

foreign unsafe import jvm "subscriptArray"
    byteArray_subscript :: JByteArray -> Int -> Byte;

foreign unsafe import jvm "updateArray"
    byteArray_update :: JByteArray -> Int -> Byte -> Byte;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JOutputStream;

data foreign unsafe import jvm "java.io.OutputStream" private JOutputStream;

foreign unsafe import jvm "method write"
    private writeBytes :: JOutputStream -> JByteArray -> ();

foreign unsafe import jvm "method write"
    private writeBytesFromTo :: JOutputStream -> JByteArray -> Int -> Int -> ();

foreign unsafe import jvm "method write"
    private writeByte :: JOutputStream -> Int -> ();

foreign unsafe import jvm "method getBytes"
    private toBytes :: String -> JByteArray;

data foreign unsafe import jvm "double[]" JDoubleArray;

foreign unsafe import jvm "newArray" doubleArray_new :: Int -> JDoubleArray;

foreign unsafe import jvm "subscriptArray"
    doubleArray_subscript :: JDoubleArray -> Int -> Double;

foreign unsafe import jvm "updateArray"
    doubleArray_update :: JDoubleArray -> Int -> Double -> Double;

alu :: JByteArray;
alu = 
    toBytes
        (
            "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
            ++ "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
            ++ "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
            ++ "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
            ++ "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
            ++ "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
            ++ "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"
        )
    ;

charToByte :: Char -> Byte;
charToByte !c = toByte (Char.toInt c);

/** create array of iub codes*/
iubCodes :: JByteArray;
iubCodes =
    let
        codes =
            [
                'a','c','g','t','B','D','H',
                'K','M','N','R','S','V','W','Y'
            ]
            ;
    in
        fst
            (foldLeftStrict
                (
                    \!array !value ->
                        (
                            byteArray_update
                                (fst array)
                                (snd array)
                                (charToByte value)
                            `seq`
                            fst array,
                            snd array + 1
                        )
                )
                (byteArray_new (length codes), 0)
                codes
            )
    ;

/** create array of cumulative frequencies*/
iubFreq :: JDoubleArray;
iubFreq =
    let
        freq =
            [
                0.27,0.12,0.12,0.27,0.02,0.02,0.02,
                0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02
            ]
            ;
    in
        (foldLeftStrict
            (
                \!accum !value ->
                    (
                        doubleArray_update
                            accum.#1
                            accum.#2
                            (accum.#3 + value)
                        `seq`
                        accum.#1,
                        accum.#2 + 1,
                        accum.#3 + value
                    )
            )
            (doubleArray_new (length freq), 0, 0.0)
            freq
        ).#1
    ;

/** array of human gene codes*/
humanCodes :: JByteArray;
humanCodes =
    let
        codes = ['a', 'c', 'g', 't'];
    in
        fst
            (foldLeftStrict
                (
                    \!array !value ->
                        (
                            byteArray_update
                                (fst array)
                                (snd array)
                                (charToByte value)
                            `seq`
                            fst array,
                            snd array + 1
                        )
                )
                (byteArray_new (length codes), 0)
                codes
            )
    ;

/** create native array of cumulative frequencies for human genes*/
humanFreq :: JDoubleArray;
humanFreq =
    let
        freq =
            [
                0.302954942668,
                0.1979883004921,
                0.1975473066391,
                0.3015094502008
            ]
            ;
    in
        (foldLeftStrict
            (
                \!accum !value ->
                    (
                        doubleArray_update
                            accum.#1
                            accum.#2
                            (accum.#3 + value)
                        `seq`
                        accum.#1,
                        accum.#2 + 1,
                        accum.#3 + value
                    )
            )
            (doubleArray_new (length freq), 0, 0.0)
            freq
        ).#1
    ;

/** naively pick a random gene from frequency table*/
selectGene :: JDoubleArray -> JByteArray -> Int -> Double -> Byte;
selectGene !freqTable !codeTable !i !rnd =
    if doubleArray_subscript freqTable i > rnd then
        byteArray_subscript codeTable i
    else
        selectGene freqTable codeTable (i + 1) rnd
    ;

/** output file line length*/
lineLength :: Int;
lineLength = 60 :: Int;

/** random number generator consts*/
im :: Int;
im = 139968;

ia :: Int;
ia = 3877;

ic :: Int;
ic = 29573;

makeRandomFasta ::
    String -> String -> JDoubleArray
    -> JByteArray -> Int -> JOutputStream -> Int -> Int;
makeRandomFasta !id !desc !freqTable !codeTable !n !stream !seed =
    let
        eol :: Byte;
        eol = eager $ fromInt (Char.toInt '\n');

        buffer :: JByteArray;
        buffer = byteArray_new 10240;

        bufferLength :: Int;
        bufferLength = 10240;

        generate :: JByteArray -> Int -> Int -> Int -> Int -> Int;
        generate !buffer !n !bytesToEol !bytesInBuffer !seed =
            if bytesToEol > 0 then
                let
                    newseed :: Int;
                    newseed = eager $ (seed * ia + ic) % im;

                    rnd :: Double;
                    rnd = 1.0 * fromInt newseed / fromInt im;
                in
                    byteArray_update
                        buffer
                        bytesInBuffer
                        (selectGene freqTable codeTable 0 rnd)
                    `seq`
                    generate
                        buffer
                        n
                        (bytesToEol - 1)
                        (bytesInBuffer + 1)
                        newseed
            else
                //end of line add the eol byte
                byteArray_update buffer bytesInBuffer eol
                `seq`
                (
                    if n > 0 then
                        let
                            bytesInNextLine :: Int;
                            bytesInNextLine = eager $ min n lineLength;
                        in
                            if
                                bytesInNextLine
                                > bufferLength - (bytesInBuffer + 1)
                            then
                                writeBytesFromTo
                                    stream
                                    buffer
                                    0
                                    (bytesInBuffer + 1)
                                `seq`
                                generate
                                    buffer
                                    (n - lineLength)
                                    bytesInNextLine
                                    0
                                    seed
                            else
                                generate
                                    buffer
                                    (n - lineLength)
                                    bytesInNextLine
                                    (bytesInBuffer + 1)
                                    seed
                    else
                        //finished, flush buffer
                        writeBytesFromTo stream buffer 0 (bytesInBuffer + 1)
                        `seq`
                        seed
                )
            ;
    in
        writeBytes stream (toBytes (">" ++ id ++ " " ++ desc ++ "\n"))
        `seq`
        generate buffer (n - lineLength) (min n lineLength) 0 seed
    ;

makeRepeatFasta ::
    String -> String -> JByteArray -> Int -> JOutputStream -> ();
makeRepeatFasta !id !desc !alu !n !stream =
    let
        seqLength :: Int;
        seqLength = eager $ byteArray_length alu;

        eol :: Int;
        eol = eager $ Char.toInt '\n';

        generate :: Int -> Int -> ();
        generate !n !k =
            if n > 0 then
                let
                    bytesToWriteThisLine :: Int;
                    bytesToWriteThisLine = eager $ min n lineLength;
                in
                    if bytesToWriteThisLine < seqLength - k then
                        writeBytesFromTo stream alu k bytesToWriteThisLine
                        `seq`
                        writeByte stream eol
                        `seq`
                        generate
                            (n - bytesToWriteThisLine)
                            (k + bytesToWriteThisLine)
                    else
                        writeBytesFromTo stream alu k (seqLength - k)
                        `seq`
                        writeBytesFromTo
                            stream
                            alu
                            0
                            (bytesToWriteThisLine - (seqLength - k))
                        `seq`
                        writeByte stream eol
                        `seq`
                        generate
                            (n - bytesToWriteThisLine)
                            (bytesToWriteThisLine - (seqLength - k))
            else
                ()
            ;
    in
        writeBytes stream (toBytes (">" ++ id ++ " " ++ desc ++ "\n"))
        `seq`
        generate n 0
    ;

main :: [String] -> ();
public main args =
    let
        n = eager $ stringToInt (head args);

        intialSeed :: Int;
        intialSeed = 42;

        seed1 :: Int;
        seed1 =
            makeRandomFasta
                "TWO"
                "IUB ambiguity codes"
                iubFreq
                iubCodes
                (n * 3)
                stdout
                intialSeed
            ;

        seed2 :: Int;
        seed2 =
            makeRandomFasta
                "THREE"
                "Homo sapiens frequency"
                humanFreq
                humanCodes
                (n * 5)
                stdout
                seed1
            ;
    in
        makeRepeatFasta "ONE" "Homo sapiens alu" alu (n * 2) stdout
        `seq`
        seed1
        `seq`
        seed2
        `seq`
        ()
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Hello;

import Cal.Core.Prelude using
    typeConstructor = String;
    ;
import Cal.IO.Console using
    function = print;
    ;

main :: [String] -> ();
public main args =
    print "hello world\n";

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Knucleotide;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Int, JObject, String;
    function =
        combineComparators, eager, fromInt, fst, induceComparator, input, not, 
        reverseComparator, seq, snd;
    ;

import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;

import Cal.Core.String using
    function = length, startsWith, subscript, substring, toUpperCase;
    ;

import Cal.Collections.List using
    function = foldLeftStrict, map, sortBy;
    ;

import Cal.Utilities.MessageFormat using
    function = formatWithPattern;
    ;

import Cal.Utilities.Locale using
    function = invariantLocale;
    ;

import Cal.IO.Console using
    function = isNullString, makeBufferedReader, print, readLine, stdin;
    typeConstructor = JBufferedReader;
    ;


data foreign unsafe import jvm "java.lang.StringBuffer"
    private JStringBuffer deriving Show;

data foreign unsafe import jvm "java.util.Collection" private JCollection;

foreign unsafe import jvm "constructor"
    private createStringBuffer :: JStringBuffer;

foreign unsafe import jvm "method append"
    private append :: JStringBuffer -> String -> JStringBuffer;

data foreign unsafe import jvm "int[]" JIntArray;

//Import Java integer arrays
foreign unsafe import jvm "newArray" newArray :: Int -> JIntArray;

foreign unsafe import jvm "subscriptArray"
    subscriptArray :: JIntArray -> Int -> Int;

foreign unsafe import jvm "updateArray"
    updateArray :: JIntArray -> Int -> Int -> Int;

data foreign unsafe import jvm "java.util.HashMap"
    private JHashMap deriving Show;

data foreign unsafe import jvm "java.util.Set" private JSet;

//Import mutable Java Hash Maps

foreign unsafe import jvm "constructor" private createHashMap :: JHashMap;

foreign unsafe import jvm "isNull" private isArrayNull :: JIntArray -> Boolean;

foreign unsafe import jvm "method get"
    private lookup :: JHashMap -> JObject -> JObject;

foreign unsafe import jvm "method keySet" private keySet :: JHashMap -> JSet;

foreign unsafe import jvm "method put"
    private insert :: JHashMap -> JObject -> JObject -> JObject;

foreign unsafe import jvm "cast" stringToObject :: String -> JObject;

foreign unsafe import jvm "cast" objectToJIntArray :: JObject -> JIntArray;

foreign unsafe import jvm "cast" jIntArrayToJObject :: JIntArray -> JObject;

foreign unsafe import jvm "cast" jSetToJObject :: JSet -> JObject;

/** 
 * update the count for a given key in the map
 * if the key is not in the map, it is added with value 1.
 */
update :: JHashMap -> String -> Int;
update !map !string =
    let
        value :: JIntArray;
        value =
            eager $ objectToJIntArray (lookup map (stringToObject string));
    in
        if not (isArrayNull value) then
            updateArray value 0 (1 + value `subscriptArray` 0)
        else
            let
                array :: JIntArray;
                array = eager (newArray 1);
            in
                insert map (stringToObject string) (jIntArrayToJObject array)
                `seq`
                updateArray array 0 1
    ;

/** 
 * Lookup a value in a hashmap.
 * Return 0 if the key is not in the hashmap
 */
getValue :: JHashMap -> String -> Int;
getValue !map !string =
    let
        value :: JIntArray;
        value =
            eager $ objectToJIntArray (lookup map (stringToObject string));
    in
        if not (isArrayNull value) then
            value `subscriptArray` 0
        else
            //the key is not in the map
            0
    ;

/** convert a JhashMap to a list of key, value pairs.*/
hashMapToPairs :: JHashMap -> [(String, Int)];
hashMapToPairs !jmap =
    let
        keys :: [String];
        keys = input (jSetToJObject (keySet jmap));
    in
        map (\!key -> (key, getValue jmap key)) keys
    ;

/** compute the frequency table for a specified fragment length*/
calculateFrequencies :: String -> Int -> JHashMap;
calculateFrequencies !sequence !fragmentLength =
    let
        len :: Int;
        len = eager $ length sequence - fragmentLength + 1;

        freqMap :: JHashMap;
        freqMap = eager createHashMap;

        process :: Int -> Int -> JHashMap;
        process !offset !index =
            if index < len then
                update
                    freqMap
                    (substring sequence index (index + fragmentLength))
                `seq`
                process offset (index + 1)
            else
                freqMap
            ;
    in
        process 0 0
    ;

/**read dna seq from stdin*/
read :: JBufferedReader -> String;
read !reader =
    let
        skipTill3 :: JBufferedReader -> ();
        skipTill3 !reader =
            let
                line :: String;
                line = eager $ readLine reader;
            in
                if not (startsWith ">THREE" line) then
                    skipTill3 reader
                else
                    ()
            ;

        stringBuffer :: JStringBuffer;
        stringBuffer = eager $ createStringBuffer;

        readSeq :: JBufferedReader -> ();
        readSeq !reader =
            let
                line :: String;
                line = eager $ readLine reader;
            in
                if isNullString line then
                    ()
                else if subscript line 0 == '>' then
                    ()
                else if subscript line 0 != ';' then
                    append stringBuffer (toUpperCase line)
                    `seq`
                    readSeq reader
                else
                    readSeq reader
            ;
    in
        skipTill3 reader
        `seq`
        readSeq reader
        `seq`
        show stringBuffer
    ;

showFreq :: [(String, Int)] -> Int -> String;
showFreq !freqList !total =
    foldLeftStrict
        (
            \!str !item ->
                case item of
                (name, freq)
                ->
                    formatWithPattern
                        "{0}{1} {2,number,0.000}\n"
                        invariantLocale
                        (str, name, fromInt freq / fromInt total * 100.0)
                    ;
        )
        ""
        (sortBy
            (combineComparators
                (reverseComparator (induceComparator snd))
                (induceComparator fst)
            )
            freqList
        )
    ++ "\n"
    ;

showCount :: JHashMap -> String -> String;
showCount !hashmap !nucleotide =
    show (getValue hashmap nucleotide) ++ "\t" ++ nucleotide ++ "\n";

main :: [String] -> ();
public main !args =
    let
        sq :: String;
        sq = eager $ read (makeBufferedReader stdin);

        //sequence (readLines (makeBufferedReader stdin));

        //build freqnece map for length 1 nucledotides
        freq1 :: [(String, Int)];
        freq1 = hashMapToPairs (calculateFrequencies sq 1);

        //build freqnece map for length 2 nucledotides
        freq2 :: [(String, Int)];
        freq2 = hashMapToPairs (calculateFrequencies sq 2);

        seqLength :: Int;
        seqLength = length sq;

        //build 3,4,6,12,18 nucledotide maps and get counts for some specific instances.
        counts :: String;
        counts =
            foldLeftStrict
                (
                    \!str !item ->
                        str
                        ++ showCount
                            (calculateFrequencies sq (length item))
                            item
                )
                ""
                [
                    "GGT",
                    "GGTA",
                    "GGTATT",
                    "GGTATTTTAATT",
                    "GGTATTTTAATTTATAGT"
                ]
            ;
    in

        print (showFreq freq1 seqLength)
        `seq`
        print (showFreq freq2 (seqLength - 1))
        `seq`
        print counts
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Mandelbrot;

import Cal.Core.Prelude using
    typeConstructor = Double, Int, String;
    function = eager, fromInt, seq, stringToInt;
    ;

import Cal.Core.Debug using
    function = show;
    ;
import Cal.Core.Bits using
    function = bitwiseAnd, bitwiseOr, shiftL;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.IO.Console using
    function = print;
    ;


data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

data foreign unsafe import jvm "java.io.FilterOutputStream"
    private JFilterOutputStream;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JPrintStream;

data foreign unsafe import jvm "java.io.OutputStream" private JOutputStream;

data foreign unsafe import jvm "java.io.BufferedOutputStream"
    private JBufferedOutputStream;

foreign unsafe import jvm "constructor"
    private createBufferedOutputStream :: JOutputStream -> JBufferedOutputStream;

foreign unsafe import jvm "method write"
    private write :: JBufferedOutputStream -> Int -> ();

foreign unsafe import jvm "method flush"
    private flush :: JBufferedOutputStream -> ();

foreign unsafe import jvm "cast"
    jPrintStreamToJOutputStream :: JPrintStream -> JOutputStream;

/** 
 * compute a binary mandelbrot image and write to stdout as a pbm file
 */
main :: [String] -> ();
public main !args =
    let
        size = eager $ stringToInt (head args);

        offset :: Int;
        offset = eager $ bitwiseAnd size 7;

        shift :: Int;
        shift =
            eager
            $
            (
                if offset == 0 then
                    0
                else
                    8 - offset
            )
            ;

        bufferedOutput = 
            eager
            $ createBufferedOutputStream (jPrintStreamToJOutputStream stdout)
            ;

        maxIterations :: Int;
        maxIterations = 50;

        /** write out the byte buffer every 8th pixel*/
        outputBitBuffer :: Int -> Int -> Int;
        outputBitBuffer !x !buffer =
            if bitwiseAnd x 7 == 7 then
                //write the buffer
                write bufferedOutput buffer
                `seq`
                0
            else
                //no, output buffer is not yet full
                buffer
            ;

        /**write out the paritial byte buffer at end of line if necessary*/
        writeLastByte :: Int -> ();
        writeLastByte !bitBuffer =
            if (shift != 0) then
                write bufferedOutput (shiftL bitBuffer shift)
            else
                ()
            ;

        /** compute and output every pixel in the image*/
        process :: Int -> Int -> Int -> Double -> Double -> ();
        process !x !y !bitBuffer !ix !iy =
            if x < size then
                let
                    calculateBit ::
                        Int -> Double -> Double -> Double -> Double -> Int;
                    calculateBit !i !zr !zi !cr !ci =
                        if i == maxIterations then
                            1
                        else if zr * zr + zi * zi > 4 then
                            0
                        else
                            calculateBit
                                (i + 1)
                                (zr * zr - zi * zi + cr)
                                (2.0 * zr * zi + ci)
                                cr
                                ci
                        ;
                in
                    process
                        (x + 1)
                        y
                        (outputBitBuffer
                            x
                            (
                                eager
                                $ bitwiseOr
                                    (eager $ shiftL bitBuffer 1)
                                    (eager $ calculateBit 0 ix iy ix iy)
                            )
                        )
                        (fromInt (2 * (x + 1)) / fromInt size - 1.5)
                        iy
            else
                writeLastByte bitBuffer
                `seq`
                (
                    if y < size - 1 then
                        process
                            0
                            (y + 1)
                            0
                            (-1.5)
                            (fromInt (2 * (y + 1)) / fromInt size - 1.0)
                    else
                        flush bufferedOutput
                )
            ;
    in
        //write out the image header
        print ("P4\n" ++ show size ++ " " ++ show size ++ "\n")
        `seq`
        //compute and write out the binary image body
        process 0 0 0 (-1.5) (-1.0)
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Message;

import Cal.Core.Prelude using
    typeConstructor = Int, String;
    function = eager, error, intToString, seq, stringToInt;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Experimental.Concurrent.Parallel using
    function = par;
    ;

import Cal.Experimental.Concurrent.BlockingQueue using
    typeConstructor = BlockingQueue;
    function = makeBlockingQueue, take, put;
    ;

import Cal.Core.System using
    function = concurrentRuntime;
    ;

/** this value is used to tell the workers to end */
end :: Int;
end = -1;

/** default queue length */
queueLength = 256;

/**
 * an indivual worker which takes values from the upstream queue, adds one, and
 * puts them on the downstream queue.
 */
worker :: BlockingQueue Int -> BlockingQueue Int -> ();
worker !inq !outq =
    let
        input :: Int;
        input = eager $ take inq;
    in
        if (input == end) then
            put outq end
            `seq`
            ()
        else
            (
                put outq (input + 1)
                `seq`
                worker inq outq
            )
    ;

/**
 * create a chain of worker functions running in parallel this is done using
 * the par function.
 */
createChain :: Int -> BlockingQueue Int -> BlockingQueue Int;
createChain !length !input =
    if (length == 0) then
        input
    else
        (
            let
                output :: BlockingQueue Int;
                output = makeBlockingQueue queueLength;
            in
                worker input output
                `par`
                createChain (length - (1 :: Int)) output
        )
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        inQueue :: BlockingQueue Int;
        inQueue = eager $ makeBlockingQueue queueLength;

        outQueue :: BlockingQueue Int;
        outQueue = eager $ createChain (500 :: Int) inQueue;

        /** this feeds n 0's into the first queue */
        feedQueue :: Int -> ();
        feedQueue n =
            if (n == 0) then
                put inQueue end
            else
                put inQueue (0 :: Int)
                `seq`
                feedQueue (n - 1)
            ;

        /** this collects n values from the last queue */
        sumResult :: Int -> Int -> Int;
        sumResult !n !sum =
            if (n == 0) then
                sum
            else
                sumResult (n - 1) (sum + (take outQueue))
            ;
    in
        if concurrentRuntime then
            feedQueue n 
            `par` 
            printLine (intToString $ sumResult n 0)
        else
            error
                "You must define the VM arg org.openquark.cal.machine.lecc.concurrent_runtime to run this program"
    ;
/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Message;

import Cal.Core.Prelude using
    typeConstructor = Int, String, JObject, Boolean;
    function =
        eager, error, intToString, seq, stringToInt, unsafeFromCalValue,
        toCalValue, input, output;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Experimental.Concurrent.Parallel using
    function = par;
    ;

import Cal.Core.System using
    function = concurrentRuntime;
    ;

/** this value is used to tell the workers to end */
end :: Int;
end = -1;

/**
 * an indivual worker which takes values from the upstream queue, adds one, and
 * puts them on the downstream queue.
 */
worker :: MutableVariable Int -> MutableVariable Int -> ();
worker !inq !outq =
    let
        input :: Int;
        input = eager $ takeMutableVariable inq;
    in
        if (input == end) then
            putMutableVariable outq end
            `seq`
            ()
        else
            (
                putMutableVariable outq (input + 1)
                `seq`
                worker inq outq
            )
    ;

/**
 * create a chain of worker functions running in parallel this is done using
 * the par function.
 */
createChain :: Int -> MutableVariable Int -> MutableVariable Int;
createChain !length !input =
    if (length == 0) then
        input
    else
        (
            let
                output :: MutableVariable Int;
                output = makeMutableVariable ();
            in
                worker input output
                `par`
                createChain (length - (1 :: Int)) output
        )
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        inq :: MutableVariable Int;
        inq = eager $ makeMutableVariable ();

        outq :: MutableVariable Int;
        outq = eager $ createChain (500 :: Int) inq;

        /** this feeds n 0's into the first queue */
        feedQueue :: Int -> ();
        feedQueue n =
            if (n == 0) then
                putMutableVariable inq end
            else
                putMutableVariable inq (0 :: Int)
                `seq`
                feedQueue (n - 1)
            ;

        /** this collects n values from the last queue */
        sumResult :: Int -> Int -> Int;
        sumResult !n !sum =
            if (n == 0) then
                sum
            else
                sumResult (n - 1) (sum + (takeMutableVariable outq))
            ;
    in
        (
            if concurrentRuntime then
                ()
            else
                error
                    "You must define the VM arg org.openquark.cal.machine.lecc.concurrent_runtime to run this program"
        )
        `seq`
        feedQueue n
        `par`
        printLine (intToString $ sumResult n 0)
    ;

//////////////////////////////////////////////////////////////////////
// This implements MutableVariable, similar to m-structures in Id.

/**
 * MutableVariable represent a value that can be passed between threads using
 * put and take. It has the same semantics as a BlockableQueue of length 1.
 */
data public MutableVariable a =
    private MutableVariable atomicRef :: !AtomicReference
    ;

/** make a new mutable variable */
makeMutableVariable :: () -> MutableVariable a;
public makeMutableVariable !unused = MutableVariable createAtomicReference;

/**
 * Put a value into a mutable variable. If the variable is not empty this
 * function will block.
 */
putMutableVariable :: MutableVariable a -> a -> ();
public putMutableVariable !mutable !value =
    let
        put :: AtomicReference -> JObject -> ();
        put !ref !value =
            if compareAndSet ref null value then
                ()
            else
                yield
                `seq`
                put ref value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            put atomicRef (output (toCalValue value));
    ;

/**
 * take a value from a mutable variable, if the there is no value in the
 * variable this will block.
 */
takeMutableVariable :: MutableVariable a -> a;
public takeMutableVariable !mutable =
    let
        take :: AtomicReference -> JObject;
        take !atomicRef =
            let
                value = eager $ getAndSet atomicRef null;
            in
                if isNull value then
                    yield
                    `seq`
                    take atomicRef
                else
                    value
            ;
    in
        case mutable of
        MutableVariable {atomicRef} ->
            unsafeFromCalValue $ input $ take atomicRef;
    ;

data foreign unsafe import jvm "java.util.concurrent.atomic.AtomicReference"
    private AtomicReference;

foreign unsafe import jvm "constructor"
    private createAtomicReference :: AtomicReference;

foreign unsafe import jvm "method weakCompareAndSet"
    private compareAndSet :: AtomicReference -> JObject -> JObject -> Boolean;

foreign unsafe import jvm "method getAndSet"
    private getAndSet :: AtomicReference -> JObject -> JObject;

foreign unsafe import jvm "static method java.lang.Thread.yield"
    private yield :: ();

foreign unsafe import jvm "isNull" private isNull :: JObject -> Boolean;

foreign unsafe import jvm "null" private null :: JObject;
/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Meteor;

import Cal.Core.Prelude using
    typeClass = Enum, Inputable, IntEnum, Outputable;
    typeConstructor = Boolean, Int, Long, String;
    dataConstructor = False, True;
    function = eager, fromInt, iff, seq, stringToInt;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Core.Bits using
    function = bitwiseAnd, bitwiseOr, shiftL, shiftRUnsigned;
    ;
import Cal.Collections.List using
    function = foldLeftStrict, head, map;
    ;
import Cal.Collections.Array using
    typeConstructor = Array;
    ;
import Cal.IO.Console using
    function = printLine;
    ;


data foreign unsafe import jvm "long[]"
    JLongArray deriving Inputable, Outputable, Show;

foreign unsafe import jvm "newArray" longArray_new :: Int -> JLongArray;

foreign unsafe import jvm "lengthArray" longArray_length :: JLongArray -> Int;

foreign unsafe import jvm "subscriptArray"
    longArray_subscript :: JLongArray -> Int -> Long;

foreign unsafe import jvm "updateArray"
    longArray_update :: JLongArray -> Int -> Long -> Long;

/** build an array from a list*/
jLongArrayfromList :: [Long] -> JLongArray;
jLongArrayfromList !input =
    let
        array :: JLongArray;
        array = eager $ longArray_new (List.length input);
    in
        array
        `seq`
        foldLeftStrict
            (
                \!index !value ->
                    longArray_update array index value
                    `seq`
                    (index + 1)
            )
            0
            input
        `seq`
        array
    ;

data Direction =
    E | SE | SW | W | NW | NE
    deriving Enum, IntEnum
    ;

/** the puzzle pieces*/
pieces :: [[Direction]];
pieces =
    [
        [E, E, E, SE],
        [SE, SW, W, SW],
        [W, W, SW, SE],
        [E, E, SW, SE],
        [NW, W, NW, SE, SW],
        [E, E, NE, W],
        [NW, NE, NE, W],
        [NE, SE, E, NE],
        [SE, SE, E, SE],
        [E, NW, NW, NW]
    ]
    ;

width :: Int;
width = 5;

height :: Int;
height = 10;

/** rotate a puzzle piece clockwise */
rotatePiece :: [Direction] -> [Direction];
rotatePiece !piece =
    let
        rotate :: Direction -> Direction;
        rotate !direction =
            case direction of
            E -> SE;
            SE -> SW;
            SW -> W;
            W -> NW;
            NW -> NE;
            NE -> E;
            ;
    in
        map rotate piece
    ;

/** flip a piece about it's vertical axis*/
flipPiece :: [Direction] -> [Direction];
flipPiece !piece =
    let
        flip :: Direction -> Direction;
        flip !direction =
            case direction of
            E -> W;
            SE -> SW;
            SW -> SE;
            W -> E;
            NW -> NE;
            NE -> NW;
            ;
    in
        map flip piece
    ;

/** 
 * the puzzle board is represented as a 64 long. The positions on the board,
 * from the top left, row by row, to the bottom right are represented
 * by bits highbit to lowbit inclusive. A set bit means the position is occupied.
 * An unset bit means the bit is not occupied.
 */
highBit :: Long;
highBit = 4611686018427387904;

lowBit :: Long;
lowBit = 8192;

fullBoard :: Long;
fullBoard = 9223372036854767616;

/** 
 * an array with one mask for each position on the board. The set bits in the mask
 * correspond to positions on the board that are adjacent.
 */
adjacentSquares :: JLongArray;
adjacentSquares =
    let
        adjacent :: [Direction];
        //route of steps to surround the square
        adjacent = [E, SW, W, NW, NE, E];
    in
        jLongArrayfromList
            (List.mapIndexed
                (
                    \!a !i ->
                        toBits
                        $ validCoords
                        $ List.tail
                        $ toCoords adjacent (i % width) (i / width)
                )
                (List.replicate (width * height) (0 :: Int))
            )
    ;

/** 
 * returns the board position 0 .. 49 of the first occuipied square
 */
getFirstSetBit :: Long -> Int;
getFirstSetBit !word =
    let
        helper :: Long -> Long -> Int -> Int;
        helper !word !bit !i =
            if bitwiseAnd word bit != 0 then
                i
            else
                helper word (shiftRUnsigned bit 1) (i + 1)
            ;
    in
        helper word highBit 0
    ;

/** 
 * return the number of bits that are set in a mask
 */
countBits :: Long -> Int;
countBits !word =
    let
        helper :: Long -> Int -> Int;
        helper !word !count =
            if word == 0 then
                count
            else
                helper (bitwiseAnd word (word - 1)) (count + 1)
            ;
    in
        eager $ helper word 0
    ;

/** 
 * returns true if the board mask has an island of fewer than five positions -
 * used to prune positions tha have 'holes' that no piece could fit into
 * (as all pieces are of size 5)
 */
hasSmallIslands :: Long -> Boolean;
hasSmallIslands !board =
    let
        fill :: Long -> Long -> Long -> Long;
        fill !board !filled !seeds =
            if seeds == 0 then
                filled
            else
                let
                    highestSeed :: Int;
                    highestSeed = eager $ getFirstSetBit seeds;

                    newSeeds :: Long;
                    newSeeds =
                        eager
                        $ bitwiseAnd
                            (longArray_subscript adjacentSquares highestSeed)
                            (Bits.complement $ bitwiseOr filled board)
                        ;
                in
                    fill
                        board
                        (bitwiseOr filled (bitwiseOr seeds newSeeds))
                        (bitwiseAnd
                            (bitwiseOr seeds newSeeds)
                            (
                                Bits.complement
                                $ Bits.shiftR highBit (fromInt highestSeed)
                            )
                        )
            ;
    in

        if bitwiseAnd board fullBoard == fullBoard then
            False
        else
            let
                island :: Long;
                island =
                    eager
                    $ fill
                        board
                        0
                        (
                            Bits.highestBitMask
                            $ bitwiseAnd fullBoard (Bits.complement board)
                        )
                    ;
            in
                if countBits island < 5 then
                    True
                else
                    hasSmallIslands (bitwiseOr board island)
    ;

/** 
 * take a solution and make the reverse - a second solution that is a rotation of the first.
 */
makeReverseSolution :: JLongArray -> JLongArray -> JLongArray;
makeReverseSolution !solution !reversed =
    let
        reverseMask :: Long -> Long;
        reverseMask !board =
            let
                reverse :: Long -> Long -> Long -> Long -> Long;
                reverse !board !res !fromBit !toBit =
                    if fromBit < lowBit then
                        res
                    else if bitwiseAnd fromBit board != 0 then
                        reverse
                            board
                            (bitwiseOr res toBit)
                            (shiftRUnsigned fromBit 1)
                            (shiftL toBit 1)
                    else
                        reverse
                            board
                            res
                            (shiftRUnsigned fromBit 1)
                            (shiftL toBit 1)
                    ;
            in
                reverse board (bitwiseAnd board 15) highBit lowBit
            ;

        len :: Int;
        len = eager $ longArray_length solution;

        loop :: Int -> JLongArray;
        loop !i =
            if i < len then
                longArray_update
                    reversed
                    i
                    (reverseMask $ longArray_subscript solution i)
                `seq`
                loop (i + 1)
            else
                reversed
            ;
    in
        loop 1
    ;

/** true if the coord is on the board*/
validCoord :: (Int, Int) -> Boolean;
validCoord !coord =
    case coord of
    (x, y) -> x >= 0 && x < width && y >= 0 && y < height;
    ;

/** filter a list of corrds and return only those that fit on the board*/
validCoords :: [(Int, Int)] -> [(Int, Int)];
validCoords !coords = List.filter validCoord coords;

/** convert a piece to a list of coords*/
toCoords :: [Direction] -> Int -> Int -> [(Int, Int)];
toCoords !piece !x !y =
    case piece of
    head : tail ->
        case head of
        E -> (x, y) : toCoords tail (x + 1) y;
        SE -> (x, y) : toCoords tail (x + bitwiseAnd y 1) (y + 1);
        SW ->
            (x, y) : toCoords tail (x - (1 - bitwiseAnd y 1)) (y + 1);
        W -> (x, y) : toCoords tail (x - 1) y;
        NW ->
            (x, y) : toCoords tail (x - (1 - bitwiseAnd y 1)) (y - 1);
        NE -> (x, y) : toCoords tail (x + bitwiseAnd y 1) (y - 1);
        ;
    [] -> [(x, y)];
    ;

getValueAtbit :: JLongArray -> Long -> Int -> Long;
getValueAtbit !solution !bit !i =
    if bitwiseAnd bit (longArray_subscript solution i) != 0 then
        bitwiseAnd (longArray_subscript solution i) 15
    else
        getValueAtbit solution bit (i + 1)
    ;

copy :: JLongArray -> JLongArray -> Int -> ();
copy !solution1 !solution2 !i =
    if i < 11 then
        longArray_update solution1 i (longArray_subscript solution2 i)
        `seq`
        copy solution1 solution2 (i + 1)
    else
        ()
    ;

/** 
 * set solution 2 to the max of solution 2 and solution 1.
 */
updateMaxSolution :: JLongArray -> JLongArray -> ();
updateMaxSolution !solution1 !solution2 =
    let
        greaterThan :: JLongArray -> JLongArray -> Long -> Boolean;
        greaterThan !solution1 !solution2 !bit =
            let
                v1 :: Long;
                v1 = eager $ getValueAtbit solution1 bit 1;

                v2 :: Long;
                v2 = eager $ getValueAtbit solution2 bit 1;
            in
                if v1 == v2 then
                    greaterThan solution1 solution2 (shiftRUnsigned bit 1)
                else
                    v1 < v2
            ;
    in

        if greaterThan solution1 solution2 highBit then
            copy solution1 solution2 0
        else
            ()
    ;

/** 
 * set solution 2 to the minimum of solution 2 and solution 1.
 */
updateMinSolution :: JLongArray -> JLongArray -> ();
updateMinSolution !solution1 !solution2 =
    let
        lessThan :: JLongArray -> JLongArray -> Long -> Boolean;
        lessThan !solution1 !solution2 !bit =
            let
                v1 :: Long;
                v1 = eager $ getValueAtbit solution1 bit 1;

                v2 :: Long;
                v2 = eager $ getValueAtbit solution2 bit 1;
            in
                if v1 == v2 then
                    lessThan solution1 solution2 (shiftRUnsigned bit 1)
                else
                    v1 > v2
            ;
    in

        if lessThan solution1 solution2 highBit then
            copy solution1 solution2 0
        else
            ()
    ;

/** true if the list of coords all fit on the board*/
fits :: [(Int, Int)] -> Boolean;
fits !coords = List.all validCoord coords;

/** convert a coord to a bit mask*/
toBit :: (Int, Int) -> Long;
toBit !coord = shiftRUnsigned highBit (fromInt (coord.#1 + coord.#2 * 5));

/** convert a list of coords to be bit mask*/
toBits :: [(Int, Int)] -> Long;
toBits !coords = foldLeftStrict bitwiseOr 0 (map toBit coords);

/** convert a list of coords to be bit mask, with a piece id in the lower bits*/
coordsToBits :: [(Int, Int)] -> Int -> Long;
coordsToBits !coords !pieceNo =
    let
        bits :: [Long];
        bits = map toBit coords;
    in
        foldLeftStrict bitwiseOr (fromInt pieceNo) bits
    ;

/** find the next empty square starting at square*/
findNextEmptySquare :: Long -> Int -> Int;
findNextEmptySquare !board !square =
    if bitwiseAnd board (shiftRUnsigned highBit (fromInt square)) == 0 then
        square
    else
        findNextEmptySquare board (square + 1)
    ;

/** convert a solution to s string in the benchmark format*/
showSolution :: JLongArray -> String;
showSolution !solution =
    let
        findId :: Int -> Long -> String;
        findId !i !bit =
            if i == 11 then
                "-"
            else if bitwiseAnd (longArray_subscript solution i) bit > 0 then
                show (i - 1)
            else
                findId (i + 1) bit
            ;

        drawBoard :: Int -> Long -> String -> String;
        drawBoard !i !bit !result =
            let
                term1 :: String;
                term1 =
                    if i > 0 && i % 5 == 0 then
                        "\n"
                    else
                        ""
                    ;

                term2 :: String;
                term2 =
                    if i % 10 == 5 then
                        " "
                    else
                        ""
                    ;
            in
                if i < 50 then
                    drawBoard
                        (i + 1)
                        (shiftRUnsigned bit 1)
                        (result ++ term1 ++ term2 ++ findId 0 bit ++ " ")
                else
                    result
            ;
    in

        drawBoard 0 highBit ""
    ;

/** 
 * Creates an array in which for each square on the board
 * there is an array of bit masks for the pieces that occupy that square as their first square
 */
allSortedMasks :: [[Direction]] -> Array JLongArray;
allSortedMasks !pieces =
    let
        masks :: [Long];
        masks =
            List.reverse
            $ List.sortExternal
            $ Prelude.concat
            $ List.zipWith getAllMasks pieces [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            ;

        loop :: Long -> [Long] -> [[Long]] -> [[Long]];
        loop !bit !masks !res =
            if bit < lowBit then
                res
            else
                loop
                    (shiftRUnsigned bit 1)
                    (List.dropWhile (\!a -> a > bit) masks)
                    (res ++ [List.takeWhile (\!a -> a > bit) masks])
            ;
    in

        Array.fromList (map jLongArrayfromList (loop highBit masks []))
    ;

meteor :: Int -> ();
meteor !n =
    let
        masks :: Array JLongArray;
        masks = allSortedMasks pieces;

        minSol :: JLongArray;
        minSol = longArray_new 11;

        maxSol :: JLongArray;
        maxSol = longArray_new 11;

        workingSolution :: JLongArray;
        workingSolution = longArray_new 11;
    in
        longArray_update maxSol 1 highBit
        `seq`
        longArray_update minSol 1 (bitwiseOr highBit 11)
        `seq`
        solve
            0
            emptyBoard
            workingSolution
            (longArray_new 11)
            masks
            (Array.subscript masks 0)
            0
            0
            maxSol
            minSol
        `seq`
        printLine
            (
                show (longArray_subscript workingSolution 0)
                ++ " solutions found"
            )
        `seq`
        printLine ""
        `seq`
        printLine (showSolution minSol)
        `seq`
        printLine ""
        `seq`
        printLine (showSolution maxSol)
        `seq`
        printLine ""
    ;

solve ::
    Int -> Long -> JLongArray -> JLongArray -> Array JLongArray -> JLongArray
    -> Int -> Int -> JLongArray -> JLongArray -> ();
solve !i !board !solution !reverseSolution !allMasks !masks !numPieces 
      !boardSquare !maxSolution !minSolution =

    if i >= longArray_length masks then
        ()
    else
        let
            pieceMask :: Long;
            pieceMask = eager $ longArray_subscript masks i;

            pieceId :: Int;
            pieceId = eager $ Prelude.fromLong (bitwiseAnd pieceMask 15);
        in

            //if the piece is not already in use and it fits
            if
                longArray_subscript solution pieceId == 0
                && bitwiseAnd board pieceMask < 16
            then
                let
                    newBoard :: Long;
                    newBoard = eager $ bitwiseOr board pieceMask;

                    nextSquare :: Int;
                    nextSquare =
                        eager $ findNextEmptySquare newBoard boardSquare;
                in
                    longArray_update solution pieceId pieceMask
                    `seq`
                    (
                        if numPieces == 9 then
                            longArray_update
                                solution
                                0
                                (longArray_subscript solution 0 + 2)
                            `seq`
                            makeReverseSolution solution reverseSolution
                            `seq`
                            updateMaxSolution maxSolution solution
                            `seq`
                            updateMaxSolution maxSolution reverseSolution
                            `seq`
                            updateMinSolution minSolution solution
                            `seq`
                            updateMinSolution minSolution reverseSolution
                            `seq`
                            longArray_update solution pieceId 0
                            `seq`
                            ()
                        else if
                            nextSquare > 25
                            && longArray_subscript solution 1 == 0
                        then
                            longArray_update solution pieceId 0
                            `seq`
                            solve
                                (i + 1)
                                board
                                solution
                                reverseSolution
                                allMasks
                                masks
                                numPieces
                                boardSquare
                                maxSolution
                                minSolution
                        else
                            solve
                                0
                                newBoard
                                solution
                                reverseSolution
                                allMasks
                                (Array.subscript allMasks nextSquare)
                                (numPieces + 1)
                                nextSquare
                                maxSolution
                                minSolution
                            `seq`
                            longArray_update solution pieceId 0
                            `seq`
                            solve
                                (i + 1)
                                board
                                solution
                                reverseSolution
                                allMasks
                                masks
                                numPieces
                                boardSquare
                                maxSolution
                                minSolution
                    )
            else
                solve
                    (i + 1)
                    board
                    solution
                    reverseSolution
                    allMasks
                    masks
                    numPieces
                    boardSquare
                    maxSolution
                    minSolution
    ;

/** 
 * computes a list of all the masks for a particular piece.
 * The list includes all positions, rotations and flips of the piece.
 */
getAllMasks :: [Direction] -> Int -> [Long];
getAllMasks !piece !pieceNo =
    let

        //this is used so we omit masks were piece 1 is in the bottom half of the board
        //these positions will be covered by symmetry
        heightp :: Int;
        heightp =
            eager
            $
            (
                if pieceNo == 1 then
                    height / 2 - 1
                else
                    height
            )
            ;

        getRotationMasks :: [Direction] -> Int -> [Long] -> [Long];
        getRotationMasks !piece !n !masks =
            getTranslationMasks piece
            ++ iff
                (n > 0)
                (getRotationMasks (rotatePiece piece) (n - 1) masks)
                []
            ;

        getTranslationMasks :: [Direction] -> [Long];
        getTranslationMasks !piece =
            let
                loop :: Int -> Int -> [Long] -> [Long];
                loop !x !y !masks =
                    if x < width then
                        let
                            coords :: [(Int, Int)];
                            coords = eager $ toCoords piece x y;

                            mask :: Long;
                            mask = eager $ coordsToBits coords pieceNo;
                        in
                            if
                                fits coords
                                && (Prelude.not $ hasSmallIslands mask)
                            then
                                loop (x + 1) y (mask : masks)
                            else
                                //reject the piece
                                loop (x + 1) y masks
                    else if y < heightp then
                        loop 0 (y + 1) masks
                    else
                        masks
                    ;
            in
                loop 0 0 []
            ;
    in
        getRotationMasks piece 5 []
        ++ getRotationMasks (flipPiece piece) 5 []
    ;

emptyBoard :: Long;
emptyBoard = 0;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);
    in
        meteor n
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Joseph Wong.
 */
module Nbody;

import Cal.Core.Prelude using
    typeClass = Inputable, Outputable;
    typeConstructor = CalValue, Double, Int, JObject, String;
    function = eager, input, output, seq, stringToInt, unsafeCoerce;
    ;
import Cal.Collections.Array;
import Cal.Collections.List using
    function = head;
    ;
import Cal.Utilities.Math using
    function = sqrt;
    ;
import Cal.Utilities.MessageFormat using
    function = formatWithPattern;
    ;
import Cal.Utilities.Locale using
    function = invariantLocale;
    ;
import Cal.IO.Console using
    function = printLine;
    ;

data foreign unsafe import jvm "double[]" JVector deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" newVector :: Int -> JVector;

foreign unsafe import jvm "subscriptArray" get :: JVector -> Int -> Double;

foreign unsafe import jvm "updateArray"
    set :: JVector -> Int -> Double -> Double;

/** a body is represented by position, velocity and mass*/
data public Body =
    Body
        position :: !JVector
        velocity :: !JVector
        mass :: !Double
    ;

/** construct a vector from three doubles*/
makeVector :: Double -> Double -> Double -> JVector;
makeVector !x !y !z =
    let
        v :: JVector;
        v = newVector 3;
    in
        set v 0 x
        `seq`
        set v 1 y
        `seq`
        set v 2 z
        `seq`
        v
    ;

daysPerYear :: Double;
daysPerYear = 365.24;

pi :: Double;
pi = 3.141592653589793;

solarMass :: Double;
solarMass = 4 * pi * pi;

/** calculate the initial offset moment for the sun*/
computeOffsetMomentum :: BodyArray -> Double;
computeOffsetMomentum bodies =
    let
        offset :: JVector;
        offset = makeVector 0 0 0;

        sun :: Body;
        sun = eager (bodies `subscriptBodyArray` 0);

        length :: Int;
        length = eager $ lengthBodyArray bodies;
        
        updateOffsetForBodies :: Int -> ();
        updateOffsetForBodies !i =
            if i < length then
                (
                    case bodies `subscriptBodyArray` i of
                    Body position velocity mass ->
                        set offset 0 (get offset 0 + get velocity 0 * mass)
                        `seq`
                        set offset 1 (get offset 1 + get velocity 1 * mass)
                        `seq`
                        set offset 2 (get offset 2 + get velocity 2 * mass)
                        ;
                )
                `seq`
                updateOffsetForBodies (i+1)
            else
                ();
        
    in
        updateOffsetForBodies 0
        `seq`
        (
            case sun of
            Body pos velocity mass ->
                set velocity 0 (-get offset 0 / solarMass)
                `seq`
                set velocity 1 (-get offset 1 / solarMass)
                `seq`
                set velocity 2 (-get offset 2 / solarMass)
                ;
        )
    ;

/** calcualte the potential and kenetic energy*/
energy :: BodyArray -> Double;
energy !bodies =
    let
        numBodies :: Int;
        numBodies = eager $ lengthBodyArray bodies;

        loop :: Double -> Int -> Int -> Double;
        loop !energy !i !j =
            if j < numBodies then
                case bodies `subscriptBodyArray` i of
                Body pos1 vel1 mass1 ->
                    case bodies `subscriptBodyArray` j of
                    Body pos2 vel2 mass2 ->
                        let
                            dx :: Double;
                            dx = eager $ get pos1 0 - get pos2 0;

                            dy :: Double;
                            dy = eager $ get pos1 1 - get pos2 1;

                            dz :: Double;
                            dz = eager $ get pos1 2 - get pos2 2;

                            distance :: Double;
                            distance =
                                eager $ sqrt (dx * dx + dy * dy + dz * dz);
                        in
                            loop
                                (energy - mass1 * mass2 / distance)
                                i
                                (j + 1)
                        ;
                    ;
            else if i < numBodies then
                case bodies `subscriptBodyArray` i of
                Body pos vel mass ->
                    loop
                        (
                            energy
                            + 0.5 * mass
                                *
                                (
                                    get vel 0 * get vel 0
                                    + get vel 1 * get vel 1
                                    + get vel 2 * get vel 2
                                )
                        )
                        (i + 1)
                        (i + 2)
                    ;
            else
                energy
            ;
    in
        loop 0.0 0 1
    ;

/** advance state of the bodies by time delta*/
advance :: Double -> BodyArray -> ();
advance !dt !bodies =
    let
        numBodies :: Int;
        numBodies = eager $ lengthBodyArray bodies;

        updateVelocity ::
            JVector -> JVector -> JVector -> JVector -> Double -> Double -> ();
        updateVelocity !pos1 !pos2 !vel1 !vel2 !mass1 !mass2 =
            let
                dx :: Double;
                dx = eager $ get pos1 0 - get pos2 0;

                dy :: Double;
                dy = eager $ get pos1 1 - get pos2 1;

                dz :: Double;
                dz = eager $ get pos1 2 - get pos2 2;

                mag :: Double;
                mag =
                    eager
                        (
                            let
                                distance :: Double;
                                distance =
                                    eager
                                    $ sqrt (dx * dx + dy * dy + dz * dz)
                                    ;
                            in
                                dt / (distance * distance * distance)
                        )
                    ;
            in
                set vel1 0 (get vel1 0 - dx * mass2 * mag)
                `seq`
                set vel1 1 (get vel1 1 - dy * mass2 * mag)
                `seq`
                set vel1 2 (get vel1 2 - dz * mass2 * mag)
                `seq`

                set vel2 0 (get vel2 0 + dx * mass1 * mag)
                `seq`
                set vel2 1 (get vel2 1 + dy * mass1 * mag)
                `seq`
                set vel2 2 (get vel2 2 + dz * mass1 * mag)
                `seq`
                ()
            ;

        updateVelocities :: Int -> Int -> ();
        updateVelocities !i !j =
            if j < numBodies then
                (
                    case bodies `subscriptBodyArray` i of
                    Body pos1 vel1 mass1 ->
                        case bodies `subscriptBodyArray` j of
                        Body pos2 vel2 mass2 ->
                            updateVelocity pos1 pos2 vel1 vel2 mass1 mass2;
                        ;
                )
                `seq`
                updateVelocities i (j + 1)
            else if i < numBodies then
                updateVelocities (i + 1) (i + 2)
            else
                ()
            ;

        updatePosition :: Double -> Body -> Double;
        updatePosition !dt !body =
            case body of
            Body pos velocity mass ->
                set pos 0 (get pos 0 + dt * get velocity 0)
                `seq`
                set pos 1 (get pos 1 + dt * get velocity 1)
                `seq`
                set pos 2 (get pos 2 + dt * get velocity 2)
                ;
            ;

        updatePositions :: Int -> ();
        updatePositions !i =
            if i == numBodies then
                ()
            else
                updatePosition dt (eager (bodies `subscriptBodyArray` i))
                `seq`
                updatePositions (i + 1)
            ;
    in

        updateVelocities 0 1
        `seq`
        updatePositions 0
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);
        bodies :: BodyArray;
        bodies =
            bodyArrayFromList
                [
                    //the sun
                    Body (makeVector 0 0 0) (makeVector 0 0 0) solarMass,
                    //jupiter
                    Body
                        (makeVector
                            4.841431442464721
                            (-1.1603200440274284)
                            (-0.10362204447112311)
                        )
                        (makeVector
                            (0.001660076642744037 * daysPerYear)
                            (0.007699011184197404 * daysPerYear)
                            (-6.90460016972063E-5 * daysPerYear)
                        )
                        (9.547919384243266E-4 * solarMass),
                    //saturn
                    Body
                        (makeVector
                            8.34336671824458
                            4.124798564124305
                            (-0.4035234171143214)
                        )
                        (makeVector
                            (-0.002767425107268624 * daysPerYear)
                            (0.004998528012349172 * daysPerYear)
                            (2.3041729757376393E-5 * daysPerYear)
                        )
                        (2.858859806661308E-4 * solarMass),
                    //uranus
                    Body
                        (makeVector
                            12.894369562139131
                            (-15.111151401698631)
                            (-0.22330757889265573)
                        )
                        (makeVector
                            (0.002964601375647616 * daysPerYear)
                            (0.0023784717395948095 * daysPerYear)
                            (-2.9658956854023756E-5 * daysPerYear)
                        )
                        (4.366244043351563E-5 * solarMass),
                    //neptune
                    Body
                        (makeVector
                            15.379697114850917
                            (-25.919314609987964)
                            0.17925877295037118
                        )
                        (makeVector
                            (0.0026806777249038932 * daysPerYear)
                            (0.001628241700382423 * daysPerYear)
                            (-9.515922545197159E-5 * daysPerYear)
                        )
                        (5.1513890204661145E-5 * solarMass)
                ]
            ;

        loop :: Int -> ();
        loop !n =
            if n > 0 then
                advance 0.01 bodies
                `seq`
                loop (n - 1)
            else
                ()
            ;
        /** function to display energy in specified format*/
        showEnergy :: Double -> ();
        showEnergy !e =
            printLine
                (formatWithPattern
                    "{0,number,0.000000000}"
                    invariantLocale
                    {#1 = e}
                )
            ;
    in

        computeOffsetMomentum bodies
        `seq`
        showEnergy (energy bodies)
        `seq`
        loop n
        `seq`
        showEnergy (energy bodies)
    ;


/** A {@link typeConstructor=Body@} array implemented as a Java array. */
data foreign unsafe import jvm "java.lang.Object[]" BodyArray deriving Inputable, Outputable;

/** Constructs a {@link BodyArray@} from a list. */
bodyArrayFromList :: [Body] -> BodyArray;
bodyArrayFromList !bodies =
    jObjectToBodyArray $ Array.outputPrimitive $ Array.fromList bodies;

instance Outputable Body where
    output = outputBodyAsCalValue;
    ;

outputBodyAsCalValue :: Body -> JObject;
outputBodyAsCalValue !body = output ((unsafeCoerce body) :: CalValue);

instance Inputable Body where
    input = inputBodyAsCalValue;
    ;

inputBodyAsCalValue :: JObject -> Body;
inputBodyAsCalValue !object = unsafeCoerce ((input object) :: CalValue);

foreign unsafe import jvm "cast" jObjectToBodyArray :: JObject -> BodyArray;

/** @return the i{@sup th@} element in the array. */
subscriptBodyArray :: BodyArray -> Int -> Body;
subscriptBodyArray !bodies !i =
    input (eager $ jSubscriptBodyArray bodies i);

foreign unsafe import jvm "subscriptArray" jSubscriptBodyArray :: BodyArray -> Int -> JObject;

/** @return the length of the array. */
foreign unsafe import jvm "lengthArray" lengthBodyArray :: BodyArray -> Int;
/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Nsieve;

import Cal.Core.Prelude using
    typeClass = Inputable, Outputable;
    typeConstructor = Boolean, Int, String;
    dataConstructor = False, True;
    function = eager, intToString, seq, stringToInt;
    ;

import Cal.Core.String using
    function = replicate;
    ;

import Cal.Core.Bits using
    function = shiftL, shiftR;
    ;

import Cal.Collections.List using
    function = head;
    ;
import Cal.IO.Console using
    function = printLine;
    ;

data foreign unsafe import jvm "boolean[]"
    JBooleanArray deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" booleanArray_new :: Int -> JBooleanArray;

foreign unsafe import jvm "subscriptArray"
    get :: JBooleanArray -> Int -> Boolean;

foreign unsafe import jvm "updateArray"
    set :: JBooleanArray -> Int -> Boolean -> Boolean;

/**pad width number returns number padded to width with spaces*/
pad :: Int -> Int -> String;
pad !width !number =
    let
        str = intToString number;
    in
        replicate (width - String.length str) ' ' ++ str
    ;

/**this is used to initialise the values in the array to true*/
setAll !start !end !array =
    if start == end then
        array
    else
        set array start True
        `seq`
        setAll (start + 1) end array
    ;

/** Count primes using nseive method*/
nsieve :: Int -> JBooleanArray -> Int;
nsieve !n !isPrime =
    let
        nsieve_helper :: Int -> Int -> Int;
        nsieve_helper !i !numPrimesFound =
            if i == n then
                numPrimesFound
            else if get isPrime i then
                let
                    update :: Int -> Int -> Int -> ();
                    update !k !i !n =
                        if k > n then
                            ()
                        else
                            set isPrime k False
                            `seq`
                            update (k + i) i n
                        ;
                in
                    update (i + i) i n
                    `seq`
                    nsieve_helper (i + 1) (numPrimesFound + 1)
            else
                nsieve_helper (i + 1) numPrimesFound
            ;
    in
        setAll 0 (n + 1) isPrime
        `seq`
        nsieve_helper 2 0
    ;

main :: [String] -> ();
public main !args =
    let
        n = eager $ stringToInt (head args);
        showResult n =
            printLine
                (
                    "Primes up to "
                    ++ pad 8 n
                    ++ " "
                    ++ pad 8 (nsieve n flags)
                )
            ;
        m = shiftL 1 n * 10000;
        flags = booleanArray_new (m + 1);
    in
        showResult m
        `seq`
        showResult (shiftR m 1)
        `seq`
        showResult (shiftR m 2)
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Joseph Wong.
 */
module Nsievebits;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Int, String;
    function = eager, intToString, seq, stringToInt;
    ;
import Cal.Core.Bits using
    function = bitwiseAnd, complement, shiftL, shiftR, shiftRUnsigned;
    ;
import Cal.Core.String using
    function = replicate;
    ;
import Cal.Collections.List using
    function = head;
    ;
import Cal.IO.Console using
    function = printLine;
    ;

/** A custom bitset implementation as an abstract data type. */
data foreign unsafe import jvm private "int[]" private BitSet;

foreign unsafe import jvm "newArray" newArray :: Int -> BitSet;

foreign unsafe import jvm "subscriptArray"
    subscriptArray :: BitSet -> Int -> Int;

foreign unsafe import jvm "updateArray"
    updateArray :: BitSet -> Int -> Int -> Int;

foreign unsafe import jvm "lengthArray" lengthArray :: BitSet -> Int;

bitsetMask :: Int;
bitsetMask = 31 :: Int;

bitsetShift :: Int;
bitsetShift = 5 :: Int;

makeBitSet :: Int -> BitSet;
makeBitSet !m = eager $ newArray ((m `shiftR` bitsetShift) + 1);

bitsetSetAll :: BitSet -> ();
bitsetSetAll !bitset =
    let
        loopUpperBound :: Int;
        loopUpperBound = eager $ lengthArray bitset;

        setAllHelper :: Int -> ();
        setAllHelper !i =
            if i < loopUpperBound then
                updateArray bitset i (-1)
                `seq`
                setAllHelper (i + 1)
            else
                ()
            ;
    in
        setAllHelper 0
    ;

bitsetClear :: BitSet -> Int -> Int;
bitsetClear !bitset !i =
    let
        pos :: Int;
        pos = eager $ i `shiftR` bitsetShift;
    in
        updateArray
            bitset
            pos
            (
                (bitset `subscriptArray` pos)
                `bitwiseAnd`
                (complement (1 `shiftL` (i `bitwiseAnd` bitsetMask)))
            )
    ;

bitsetGet :: BitSet -> Int -> Boolean;
bitsetGet !bitset !i =
    (
        (
            (bitset `subscriptArray` (i `shiftR` bitsetShift))
            `shiftRUnsigned`
            (i `bitwiseAnd` bitsetMask)
        )
        `bitwiseAnd`
        1
    )
    != 0
    ;

/** pad width number returns number padded to width with spaces*/
pad :: Int -> Int -> String;
pad !width !number =
    let
        str :: String;
        str = intToString number;
    in
        replicate (width - String.length str) ' ' ++ str
    ;

nsieve :: Int -> BitSet -> Int;
nsieve !n !isPrime =
    let
        nsieve_helper :: Int -> Int -> Int;
        nsieve_helper !i !numPrimesFound =
            if i == n then
                numPrimesFound
            else if bitsetGet isPrime i then
                let
                    update :: Int -> Int -> Int -> ();
                    update !k !i !n =
                        if k > n then
                            ()
                        else
                            bitsetClear isPrime k
                            `seq`
                            update (k + i) i n
                        ;
                in
                    update (i + i) i n
                    `seq`
                    nsieve_helper (i + 1) (numPrimesFound + 1)
            else
                nsieve_helper (i + 1) numPrimesFound
            ;
    in
        bitsetSetAll isPrime
        `seq`
        nsieve_helper 2 0
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);

        showResult :: Int -> ();
        showResult !n =
            printLine
                ("Primes up to " ++ pad 8 n ++ " " ++ pad 8 (nsieve n bits))
            ;

        m :: Int;
        m = shiftL 1 n * 10000;

        bits :: BitSet;
        bits = makeBitSet (m + 1);
    in
        showResult m
        `seq`
        showResult (shiftR m 1)
        `seq`
        showResult (shiftR m 2)
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Partialsums;

import Cal.Core.Prelude using
    typeConstructor = Double, Int, String;
    function = eager, fromInt, stringToInt;
    ;



import Cal.Collections.List using
    function = head;
    ;

import Cal.Utilities.MessageFormat using
    function = formatWithPattern;
    ;

import Cal.Utilities.Locale using
    function = invariantLocale;
    ;

import Cal.Utilities.Math using
    function = cos, power, sin, sqrt;
    ;

import Cal.IO.Console using
    function = print;
    ;

main :: [String] -> ();
public main !args =
    let
        n = eager $ stringToInt (head args);
    in
        computeSums n 1 1 0 0 0 0 0 0 0 0 0
    ;

computeSums ::
    Int -> Int -> Double -> Double -> Double -> Double
    -> Double -> Double -> Double -> Double -> Double -> Double -> ();
computeSums !maxIterations !iteration !alt !a1 !a2 !a3 !a4 !a5 !a6 !a7 !a8 !a9=
    if iteration <= maxIterations then
        let
            k = eager $ fromInt iteration :: Double;
            k3 = eager $ k * k * k :: Double;
            dk = eager $ 1 / k :: Double;
            sk = eager $ sin k;
            ck = eager $ cos k;
        in
            computeSums
                maxIterations
                (iteration + 1)
                (-alt)
                (a1 + power (2 / 3) (k - 1))
                (a2 + sqrt dk)
                (a3 + 1 / (k * (k + 1)))
                (a4 + 1 / (k3 * sk * sk))
                (a5 + 1 / (k3 * ck * ck))
                (a6 + dk)
                (a7 + dk * dk)
                (a8 + alt * dk)
                (a9 + alt / (2 * k - 1))
    else
        print
            (List.foldLeftStrict
                (
                    \!acc !elem ->
                        acc
                        ++ formatWithPattern
                            "{0,number,0.000000000}\t{1}\n"
                            invariantLocale
                            elem
                )
                ""
                [
                    (a1, "(2/3)^k"),
                    (a2, "k^-0.5"),
                    (a3, "1/k(k+1)"),
                    (a4, "Flint Hills"),
                    (a5, "Cookson Hills"),
                    (a6, "Harmonic"),
                    (a7, "Riemann Zeta"),
                    (a8, "Alternating Harmonic"),
                    (a9, "Gregory")
                ]
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Pidigits;

import Cal.Core.Prelude using
    typeConstructor = Int, Integer, String;
    function = eager, fromInteger, seq, stringToInt;
    ;

import Cal.Core.Debug using
    function = show;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Core.String using
    function = replicate;
    ;

import Cal.IO.Console using
    function = print;
    ;

data F =
    F
        w :: !Integer
        x :: !Integer
        y :: !Integer
        z :: !Integer
    ;

lfts :: Integer -> [F];
lfts !k = F k (4 * k + 2) 0 (2 * k + 1) : lfts (k + 1);

floor :: Integer -> F -> Integer;
floor !x !m =
    case m of
    F q r s t -> (q * x + r) / (s * x + t);
    ;

complement1 :: F -> F -> F;
complement1 !m !n =
    case m of
    F q r s t ->
        case n of
        F u v w x ->
            F (q * u + r * w) (q * v + r * x) (t * w) (t * x);
        ;
    ;

complement2 :: F -> F -> F;
complement2 !m !n =
    case m of
    F q r s t ->
        case n of
        F u v w x ->
            F (q * u) (q * v + r * x) (s * u) (s * v + t * x);
        ;
    ;

main :: [String] -> ();
public main !args =
    let
        pidigits :: [Int];
        pidigits =
            let
                stream :: F -> [F] -> [Int];
                stream !z !l =
                    let
                        y :: Integer;
                        y = eager $ floor 3 z;
                    in
                        case l of
                        x : xs ->
                            if y == floor 4 z then
                                fromInteger y
                                : stream
                                    (complement1 (F 10 (-10 * y) 0 1) z)
                                    (x : xs)
                            else
                                stream (complement2 z x) xs
                            ;
                    ;
            in
                stream (F 1 0 0 1) (lfts 1)
            ;

        n :: Int;
        n = eager $ stringToInt (head args);

        lineLength :: Int;
        lineLength = 10;

        //print digits in accordance with the benchmark spec
        printDigits :: [Int] -> Int -> Int -> ();
        printDigits !digits !digitsPrinted !digitsPrintedOnLine =
            if digitsPrinted == n then
                print
                    (
                        replicate (lineLength - digitsPrintedOnLine) ' '
                        ++ "\t:"
                        ++ show digitsPrinted
                        ++ "\n"
                    )
            else if digitsPrintedOnLine == lineLength then
                print ("\t:" ++ show digitsPrinted ++ "\n")
                `seq`
                printDigits digits digitsPrinted 0
            else
                case digits of
                digit : remainingDigits ->
                    print (show digit)
                    `seq`
                    printDigits
                        remainingDigits
                        (digitsPrinted + 1)
                        (digitsPrintedOnLine + 1)
                    ;
            ;
    in
        printDigits pidigits 0 0
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Recursive;

import Cal.Core.Prelude using
    typeConstructor = Double, Int, String;
    function = eager, fromInt, seq, stringToInt;
    ;

import Cal.Core.Debug using
    function = show;
    ;

import Cal.Collections.List using
    function = head;
    ;

import Cal.Utilities.MessageFormat using
    function = formatWithPattern;
    ;

import Cal.Utilities.Locale using
    function = invariantLocale;
    ;

import Cal.IO.Console using
    function = printLine;
    ;

main :: [String] -> ();
public main !args =
    let
        n = eager $ stringToInt (head args);
        m = n - 1;
        f = n + 27;
    in
        printLine ("Ack(3," ++ show n ++ "): " ++ show (ack 3 n))
        `seq`
        printLine
            (formatWithPattern
                "Fib({0,number,#.0}): {1,number,#.0}"
                invariantLocale
                (f, fibDouble (fromInt f))
            )
        `seq`
        printLine
            (formatWithPattern
                "Tak({0},{1},{2}): {3}"
                invariantLocale
                (m * 3, m * 2, m, tak (m * 3) (m * 2) m)
            )
        `seq`
        printLine ("Fib(3): " ++ show (fib 3))
        `seq`
        printLine
            ("Tak(3.0,2.0,1.0): " ++ show (takDouble 3.0 2.0 1.0))
    ;

fib :: Int -> Int;
fib !n =
    if n < 2 then
        1
    else
        fib (n - 2) + fib (n - 1)
    ;

fibDouble :: Double -> Double;
fibDouble !n =
    if n < 2 then
        1
    else
        fibDouble (n - 2) + fibDouble (n - 1)
    ;

ack :: Int -> Int -> Int;
ack !x !y =
    if x == 0 then
        y + 1
    else if y == 0 then
        ack (x - 1) 1
    else
        ack (x - 1) (eager $ ack x (y - 1))
    ;

tak :: Int -> Int -> Int -> Int;
tak !x !y !z =
    if y >= x then
        z
    else
        tak
            (eager $ tak (x - 1) y z)
            (eager $ tak (y - 1) z x)
            (eager $ tak (z - 1) x y)
    ;

takDouble :: Double -> Double -> Double -> Double;
takDouble !x !y !z =
    if y >= x then
        z
    else
        takDouble
            (eager $ takDouble (x - 1) y z)
            (eager $ takDouble (y - 1) z x)
            (eager $ takDouble (z - 1) x y)
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Regexdna;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Int, String;
    function = eager, seq;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Core.String using
    function = length, replaceAllString;
    ;
import Cal.Collections.List using
    function = foldLeftStrict;
    ;
import Cal.IO.Console using
    function = print, printLine;
    ;

data foreign unsafe import jvm "java.io.BufferedReader" private JBufferedReader;

data foreign unsafe import jvm "java.io.InputStream" private JInputStream;

data foreign unsafe import jvm "java.io.InputStreamReader"
    private JInputStreamReader;

data foreign unsafe import jvm "java.io.Reader" private JReader;

data foreign unsafe import jvm "java.io.FileReader" private JFileReader;

data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

data foreign unsafe import jvm "java.lang.StringBuffer"
    private JStringBuffer deriving Show;

data foreign unsafe import jvm "java.util.regex.Matcher" private JMatcher;

data foreign unsafe import jvm "java.util.regex.Pattern" private JPattern;

data foreign unsafe import jvm "java.lang.CharSequence" private JCharSequence;

foreign unsafe import jvm "static method java.util.regex.Pattern.compile"
    private compilePattern :: String -> JPattern;

foreign unsafe import jvm "method matcher"
    private getMatcher :: JPattern -> JCharSequence -> JMatcher;

foreign unsafe import jvm "method find" private find :: JMatcher -> Boolean;

foreign unsafe import jvm "constructor"
    private createStringBuffer :: JStringBuffer;

foreign unsafe import jvm "constructor"
    private createBufferedReader :: JReader -> JBufferedReader;

foreign unsafe import jvm "constructor"
    private createInputStreamReaderStream :: JInputStream -> JInputStreamReader;

foreign unsafe import jvm "method append"
    private append :: JStringBuffer -> JCharArray -> Int -> Int -> JStringBuffer;

foreign unsafe import jvm "method read"
    private read :: JBufferedReader -> JCharArray -> Int -> Int -> Int;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JPrintStream;

foreign unsafe import jvm "static field java.lang.System.in"
    private stdin :: JInputStream;

data foreign unsafe import jvm "char[]" JCharArray;

foreign unsafe import jvm "newArray" char_newArray :: Int -> JCharArray;

foreign unsafe import jvm "cast"
    jInputStreamReaderToJReader :: JInputStreamReader -> JReader;

foreign unsafe import jvm "cast"
    stringToJCharSequence :: String -> JCharSequence;

/**read a dna file from stdin into a buffer*/
readFile :: JBufferedReader -> String;
readFile !bufferedReader =
    let
        charBuffer :: JCharArray;
        charBuffer = eager $ char_newArray 10240;

        stringBuffer :: JStringBuffer;
        stringBuffer = eager $ createStringBuffer;

        readAll :: JCharArray -> JStringBuffer -> String;
        readAll !charBuffer !stringBuffer =
            let
                charsRead :: Int;
                charsRead = eager $ read bufferedReader charBuffer 0 10240;
            in
                if charsRead != -1 then
                    append stringBuffer charBuffer 0 charsRead
                    `seq`
                    readAll charBuffer stringBuffer
                else
                    show stringBuffer
            ;
    in
        readAll charBuffer stringBuffer
    ;

/** Counts the number of matches remaining in a matcher*/
countMatches :: JMatcher -> Int -> Int;
countMatches !matcher !count =
    if find matcher then
        countMatches matcher (count + 1)
    else
        count
    ;

/** List of variants to search for */
variants :: [String];
variants =
    [
        "agggtaaa|tttaccct",
        "[cgt]gggtaaa|tttaccc[acg]",
        "a[act]ggtaaa|tttacc[agt]t",
        "ag[act]gtaaa|tttac[agt]ct",
        "agg[act]taaa|ttta[agt]cct",
        "aggg[acg]aaa|ttt[cgt]ccct",
        "agggt[cgt]aa|tt[acg]accct",
        "agggta[cgt]a|t[acg]taccct",
        "agggtaa[cgt]|[acg]ttaccct"
    ]
    ;

/** list of replacements to make (from, to)*/
replacements =
    [
        ("B", "(c|g|t)"),
        ("D", "(a|g|t)"),
        ("H", "(a|c|t)"),
        ("K", "(g|t)"),
        ("M", "(a|c)"),
        ("N", "(a|c|g|t)"),
        ("R", "(a|g)"),
        ("S", "(c|g)"),
        ("V", "(a|c|g)"),
        ("W", "(a|t)"),
        ("Y", "(c|t)")
    ]
    ;

doReplacement !str !replacement =
    case replacement of
    (stringToReplace, newValue)
    -> replaceAllString str stringToReplace newValue;
    ;

main :: [String] -> ();
public main args =
    let
        bufferReader :: JBufferedReader;
        bufferReader =
            eager
            $ createBufferedReader
                (jInputStreamReaderToJReader
                    (createInputStreamReaderStream stdin)
                )
            ;

        input :: String;
        input = eager $ readFile bufferReader;

        sequence :: String;
        sequence = replaceAllString input ">.*\n|\n" "";
    in

        print
            (foldLeftStrict
                (
                    \!accumulator !variant ->
                        accumulator
                        ++ variant
                        ++ " "
                        ++ show
                            (countMatches
                                (getMatcher
                                    (compilePattern variant)
                                    (stringToJCharSequence sequence)
                                )
                                0
                            )
                        ++ "\n"
                )
                ""
                variants
            )
        `seq`
        printLine ""
        `seq`
        printLine (show $ length input)
        `seq`
        printLine (show $ length sequence)
        `seq`
        printLine
            (
                show
                $ length (foldLeftStrict doReplacement sequence replacements)
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Regexdna;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Char, Int, String;
    function = concat, eager, seq;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Core.String using
    function = length, replaceAllString, splitString;
    ;
import Cal.Collections.List using
    function = foldLeftStrict;
    ;
import Cal.IO.Console using
    function = print, printLine;
    ;

data foreign unsafe import jvm "java.lang.StringBuilder"
    private JStringBuilder deriving Show;

foreign unsafe import jvm "constructor"
    private createStringBuilder :: JStringBuilder;

foreign unsafe import jvm "method append"
    private appendString :: JStringBuilder -> String -> JStringBuilder;

foreign unsafe import jvm "method append"
    private appendChar :: JStringBuilder -> Char -> JStringBuilder;

data foreign unsafe import jvm "java.io.BufferedReader"
    private JBufferedReader;

data foreign unsafe import jvm "java.io.InputStream" private JInputStream;

data foreign unsafe import jvm "java.io.InputStreamReader"
    private JInputStreamReader;

data foreign unsafe import jvm "java.io.Reader" private JReader;

data foreign unsafe import jvm "java.io.FileReader" private JFileReader;

data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

data foreign unsafe import jvm "java.util.regex.Matcher" private JMatcher;

data foreign unsafe import jvm "java.util.regex.Pattern" private JPattern;

data foreign unsafe import jvm "java.lang.CharSequence" private JCharSequence;

foreign unsafe import jvm "static method java.util.regex.Pattern.compile"
    private compilePattern :: String -> JPattern;

foreign unsafe import jvm "method matcher"
    private getMatcher :: JPattern -> JCharSequence -> JMatcher;

foreign unsafe import jvm "method find" private find :: JMatcher -> Boolean;

foreign unsafe import jvm "constructor"
    private createBufferedReader :: JReader -> JBufferedReader;

foreign unsafe import jvm "constructor"
    private createInputStreamReaderStream ::
        JInputStream -> JInputStreamReader;

foreign unsafe import jvm "method append"
    private append ::
        JStringBuilder -> JCharArray -> Int -> Int -> JStringBuilder;

foreign unsafe import jvm "method read"
    private read :: JBufferedReader -> JCharArray -> Int -> Int -> Int;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JPrintStream;

foreign unsafe import jvm "static field java.lang.System.in"
    private stdin :: JInputStream;

data foreign unsafe import jvm "char[]" JCharArray;

foreign unsafe import jvm "newArray" char_newArray :: Int -> JCharArray;

foreign unsafe import jvm "cast"
    jInputStreamReaderToJReader :: JInputStreamReader -> JReader;

foreign unsafe import jvm "cast"
    stringToJCharSequence :: String -> JCharSequence;

/** read a dna file from stdin into a buffer */
readFile :: JBufferedReader -> String;
readFile !bufferedReader =
    let
        charBuffer :: JCharArray;
        charBuffer = eager $ char_newArray 10240;

        stringBuilder :: JStringBuilder;
        stringBuilder = eager $ createStringBuilder;

        readAll :: JCharArray -> JStringBuilder -> String;
        readAll !charBuffer !stringBuilder =
            let
                charsRead :: Int;
                charsRead = eager $ read bufferedReader charBuffer 0 10240;
            in
                if charsRead != -1 then
                    append stringBuilder charBuffer 0 charsRead
                    `seq`
                    readAll charBuffer stringBuilder
                else
                    show stringBuilder
            ;
    in
        readAll charBuffer stringBuilder
    ;

/** Counts the number of matches remaining in a matcher */
countMatches :: JMatcher -> Int -> Int;
countMatches !matcher !count =
    if find matcher then
        countMatches matcher (count + 1)
    else
        count
    ;

/** List of variants to search for */
variants :: [String];
variants =
    [
        "agggtaaa|tttaccct",
        "[cgt]gggtaaa|tttaccc[acg]",
        "a[act]ggtaaa|tttacc[agt]t",
        "ag[act]gtaaa|tttac[agt]ct",
        "agg[act]taaa|ttta[agt]cct",
        "aggg[acg]aaa|ttt[cgt]ccct",
        "agggt[cgt]aa|tt[acg]accct",
        "agggta[cgt]a|t[acg]taccct",
        "agggtaa[cgt]|[acg]ttaccct"
    ]
    ;

doReplace !str !pos !strBuilder =
    if (pos == String.length str) then
        strBuilder
    else
        let
            c = eager $ String.subscript str pos;
        in
            (case c of
            'B' -> appendString strBuilder "(c|g|t)";
            'D' -> appendString strBuilder "(a|g|t)";
            'H' -> appendString strBuilder "(a|c|t)";
            'K' -> appendString strBuilder "(g|t)";
            'M' -> appendString strBuilder "(a|c)";
            'N' -> appendString strBuilder "(a|c|g|t)";
            'R' -> appendString strBuilder "(a|g)";
            'S' -> appendString strBuilder "(c|g)";
            'V' -> appendString strBuilder "(a|c|g)";
            'W' -> appendString strBuilder "(a|t)";
            'Y' -> appendString strBuilder "(c|t)";
            _ -> appendChar strBuilder c;)
            `seq`
            doReplace str (pos+1) strBuilder
    ;

main :: [String] -> ();
public main args =
    let
        bufferReader :: JBufferedReader;
        bufferReader =
            eager
            $ createBufferedReader
                (jInputStreamReaderToJReader
                    (createInputStreamReaderStream stdin)
                )
            ;

        input :: String;
        input = eager $ readFile bufferReader;

        sequence :: String;
        sequence = replaceAllString input ">.*\n|\n" "";
    in

        print
            (foldLeftStrict
                (
                    \!accumulator !variant ->
                        accumulator
                        ++ variant
                        ++ " "
                        ++ show
                            (
                                List.sum
                                $ List.map
                                    (
                                        \!v ->
                                            countMatches
                                                (getMatcher
                                                    (compilePattern v)
                                                    (stringToJCharSequence
                                                        sequence
                                                    )
                                                )
                                                0
                                    )
                                    (String.splitString "|" variant)
                            )
                        ++ "\n"
                )
                ""
                variants
            )
        `seq`
        printLine ""
        `seq`
        printLine (show $ length input)
        `seq`
        printLine (show $ length sequence)
        `seq`
        printLine
            (
                show
                $ length (show $ doReplace sequence 0 createStringBuilder)
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Revcomp;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Byte, Char, Int, JObject, String;
    function = eager, seq, toByte;
    ;
import Cal.Core.Char using
    function = toInt, toLowerCase;
    ;
import Cal.Core.String using
    function = subscript;
    ;
import Cal.Collections.List using
    function = foldLeftStrict;
    ;
import Cal.IO.Console using
    function = printLine;
    ;


data foreign unsafe import jvm "java.io.BufferedReader" private JBufferedReader;

data foreign unsafe import jvm "java.io.InputStream" private JInputStream;

data foreign unsafe import jvm "java.io.InputStreamReader"
    private JInputStreamReader;

data foreign unsafe import jvm "java.io.Reader" private JReader;

data foreign unsafe import jvm "java.io.FileReader" private JFileReader;

data foreign unsafe import jvm "java.io.PrintStream" private JPrintStream;

foreign unsafe import jvm "constructor"
    private createBufferedReader :: JReader -> JBufferedReader;

foreign unsafe import jvm "constructor"
    private createInputStreamReaderStream :: JInputStream -> JInputStreamReader;

foreign unsafe import jvm "method readLine"
    private readLine :: JBufferedReader -> String;

foreign unsafe import jvm "static field java.lang.System.out"
    private stdout :: JPrintStream;

foreign unsafe import jvm "static field java.lang.System.in"
    private stdin :: JInputStream;

foreign unsafe import jvm "isNull" private isNull :: String -> Boolean;

foreign unsafe import jvm "method write"
    private write :: JPrintStream -> JByteArray -> Int -> Int -> ();

data foreign unsafe import jvm "byte[]" JByteArray;

//Import Java byte arrays
foreign unsafe import jvm "newArray" byteArray_new :: Int -> JByteArray;

foreign unsafe import jvm "subscriptArray"
    byteArray_subscript :: JByteArray -> Int -> Byte;

foreign unsafe import jvm "lengthArray" byteArray_length :: JByteArray -> Int;

foreign unsafe import jvm "updateArray"
    byteArray_update :: JByteArray -> Int -> Byte -> Byte;

foreign unsafe import jvm "cast"
    jInputStreamReaderToJReader :: JInputStreamReader -> JReader;

foreign unsafe import jvm "cast" cast :: JByteArray -> JObject;

data Chunk =
    Chunk
        dataChunk :: !JByteArray
        length :: !Int
    ;

charToByte :: Char -> Byte;
charToByte !c = toByte (Char.toInt c);

initCharMap :: JByteArray -> ();
initCharMap !charMap =
    let
        loop :: Int -> ();
        loop !i =
            if i < 128 then
                byteArray_update charMap i (toByte i)
                `seq`
                ()
            else
                ()
            ;

        mappings :: [(Char, Char)];
        mappings =
            [
                ('A', 'T'),
                ('C', 'G'),
                ('G', 'C'),
                ('T', 'A'),
                ('U', 'A'),
                ('M', 'K'),
                ('R', 'Y'),
                ('W', 'W'),
                ('S', 'S'),
                ('Y', 'R'),
                ('K', 'M'),
                ('V', 'B'),
                ('H', 'D'),
                ('D', 'H'),
                ('B', 'V'),
                ('N', 'N')
            ]
            ;
    in
        loop 0
        `seq`
        foldLeftStrict
            (
                \!a !mapping ->
                    byteArray_update
                        charMap
                        (Char.toInt mapping.#1)
                        (charToByte mapping.#2)
                    `seq`
                    byteArray_update
                        charMap
                        (Char.toInt (toLowerCase mapping.#1))
                        (charToByte mapping.#2)
                    `seq`
                    a
            )
            ()
            mappings
    ;

//this includes the CR
outputLineLength :: Int;
outputLineLength = 61;

printChunks :: [Chunk] -> ();
printChunks chunks =
    let
        outputBuffer :: JByteArray;
        outputBuffer =
            eager $ byteArray_new (chunkSize * List.length chunks * 61 / 60)
            ;

        eol :: Byte;
        eol = eager $ toByte (eager $ Char.toInt '\n');

        appendChunk :: JByteArray -> Int -> Int -> Int -> Int;
        appendChunk !chunk !i !charsOnLine !ptr =
            if i >= 0 then
                byteArray_update
                    outputBuffer
                    ptr
                    (byteArray_subscript chunk i)
                `seq`
                (
                    if (ptr + 2) % outputLineLength == 0 then
                        byteArray_update outputBuffer (ptr + 1) eol
                        `seq`
                        appendChunk chunk (i - 1) 0 (ptr + 2)
                    else
                        appendChunk
                            chunk
                            (i - 1)
                            (charsOnLine + 1)
                            (ptr + 1)
                )
            else
                ptr
            ;

        appendChunks :: [Chunk] -> Int -> Int;
        appendChunks !chunks !ptr =
            case chunks of
            [] ->
                if ptr % outputLineLength != 0 then
                    byteArray_update outputBuffer ptr eol 
                    `seq` 
                    ptr + 1
                else
                    ptr
                ;
            first : rest ->
                case first of
                Chunk buffer bytes ->
                    appendChunks
                        rest
                        (appendChunk buffer (bytes - 1) (0 :: Int) ptr)
                    ;
                ;
            ;
    in
        write stdout outputBuffer 0 (appendChunks chunks 0)
    ;

appendToChunk :: JByteArray -> String -> JByteArray -> Int -> ();
appendToChunk !charMap !line !buffer !offset =
    let
        helper :: Int -> Int -> ();
        helper !i !end =
            if i < end then
                byteArray_update
                    buffer
                    (offset + i)
                    (byteArray_subscript
                        charMap
                        (toInt (String.subscript line i))
                    )
                `seq`
                helper (i + 1) end
            else
                ()
            ;
    in
        helper 0 (String.length line)
    ;

chunkSize :: Int;
chunkSize = 10240;

main :: [String] -> ();
public main !args =
    let
        charMap :: JByteArray;
        charMap = eager $ byteArray_new 128;

        reader :: JBufferedReader;
        reader =
            eager
            $ createBufferedReader
                (jInputStreamReaderToJReader
                    (createInputStreamReaderStream stdin)
                )
            ;

        readLines :: JBufferedReader -> [Chunk] -> JByteArray -> Int -> ();
        readLines !reader !chunks !buffer !bytesInBuffer =
            let
                line :: String;
                line = eager $ readLine reader;
            in

                if isNull line then
                    printChunks (Chunk buffer bytesInBuffer : chunks)
                else if subscript line 0 == '>' then
                    printChunks (Chunk buffer bytesInBuffer : chunks)
                    `seq`
                    printLine line
                    `seq`
                    readLines reader [] (byteArray_new chunkSize) 0
                else if bytesInBuffer + String.length line < chunkSize then
                    appendToChunk charMap line buffer bytesInBuffer
                    `seq`
                    readLines
                        reader
                        chunks
                        buffer
                        (bytesInBuffer + String.length line)
                else
                    let
                        newBuffer :: JByteArray;
                        newBuffer = eager $ byteArray_new chunkSize;

                        len :: Int;
                        len = eager $ String.length line;
                    in
                        appendToChunk charMap line newBuffer 0
                        `seq`
                        readLines
                            reader
                            (Chunk buffer bytesInBuffer : chunks)
                            newBuffer
                            len
            ;
    in

        initCharMap charMap
        `seq`
        readLines reader [] (byteArray_new chunkSize) 0
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Spectralnorm;

import Cal.Core.Prelude using
    typeClass = Inputable, Outputable;
    typeConstructor = Double, Int, String;
    function = eager, fromInt, seq, stringToInt;
    ;
import Cal.Utilities.Math using
    function = sqrt;
    ;
import Cal.Collections.List using
    function = head;
    ;
import Cal.Utilities.MessageFormat using
    function = formatWithPattern;
    ;
import Cal.Utilities.Locale using
    function = invariantLocale;
    ;
import Cal.IO.Console using
    function = printLine;
    ;

data foreign unsafe import jvm "double[]" JVector deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" newVector :: Int -> JVector;

foreign unsafe import jvm "subscriptArray" subscript :: JVector -> Int -> Double;

foreign unsafe import jvm "updateArray"
    update :: JVector -> Int -> Double -> Double;

/** get element i,j of infinite matrix A*/
matrixA :: Int -> Int -> Double;
matrixA !i !j = 1.0 / fromInt ((i + j) * (i + j + 1) / 2 + i + 1);

/** multiply A by v*/
multiplyAv :: Int -> JVector -> JVector -> ();
multiplyAv !n !v !av =
    let
        go :: Int -> Int -> ();
        go !i !j =
            if j < n then
                update
                    av
                    i
                    (av `subscript` i + matrixA i j * v `subscript` j)
                `seq`
                go i (j + 1)
            else
                let
                    inc :: Int;
                    inc = i + 1;
                in
                    if inc < n then
                        update av inc 0.0
                        `seq`
                        go inc 0
                    else
                        ()
            ;
    in
        go (-1) n
    ;

/** multiply (Transpose A) by v*/
multiplyAtv :: Int -> JVector -> JVector -> ();
multiplyAtv !n !v !av =
    let
        go :: Int -> Int -> ();
        go !i !j =
            if j < n then
                update
                    av
                    i
                    (av `subscript` i + matrixA j i * v `subscript` j)
                `seq`
                go i (j + 1)
            else
                let
                    inc :: Int;
                    inc = i + 1;
                in
                    if inc < n then
                        update av inc 0.0
                        `seq`
                        go inc 0
                    else
                        ()
            ;
    in
        go (-1) n
    ;

/**(transpose A) * A * v*/
multiplyAtAv :: Int -> JVector -> JVector -> JVector -> ();
multiplyAtAv !n !temp !v !result =
    multiplyAv n v temp
    `seq`
    multiplyAtv n temp result
    ;

/**run n steps of the approximation*/
approximate :: Int -> Double;
approximate !n =
    let
        u :: JVector;
        u = eager $ newVector n;

        v :: JVector;
        v = eager $ newVector n;

        temp :: JVector;
        temp = eager $ newVector n;

        doStep :: Int -> ();
        doStep !i =
            if i == 0 then
                ()
            else
                multiplyAtAv n temp u v
                `seq`
                multiplyAtAv n temp v u
                `seq`
                doStep (i - 1)
            ;

        vbv :: Int -> Double -> Double;
        vbv !i !sum =
            if i == n then
                sum
            else
                vbv (i + 1) (sum + u `subscript` i * v `subscript` i)
            ;

        vv :: Int -> Double -> Double;
        vv !i !sum =
            if i == n then
                sum
            else
                vv (i + 1) (sum + v `subscript` i * v `subscript` i)
            ;

        initVector :: Int -> Int -> JVector -> ();
        initVector !i !size !v =
            if i == size then
                ()
            else
                update v i 1.0
                `seq`
                initVector (i + 1) size v
            ;
    in

        initVector 0 n u
        `seq`
        doStep 10
        `seq`
        sqrt (vbv 0 0.0 / vv 0 0.0)
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = eager $ stringToInt (head args);
    in
        printLine
            (formatWithPattern
                "{0,number,#.000000000}"
                invariantLocale
                {#1 = approximate n}
            )
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */
module Sumcol;

import Cal.Core.Prelude using
    typeConstructor = Int, String;
    function = eager, intToString, stringToInt;
    ;

import Cal.IO.Console using
    typeConstructor = JBufferedReader;
    function = isNullString, makeBufferedReader, printLine, readLine, stdin;
    ;

main :: [String] -> ();
public main args =
    let
        loop :: JBufferedReader -> Int -> Int;
        loop !input !sum =
            let
                line = eager $ readLine input;
            in
                if isNullString line then
                    sum
                else
                    loop input (sum + stringToInt line)
            ;
    in
        printLine (intToString (loop (makeBufferedReader stdin) 0))
    ;

/** 
 * The Computer Language Benchmarks Game 
 * Based on the CAL Open Quark version
 * Contributed by Magnus Byne.
 */

module Threadring;

import Cal.Core.Prelude using
    typeConstructor = Int, JObject, String;
    function =
        eager, error, input, intToString, output, seq, stringToInt, toCalValue,
        unsafeFromCalValue, upFromTo;
    ;
import Cal.IO.Console using
    function = printLine;
    ;
import Cal.Experimental.Concurrent.Parallel using
    function = par, parallelMap;
    ;
import Cal.Collections.List using
    function = cycle, head, map, replicate, tail, zip3;
    ;
import Cal.Core.System using
    function = concurrentRuntime;
    ;


ringSize :: Int;
ringSize = 503;

/**
 * this implements the thread body, taking tokens form its input queue,
 * decrementing the token, and then putting it on the output queue. 
 * When the token is zero, the id is printed, and exit is called.
 */
threadBody :: Int -> SynchronousQueue Int -> SynchronousQueue Int -> ();
threadBody !id !input !output =
    let
        token :: Int;
        token = eager $ (take input);
    in
        if (token == 0) then
            printLine (intToString id) `seq`
            exit 0
        else
            put output (token - 1) `seq`
            threadBody id input output
    ;
        
        
startThreads :: Int -> Int -> [()];
startThreads !ringSize !token =
    let
        queues :: [SynchronousQueue a];
        queues = map makeSynchronousQueue (replicate ringSize ());

        ids :: [Int];
        ids = upFromTo 1 ringSize;
    in
        //feed the token into the first queue
        put (head queues) token
        `par`
        //create threads running the threadBody func, with ids [1 .. ringSize]
        parallelMap
            (\!args -> threadBody args.#1 args.#2 args.#3)
            (zip3 ids queues (tail $ cycle queues))
    ;

main :: [String] -> ();
public main !args =
    let
        n :: Int;
        n = stringToInt (head args);
    in

        if concurrentRuntime then
            List.strictList (startThreads ringSize n)
            `seq`
            ()
        else
            error
                "You must define the VM arg org.openquark.cal.machine.lecc.concurrent_runtime to run this program"
    ;


/**
 * A Synchronous queue has no storage. There must always be a matching put for
 * every take and visa versa
 */
data public SynchronousQueue a =
    private SynchronousQueue jqueue :: !JSynchronousQueue
    ;

/**
 * This creates a Synchronous queue. Whenever you attempt to put an element
 * into the queue it will block if there is not already a thread waiting on
 * take. Get will block unless there is already a thread waiting on put.
 */
makeSynchronousQueue :: () -> SynchronousQueue a;
public makeSynchronousQueue !unused = SynchronousQueue (jmakeQueue);

/**
 * Puts an element into the queue. This will block unless there is already a
 * thread waiting on take.
 *
 * @arg queue the queue to add to
 * @arg item the item to add
 */
put :: SynchronousQueue a -> a -> ();
public put !queue item =
    jput queue.SynchronousQueue.jqueue (output $ toCalValue item);

/**
 * Takes an item from a queue. This will block, unless there is already a
 * thread waiting on put.
 *
 * @arg queue the queue to take an item from.
 */
take :: SynchronousQueue a -> a;
public take !queue =
    unsafeFromCalValue $ input $ jtake queue.SynchronousQueue.jqueue;

data foreign unsafe import jvm "java.util.concurrent.SynchronousQueue"
    private JSynchronousQueue;

foreign unsafe import jvm "constructor"
    private jmakeQueue :: JSynchronousQueue;

foreign unsafe import jvm "method put"
    private jput :: JSynchronousQueue -> JObject -> ();

foreign unsafe import jvm "method take"
    private jtake :: JSynchronousQueue -> JObject;


foreign unsafe import jvm "static method java.lang.System.exit"
    private exit :: Int -> ();
