/* -*- mode: c -*-
 * $Id: ackermann.gcc-2.gcc,v 1.1 2005-03-15 06:17:49 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 *
 * Modified to use C inline and unroll of recursive functions
 * by Paul Hsieh
 */

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#if (defined(__linux) || defined(__unix) || defined(__GNUC__))
#include <unistd.h>
#elif (defined(WIN32) || defined(_WIN32) || defined(__WIN32) || 
defined(_WINDOWS) || defined(_WINDOWS_))
#include <windows.h>
#endif

#define glueAckExpand(m) Ack##m
#define glueAck(m) glueAckExpand(m)

#define Ack0(N) ((N)+1)

#define AckDecl(M,M1)                                 \
static int glueAck(M) (int N) {                       \
    if (0 == N) return glueAck(M1) (1);               \
    if (1 == N) return glueAck(M1) (glueAck(M1) (1)); \
    return glueAck(M1) (glueAck(M) (N-1));            \
}

AckDecl(1,0)
AckDecl(2,1)
AckDecl(3,2)
AckDecl(4,3)

/* Removes the overhead of passing around and M parameter, 
   when it is low (which is the only way this can actually
   complete execution.) */

int Ack (int M, int N) {
    switch (M) {
        case 0: return Ack0 (N);
        case 1: return Ack1 (N);
        case 2: return Ack2 (N);
        case 3: return Ack3 (N);
        case 4: return Ack4 (N);
    }

    if (0 == N) return Ack (M-1, 1);
    if (1 == N) return Ack (M-1, Ack (M-1, 1));
    return Ack (M-1, Ack (M, N-1));
}

/* Not called.  Uses full mathematical simplfications when 
   its possible and unravells the recursion on the N 
   parameter into a for() loop (so the stack level never 
   goes deeper than O(M)). */

int AckCheat (int M, int N) {
    switch (M) {
        case 0: return Ack0 (N);
        case 1: return N + 2;
        case 2: return 2*N + 3;
        case 3: if (N < (CHAR_BIT * sizeof(int) - 3)) 
                    return (1 << (N+3))-3;
    }

    if (0 == N) return AckCheat (M-1, 1);
    if (1 == N) return AckCheat (M-1, AckCheat (M-1, 1));

    {
        int a = AckCheat (M-1, 1);
        for (;N; N--) a = AckCheat (M-1, a);
        return a;
    }
}

int main(int argc, char *argv[]) {
    int m = ((argc >= 3) ? atoi(argv[argc-2]) : 3);
    int n = ((argc >= 2) ? atoi(argv[argc-1]) : 1);

    printf("Ack(%d,%d): %d\n", m, n, Ack (m, n));

    /* sleep long enough so we can measure memory usage */
#if (defined(__linux) || defined(__unix) || defined(__GNUC__))
    sleep(1);
#elif (defined(WIN32) || defined(_WIN32) || defined(__WIN32) || 
defined(_WINDOWS) || defined(_WINDOWS_))
    Sleep(1000);
#endif

    return(0);
}
/* -*- mode: c -*-
 * $Id: ackermann.gcc-3.gcc,v 1.1 2005-04-27 05:21:30 igouy-guest Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * modified by Isaac Gouy
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int Ack(int M, int N) { return(M ? (Ack(M-1,N ? Ack(M,(N-1)) : 1)) : N+1); }

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);

    printf("Ack(3,%d): %d\n", n, Ack(3, n));
    return(0);
}

/* -*- mode: c -*-
 * $Id: ary.gcc,v 1.2 2004-05-22 07:25:00 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * this program is modified from:
 *   http://cm.bell-labs.com/cm/cs/who/bwk/interps/pap.html
 * Timing Trials, or, the Trials of Timing: Experiments with Scripting
 * and User-Interface Languages</a> by Brian W. Kernighan and
 * Christopher J. Van Wyk.
 *
 * I added free() to deallocate memory.
 */

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int i, k, *x, *y;
	
    x = (int *) calloc(n, sizeof(int));
    y = (int *) calloc(n, sizeof(int));

    for (i = 0; i < n; i++) {
	x[i] = i + 1;
    }
    for (k=0; k<1000; k++) {
	for (i = n-1; i >= 0; i--) {
	    y[i] += x[i];
	}
    }

    fprintf(stdout, "%d %d\n", y[0], y[n-1]);

    free(x);
    free(y);

    return(0);
}
/* The Computer Language Shootout Benchmarks
   http://shootout.alioth.debian.org/

   contributed by Kevin Carson
   compilation:
       gcc -O3 -fomit-frame-pointer -funroll-loops -static binary-trees.c -lm
       icc -O3 -ip -unroll -static binary-trees.c -lm
*/

#include <malloc.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>


typedef struct tn {
    struct tn*    left;
    struct tn*    right;
    long          item;
} treeNode;


treeNode* NewTreeNode(treeNode* left, treeNode* right, long item)
{
    treeNode*    new;

    new = (treeNode*)malloc(sizeof(treeNode));

    new->left = left;
    new->right = right;
    new->item = item;

    return new;
} /* NewTreeNode() */


long ItemCheck(treeNode* tree)
{
    if (tree->left == NULL)
        return tree->item;
    else
        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);
} /* ItemCheck() */


treeNode* BottomUpTree(long item, unsigned depth)
{
    if (depth > 0)
        return NewTreeNode
        (
            BottomUpTree(2 * item - 1, depth - 1),
            BottomUpTree(2 * item, depth - 1),
            item
        );
    else
        return NewTreeNode(NULL, NULL, item);
} /* BottomUpTree() */


void DeleteTree(treeNode* tree)
{
    if (tree->left != NULL)
    {
        DeleteTree(tree->left);
        DeleteTree(tree->right);
    }

    free(tree);
} /* DeleteTree() */


int main(int argc, char* argv[])
{
    unsigned   N, depth, minDepth, maxDepth, stretchDepth;
    treeNode   *stretchTree, *longLivedTree, *tempTree;

    N = atol(argv[1]);

    minDepth = 4;

    if ((minDepth + 2) > N)
        maxDepth = minDepth + 2;
    else
        maxDepth = N;

    stretchDepth = maxDepth + 1;

    stretchTree = BottomUpTree(0, stretchDepth);
    printf
    (
        "stretch tree of depth %u\t check: %li\n",
        stretchDepth,
        ItemCheck(stretchTree)
    );

    DeleteTree(stretchTree);

    longLivedTree = BottomUpTree(0, maxDepth);

    for (depth = minDepth; depth <= maxDepth; depth += 2)
    {
        long    i, iterations, check;

        iterations = pow(2, maxDepth - depth + minDepth);

        check = 0;

        for (i = 1; i <= iterations; i++)
        {
            tempTree = BottomUpTree(i, depth);
            check += ItemCheck(tempTree);
            DeleteTree(tempTree);

            tempTree = BottomUpTree(-i, depth);
            check += ItemCheck(tempTree);
            DeleteTree(tempTree);
        } /* for(i = 1...) */

        printf
        (
            "%li\t trees of depth %u\t check: %li\n",
            iterations * 2,
            depth,
            check
        );
    } /* for(depth = minDepth...) */

    printf
    (
        "long lived tree of depth %u\t check: %li\n",
        maxDepth,
        ItemCheck(longLivedTree)
    );

    return 0;
} /* main() */
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Eckehard Berns
 * Based on code by Kevin Carson
 */

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

typedef struct node {
   struct node *left, *right;
   long item;
} node;

static node *
new_node(node *left, node *right, long item)
{
   node *ret;

   ret = malloc(sizeof(node));
   ret->left = left;
   ret->right = right;
   ret->item = item;

   return ret;
}

static long
item_check(node *tree)
{
   if (tree->left == NULL)
      return tree->item;
   else
      return tree->item + item_check(tree->left) -
          item_check(tree->right);
}

static node *
bottom_up_tree(long item, int depth)
{
   if (depth > 0)
      return new_node(bottom_up_tree(2 * item - 1, depth - 1),
          bottom_up_tree(2 * item, depth - 1), item);
   else
      return new_node(NULL, NULL, item);
}

static void
delete_tree(node *tree)
{
   if (tree->left != NULL) {
      delete_tree(tree->left);
      delete_tree(tree->right);
   }
   free(tree);
}

struct worker_args {
   long iter, check;
   int depth;
   pthread_t id;
   struct worker_args *next;
};

static void *
check_tree_of_depth(void *_args)
{
   struct worker_args *args = _args;
   long i, iter, check, depth;
   node *tmp;

   iter = args->iter;
   depth = args->depth;

   check = 0;
   for (i = 1; i <= iter; i++) {
      tmp = bottom_up_tree(i, depth);
      check += item_check(tmp);
      delete_tree(tmp);

      tmp = bottom_up_tree(-i, depth);
      check += item_check(tmp);
      delete_tree(tmp);
   }

   args->check = check;
   return NULL;
}

int
main(int ac, char **av)
{
   node *stretch, *longlived;
   struct worker_args *args, *targs, *hargs;
   int n, depth, mindepth, maxdepth, stretchdepth;

   n = ac > 1 ? atoi(av[1]) : 10;
   if (n < 1) {
      fprintf(stderr, "Wrong argument.\n");
      exit(1);
   }

   mindepth = 4;
   maxdepth = mindepth + 2 > n ? mindepth + 2 : n;
   stretchdepth = maxdepth + 1;

   stretch = bottom_up_tree(0, stretchdepth);
   printf("stretch tree of depth %u\t check: %li\n", stretchdepth,
       item_check(stretch));
   delete_tree(stretch);

   longlived = bottom_up_tree(0, maxdepth);

   hargs = NULL;
   targs = NULL;
   for (depth = mindepth; depth <= maxdepth; depth += 2) {

      args = malloc(sizeof(struct worker_args));
      args->iter = 1 << (maxdepth - depth + mindepth);
      args->depth = depth;
      args->next = NULL;
      if (targs == NULL) {
         hargs = args;
         targs = args;
      } else {
         targs->next = args;
         targs = args;
      }
      pthread_create(&args->id, NULL, check_tree_of_depth, args);
   }

   while (hargs != NULL) {
      args = hargs;
      pthread_join(args->id, NULL);
      printf("%ld\t trees of depth %d\t check: %ld\n",
          args->iter * 2, args->depth, args->check);
      hargs = args->next;
      free(args);
   }

   printf("long lived tree of depth %d\t check: %ld\n", maxdepth,
       item_check(longlived));

   /* not in original C version: */
   delete_tree(longlived);

   return 0;
}

/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Francesco Abbate
 */


#include <stdlib.h>
#include <stdio.h>

typedef off_t off64_t;
#include <apr_pools.h>

const size_t	LINE_SIZE = 64;

struct node
{
  int i;
  struct node *left;
  struct node *right;
};

int
node_check(const struct node *n)
{
  if (n->left)
    {
      int lc = node_check (n->left);
      int rc = node_check (n->right);
      return lc + n->i - rc;
    }

  return n->i;
}

struct node *
node_get_avail (apr_pool_t *pool)
{
  return apr_palloc (pool, sizeof(struct node));
}

struct node *
make (int i, int depth, apr_pool_t *pool)
{
  struct node *curr = node_get_avail (pool);

  curr->i = i;

  if (depth > 0)
    {
      curr->left  = make (2*i-1, depth - 1, pool);
      curr->right = make (2*i  , depth - 1, pool);
    }
  else
    {
      curr->left  = NULL;
      curr->right = NULL;
    }

  return curr;
}

int
main(int argc, char *argv[])
{
  apr_pool_t *long_lived_pool;
  int min_depth = 4;
  int req_depth = (argc == 2 ? atoi(argv[1]) : 10);
  int max_depth = (req_depth > min_depth + 2 ? req_depth : min_depth + 2);
  int stretch_depth = max_depth+1;

  apr_initialize();

  /* Alloc then dealloc stretchdepth tree */
  {
    apr_pool_t *store;
    struct node *curr;

    apr_pool_create (&store, NULL);
    curr = make (0, stretch_depth, store);
    printf ("stretch tree of depth %i\t check: %i\n", stretch_depth, 
	    node_check (curr));
    apr_pool_destroy (store);
  }

  apr_pool_create (&long_lived_pool, NULL);

  {
    struct node *long_lived_tree = make(0, max_depth, long_lived_pool);

    /* buffer to store output of each thread */
    char *outputstr = (char*) malloc(LINE_SIZE * (max_depth +1) * sizeof(char));
    int d;

#pragma omp parallel for
    for (d = min_depth; d <= max_depth; d += 2)
      {
        int iterations = 1 << (max_depth - d + min_depth);
	apr_pool_t *store;
        int c = 0, i;

	apr_pool_create (&store, NULL);

        for (i = 1; i <= iterations; ++i)
	  {
	    struct node *a, *b;

	    a = make ( i, d, store);
	    b = make (-i, d, store);
            c += node_check (a) + node_check (b);
	    apr_pool_clear (store);
        }
	apr_pool_destroy (store);
	
	/* each thread write to separate location */
	sprintf(outputstr + LINE_SIZE * d, "%d\t trees of depth %d\t check: %d\n", (2 * iterations), d, c);
      }

    /* print all results */
    for (d = min_depth; d <= max_depth; d += 2)
      printf("%s", outputstr + (d * LINE_SIZE) );
    free(outputstr);

    printf ("long lived tree of depth %i\t check: %i\n", max_depth, 
	    node_check (long_lived_tree));

    return 0;
  }
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Kenneth Jonsson
 */
#include <alloca.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

/* The work area are for local variables and return addresses. */
#define STACK_WORK_SZ 32*1024

/*
 * Assume 4kB pages, which is true for both i386 and x86_64, some
 * OS:es requires stack sizes aligned to a page boundary.
 * Linux does not, OS X does.
 */
#define PAGE_SIZE (1 << 12)

#define bottom_up_tree(item, depth)                                     \
    init_node(alloca(sizeof(struct node) * num_elem(depth)),            \
              item,                                                     \
              num_elem(depth))

struct node {
    int item;
    struct node *left;
    struct node *right;
};

struct item_worker_data {
    int iterations;
    int depth;
    int check;
};

struct args {
    int min_depth;
    int max_depth;
};


static int
num_elem(int height)
{
    if (height < 0)
        return 0;
    return (1 << height) + num_elem(height - 1);
}

/*
 * Some pthread implementations requires that the stack size is a
 * multiple of the size of a page
 */
static int
stack_sz(int depth)
{
    int sz = (num_elem(depth) * sizeof(struct node) + STACK_WORK_SZ);
    return (sz + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
}

static int
node_check(const struct node *n)
{
    if (n->left)
        return node_check(n->left) + n->item - node_check(n->right);
    return n->item;
}

static struct node *
init_node(struct node *node, int item, int n)
{
    int subtree_n; /* Number of nodes in left/right subtree to this
                    * node */

    if (n == 0)
        return NULL;

    node->item = item;
    subtree_n = n / 2;
    /*
     * left subtree is stored in the front half of the stack space and
     * the right subtree is stored in the back half of the stack
     * space
     */
    node->left = init_node(node + 1, 2 * item - 1, subtree_n);
    node->right = init_node(node + 1 + subtree_n, 2 * item, subtree_n);
    return node;
}

/*
 * Do one iteration, must be in a non-static function to ensure that
 * the stack frame is released between each invocation, i.e. this
 * function must not be inlined.
 */
int
do_one_iteration(int i, int depth)
{
    struct node *a, *b;

    a = bottom_up_tree(i, depth);
    b = bottom_up_tree(-i, depth);
    return node_check(a) + node_check(b);
}

/*
 * Calculate the checksum at a specific depth. This is the equivalent
 * of the body to the the outer for-loop of most other
 * solutions. Enough space to store two trees with a depth of
 * 'wd->depth'
 */
void *
item_worker(void *arg)
{
    struct item_worker_data *wd = arg;
    int i;

    for (i = 1; i <= wd->iterations; ++i)
        wd->check += do_one_iteration(i, wd->depth);
    return wd;
}

/*
 * The calculations is started in reverse order compared to most other
 * solutions. The reason is that all data must be on the stack and the
 * result from shallowest tree must be printed first.
 */
void
do_trees(int depth, int min_depth, int max_depth)
{
    pthread_t thread;
    pthread_attr_t attr;
    struct item_worker_data wd;

    if (depth < min_depth)
        return;

    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, stack_sz(depth + 1));

    wd.iterations = 1 << (max_depth - depth + min_depth);
    wd.check = 0;
    wd.depth = depth;
    pthread_create(&thread, &attr, item_worker, &wd);

    do_trees(depth-2, min_depth, max_depth);

    pthread_join(thread, NULL);
    pthread_attr_destroy(&attr);

    printf("%d\t trees of depth %d\t check: %d\n",
           2 * wd.iterations,
           depth,
           wd.check);
}

void
stretchdepth_tree(int depth)
{
    struct node *stretch_tree = bottom_up_tree(0, depth);

    printf("stretch tree of depth %i\t check: %i\n",
           depth,
           node_check(stretch_tree));
}

/*
 * Main function with enough stack space to fit the tree used to
 * 'stretch' memory. Same space is reused to the long lived tree.
 */
void *
main_thread(void *args_)
{
    struct node *long_lived_tree;
    struct args *args = args_;

    stretchdepth_tree(args->max_depth + 1);
    long_lived_tree = bottom_up_tree(0, args->max_depth);
    /*
     * Calculates all subtrees for every second depth ranging from
     * min_depth up to, but not including max_depth
     */
    do_trees(args->max_depth & ~1,
             args->min_depth,
             args->max_depth);
    printf("long lived tree of depth %i\t check: %i\n",
           args->max_depth,
           node_check(long_lived_tree));

    return NULL;
}

int
main(int argc, char *argv[])
{
    int req_depth = (argc == 2 ? atoi(argv[1]) : 10);
    pthread_t thread;
    pthread_attr_t attr;
    struct args args;

    args.min_depth = 4;
    args.max_depth = (req_depth > args.min_depth + 2
                      ? req_depth
                      : args.min_depth + 2);

    pthread_attr_init(&attr);
    pthread_attr_setstacksize(&attr, stack_sz(args.max_depth + 1));
    pthread_create(&thread, &attr, main_thread, &args);
    pthread_attr_destroy(&attr);
    pthread_join(thread, NULL);

    return 0;
}
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Josh Goldfoot
*/

#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

typedef enum { Blue, Red, Yellow, Faded } color;

sem_t AtMostTwo;
sem_t Mutex;
sem_t SemPriv;

int mpStatus = 1;
color aColor, bColor;
long meetingsLeft;
long reports[4];

color complementaryColor (color c1, color c2)
{
  if (c2 == Faded) return Faded;
  if (c1 == c2) return c1;
  switch (c1)
    {
    case Blue:
      return c2 == Red ? Yellow : Red;
    case Red:
      return c2 == Blue ? Yellow : Blue;
    case Yellow:
      return c2 == Blue ? Red : Blue;
    default:
      return c1;
    }
}

color Cooperation (int id, color c)
{
  color otherColor;

  sem_wait (&AtMostTwo);
  sem_wait (&Mutex);
  switch (mpStatus)
    {
    case 1:
      aColor = c;
      mpStatus = 2;
      sem_post (&Mutex);
      sem_wait (&SemPriv);
      otherColor = bColor;
      sem_post (&Mutex);
      sem_post (&AtMostTwo);
      sem_post (&AtMostTwo);
      break;
    case 2:
      mpStatus = (--meetingsLeft > 0 ? 1 : 3);
      bColor = c;
      otherColor = aColor;
      sem_post (&SemPriv);
      break;
    case 3:
    default:
      otherColor = Faded;
      sem_post (&Mutex);
      sem_post (&AtMostTwo);
    }
  return otherColor;
}

void chameneosCode (void *args)
{
  int myId;
  long meetings;
  color myColor, otherColor;
  sscanf ((char *) args, "%d %d", &myId, &myColor);
  meetings = 0;
  while (myColor != Faded)
    {
      otherColor = Cooperation (myId, myColor);
      myColor = complementaryColor (myColor, otherColor);
      meetings++;
    }
  reports[myId] = meetings - 1;
}

int main (int argc, char *argv[])
{
  color tabColor[4] = { Blue, Red, Yellow, Blue };
  pthread_t tabPid[4];
  char theArgs[32][4];
  int i;

  sem_init (&AtMostTwo, 0, 2);
  sem_init (&Mutex, 0, 1);
  sem_init (&SemPriv, 0, 0);

  meetingsLeft = (argc > 1) ? atoi (argv[1]) : 1000000;

  for (i = 0; i < 4; i++)
    {
      sprintf (theArgs[i], "%d %d", i, tabColor[i]);
      pthread_create (&tabPid[i], NULL, (void *(*)(void *)) chameneosCode,
		      theArgs[i]);
    }
  for (i = 0; i < 4; i++)
    pthread_join (tabPid[i], NULL);

  long sum = reports[0];
  for (i = 1; i < 4; i++)
    sum += reports[i];
  printf ("%d\n", sum);

  return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Written by Jorge Peixoto de Morais Neto
   based on code by Josh Goldfoot */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <err.h>

static sem_t mutex, second_creature;

static unsigned long meetingsleft;

typedef enum { Blue, Red, Yellow, Faded } color_t;
typedef struct {
    unsigned long *meetingsp;
    color_t color;
} creature_t;

/* When this function is called with two different colors, it must return the other color */
/* We assume that none of the colors is Faded */
/* If it is called with two equal colors, the specification allows us to return any color.  */
/* In this case, we return Red if both colors are Blue, Yellow if both are Red and Blue if both are Yellow */
static color_t complementarycolor (color_t c1, color_t c2) {
    switch (c1) {
    case Blue:
	return c2 == Red ? Yellow : Red;
    case Red:
	return c2 == Yellow ? Blue : Yellow;
    case Yellow:
    default:
	return c2 == Blue ? Red : Blue;
    }
}

/* This is the meeting place. Multiple threads call this function.  */
/* This function returns the new color the creature must assume after the meeting*/
/* The first creature locks mutex, sets color1 = color, updates mp_state, */
/* unlocks the mutex and waits to lock second_creature */
/* The second creature locks mutex, sets othercolor=color1 and color2 = color , */
/* decrements meetingsleft, updates mp_state, unlocks second_creature and returns */
/* The first creature sets othercolor = color2, unlocks mutex and returns */
/* mp_state is EMPTY again, the two semaphores are back to initial values and the cycle continues */
/* until meetingsleft reaches 0. */
static color_t new_color (color_t color) {
/* Meeting place state*/
    static enum {
	MEETINGS_LIMIT_REACHED = -1,
	EMPTY,
	ONE_CREATURE
    } mp_state = EMPTY;

    static color_t color1, color2;
    color_t othercolor;
    sem_wait (&mutex);
    switch (mp_state) {
    case EMPTY:
	color1 = color;
	mp_state = ONE_CREATURE;
	sem_post (&mutex);
	sem_wait (&second_creature);
	othercolor = color2;
	sem_post (&mutex);
	break;
    case ONE_CREATURE:
	othercolor = color1;
	color2 = color;
	mp_state = (--meetingsleft ? EMPTY : MEETINGS_LIMIT_REACHED);
	sem_post (&second_creature);
	break;
    case MEETINGS_LIMIT_REACHED:
    default:
	sem_post (&mutex);
	return Faded;
    }
    return complementarycolor (color, othercolor);
}

/* This function simulates a creature. */
static void *run_creature (void *voidpme) {
    creature_t const *me = voidpme;
    unsigned long meetings = 0;
    color_t color = me->color;
    do {
	meetings++;
	color = new_color (color);
    } while (color != Faded);
/* The '-1' compensates the fact that the meetings variable counts the meeting  */
/* in wich the creature becomes faded (but it shouldn't) */
    *me->meetingsp = meetings - 1;
    static int zero = 0;
/* We return a pointer to 0, meaning success. */
    return &zero;
}

/* This function sets loose four creatures and returns the sum of reported meetings*/
static unsigned long meetings_of_four_creatures (void) {
    sem_init (&mutex, 0, 1);
    sem_init (&second_creature, 0, 0);

    unsigned long reports[4];
    creature_t creatures[4] = {{&reports[0], Blue},
			       {&reports[1], Red},
			       {&reports[2], Yellow},
			       {&reports[3], Blue}};
    pthread_t pids[4];
    int i;
    for (i = 0; i < 4; i++)
	pthread_create (&pids[i], NULL, run_creature, &creatures[i]);

    for (i = 0; i < 4; i++)
	pthread_join (pids[i], NULL);

    unsigned long sum = reports[0];
    for (i = 1; i < 4; i++)
	sum += reports[i];
    return sum;
}

int main (int argc, char const **argv) {
    meetingsleft = 1e6;
    if (argc > 1) {
	char *tail;
	meetingsleft = strtoul (argv[1], &tail, 0);
	if (tail == argv[1]) 
	    errx (1, "Could not convert \"%s\" to an unsigned long integer", argv[1]);
    }
    unsigned long sum = meetings_of_four_creatures ();
    printf ("%lu\n", sum);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Written by Jorge Peixoto de Morais Neto
   based on code by Josh Goldfoot
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sched.h>
#include <stdbool.h>
#include <err.h>
static unsigned long meetingsleft;

typedef enum { Blue, Red, Yellow, Faded } color_t;
typedef struct {
    color_t color;
    bool waiting_partner;
} creature_t;

/* When this function is called with two different colors, it must return the other color */
/* We assume that none of the colors is Faded */
/* If it is called with two equal colors, the specification allows us to return any color.  */
/* In this case, we return Red if both colors are Blue, Yellow if both are Red and Blue if both are Yellow */
static color_t complementarycolor (color_t c1, color_t c2) {
    switch (c1) {
    case Yellow:
	return c2 == Blue ? Red : Blue;
    case Red:
	return c2 == Yellow ? Blue : Yellow;
    default:
    case Blue:
	return c2 == Red ? Yellow : Red;
    }
}

/* This is the meeting place. The threads simulating creatures call this function. */
/* This function takes a pointer to the creaure data */
/* and writes to the color field the new color the creature must assume */
static void meeting_place (creature_t volatile *creature_p) {
    /* A creature in the meeting place waiting for a partner. NULL means */
    /* there is no such creature */
    static creature_t volatile *waiting_creature_p = NULL;
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock (&mutex);
    if (!waiting_creature_p) {
	if (meetingsleft) {
	    waiting_creature_p = creature_p;
	    creature_p->waiting_partner = true;
	    pthread_mutex_unlock(&mutex);
	    while (creature_p->waiting_partner)
		sched_yield ();
	} else {
	    pthread_mutex_unlock (&mutex);
	    creature_p->color = Faded;
	}
    } else {
	color_t newcolor = 
	    complementarycolor (creature_p->color, waiting_creature_p->color);
	creature_p->color = newcolor;
	waiting_creature_p->color = newcolor;
	waiting_creature_p->waiting_partner = false;
	waiting_creature_p = NULL;
	meetingsleft--;
	pthread_mutex_unlock (&mutex);
    }
}

/* This function simulates a creature. */
/* It returns a pointer to the number of meetings this creature performed */
static void *run_creature (void *me_voidp) {
    creature_t *me_p = me_voidp;
    unsigned long meetings = 0;
    do {
	meetings++;
	meeting_place (me_p);
    } while (me_p->color != Faded);
    unsigned long *meetings_p = malloc (sizeof *meetings_p);
/* The '-1' compensates the fact that the meetings variable counts the meeting */
/* in wich the creature becomes faded (but it shouldn't) */
    *meetings_p = meetings - 1;
    return meetings_p;
}

#define NCREATURES 4
/* This function unleashes NCREATURES creatures and returns the sum of reported meetings */
static unsigned long meetings_of_creatures (void) {
    creature_t creatures[NCREATURES];
    creatures[0].color = Blue;
    creatures[1].color = Red;
    creatures[2].color = Yellow;
    creatures[3].color = Blue;

    pthread_t pids[NCREATURES];
    int i;
    for (i = NCREATURES - 1; i >= 0; i--)
	pthread_create (&pids[i], NULL, run_creature, &creatures[i]);

    unsigned long sum = 0;
    for (i = NCREATURES - 1; i >= 0; i--) {
	void *result_p;
	pthread_join (pids[i], &result_p);
	sum += *(unsigned long *) result_p;
    }
    return sum;
}

int main (int argc, char **argv) {
    meetingsleft = 1e6;
    if (argc > 1) {
	char *tail;
	meetingsleft = strtoul (argv[1], &tail, 0);
	if (tail == argv[1]) 
	    errx (1, "Could not convert \"%s\" to an unsigned long integer", argv[1]);
    }
    unsigned long sum = meetings_of_creatures ();
    printf ("%lu\n", sum);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Michael Barker
   based on a Java contribution by Luzius Meisser

   convert to C by dualamd
*/

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>


enum Colour 
{
   blue      = 0,
   red      = 1,
   yellow   = 2,
   Invalid   = 3
};

const char* ColourName[] = {"blue", "red", "yellow"};
const int STACK_SIZE   = 32*1024;

typedef unsigned int BOOL;
const BOOL TRUE = 1;
const BOOL FALSE = 0;

int CreatureID = 0;


enum Colour doCompliment(enum Colour c1, enum Colour c2) 
{
   switch (c1) 
   {
   case blue:
      switch (c2) 
      {
      case blue:
         return blue;
      case red:
         return yellow;
      case yellow:
         return red;
      default:
         goto errlb;
      }
   case red:
      switch (c2) 
      {
      case blue:
         return yellow;
      case red:
         return red;
      case yellow:
         return blue;
      default:
         goto errlb;
      }
   case yellow:
      switch (c2) 
      {
      case blue:
         return red;
      case red:
         return blue;
      case yellow:
         return yellow;
      default:
         goto errlb;
      }
   default:
      break;
   }

errlb:   
   printf("Invalid colour\n");
   exit( 1 );
}

/* convert integer to number string: 1234 -> "one two three four" */
char* formatNumber(int n, char* outbuf)
{
   int ochar = 0, ichar = 0;
   int i;
   char tmp[64];

   const char* NUMBERS[] =
   {
      "zero", "one", "two", "three", "four", "five",
      "six", "seven", "eight", "nine"
   };

   ichar = sprintf(tmp, "%d", n);

   for (i = 0; i < ichar; i++)
      ochar += sprintf( outbuf + ochar, " %s", NUMBERS[ tmp[i] - '0' ] );

   return outbuf;
}


struct MeetingPlace 
{
   pthread_mutex_t   mutex;
   int             meetingsLeft;
   struct Creature*   firstCreature;
};

struct Creature
{
   pthread_t         ht;
   pthread_attr_t      stack_att;

   struct MeetingPlace* place;
   int         count;
   int         sameCount;

   enum Colour   colour;
   int          id;

   BOOL      two_met;
   BOOL      sameid;
};


void MeetingPlace_Init(struct MeetingPlace* m, int meetings ) 
{
   pthread_mutex_init( &m->mutex, 0 );
   m->meetingsLeft = meetings;
   m->firstCreature = 0;
}


BOOL Meet( struct Creature* cr)
{
   BOOL retval = TRUE;

   struct MeetingPlace* mp = cr->place;
   pthread_mutex_lock( &(mp->mutex) );

   if ( mp->meetingsLeft > 0 )
   {
      if ( mp->firstCreature == 0 ) 
      {
         cr->two_met = FALSE;
         mp->firstCreature = cr;
      } 
      else 
      {
         struct Creature* first;
         enum Colour newColour;

         first = mp->firstCreature;
         newColour = doCompliment( cr->colour, first->colour );

         cr->sameid = cr->id == first->id;
         cr->colour = newColour;
         cr->two_met = TRUE;
         
         first->sameid = cr->sameid;
         first->colour = newColour;
         first->two_met = TRUE;

         mp->firstCreature = 0;
         mp->meetingsLeft--;
      }
   } 
   else 
      retval = FALSE;

   pthread_mutex_unlock( &(mp->mutex) );
   return retval;
}

   
void* CreatureThreadRun(void* param)
{
   struct Creature* cr = (struct Creature*)param;
   
   while (TRUE) 
   {
      if ( Meet(cr) )
      {
         while (cr->two_met == FALSE)
            sched_yield();
            
         if (cr->sameid) 
            cr->sameCount++;
         cr->count++;
      }
      else
         break;
   }

   return 0;
}

void Creature_Init( struct Creature *cr, struct MeetingPlace* place, enum Colour colour ) 
{
   cr->place = place;
   cr->count = cr->sameCount = 0;

   cr->id = ++CreatureID;
   cr->colour = colour;
   cr->two_met = FALSE;

   pthread_attr_init( &cr->stack_att );
   pthread_attr_setstacksize( &cr->stack_att, STACK_SIZE );
   pthread_create( &cr->ht, &cr->stack_att, &CreatureThreadRun, (void*)(cr) );
}

/* format meeting times of each creature to string */
char* Creature_getResult(struct Creature* cr, char* str) 
{
   char numstr[256];
   formatNumber(cr->sameCount, numstr);

   sprintf( str, "%u%s", cr->count, numstr );
   return str;
}


void runGame( int n_meeting, int ncolor, const enum Colour* colours ) 
{
   int i;
   int total = 0;
   char str[256];

   struct MeetingPlace place;
   struct Creature *creatures = (struct Creature*) calloc( ncolor, sizeof(struct Creature) );

   MeetingPlace_Init( &place, n_meeting );

   /* print initial color of each creature */
   for (i = 0; i < ncolor; i++)
   {
      printf( "%s ", ColourName[ colours[i] ] );
      Creature_Init( &(creatures[i]), &place, colours[i] );
   }
   printf("\n");

   /* wait for them to meet */
   for (i = 0; i < ncolor; i++) 
      pthread_join( creatures[i].ht, 0 );      

   /* print meeting times of each creature */
   for (i = 0; i < ncolor; i++) 
   {
      printf( "%s\n", Creature_getResult(&(creatures[i]), str) );
      total += creatures[i].count;
   }

   /* print total meeting times, should equal n_meeting */
   printf( "%s\n\n", formatNumber(total, str) );

   /* cleaup & quit */
   pthread_mutex_destroy( &place.mutex );
   free( creatures );
}


void printColours( enum Colour c1, enum Colour c2 ) 
{
   printf( "%s + %s -> %s\n", 
      ColourName[c1], 
      ColourName[c2], 
      ColourName[doCompliment(c1, c2)]   );
}

void printColoursTable(void) 
{
   printColours(blue, blue);
   printColours(blue, red);
   printColours(blue, yellow);
   printColours(red, blue);
   printColours(red, red);
   printColours(red, yellow);
   printColours(yellow, blue);
   printColours(yellow, red);
   printColours(yellow, yellow);
}

int main(int argc, char** argv) 
{
   int n = (argc == 2) ? atoi(argv[1]) : 600;

   printColoursTable();
   printf("\n");
   
   const enum Colour r1[] = {   blue, red, yellow   };
   const enum Colour r2[] = {   blue, red, yellow, 
               red, yellow, blue, 
               red, yellow, red, blue   };

   runGame( n, sizeof(r1) / sizeof(r1[0]), r1 );
   runGame( n, sizeof(r2) / sizeof(r2[0]), r2 );

   return 0;
}

/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/
Contributed by Dmitry Vyukov

Kernel thread is created for each chameneous.
Atomic compare-and-swap primitive is used 
for meeting place state manipulation.
*/

#define _GNU_SOURCE
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/time.h>
#include <pthread.h>
#include <sched.h>

#define CPUINFO_FILENAME "/proc/cpuinfo"

#define CL_SIZE 64

void* cache_aligned_malloc(size_t sz)
{
    char*                       mem;
    char*                       res;
    void**                      pos;

    mem = (char*)malloc(sz + 2 * CL_SIZE);
    if (mem == 0)
        exit(1);
    res = (char*)((uintptr_t)(mem + CL_SIZE) & ~(CL_SIZE - 1));
    pos = (void**)(res - sizeof(void*));
    pos[0] = mem;
    return res;
}

void cache_aligned_free(void* res)
{
    void*                       mem;
    void**                      pos;

    assert(((uintptr_t)res & (CL_SIZE - 1)) == 0);
    pos = (void**)((char*)res - sizeof(void*));
    mem = pos[0];
    free(mem);
}

enum color_t
{
    color_blue,
    color_red,
    color_yellow,
};

char const* color_names[] = {"blue", "red", "yellow"};

enum color_t color_complement(enum color_t c1, enum color_t c2)
{
   switch (c1)
   {
   case color_blue:
      switch (c2)
      {
      case color_blue:      return color_blue;
      case color_red:       return color_yellow;
      case color_yellow:    return color_red;
      }
   case color_red:
      switch (c2)
      {
      case color_blue:      return color_yellow;
      case color_red:       return color_red;
      case color_yellow:    return color_blue;
      }
   case color_yellow:
      switch (c2)
      {
      case color_blue:      return color_red;
      case color_red:       return color_blue;
      case color_yellow:    return color_yellow;
      }
   }
   assert(0);
   return 0;
}

void print_colors()
{
    enum color_t                c1;
    enum color_t                c2;
    enum color_t                c3;

    for (c1 = color_blue; c1 <= color_yellow; c1 += 1)
    {
        for (c2 = color_blue; c2 <= color_yellow; c2 += 1)
        {
            c3 = color_complement(c1, c2);
            printf("%s + %s -> %s\n",
                color_names[c1], color_names[c2], color_names[c3]);
        }
    }
    printf("\n");
}

char const* spell_number(size_t n)
{
    static char                 buf [128];
    static char const*          numbers [] = {
        " zero", " one", " two",   " three", " four",
        " five", " six", " seven", " eight", " nine"};

    size_t                      tokens [32];
    size_t                      token_count;
    char const*                 tok;
    char*                       pos;

    token_count = 0;
    do
    {
        tokens[token_count] = n % 10;
        token_count += 1;
        n /= 10;
    }
    while (n);

    pos = buf;
    while (token_count)
    {
        token_count -= 1;
        tok = numbers[tokens[token_count]];
        while (tok[0])
            pos++[0] = tok++[0];
    }
    pos[0] = 0;
    return buf;
}

struct meeting_place_t
{
    uintptr_t volatile          state;
};

#define CHAMENEOS_IDX_MASK      0xFF
#define MEET_COUNT_SHIFT        8

struct chameneos_t
{
    enum color_t                color;
    size_t                      meet_count;
    size_t                      meet_same_count;
    int volatile                meeting_completed;
    struct meeting_place_t*     place;
    struct chameneos_t**        chameneos;
    size_t                      id;
    int                         is_smp;
    pthread_t                   thread;
    pthread_attr_t              thread_attr;
};

void* chameneos_func(void* ctx)
{
    struct chameneos_t*         chameneos;
    struct chameneos_t**        chameneoses;
    struct chameneos_t*         peer;
    size_t                      my_id;
    size_t                      is_same;
    size_t                      spin_count;
    uintptr_t volatile*         state_p;
    uintptr_t                   state;
    uintptr_t                   peer_idx;
    uintptr_t                   xchg;
    uintptr_t                   prev;
    enum color_t                new_color;
    int                         is_smp;

    chameneos = (struct chameneos_t*)ctx;
    chameneoses = chameneos->chameneos;
    state_p = &chameneos->place->state;
    my_id = chameneos->id;
    is_smp = chameneos->is_smp;

    state = state_p[0];
    for (;;)
    {
        peer_idx = state & CHAMENEOS_IDX_MASK;
        if (peer_idx)
            xchg = state - peer_idx - (1 << MEET_COUNT_SHIFT);
        else if (state)
            xchg = state | my_id;
        else
            break;
        prev = __sync_val_compare_and_swap(state_p, state, xchg);
        if (prev == state)
        {
            if (peer_idx)
            {
                is_same = (peer_idx == my_id);
                peer = chameneoses[peer_idx - 1];
                new_color = color_complement(chameneos->color, peer->color);
                peer->color = new_color;
                peer->meet_count += 1;
                peer->meet_same_count += is_same;
                peer->meeting_completed = 1;
                chameneos->color = new_color;
                chameneos->meet_count += 1;
                chameneos->meet_same_count += is_same;
            }
            else
            {
                if (is_smp)
                {
                    spin_count = 20000;
                    while (chameneos->meeting_completed == 0)
                    {
                        if (spin_count)
                            spin_count -= 1;
                        else
                            sched_yield();
                    }
                }
                else
                {
                    while (chameneos->meeting_completed == 0)
                    {
                        sched_yield();
                    }
                }
                chameneos->meeting_completed = 0;
                state = state_p[0];
            }
        }
        else
        {
            state = prev;

        }
    }
    return 0;
}

void get_affinity(int* is_smp, cpu_set_t* affinity1, cpu_set_t* affinity2)
{
    cpu_set_t                   active_cpus;
    FILE*                       f;
    char                        buf [2048];
    char const*                 pos;
    int                         cpu_idx;
    int                         physical_id;
    int                         core_id;
    int                         cpu_cores;
    int                         apic_id;
    size_t                      cpu_count;
    size_t                      i;

    char const*                 processor_str       = "processor";
    size_t                      processor_str_len   = strlen(processor_str);
    char const*                 physical_id_str     = "physical id";
    size_t                      physical_id_str_len = strlen(physical_id_str);
    char const*                 core_id_str         = "core id";
    size_t                      core_id_str_len     = strlen(core_id_str);
    char const*                 cpu_cores_str       = "cpu cores";
    size_t                      cpu_cores_str_len   = strlen(cpu_cores_str);
    
    CPU_ZERO(&active_cpus);
    sched_getaffinity(0, sizeof(active_cpus), &active_cpus);
    cpu_count = 0;
    for (i = 0; i != CPU_SETSIZE; i += 1)
    {
        if (CPU_ISSET(i, &active_cpus))
        {
            cpu_count += 1;
        }
    }

    if (cpu_count == 1)
    {
        is_smp[0] = 0;
        return;
    }

    is_smp[0] = 1;
    CPU_ZERO(affinity1);
    CPU_ZERO(affinity2);

    f = fopen(CPUINFO_FILENAME, "r");

    if (cpu_count < 4 || f == 0)
    {
        for (i = 0; i != CPU_SETSIZE; i += 1)
        {
            if (CPU_ISSET(i, &active_cpus))
            {
                CPU_SET(i, affinity1);
                CPU_SET(i, affinity2);
            }
        }
        return;
    }

    cpu_idx = physical_id = core_id = cpu_cores = -1;
    while (fgets(buf, 2048, f))
    {
        if (0 == strncmp(buf, processor_str, processor_str_len))
        {
            pos = strchr(buf + processor_str_len, ':');
            if (pos)
                cpu_idx = atoi(pos + 1);
        }
        else if (0 == strncmp(buf, physical_id_str, physical_id_str_len))
        {
            pos = strchr(buf + physical_id_str_len, ':');
            if (pos)
                physical_id = atoi(pos + 1);
        }
        else if (0 == strncmp(buf, core_id_str, core_id_str_len))
        {
            pos = strchr(buf + core_id_str_len, ':');
            if (pos)
                core_id = atoi(pos + 1);
        }
        else if (0 == strncmp(buf, cpu_cores_str, cpu_cores_str_len))
        {
            pos = strchr(buf + cpu_cores_str_len, ':');
            if (pos)
                cpu_cores = atoi(pos + 1);
        }
        if (cpu_idx >= 0 && physical_id >= 0 && core_id >= 0 && cpu_cores >= 0)
        {
            apic_id = physical_id * cpu_cores + core_id;
            if (apic_id == 0 || apic_id == 1)
                CPU_SET(cpu_idx, affinity1);
            else if (apic_id == 2 || apic_id == 3)
                CPU_SET(cpu_idx, affinity2);
            cpu_idx = physical_id = core_id = cpu_cores = -1;
        }
    }

    fclose(f);
}

void init_and_start(enum color_t* initial_colors, size_t chameneos_count,
    struct meeting_place_t** place, struct chameneos_t*** chameneos,
    size_t meet_count, int is_smp, cpu_set_t* affinity)
{
    size_t                      i;

    place[0] = (struct meeting_place_t*)
        cache_aligned_malloc(sizeof(struct meeting_place_t));
    place[0]->state = meet_count << MEET_COUNT_SHIFT;
    chameneos[0] = (struct chameneos_t**)
        cache_aligned_malloc(chameneos_count * sizeof(struct chameneos_t*));
    for (i = 0; i != chameneos_count; i += 1)
    {
        chameneos[0][i] = (struct chameneos_t*)
            cache_aligned_malloc(sizeof(struct chameneos_t));
        chameneos[0][i]->place = place[0];
        chameneos[0][i]->chameneos = chameneos[0];
        chameneos[0][i]->id = i + 1;
        chameneos[0][i]->is_smp = is_smp;
        chameneos[0][i]->meet_count = 0;
        chameneos[0][i]->meet_same_count = 0;
        chameneos[0][i]->color = initial_colors[i];
        chameneos[0][i]->meeting_completed = 0;
        if (pthread_attr_init(&chameneos[0][i]->thread_attr))
            exit(1);
        if (is_smp)
            pthread_attr_setaffinity_np(&chameneos[0][i]->thread_attr,
                sizeof(cpu_set_t), affinity);
        if (pthread_create(&chameneos[0][i]->thread,
            &chameneos[0][i]->thread_attr, chameneos_func, chameneos[0][i]))
            exit(1);
    }
}

void join_and_output(enum color_t* initial_colors, size_t chameneos_count,
    struct meeting_place_t* place, struct chameneos_t** chameneos)
{
    size_t                      total_meet_count;
    size_t                      i;

    for (i = 0; i != chameneos_count; i += 1)
        printf(" %s", color_names[initial_colors[i]]);
    printf("\n");

    for (i = 0; i != chameneos_count; i += 1)
    {
        pthread_join(chameneos[i]->thread, 0);
        pthread_attr_destroy(&chameneos[i]->thread_attr);
    }

    total_meet_count = 0;
    for (i = 0; i != chameneos_count; i += 1)
    {
        total_meet_count += chameneos[i]->meet_count;
        printf("%u%s\n", chameneos[i]->meet_count,
            spell_number(chameneos[i]->meet_same_count));
        cache_aligned_free(chameneos[i]);
    }
    printf("%s\n\n", spell_number(total_meet_count));

    cache_aligned_free(chameneos);
    cache_aligned_free(place);
}

int main(int argc, char** argv)
{
    enum color_t                initial_colors1 [] = 
        {color_blue, color_red, color_yellow};

    enum color_t                initial_colors2 [] = 
        {color_blue, color_red, color_yellow, color_red, color_yellow,
        color_blue, color_red, color_yellow, color_red, color_blue};

    struct meeting_place_t*     place1;
    struct chameneos_t**        chameneos1;
    size_t                      chameneos_count1;

    struct meeting_place_t*     place2;
    struct chameneos_t**        chameneos2;
    size_t                      chameneos_count2;

    int                         is_smp;
    cpu_set_t                   affinity1;
    cpu_set_t                   affinity2;
    size_t                      meet_count;

    meet_count = 6000000;
    if (argc > 1 && atoi(argv[1]) > 0)
        meet_count = atoi(argv[1]);

    print_colors();

    get_affinity(&is_smp, &affinity1, &affinity2);

    chameneos_count1 = sizeof(initial_colors1)/sizeof(initial_colors1[0]);
    chameneos_count2 = sizeof(initial_colors2)/sizeof(initial_colors2[0]);

    if (is_smp)
    {
        init_and_start(initial_colors1, chameneos_count1, &place1, &chameneos1, meet_count, is_smp, &affinity1);
        init_and_start(initial_colors2, chameneos_count2, &place2, &chameneos2, meet_count, is_smp, &affinity2);
        join_and_output(initial_colors1, chameneos_count1, place1, chameneos1);
        join_and_output(initial_colors2, chameneos_count2, place2, chameneos2);
    }
    else
    {
        init_and_start(initial_colors1, chameneos_count1, &place1, &chameneos1, meet_count, is_smp, &affinity1);
        join_and_output(initial_colors1, chameneos_count1, place1, chameneos1);
        init_and_start(initial_colors2, chameneos_count2, &place2, &chameneos2, meet_count, is_smp, &affinity2);
        join_and_output(initial_colors2, chameneos_count2, place2, chameneos2);
    }

    return 0;
}

/* -*- mode: c -*-
 * $Id: echo.gcc,v 1.1 2004-05-19 18:09:36 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>


typedef int (*SOCKACTION_P)(int,struct sockaddr *,socklen_t);
#define DATA "Hello there sailor\n"

void myabort (char *m) { fprintf(stderr, "%s\n", m); exit(1); }
void sysabort (char *m) { perror(m); exit(1); }

int sigchld = 0;
void reaper (int sig) { sigchld = 1; }

int 
genericSock(int port,SOCKACTION_P action,char *actionExceptionText) {
    int ss, optval = 1;
    struct sockaddr_in sin;
    if ((ss = socket(PF_INET, SOCK_STREAM, 0)) == -1)
	sysabort("socket");
    if (setsockopt(ss, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1)
	sysabort("setsockopt");
    memset(&sin,0,sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sin.sin_port = port; 
    if (action(ss, (struct sockaddr *)&sin,(socklen_t)sizeof(sin)) == -1)
	sysabort(actionExceptionText);

    return(ss);
}

int
server_sock () {
    int ss = genericSock(0,(SOCKACTION_P)bind,"server/bind");
    return(listen(ss,2),ss);
}

int
client_sock (int port) {
    return(genericSock(port,(SOCKACTION_P)connect,"client/connect"));
}

int
get_port (int sock) {
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    if (getsockname(sock, (struct sockaddr *)&sin, &slen) == -1)
	sysabort("server/getsockname");
    return(sin.sin_port);
}    

void
echo_client (int n, int port) {
    int i, sock, olen, len, nwritten, nread;
    char *offset, obuf[64], ibuf[64];
    char *end = ibuf + sizeof(ibuf);

    sock = client_sock(port);
    strcpy(obuf, DATA);
    olen = strlen(obuf);
    for (i=0; i<n; i++) {
	len = olen;
	offset = obuf;
	while (len > 0) {
	    if ((nwritten = write(sock, offset, len)) == -1)
		sysabort("client/write");
	    offset += nwritten;
	    len -= nwritten;
	}
	offset = ibuf;
	while ((nread = read(sock, offset, (end - offset))) > 0) {
	    offset += nread;
	    if (*(offset-1) == '\n') break;
	}
	if (nread == -1)
	    sysabort("client/read");
	*offset = 0;
	if ((strcmp(obuf, ibuf)) != 0) {
	    char mbuf[128];
	    sprintf(mbuf, "client: \"%s\" ne \"%s\"", obuf, ibuf);
	    myabort(mbuf);
	}
    }
    close(sock);
}

void
echo_server (int n) {
    int ssock, csock, len, nwritten, total_bytes;
    pid_t pid;
    char buf[64], *offset;
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    int status;

    ssock = server_sock();
    signal(SIGCHLD, reaper);
    if ((pid = fork()) == -1)
	sysabort("server/fork");
    if (pid) {
	/* parent is server */
	if ((csock = accept(ssock, (struct sockaddr *)&sin, &slen)) == -1)
	    sysabort("server/accept");
	total_bytes = 0;
	while ((len = read(csock, buf, sizeof(buf))) > 0) {
	    if (sigchld) myabort("server/sigchld");
	    offset = buf;
	    total_bytes += len;
	    while (len > 0) {
		if ((nwritten = write(csock, offset, len)) == -1)
		    sysabort("server/write");
		offset += nwritten;
		len -= nwritten;
	    }
	}
	if (len == -1)
	    sysabort("server/read");
	close(csock);
	fprintf(stdout, "server processed %d bytes\n", total_bytes);
    } else {
	/* child is client */
	echo_client(n, get_port(ssock));
    }
    wait(&status);
}

int
main(int argc, char *argv[]) {
    echo_server((argc == 2) ? atoi(argv[1]) : 1);
    return(0);
}
/* -*- mode: c -*-
 * $Id: except.gcc,v 1.1 2004-05-19 18:09:42 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

int HI = 0, LO = 0;

static jmp_buf Hi_exception;
static jmp_buf Lo_exception;

void blowup (int n) {
    if (n & 1) {
	longjmp(Lo_exception, 1);
    } else {
	longjmp(Hi_exception, 1);
    }
}

void lo_function (volatile int n) {
    if (setjmp(Lo_exception) != 0) {
	LO++;
    } else {
	blowup(n);
    }
}

void hi_function (volatile int n) {
    if (setjmp(Hi_exception) != 0) {
	HI++;
    } else {
	lo_function(n);
    }
}

void some_function (int n) {
    hi_function(n);
}

int
main(int argc, char *argv[]) {
    int volatile N = ((argc == 2) ? atoi(argv[1]) : 1);

    while (N) {
	some_function(N--);
    }
    printf("Exceptions: HI=%d / LO=%d\n", HI, LO);
    return(0);
}
/*
 * The Computer Lannguage Shootout
 * http://shootout.alioth.debian.org/
 * Contributed by Heiner Marxen
 *
 * "fannkuch"	for C gcc
 *
 * $Id: fannkuch.gcc,v 1.5 2005-12-04 23:58:38 igouy-guest Exp $
 */

#include <stdio.h>
#include <stdlib.h>

#define Int	int
#define Aint	int

    static long
fannkuch( int n )
{
    Aint*	perm;
    Aint*	perm1;
    Aint*	count;
    long	flips;
    long	flipsMax;
    Int		r;
    Int		i;
    Int		k;
    Int		didpr;
    const Int	n1	= n - 1;

    if( n < 1 ) return 0;

    perm  = calloc(n, sizeof(*perm ));
    perm1 = calloc(n, sizeof(*perm1));
    count = calloc(n, sizeof(*count));

    for( i=0 ; i<n ; ++i ) perm1[i] = i;	/* initial (trivial) permu */

    r = n; didpr = 0; flipsMax = 0;
    for(;;) {
	if( didpr < 30 ) {
	    for( i=0 ; i<n ; ++i ) printf("%d", (int)(1+perm1[i]));
	    printf("\n");
	    ++didpr;
	}
	for( ; r!=1 ; --r ) {
	    count[r-1] = r;
	}

#define XCH(x,y)	{ Aint t_mp; t_mp=(x); (x)=(y); (y)=t_mp; }

	if( ! (perm1[0]==0 || perm1[n1]==n1) ) {
	    flips = 0;
	    for( i=1 ; i<n ; ++i ) {	/* perm = perm1 */
		perm[i] = perm1[i];
	    }
	    k = perm1[0];		/* cache perm[0] in k */
	    do {			/* k!=0 ==> k>0 */
		Int	j;
		for( i=1, j=k-1 ; i<j ; ++i, --j ) {
		    XCH(perm[i], perm[j])
		}
		++flips;
		/*
		 * Now exchange k (caching perm[0]) and perm[k]... with care!
		 * XCH(k, perm[k]) does NOT work!
		 */
		j=perm[k]; perm[k]=k ; k=j;
	    }while( k );
	    if( flipsMax < flips ) {
		flipsMax = flips;
	    }
	}

	for(;;) {
	    if( r == n ) {
		return flipsMax;
	    }
	    /* rotate down perm[0..r] by one */
	    {
		Int	perm0 = perm1[0];
		i = 0;
		while( i < r ) {
		    k = i+1;
		    perm1[i] = perm1[k];
		    i = k;
		}
		perm1[r] = perm0;
	    }
	    if( (count[r] -= 1) > 0 ) {
		break;
	    }
	    ++r;
	}
    }
}

    int
main( int argc, char* argv[] )
{
    int		n = (argc>1) ? atoi(argv[1]) : 0;

    printf("Pfannkuchen(%d) = %ld\n", n, fannkuch(n));
    return 0;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Eckehard Berns
 * Based on code by Heiner Marxen
 * and the ATS version by Hongwei Xi
 */

#include <stdlib.h>
#include <stdio.h>

#define USETHREADS 1
#if USETHREADS
#include <pthread.h>
#endif

struct worker_args {
   int i, n;
#if USETHREADS
   pthread_t id;
#endif
   struct worker_args *next;
};

static void *
fannkuch_worker(void *_arg)
{
   struct worker_args *args = _arg;
   int *perm1, *count, *perm;
   int maxflips, flips, i, n, r, j, k, tmp;

   maxflips = 0;
   n = args->n;
   perm1 = malloc(n * sizeof(int));
   perm = malloc(n * sizeof(int));
   count = malloc(n * sizeof(int));
   for (i = 0; i < n; i++)
      perm1[i] = i;
   perm1[args->i] = n - 1;
   perm1[n - 1] = args->i;
   r = n;

   for (;;) {
      for (; r > 1; r--)
         count[r - 1] = r;
      if (perm1[0] != 0 && perm1[n - 1] != n - 1) {
         for (i = 0; i < n; i++)
            perm[i] = perm1[i];
         flips = 0;
         k = perm[0];
         do {
            for (i = 1, j = k - 1; i < j; i++, j--) {
               tmp = perm[i];
               perm[i] = perm[j];
               perm[j] = tmp;
            }
            flips++;
            tmp = perm[k];
            perm[k] = k;
            k = tmp;
         } while (k);
         if (maxflips < flips)
            maxflips = flips;
      }
      for (;;) {
         if (r >= n - 1) {
            free(perm1);
            free(perm);
            free(count);
            return (void *)maxflips;
         }

         {
            int p0 = perm1[0];
            for (i = 0; i < r; i++)
               perm1[i] = perm1[i + 1];
            perm1[i] = p0;
         }
         if (--count[r] > 0)
            break;
         r++;
      }
   }
}

static int
fannkuch(int n)
{
   struct worker_args *args, *targs;
   int showmax = 30;
   int *perm1, *count, i, r, maxflips, flips;

   args = NULL;
   for (i = 0; i < n - 1; i++) {
      targs = malloc(sizeof(struct worker_args));
      targs->i = i;
      targs->n = n;
      targs->next = args;
      args = targs;
#if USETHREADS
      if (0 != pthread_create(&args->id, NULL, fannkuch_worker, args))
         abort();
#endif
   }

   perm1 = malloc(n * sizeof(int));
   count = malloc(n * sizeof(int));

   for (i = 0; i < n; i++)
      perm1[i] = i;

   r = n;
   for (;;) {
      if (showmax) {
         for (i = 0; i < n; i++)
            printf("%d", perm1[i] + 1);
         printf("\n");
         showmax--;
      } else
         goto cleanup;

      for (; r > 1; r--)
         count[r - 1] = r;

      for (;;) {
         if (r == n)
            goto cleanup;
         {
            int p0 = perm1[0];
            for (i = 0; i < r; i++)
               perm1[i] = perm1[i + 1];
            perm1[i] = p0;
         }
         if (--count[r] > 0)
            break;

         r++;
      }
   }

    cleanup:
   free(perm1);
   free(count);
   maxflips = 0;
   while (args != NULL) {
#if USETHREADS
      if (0 != pthread_join(args->id, (void **)&flips))
         abort();
#else
      flips = (int)fannkuch_worker(args);
#endif
      if (maxflips < flips)
         maxflips = flips;
      targs = args;
      args = args->next;
      free(targs);
   }
   return maxflips;
}

int
main(int ac, char **av)
{
   int n = ac > 1 ? atoi(av[1]) : 0;

   if (n < 1) {
      printf("Wrong argument.\n");
      return 1;
   }
   printf("Pfannkuchen(%d) = %d\n", n, fannkuch(n));
   return 0;
}

/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * converted to C by Joseph Pich
 * from Java version by Oleg Mazurov and Isaac Gouy
 *
 */

#include <stdio.h>
#include <stdlib.h>

inline static int max(int a, int b)
{
    return a > b ? a : b;
}

int fannkuchredux(int n)
{
    int perm[n];
    int perm1[n];
    int count[n];
    int maxFlipsCount = 0;
    int permCount = 0;
    int checksum = 0;

    int i;

    for (i=0; i<n; i+=1)
        perm1[i] = i;
    int r = n;

    while (1) {
        while (r != 1) {
            count[r-1] = r;
            r -= 1;
        }

        for (i=0; i<n; i+=1)
            perm[i] = perm1[i];
        int flipsCount = 0;
        int k;

        while ( !((k = perm[0]) == 0) ) {
            int k2 = (k+1) >> 1;
            for (i=0; i<k2; i++) {
                int temp = perm[i]; perm[i] = perm[k-i]; perm[k-i] = temp;
            }
            flipsCount += 1;
        }

        maxFlipsCount = max(maxFlipsCount, flipsCount);
        checksum += permCount % 2 == 0 ? flipsCount : -flipsCount;

        /* Use incremental change to generate another permutation */
        while (1) {
            if (r == n) {
                printf("%d\n", checksum);
                return maxFlipsCount;
            }

            int perm0 = perm1[0];
            i = 0;
            while (i < r) {
                int j = i + 1;
                perm1[i] = perm1[j];
                i = j;
            }
            perm1[r] = perm0;
            count[r] = count[r] - 1;
            if (count[r] > 0) break;
            r++;
        }
        permCount++;
    }
}

int main(int argc, char *argv[])
{
    int n = argc > 1 ? atoi(argv[1]) : 7;
    printf("Pfannkuchen(%d) = %d\n", n, fannkuchredux(n));
    return 0;
}
/* -*- mode: c -*-
 * $Id: fasta.gcc,v 1.1 2005-03-19 07:50:09 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 *
 * by Paul Hsieh
 */

#include <stdio.h>
#include <stdlib.h>

#define IM 139968
#define IA   3877
#define IC  29573

double gen_random (double max) {
    static long last = 42;
    return max * (last = (last * IA + IC) % IM) / IM;
}

struct aminoacids {
    char c;
    double p;
};

/* Weighted selection from alphabet */

void makeCumulative (struct aminoacids * genelist, int count) {
    double cp = 0.0;
    int i;

    for (i=0; i < count; i++) {
        cp += genelist[i].p;
        genelist[i].p = cp;
    }
}

char selectRandom (const struct aminoacids * genelist, int count) {
    double r = gen_random (1);
    int i, lo, hi;

    if (r < genelist[0].p) return genelist[0].c;

    lo = 0;
    hi = count-1;

    while (hi > lo+1) {
        i = (hi + lo) / 2;
        if (r < genelist[i].p) hi = i; else lo = i;
    }
    return genelist[hi].c;
}

/* Generate and write FASTA format */

#define LINE_LENGTH (60)

void makeRandomFasta (const char * id, const char * desc, const struct 
aminoacids * genelist, int count, int n) {
   int todo = n;
   int i, m;

   printf (">%s %s\n", id, desc);

   for (; todo > 0; todo -= LINE_LENGTH) {
       char pick[LINE_LENGTH+1];
       if (todo < LINE_LENGTH) m = todo; else m = LINE_LENGTH;
       for (i=0; i < m; i++) pick[i] = selectRandom (genelist, count);
       pick[m] = '\0';
       puts (pick);
   }
}

void makeRepeatFasta (const char * id, const char * desc, const char * 
s, int n) {
   char * ss;
   int todo = n, k = 0, kn = strlen (s);
   int m;

   ss = (char *) malloc (kn + 1);
   memcpy (ss, s, kn+1);

   printf (">%s %s\n", id, desc);

   for (; todo > 0; todo -= LINE_LENGTH) {
       if (todo < LINE_LENGTH) m = todo; else m = LINE_LENGTH;

       while (m >= kn - k) {
           printf ("%s", s+k);
           m -= kn - k;
           k = 0;
       }

       ss[k + m] = '\0';
       puts (ss+k);
       ss[k + m] = s[m+k];
       k += m;
   }

   free (ss);
}

/* Main -- define alphabets, make 3 fragments */

struct aminoacids iub[] = {
    { 'a', 0.27 },
    { 'c', 0.12 },
    { 'g', 0.12 },
    { 't', 0.27 },

    { 'B', 0.02 },
    { 'D', 0.02 },
    { 'H', 0.02 },
    { 'K', 0.02 },
    { 'M', 0.02 },
    { 'N', 0.02 },
    { 'R', 0.02 },
    { 'S', 0.02 },
    { 'V', 0.02 },
    { 'W', 0.02 },
    { 'Y', 0.02 }
};

#define IUB_LEN (sizeof (iub) / sizeof (struct aminoacids))

struct aminoacids homosapiens[] = {
    { 'a', 0.3029549426680 },
    { 'c', 0.1979883004921 },
    { 'g', 0.1975473066391 },
    { 't', 0.3015094502008 },
};

#define HOMOSAPIENS_LEN (sizeof (homosapiens) / sizeof (struct aminoacids))

char * alu =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" \
   "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" \
   "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" \
   "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" \
   "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" \
   "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" \
   "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int main (int argc, char * argv[]) {
    int n = 1000;

    if (argc > 1) sscanf (argv[1], "%d", &n);

    makeCumulative (iub, IUB_LEN);
    makeCumulative (homosapiens, HOMOSAPIENS_LEN);

    makeRepeatFasta ("ONE", "Homo sapiens alu", alu, n*2);
    makeRandomFasta ("TWO", "IUB ambiguity codes", iub, IUB_LEN, n*3);
    makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, 
HOMOSAPIENS_LEN, n*5);

    return 0;
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   based on C++ program by Andrew Moon
   contributed by Damien Grassart
*/

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define MIN(x, y) ((x < y) ? x : y)
#define LINELEN 60
#define SLOTS 4095

struct aminoacid {
   char c;
   float p;
};

static struct aminoacid *lu[SLOTS + 1];

static void repeat_fasta(const char *alu, size_t n)
{
   const size_t alulen = strlen(alu);
   char buf[alulen + LINELEN];
   size_t pos = 0, bytes;

   memcpy(buf, alu, alulen);
   memcpy(buf + alulen, alu, LINELEN);
   while (n) {
      bytes = MIN(LINELEN, n);
      fwrite_unlocked(buf + pos, bytes, 1, stdout);
      putchar_unlocked('\n');
      pos += bytes;
      if (pos > alulen)
         pos -= alulen;
      n -= bytes;
   }
}

static void acc_probs(struct aminoacid *table)
{
   struct aminoacid *iter = table;

   while ((++iter)->c) {
      iter->p += (iter-1)->p;
   }
   for (int i = 0; i <= SLOTS; ++i) {
      while (i > (table->p * SLOTS))
         ++table;
      lu[i] = table;
   }
}

static float rng(float max)
{
   const unsigned int IM = 139968, IA = 3877, IC = 29573;
   static unsigned int seed = 42;

   seed = (seed * IA + IC) % IM;
   return max * seed / IM;
}

static char nextc()
{
   float r;
   struct aminoacid *iter;

   r = rng(1.0f);
   iter = lu[(int)(r * SLOTS)];
   while (iter->p < r)
      ++iter;
   return iter->c;
}

static void random_fasta(struct aminoacid *table, size_t n)
{
   size_t i, lines = n / LINELEN;
   const size_t chars_left = n % LINELEN;
   char buf[LINELEN + 1];

   while (lines--) {
      for (i = 0; i < LINELEN; ++i) {
         buf[i] = nextc();
      }
      buf[i] = '\n';
      fwrite_unlocked(buf, i + 1, 1, stdout);
   }
   for (i = 0; i < chars_left; ++i)
      buf[i] = nextc();
   fwrite_unlocked(buf, i, 1, stdout);
}

int main(int argc, char **argv)
{
   const size_t n = (argc > 1) ? atoi(argv[1]) : 1000;
   const char alu[] =
      "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
      "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
      "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
      "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
      "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
      "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
      "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";
   struct aminoacid iub[] = {
      { 'a', 0.27 },
      { 'c', 0.12 },
      { 'g', 0.12 },
      { 't', 0.27 },
      { 'B', 0.02 },
      { 'D', 0.02 },
      { 'H', 0.02 },
      { 'K', 0.02 },
      { 'M', 0.02 },
      { 'N', 0.02 },
      { 'R', 0.02 },
      { 'S', 0.02 },
      { 'V', 0.02 },
      { 'W', 0.02 },
      { 'Y', 0.02 },
      { 0, 0 }
   };
   struct aminoacid homosapiens[] = {
      { 'a', 0.3029549426680 },
      { 'c', 0.1979883004921 },
      { 'g', 0.1975473066391 },
      { 't', 0.3015094502008 },
      { 0, 0 }
   };

   fputs_unlocked(">ONE Homo sapiens alu\n", stdout);
   repeat_fasta(alu, n * 2);
   fputs_unlocked(">TWO IUB ambiguity codes\n", stdout);
   acc_probs(iub);
   random_fasta(iub, n * 3);
   fputs_unlocked(">THREE Homo sapiens frequency\n", stdout);
   acc_probs(homosapiens);
   random_fasta(homosapiens, n * 5);
   putchar_unlocked('\n');

   return 0;
}
/*  The Computer Language Benchmarks Game
 *  http://shootout.alioth.debian.org/
 * 
 *  contributed by Petr Prokhorenkov
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
#define unlikely(x) __builtin_expect((x), 0)

#define IM 139968
#define IA 3877
#define IC 29573

#define LINE_LEN 60
#define LOOKUP_SIZE 4096
#define LOOKUP_SCALE ((float)(LOOKUP_SIZE - 1))

typedef unsigned random_t;

void
random_init(random_t *random) {
    *random = 42;
}

// Special version with result rescaled to LOOKUP_SCALE.
static inline
float
random_next_lookup(random_t *random) {
    *random = (*random*IA + IC)%IM;

    return (*random)*(LOOKUP_SCALE/IM);
}

struct amino_acid {
   char sym;
   float prob;
   float cprob_lookup;
};

void
repeat(const char *alu, const char *title, int n) {
    int len = strlen(alu);
    char buffer[len + LINE_LEN];
    int pos = 0;

    memcpy(buffer, alu, len);
    memcpy(buffer + len, alu, LINE_LEN);

    fputs_unlocked(title, stdout);
    while (n > 0) {
        int bytes = n > LINE_LEN ? LINE_LEN : n;

        fwrite_unlocked(buffer + pos, bytes, 1, stdout);
        pos += bytes;
        if (pos > len) {
            pos -= len;
        }
        fputc_unlocked('\n', stdout);
        n -= bytes;
    }
}

/*
 * Lookup table contains mapping from real values to cumulative
 * probabilities. Careful selection of table size allows lookup
 * virtually in constant time.
 *
 * All cumulative probabilities are rescaled to LOOKUP_SCALE,
 * this allows to save one multiplication operation on each iteration
 * in randomize().
 */

void *
fill_lookup(struct amino_acid **lookup, struct amino_acid *amino_acid, int amino_acid_size) {
    float p = 0;
    for (int i = 0; i < amino_acid_size; i++) {
        p += amino_acid[i].prob;
        amino_acid[i].cprob_lookup = p*LOOKUP_SCALE;
    }

    // Prevent rounding error.
    amino_acid[amino_acid_size - 1].cprob_lookup = LOOKUP_SIZE - 1;

    for (int i = 0, j = 0; i < LOOKUP_SIZE; i++) {
        while (amino_acid[j].cprob_lookup < i) {
            j++;
        }
        lookup[i] = &amino_acid[j];
    }

    return 0;
}

void
randomize(struct amino_acid *amino_acid, int amino_acid_size,
        const char *title, int n, random_t *rand) {
    struct amino_acid *lookup[LOOKUP_SIZE];
    char line_buffer[LINE_LEN + 1];
    int i, j;

    line_buffer[LINE_LEN] = '\n';

    fill_lookup(lookup, amino_acid, amino_acid_size);

    fputs_unlocked(title, stdout);

    for (i = 0, j = 0; i < n; i++, j++) {
        if (j == LINE_LEN) {
            fwrite_unlocked(line_buffer, LINE_LEN + 1, 1, stdout);
            j = 0;
        }

        float r = random_next_lookup(rand);
        struct amino_acid *u = lookup[(short)r];
        while (unlikely(u->cprob_lookup < r)) {
            ++u;
        }
        line_buffer[j] = u->sym;
    }
    line_buffer[j] = '\n';
    fwrite_unlocked(line_buffer, j + 1, 1, stdout);
}

struct amino_acid amino_acid[] = {
   { 'a', 0.27 },
   { 'c', 0.12 },
   { 'g', 0.12 },
   { 't', 0.27 },

   { 'B', 0.02 },
   { 'D', 0.02 },
   { 'H', 0.02 },
   { 'K', 0.02 },
   { 'M', 0.02 },
   { 'N', 0.02 },
   { 'R', 0.02 },
   { 'S', 0.02 },
   { 'V', 0.02 },
   { 'W', 0.02 },
   { 'Y', 0.02 },
};

struct amino_acid homo_sapiens[] = {
   { 'a', 0.3029549426680 },
   { 'c', 0.1979883004921 },
   { 'g', 0.1975473066391 },
   { 't', 0.3015094502008 },
};

static const char alu[] =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG"
   "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA"
   "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA"
   "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT"
   "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC"
   "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG"
   "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int
main(int argc, const char **argv) {
    int n = argc > 1 ? atoi( argv[1] ) : 512;
    random_t rand;

    random_init(&rand);

    repeat(alu, ">ONE Homo sapiens alu\n", n*2);
    randomize(amino_acid, ARRAY_SIZE(amino_acid),
            ">TWO IUB ambiguity codes\n", n*3, &rand);
    randomize(homo_sapiens, ARRAY_SIZE(homo_sapiens),
            ">THREE Homo sapiens frequency\n", n*5, &rand);

    return 0;
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * Contributed by Joern Inge Vestgaarden
 * Modified by Jorge Peixoto de Morais Neto
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>

#define WIDTH 60
#define MIN(a,b) ((a) <= (b) ? (a) : (b))
#define NELEMENTS(x) (sizeof (x) / sizeof ((x)[0]))

typedef struct {
    float p;
    char c;
} aminoacid_t;

static inline float myrandom (float max) { 
    unsigned long const IM = 139968;
    unsigned long const IA = 3877;
    unsigned long const IC = 29573;
    static unsigned long last = 42; 
    last = (last * IA + IC) % IM; 
    /*Integer to float conversions are faster if the integer is signed*/
    return max * (long) last / IM; 
} 

static inline void accumulate_probabilities (aminoacid_t *genelist, size_t len) {
    float cp = 0.0;
    size_t i;
    for (i = 0; i < len; i++) {
        cp += genelist[i].p;
        genelist[i].p = cp;
    }
}

/* This function prints the characters of the string s. When it */
/* reaches the end of the string, it goes back to the beginning */
/* It stops when the total number of characters printed is count. */
/* Between each WIDTH consecutive characters it prints a newline */
/* This function assumes that WIDTH <= strlen (s) + 1 */
static void repeat_fasta (char const *s, size_t count) {
    size_t pos = 0;  
    size_t len = strlen (s); 
    char *s2 = malloc (len + WIDTH);
    memcpy (s2, s, len); 
    memcpy (s2 + len, s, WIDTH); 
    do {   
     	size_t line = MIN(WIDTH, count); 
     	fwrite_unlocked (s2 + pos,1,line,stdout); 
     	putchar_unlocked ('\n'); 
     	pos += line; 
     	if (pos >= len) pos -= len; 
     	count -= line;  
    } while (count); 
    free (s2); 
}

/* This function takes a pointer to the first element of an array */
/* Each element of the array is a struct with a character and */
/* a float number p between 0 and 1. */
/* The function generates a random float number r and */
/* finds the first array element such that p >= r. */
/* This is a weighted random selection. */
/* The function then prints the character of the array element. */
/* This is done count times. */
/* Between each WIDTH consecutive characters, the function prints a newline */
static void random_fasta (aminoacid_t const *genelist, size_t count) {
    do {    
	size_t line = MIN(WIDTH, count);    
	size_t pos = 0;    
	char buf[WIDTH + 1];    
	do {    
	    float r = myrandom (1.0);
	    size_t i = 0;   
	    while (genelist[i].p < r)    
		++i; /* Linear search */    
	    buf[pos++] = genelist[i].c;    
	} while (pos < line);   
	buf[line] = '\n';
	fwrite_unlocked (buf, 1, line + 1, stdout);    
	count -= line;    
    } while (count);   
}

int main (int argc, char **argv) {
    size_t n;
    if (argc > 1) { 
	char const *arg = argv[1];
 	char *tail; 
 	n = strtoul (arg, &tail, 0); 
 	if (tail == arg)  
	    errx (1, "Could not convert \"%s\" to an unsigned long integer", arg); 
    } else n = 1000;

    static aminoacid_t iub[] = {
	{ 0.27, 'a' },
	{ 0.12, 'c' },
	{ 0.12, 'g' },
	{ 0.27, 't' },
	{ 0.02, 'B' },
	{ 0.02, 'D' },
	{ 0.02, 'H' },
	{ 0.02, 'K' },
	{ 0.02, 'M' },
	{ 0.02, 'N' },
	{ 0.02, 'R' },
	{ 0.02, 'S' },
	{ 0.02, 'V' },
	{ 0.02, 'W' },
	{ 0.02, 'Y' }};

    static aminoacid_t homosapiens[] = {
	{ 0.3029549426680, 'a' },
	{ 0.1979883004921, 'c' },
	{ 0.1975473066391, 'g' },
	{ 0.3015094502008, 't' }};

    accumulate_probabilities (iub, NELEMENTS(iub)); 
    accumulate_probabilities (homosapiens, NELEMENTS(homosapiens));

    static char const *const alu ="\
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\
GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\
CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\
ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\
GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\
AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\
AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

    fputs_unlocked (">ONE Homo sapiens alu\n", stdout);
    repeat_fasta (alu, 2 * n);
    fputs_unlocked (">TWO IUB ambiguity codes\n", stdout);
    random_fasta (iub, 3 * n);
    fputs_unlocked (">THREE Homo sapiens frequency\n", stdout);
    random_fasta (homosapiens, 5 * n);
    return 0;
}
/* -*- mode: c -*-
 * $Id: fibo.gcc,v 1.6 2005-04-25 19:01:38 igouy-guest Exp $
 * http://shootout.alioth.debian.org/
 * Revised with register allocation by David Bronaugh
 */

#include <stdio.h>
#include <stdlib.h>

static unsigned long
fib(unsigned long n) {
    return( (n < 2) ? 1 : (fib(n-2) + fib(n-1)) );
}

int
main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%ld\n", fib(N));
    return(0);
}
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Greg Buchholz 
   Optimized by Paul Hsieh
   compile:  gcc -O2 -o harmonic harmonic.c
*/
#include<stdio.h>
#include<stdlib.h>

int main (int argc, char **argv)
{
    double i=1, sum=0;
    int n;

    for(n = atoi(argv[1]); n > 0; n--, i++)
        sum += 1/i;

    printf("%.9f\n", sum);
    return 0;
}

/* -*- mode: c -*-
 * $Id: hash.gcc,v 1.1 2004-05-19 18:09:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "../../Include/simple_hash.h"

int main(int argc, char *argv[]) {
    int i, c=0, n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[32];
	
    struct ht_ht *ht = ht_create(n);
    
    for (i=1; i<=n; i++) {
	sprintf(buf, "%x", i);
	(ht_find_new(ht, buf))->val = i;
    }

    for (i=n; i>0; i--) {
	sprintf(buf, "%d", i);
	if (ht_find(ht, buf)) c++;
    }

    ht_destroy(ht);

    printf("%d\n", c);
    return(0);
}
/* -*- mode: c -*-
 * $Id: hash2.gcc,v 1.1 2004-05-19 18:10:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "../../Include/simple_hash.h"

int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[32];
    struct ht_ht *ht1 = ht_create(10000);
    struct ht_ht *ht2 = ht_create(10000);
    struct ht_node *node;

    for (i=0; i<=9999; ++i) {
	sprintf(buf, "foo_%d", i);
	ht_find_new(ht1, buf)->val = i;
    }

    for (i=0; i<n; ++i) {
	for (node=ht_first(ht1); node; node=ht_next(ht1)) {
	    ht_find_new(ht2, node->key)->val += node->val;
	}
    }

    printf("%d %d %d %d\n",
	   (ht_find(ht1, "foo_1"))->val,
	   (ht_find(ht1, "foo_9999"))->val,
	   (ht_find(ht2, "foo_1"))->val,
	   (ht_find(ht2, "foo_9999"))->val);

    ht_destroy(ht1);
    ht_destroy(ht2);
    return(0);
}
/* -*- mode: c -*-
 * $Id: heapsort.gcc,v 1.1 2004-05-19 18:10:08 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>

#define IM 139968
#define IA   3877
#define IC  29573

double
gen_random(double max) {
    static long last = 42;
    return( max * (last = (last * IA + IC) % IM) / IM );
}

void
heapsort(int n, double *ra) {
    int i, j;
    int ir = n;
    int l = (n >> 1) + 1;
    double rra;

    for (;;) {
	if (l > 1) {
	    rra = ra[--l];
	} else {
	    rra = ra[ir];
	    ra[ir] = ra[1];
	    if (--ir == 1) {
		ra[1] = rra;
		return;
	    }
	}
	i = l;
	j = l << 1;
	while (j <= ir) {
	    if (j < ir && ra[j] < ra[j+1]) { ++j; }
	    if (rra < ra[j]) {
		ra[i] = ra[j];
		j += (i = j);
	    } else {
		j = ir + 1;
	    }
	}
	ra[i] = rra;
    }
}

int
main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    double *ary;
    int i;
    
    /* create an array of N random doubles */
    ary = (double *)malloc((N+1) * sizeof(double));
    for (i=1; i<=N; i++) {
	ary[i] = gen_random(1);
    }

    heapsort(N, ary);

    printf("%.10f\n", ary[N]);

    free(ary);
    return(0);
}

/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * contributed by Joe Tucek 2008-03-29 
 * Clearly printf is worse than fputs, which is worse than write...
 */

#include <unistd.h>

int main() {
  write(1, "hello world\n", 12);
  return(0);
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * contributed by Joe Tucek 2008-03-31
 *
 * Tell GCC that we don't want atexit, we don't want to use the heap,
 * and we really don't want anything.  Can't even call write the "normal"
 * way, because write() isn't linked in....
 *
 * Compile flags are picky for this.  I used:
 * gcc -pipe -Wall -O3 -fomit-frame-pointer -march=pentium4 -ffreestanding -nostartfiles -s -static -o start3 start3.c
 */

#include <sys/syscall.h>
#include <unistd.h>

int _start() {
  syscall(__NR_write, 1, "hello world\n", 12);
  syscall(__NR_exit, 0);
  return(0);
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
 
   Based on bit encoding idea of C++ contribution of Andrew Moon
   Copy task division idea from Java entry, contributed by James McIlree
   Contributed by Petr Prokhorenkov
*/

//#include "simple_hash3.h"

#include <ctype.h>
#include <malloc.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#define HT_SIZE 1000000

typedef unsigned char uint8_t;

/* Thread pool implementation */

struct tp_entry {
    void *job;
    void *param;
};

struct tp {
    struct tp_entry *jobs;
    int capacity;
    int size;
    pthread_mutex_t mutex;
};

struct tp *
tp_create(int max_jobs) {
    struct tp *pool = malloc(sizeof(*pool));

    pool->jobs = malloc(sizeof(struct tp_entry)*max_jobs);
    pool->capacity = max_jobs;
    pool->size = 0;
    pthread_mutex_init(&pool->mutex, 0);

    return pool;
}

void
tp_destroy(struct tp *pool) {
    free(pool->jobs);
    pthread_mutex_destroy(&pool->mutex);
    free(pool);
}

void
tp_add_job(struct tp *pool, void *job, void *param) {
    if (pool->size < pool->capacity) {
        pool->jobs[pool->size].job = job;
        pool->jobs[pool->size].param = param;
        ++pool->size;
    }
}

void *
_tp_run(void *param) {
    struct tp *pool = param;

    for (;;) {
        void (*job)(void *) = 0;
        void *param = 0;

        pthread_mutex_lock(&pool->mutex);
        if (pool->size > 0) {
            job = pool->jobs[pool->size - 1].job;
            param = pool->jobs[pool->size - 1].param;
            --pool->size;
        }
        pthread_mutex_unlock(&pool->mutex);
        if (job == 0) {
            return 0;
        } else {
            job(param);
        }
    }
}

void
tp_run(struct tp *pool, int max_threads) {
    pthread_t threads[max_threads];
    for (int i = 0; i < max_threads; i++) {
        if (pthread_create(&threads[i], 0, &_tp_run, pool) < 0) {
            perror("pthread_create");
            exit(1);
        }
    }

    for (int i = 0; i < max_threads; i++) {
        pthread_join(threads[i], 0);
    }
}

void *
mmap_stdin(off_t *stdin_size) {
    void *result;

    struct stat stat;
    if (fstat(0, &stat) < 0) {
        perror("fstat");
        exit(1);
    }

    *stdin_size = stat.st_size;

    result = mmap(0, stat.st_size, PROT_READ, MAP_PRIVATE, 0, 0);
    if (result == (void *)-1) {
        perror("mmap");
        exit(1);
    }

    return result;
}

struct input_sequence {
    char *start;
    int length;
};

void
identify_input_sequence(char *stdin_mem, int stdin_size,
        struct input_sequence *seq) {
    char *p =  strchr(strstr(stdin_mem, ">THREE"), '\n');

    while (isalpha(*p++)) {
        ;
    }

    char *end = strchr(p, '>');

    seq->start = p;
    seq->length = end == 0 ? stdin_size + stdin_mem - p : end - p;
}

char *
get_sequence_start(char *stdin_mem) {
    char *p =  strchr(strstr(stdin_mem, ">THREE"), '\n');

    while (isalpha(*p++)) {
        ;
    }

    return p;
}

static
inline uint8_t
pack_symbol(char c) {
    switch (c) {
        case 'a':
        case 'A':
            return 0;
        case 'c':
        case 'C':
            return 1;
        case 'g':
        case 'G':
            return 2;
        case 't':
        case 'T':
            return 3;
    }
    fprintf(stderr, "Unexpected: %c\n", c);
    exit(-1);
}

char unpack_symbol(uint8_t c) {
    static char table[] = {'A', 'C', 'G', 'T'};
    
    return table[c];
}

static
inline char *
next_char(char *p) {
    do {
        ++p;
    } while (isspace(*p));

    return p;
}

static
inline uint64_t
push_char(uint64_t cur, uint8_t c) {
    return (cur << 2) + pack_symbol(c);
}

static
inline uint64_t
rotate_code(uint64_t cur, uint8_t c, int frame) {
    return push_char(cur, c) & ((1ull << 2*frame) - 1);
}

uint64_t
pack_key(char *key, int len) {
    uint64_t code = 0;
    for (int i = 0; i < len; i++) {
        code = push_char(code, *key);
        key = next_char(key);
    }

    return code;
}

void
unpack_key(uint64_t key, int length, char *buffer) {
    int i;

    for (i = 0; i < length; i++) {
        buffer[i] = unpack_symbol(key & 3);
        key >>= 2;
    }
    buffer[i] = 0;

    // Reverse string.
    for (int j = (i - 1)/2; j >= 0; j--) {
        char c = buffer[j];
        buffer[j] = buffer[i - 1 - j];
        buffer[i - 1 - j] = c;
    }
}

void
generate_seqences(char *start, int length, int frame, struct ht_ht *ht) {
    uint64_t code = 0;
    char *p = start;
    char *end = start + length;

    // Pull first frame.
    for (int i = 0; i < frame; i++) {
        code = push_char(code, *p);
        p = next_char(p);
    }
    ht_find_new(ht, code)->val++;

    while (*p != '>' && p != end) {
        code = rotate_code(code, *p, frame);
        ht_find_new(ht, code)->val++;
        p = next_char(p);
    }
}

int
key_count_cmp(const void *l, const void *r) {
    const struct ht_node *lhs = l, *rhs = r;

    if (lhs->val != rhs->val) {
        return rhs->val - lhs->val;
    } else {
        // Overflow is possible here,
        // so use comparisons instead of subtraction.
        if (lhs->key < rhs->key) {
            return -1;
        } else if (lhs->key > rhs->key) {
            return 1;
        } else {
            return 0;
        }
    }
}

struct print_freqs_param {
    struct input_sequence *seq;
    int frame;
    char *output;
    int output_size;
};

struct ht_node *
ht_values_as_vector(struct ht_ht *ht) {
    struct ht_node *v = malloc(ht->items*sizeof(struct ht_node));
    struct ht_node *n = ht_first(ht);

    for (int i = 0; i < ht->items; i++) {
        v[i] = *n;
        n = ht_next(ht);
    }

    return v;
}

void
print_freqs(struct print_freqs_param *param) {
    struct input_sequence *seq = param->seq;
    int frame = param->frame;
    char *output = param->output;
    int output_size = param->output_size;

    struct ht_ht *ht = ht_create(32);
    char buffer[frame + 1];
    int output_pos = 0;

    generate_seqences(seq->start, seq->length, frame, ht);
    
    struct ht_node *counts = ht_values_as_vector(ht);
    int size = ht->items;

    qsort(counts, size, sizeof(struct ht_node), &key_count_cmp);

    int total_count = 0;
    for (int i = 0; i < size; i++) {
        total_count += counts[i].val;
    }

    for (int i = 0; i < size; i++) {
        unpack_key(counts[i].key, frame, buffer);
        output_pos += snprintf(output + output_pos, output_size - output_pos,
                "%s %.3f\n", buffer, counts[i].val*100.0f/total_count);
    }

    free(counts);
    ht_destroy(ht);
}

struct print_occurences_param {
    struct input_sequence *seq;
    char *nuc_seq;
    char *output;
    int output_size;
};

void
print_occurences(struct print_occurences_param *param) {
    struct input_sequence *seq = param->seq;
    char *nuc_seq = param->nuc_seq;
    char *output = param->output;
    int output_size = param->output_size;
    int nuc_seq_len = strlen(nuc_seq);
    struct ht_ht *ht = ht_create(HT_SIZE);

    generate_seqences(seq->start, seq->length, nuc_seq_len, ht);

    uint64_t key = pack_key(nuc_seq, nuc_seq_len);
    int count = ht_find_new(ht, key)->val;
    snprintf(output, output_size, "%d\t%s\n", count, nuc_seq);
    
    ht_destroy(ht);
}

int
get_cpu_count(void) {
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    sched_getaffinity(0, sizeof(cpu_set), &cpu_set);

    return CPU_COUNT(&cpu_set);
}

#define MAX_OUTPUT 1024

int
main(void) {
    off_t stdin_size;
    char *stdin_mem = mmap_stdin(&stdin_size);
    struct input_sequence seq;
    int cpu_count = get_cpu_count();

    identify_input_sequence(stdin_mem, stdin_size, &seq);

    char output_buffer[7][MAX_OUTPUT];

#   define DECLARE_PARAM(o, n) {\
    .seq = &seq,\
    .frame = n,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_freqs_param freq_params[2] = {
        DECLARE_PARAM(0, 1),
        DECLARE_PARAM(1, 2)
    }; 

#   undef DECLARE_PARAM

#   define DECLARE_PARAM(o, s) {\
    .seq = &seq,\
    .nuc_seq = s,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_occurences_param occurences_params[5] = {
        DECLARE_PARAM(2, "GGT"),
        DECLARE_PARAM(3, "GGTA"),
        DECLARE_PARAM(4, "GGTATT"),
        DECLARE_PARAM(5, "GGTATTTTAATT"),
        DECLARE_PARAM(6, "GGTATTTTAATTTATAGT")
    };

#   undef DECLARE_PARAM

    struct tp *tp = tp_create(7);

    for (int i = 0 ; i < 2; i++) {
        tp_add_job(tp, &print_freqs, &freq_params[i]);
    }
    for (int i = 0 ;i <  5; i++) {
        tp_add_job(tp, &print_occurences, &occurences_params[i]);
    }

    tp_run(tp, cpu_count + 1);

    tp_destroy(tp);

    for (int i = 0; i < 2; i++) {
        printf("%s\n", output_buffer[i]);
    }
    for (int i = 2; i < 7; i++) {
        printf("%s", output_buffer[i]);
    }

    if (munmap(stdin_mem, stdin_size) < 0) {
        perror("munmap");
        return 1;
    }

    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
 
   Based on bit encoding idea of C++ contribution of Andrew Moon
   Copy task division idea from Java entry, contributed by James McIlree
   Contributed by Petr Prokhorenkov
*/

//#include "simple_hash3.h"

#include <ctype.h>
#include <malloc.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#define HT_SIZE 2000000

typedef unsigned char uint8_t;

/* Thread pool implementation */

struct tp_entry {
    void *job;
    void *param;
};

struct tp {
    struct tp_entry *jobs;
    int capacity;
    int size;
    pthread_mutex_t mutex;
};

struct tp *
tp_create(int max_jobs) {
    struct tp *pool = malloc(sizeof(*pool));

    pool->jobs = malloc(sizeof(struct tp_entry)*max_jobs);
    pool->capacity = max_jobs;
    pool->size = 0;
    pthread_mutex_init(&pool->mutex, 0);

    return pool;
}

void
tp_destroy(struct tp *pool) {
    free(pool->jobs);
    pthread_mutex_destroy(&pool->mutex);
    free(pool);
}

void
tp_add_job(struct tp *pool, void *job, void *param) {
    if (pool->size < pool->capacity) {
        pool->jobs[pool->size].job = job;
        pool->jobs[pool->size].param = param;
        ++pool->size;
    }
}

void *
_tp_run(void *param) {
    struct tp *pool = param;

    for (;;) {
        void (*job)(void *) = 0;
        void *param = 0;

        pthread_mutex_lock(&pool->mutex);
        if (pool->size > 0) {
            job = pool->jobs[pool->size - 1].job;
            param = pool->jobs[pool->size - 1].param;
            --pool->size;
        }
        pthread_mutex_unlock(&pool->mutex);
        if (job == 0) {
            return 0;
        } else {
            job(param);
        }
    }
}

void
tp_run(struct tp *pool, int max_threads) {
    pthread_t threads[max_threads];
    for (int i = 0; i < max_threads; i++) {
        if (pthread_create(&threads[i], 0, &_tp_run, pool) < 0) {
            perror("pthread_create");
            exit(1);
        }
    }

    for (int i = 0; i < max_threads; i++) {
        pthread_join(threads[i], 0);
    }
}

char *
read_stdin(int *stdin_size) {
    struct stat stat;
    if (fstat(0, &stat) < 0) {
        perror("fstat");
        exit(1);
    }

    char *result = malloc(stat.st_size);

    do {
        fgets_unlocked(result, stat.st_size, stdin);
    } while (strncmp(result, ">THREE", 6));

    int read = 0;
    while (fgets_unlocked(result + read, stat.st_size - read, stdin)) {
        int len = strlen(result + read);
        if (len == 0 || result[read] == '>') {
            break;
        }
        read += len;
        if (result[read - 1] == '\n') {
            read--;
        }
    }

    result[read++] = '>';
    result = realloc(result, read);
    *stdin_size = read;

    return result;
}

static
inline uint8_t
pack_symbol(char c) {
    switch (c) {
        case 'a':
        case 'A':
            return 0;
        case 'c':
        case 'C':
            return 1;
        case 'g':
        case 'G':
            return 2;
        case 't':
        case 'T':
            return 3;
    }
    fprintf(stderr, "Unexpected: %c\n", c);
    exit(-1);
}

char unpack_symbol(uint8_t c) {
    static char table[] = {'A', 'C', 'G', 'T'};
    
    return table[c];
}

static
inline char *
next_char(char *p) {
    do {
        ++p;
    } while (isspace(*p));

    return p;
}

static
inline uint64_t
push_char(uint64_t cur, uint8_t c) {
    return (cur << 2) + pack_symbol(c);
}

static
inline uint64_t
rotate_code(uint64_t cur, uint8_t c, int frame) {
    return push_char(cur, c) & ((1ull << 2*frame) - 1);
}

uint64_t
pack_key(char *key, int len) {
    uint64_t code = 0;
    for (int i = 0; i < len; i++) {
        code = push_char(code, *key);
        key = next_char(key);
    }

    return code;
}

void
unpack_key(uint64_t key, int length, char *buffer) {
    int i;

    for (i = 0; i < length; i++) {
        buffer[i] = unpack_symbol(key & 3);
        key >>= 2;
    }
    buffer[i] = 0;

    // Reverse string.
    for (int j = (i - 1)/2; j >= 0; j--) {
        char c = buffer[j];
        buffer[j] = buffer[i - 1 - j];
        buffer[i - 1 - j] = c;
    }
}

void
generate_seqences(char *start, int length, int frame, struct ht_ht *ht) {
    uint64_t code = 0;
    char *p = start;
    char *end = start + length;

    // Pull first frame.
    for (int i = 0; i < frame; i++) {
        code = push_char(code, *p);
        p = next_char(p);
    }
    ht_find_new(ht, code)->val++;

    while (*p != '>' && p < end) {
        code = rotate_code(code, *p, frame);
        ht_find_new(ht, code)->val++;
        p = next_char(p);
    }
}

int
key_count_cmp(const void *l, const void *r) {
    const struct ht_node *lhs = l, *rhs = r;

    if (lhs->val != rhs->val) {
        return rhs->val - lhs->val;
    } else {
        // Overflow is possible here,
        // so use comparisons instead of subtraction.
        if (lhs->key < rhs->key) {
            return -1;
        } else if (lhs->key > rhs->key) {
            return 1;
        } else {
            return 0;
        }
    }
}

struct print_freqs_param {
    char *start;
    int length;
    int frame;
    char *output;
    int output_size;
};

struct ht_node *
ht_values_as_vector(struct ht_ht *ht) {
    struct ht_node *v = malloc(ht->items*sizeof(struct ht_node));
    struct ht_node *n = ht_first(ht);

    for (int i = 0; i < ht->items; i++) {
        v[i] = *n;
        n = ht_next(ht);
    }

    return v;
}

void
print_freqs(struct print_freqs_param *param) {
    char *start = param->start;
    int length = param->length;
    int frame = param->frame;
    char *output = param->output;
    int output_size = param->output_size;

    struct ht_ht *ht = ht_create(32);
    char buffer[frame + 1];
    int output_pos = 0;

    generate_seqences(start, length, frame, ht);
    
    struct ht_node *counts = ht_values_as_vector(ht);
    int size = ht->items;

    qsort(counts, size, sizeof(struct ht_node), &key_count_cmp);

    int total_count = 0;
    for (int i = 0; i < size; i++) {
        total_count += counts[i].val;
    }

    for (int i = 0; i < size; i++) {
        unpack_key(counts[i].key, frame, buffer);
        output_pos += snprintf(output + output_pos, output_size - output_pos,
                "%s %.3f\n", buffer, counts[i].val*100.0f/total_count);
    }

    free(counts);
    ht_destroy(ht);
}

struct print_occurences_param {
    char *start;
    int length;
    char *nuc_seq;
    char *output;
    int output_size;
};

void
print_occurences(struct print_occurences_param *param) {
    char *start = param->start;
    int length = param->length;
    char *nuc_seq = param->nuc_seq;
    char *output = param->output;
    int output_size = param->output_size;
    int nuc_seq_len = strlen(nuc_seq);
    struct ht_ht *ht = ht_create(HT_SIZE);

    generate_seqences(start, length, nuc_seq_len, ht);

    uint64_t key = pack_key(nuc_seq, nuc_seq_len);
    int count = ht_find_new(ht, key)->val;
    snprintf(output, output_size, "%d\t%s\n", count, nuc_seq);
    
    ht_destroy(ht);
}

int
get_cpu_count(void) {
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    sched_getaffinity(0, sizeof(cpu_set), &cpu_set);

    return CPU_COUNT(&cpu_set);
}

#define MAX_OUTPUT 1024

int
main(void) {
    int stdin_size;
    char *stdin_mem = read_stdin(&stdin_size);
    int cpu_count = get_cpu_count();

    char output_buffer[7][MAX_OUTPUT];

#   define DECLARE_PARAM(o, n) {\
    .start = stdin_mem, \
    .length = stdin_size, \
    .frame = n,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_freqs_param freq_params[2] = {
        DECLARE_PARAM(0, 1),
        DECLARE_PARAM(1, 2)
    }; 

#   undef DECLARE_PARAM

#   define DECLARE_PARAM(o, s) {\
    .start = stdin_mem, \
    .length = stdin_size, \
    .nuc_seq = s,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_occurences_param occurences_params[5] = {
        DECLARE_PARAM(2, "GGT"),
        DECLARE_PARAM(3, "GGTA"),
        DECLARE_PARAM(4, "GGTATT"),
        DECLARE_PARAM(5, "GGTATTTTAATT"),
        DECLARE_PARAM(6, "GGTATTTTAATTTATAGT")
    };

#   undef DECLARE_PARAM

    struct tp *tp = tp_create(7);

    for (int i = 0 ; i < 2; i++) {
        tp_add_job(tp, &print_freqs, &freq_params[i]);
    }
    for (int i = 0 ;i <  5; i++) {
        tp_add_job(tp, &print_occurences, &occurences_params[i]);
    }

    tp_run(tp, cpu_count + 1);

    tp_destroy(tp);

    for (int i = 0; i < 2; i++) {
        printf("%s\n", output_buffer[i]);
    }
    for (int i = 2; i < 7; i++) {
        printf("%s", output_buffer[i]);
    }

    free(stdin_mem);

    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
 
   Based on bit encoding idea of C++ contribution of Andrew Moon
   Copy task division idea from Java entry, contributed by James McIlree
   Contributed by Petr Prokhorenkov
   Modified by Stefano Guidoni
*/

//#include "simple_hash3.h"

#include <ctype.h>
#include <malloc.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#define HT_SIZE 2000000

typedef unsigned char uint8_t;
const uint8_t selector[] = { -1, 0,-1, 1, 3,-1,-1, 2 };
const char table[] = {'A', 'C', 'G', 'T'};

/* this is sligthly faster
struct ht_node *
ht_find_new(struct ht_ht *ht, ui64 key) 
{
    int hash_code = ht_hashcode(ht, key);
    struct ht_node *node = ht->tbl[hash_code];
    
    if (node) 
    {
      if (key == node->key)
          return(node);
    } else {
      ht->items++;
      return(ht->tbl[hash_code] = ht_node_create(key));
    }
    
    while (node->next) 
    {
        if (key == node->next->key)
            return(node->next);
        node = node->next;
    }

    ht->items++;
    return (node->next = ht_node_create(key));
}*/

/* Thread pool implementation */

struct tp_entry {
    void *job;
    void *param;
};

struct tp {
    struct tp_entry *jobs;
    int capacity;
    int size;
    pthread_mutex_t mutex;
};

struct tp *
tp_create(int max_jobs) {
    struct tp *pool = malloc(sizeof(*pool));

    pool->jobs = malloc(sizeof(struct tp_entry)*max_jobs);
    pool->capacity = max_jobs;
    pool->size = 0;
    pthread_mutex_init(&pool->mutex, 0);

    return pool;
}

void
tp_destroy(struct tp *pool) {
    free(pool->jobs);
    pthread_mutex_destroy(&pool->mutex);
    free(pool);
}

void
tp_add_job(struct tp *pool, void *job, void *param) {
    if (pool->size < pool->capacity) {
        pool->jobs[pool->size].job = job;
        pool->jobs[pool->size].param = param;
        ++pool->size;
    }
}

void *
_tp_run(void *param) {
    struct tp *pool = param;

    for (;;) {
        void (*job)(void *) = 0;
        void *param = 0;

        pthread_mutex_lock(&pool->mutex);
        if (pool->size > 0) {
            job = pool->jobs[pool->size - 1].job;
            param = pool->jobs[pool->size - 1].param;
            --pool->size;
        }
        pthread_mutex_unlock(&pool->mutex);
        if (job == 0) {
            return 0;
        } else {
            job(param);
        }
    }
}

void
tp_run(struct tp *pool, int max_threads) {
    pthread_t threads[max_threads];
    for (int i = 0; i < max_threads; i++) {
        pthread_create(&threads[i], 0, &_tp_run, pool);
    }

    for (int i = 0; i < max_threads; i++) {
        pthread_join(threads[i], 0);
    }
}

char *
read_stdin(int *stdin_size) {
    struct stat stat;
    fstat(0, &stat);

    char *result = malloc(stat.st_size);

    do {
        fgets_unlocked(result, stat.st_size, stdin);
    } while (strncmp(result, ">THREE", 6));

    int read = 0;
    while (fgets_unlocked(result + read, stat.st_size - read, stdin)) {
        int len = strlen(result + read);
        if (len == 0 || result[read] == '>') {
            break;
        }
        read += len;
        if (result[read - 1] == '\n') {
            read--;
        }
    }

    result[read++] = '>';
    result = realloc(result, read);
    *stdin_size = read;

    return result;
}

static
inline char *
next_char(char *p) {
    do {
        ++p;
    } while (isspace(*p));

    return p;
}

inline uint64_t
push_char(uint64_t cur, uint8_t c) {
    return (cur << 2) + selector[(c & 7)];
}

uint64_t
pack_key(char *key, int len) {
    uint64_t code = 0;
    for (int i = 0; i < len; i++) {
        code = push_char(code, *key);
        key = next_char(key);
    }

    return code;
}

void
unpack_key(uint64_t key, int length, char *buffer) {
    int i;

    for (i = length - 1; i > -1; i--) {
        buffer[i] = table[key & 3];
        key >>= 2;
    }
    buffer[length] = 0;
}

void
generate_seqences(char *start, int length, int frame, struct ht_ht *ht) {
    uint64_t code = 0;
    uint64_t mask = (1ull << 2*frame) - 1;
    char *p = start;
    char *end = start + length;

    // Pull first frame.
    for (int i = 0; i < frame; i++) {
        code = push_char(code, *p);
        ++p;
    }
    ht_find_new(ht, code)->val++;

    while (p < end) {
        code = push_char(code, *p) & mask;
        ht_find_new(ht, code)->val++;
        ++p;
        if (*p & 8) {
            if (*p & 1) {
                ++p;
            } else
                break;
        }
    }
}

int
key_count_cmp(const void *l, const void *r) {
    const struct ht_node *lhs = l, *rhs = r;

    if (lhs->val != rhs->val) {
        return rhs->val - lhs->val;
    } else {
        // Overflow is possible here,
        // so use comparisons instead of subtraction.
        if (lhs->key < rhs->key) {
            return -1;
        } else if (lhs->key > rhs->key) {
            return 1;
        } else {
            return 0;
        }
    }
}

struct print_freqs_param {
    char *start;
    int length;
    int frame;
    char *output;
    int output_size;
};

struct ht_node *
ht_values_as_vector(struct ht_ht *ht) {
    struct ht_node *v = malloc(ht->items*sizeof(struct ht_node));
    struct ht_node *n = ht_first(ht);

    for (int i = 0; i < ht->items; i++) {
        v[i] = *n;
        n = ht_next(ht);
    }

    return v;
}

void
print_freqs(struct print_freqs_param *param) {
    char *start = param->start;
    int length = param->length;
    int frame = param->frame;
    char *output = param->output;
    int output_size = param->output_size;

    struct ht_ht *ht = ht_create(32);
    char buffer[frame + 1];
    int output_pos = 0;

    generate_seqences(start, length, frame, ht);
    
    struct ht_node *counts = ht_values_as_vector(ht);
    int size = ht->items;

    qsort(counts, size, sizeof(struct ht_node), &key_count_cmp);

    int total_count = 0;
    for (int i = 0; i < size; i++) {
        total_count += counts[i].val;
    }

    for (int i = 0; i < size; i++) {
        unpack_key(counts[i].key, frame, buffer);
        output_pos += snprintf(output + output_pos, output_size - output_pos,
                "%s %.3f\n", buffer, counts[i].val*100.0f/total_count);
    }

    free(counts);
    ht_destroy(ht);
}

struct print_occurences_param {
    char *start;
    int length;
    char *nuc_seq;
    char *output;
    int output_size;
};

void
print_occurences(struct print_occurences_param *param) {
    char *start = param->start;
    int length = param->length;
    char *nuc_seq = param->nuc_seq;
    char *output = param->output;
    int output_size = param->output_size;
    int nuc_seq_len = strlen(nuc_seq);
    struct ht_ht *ht = ht_create(HT_SIZE);

    generate_seqences(start, length, nuc_seq_len, ht);

    uint64_t key = pack_key(nuc_seq, nuc_seq_len);
    int count = ht_find_new(ht, key)->val;
    snprintf(output, output_size, "%d\t%s\n", count, nuc_seq);
    
    ht_destroy(ht);
}

int
get_cpu_count(void) {
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    sched_getaffinity(0, sizeof(cpu_set), &cpu_set);

    return CPU_COUNT(&cpu_set);
}

#define MAX_OUTPUT 1024

int
main(void) {
    int stdin_size;
    char *stdin_mem = read_stdin(&stdin_size);
    int cpu_count = get_cpu_count();

    char output_buffer[7][MAX_OUTPUT];

#   define DECLARE_PARAM(o, n) {\
    .start = stdin_mem, \
    .length = stdin_size, \
    .frame = n,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_freqs_param freq_params[2] = {
        DECLARE_PARAM(0, 1),
        DECLARE_PARAM(1, 2)
    }; 

#   undef DECLARE_PARAM

#   define DECLARE_PARAM(o, s) {\
    .start = stdin_mem, \
    .length = stdin_size, \
    .nuc_seq = s,\
    .output = output_buffer[o],\
    .output_size = MAX_OUTPUT }

    struct print_occurences_param occurences_params[5] = {
        DECLARE_PARAM(2, "GGT"),
        DECLARE_PARAM(3, "GGTA"),
        DECLARE_PARAM(4, "GGTATT"),
        DECLARE_PARAM(5, "GGTATTTTAATT"),
        DECLARE_PARAM(6, "GGTATTTTAATTTATAGT")
    };

#   undef DECLARE_PARAM

    struct tp *tp = tp_create(7);

    for (int i = 0 ; i < 2; i++) {
        tp_add_job(tp, &print_freqs, &freq_params[i]);
    }
    for (int i = 0 ;i <  5; i++) {
        tp_add_job(tp, &print_occurences, &occurences_params[i]);
    }

    tp_run(tp, cpu_count + 1);

    tp_destroy(tp);

    for (int i = 0; i < 2; i++) {
        printf("%s\n", output_buffer[i]);
    }
    for (int i = 2; i < 7; i++) {
        printf("%s", output_buffer[i]);
    }

    free(stdin_mem);

    return 0;
}
 
/* -*- mode: c -*-
 * $Id: lists.gcc,v 1.1 2004-05-19 18:10:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SIZE 10000

// a simple Double Linked List
// the head node is special, it's val is length of list
typedef struct DLL {
    int val;
    struct DLL *next;	/* points to next or head (if at tail) */
    struct DLL *prev;	/* points to prev or tail (if at head) */
} DLL;

inline int list_length(DLL *head) { return(head->val); }
inline int list_empty(DLL *head) { return(list_length(head) == 0); }
inline DLL *list_first(DLL *head) { return(head->next); }
inline DLL *list_last(DLL *head) { return(head->prev); }

void list_push_tail(DLL *head, DLL *item) {
    DLL *tail = head->prev;
    tail->next = item;
    item->next = head;
    head->prev = item;
    item->prev = tail;
    head->val++;
}

DLL *list_pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (list_empty(head)) return(NULL);
    tail = head->prev;
    prev = tail->prev;
    prev->next = head;
    head->prev = prev;
    head->val--;
    return(tail);
}

void list_push_head(DLL *head, DLL *item) {
    DLL *next = head->next;
    head->next = item;
    next->prev = item;
    item->next = next;
    item->prev = head;
    head->val++;
}

DLL *list_pop_head(DLL *head) {
    DLL *next;
    if (list_empty(head)) return(NULL);
    next = head->next;
    head->next = next->next;
    next->next->prev = head;
    head->val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp->next != x; xp=xp->next, yp=yp->next) {
	if (xp->val != yp->val) return(0);
    }
    if (xp->val != yp->val) return(0);
    return(yp->next == y);
}

void list_print(char *msg, DLL *x) {
    DLL *xp, *first = x->next;
    int i = 0;
    fputs(msg, stdout);
    printf("length: %d\n", list_length(x));
    for (xp=x->next; xp->next != first; xp=xp->next) {
	printf("i:%3d  v:%3d  n:%3d  p:%3d\n", ++i,
	       xp->val, xp->next->val, xp->prev->val);
    }
    printf("[last entry points to list head]\n");
    printf("[val of next of tail is:  %d]\n", xp->next->val);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l->next = l;
    l->prev = l;
    l->val = 0;
    return(l);
}

/* inclusive sequence 'from' <-> 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from > to) {
	tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i<size; ++i, ++j) {
	l[i].next = &l[i+1];
	l[j].prev = &l[j-1];
	l[i].val = from++;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].prev = &l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *list_copy(DLL *x) {
    int i, j, size = list_length(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i<size; i++, j++, xp=xp->next) {
	l[i].next = &l[j];
	l[j].prev = &l[i];
	l[i].val = xp->val;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].val = list_last(x)->val;
    return(l);
}

void list_reverse (DLL *head) {
    DLL *tmp, *p = head;
    do {
	tmp = p->next;
	p->next = p->prev;
	p->prev = tmp;
	p = tmp;
    } while (p != head);
}

int test_lists() {
    int len = 0;
    // create a list of integers (li1) from 1 to SIZE
    DLL *li1 = list_sequence(1, SIZE);
    // copy the list to li2
    DLL *li2 = list_copy(li1);
    // remove each individual item from left side of li2 and
    // append to right side of li3 (preserving order)
    DLL *li3 = list_new();
    // compare li2 and li1 for equality
    if (!list_equal(li2, li1)) {
	fprintf(stderr, "li2 and li1 are not equal\n");
	exit(1);
    }
    while (!list_empty(li2)) {
	list_push_tail(li3, list_pop_head(li2));
    }
    // li2 must now be empty
    if (!list_empty(li2)) {
	fprintf(stderr, "li2 should be empty now\n");
	exit(1);
    }
    // remove each individual item from right side of li3 and
    // append to right side of li2 (reversing list)
    while (!list_empty(li3)) {
	list_push_tail(li2, list_pop_tail(li3));
    }
    // li3 must now be empty
    if (!list_empty(li3)) {
	fprintf(stderr, "li3 should be empty now\n");
	exit(1);
    }
    // reverse li1 in place
    list_reverse(li1);
    // check that li1's first item is now SIZE
    if (list_first(li1)->val != SIZE) {
	fprintf(stderr, "li1 first value wrong, wanted %d, got %d\n",
		SIZE, list_first(li1)->val);
	exit(1);
    }
    // check that li1's last item is now 1
    if (list_last(li1)->val != 1) {
	fprintf(stderr, "last value wrong, wanted %d, got %d\n",
		SIZE, list_last(li1)->val);
	exit(1);
    }
    // check that li2's first item is now SIZE
    if (list_first(li2)->val != SIZE) {
	fprintf(stderr, "li2 first value wrong, wanted %d, got %d\n",
		SIZE, list_first(li2)->val);
	exit(1);
    }
    // check that li2's last item is now 1
    if (list_last(li2)->val != 1) {
	fprintf(stderr, "last value wrong, wanted %d, got %d\n",
		SIZE, list_last(li2)->val);
	exit(1);
    }
    // check that li1's length is still SIZE
    if (list_length(li1) != SIZE) {
	fprintf(stderr, "li1 size wrong, wanted %d, got %d\n",
		SIZE, list_length(li1));
	exit(1);
    }
    // compare li1 and li2 for equality
    if (!list_equal(li1, li2)) {
	fprintf(stderr, "li1 and li2 are not equal\n");
	exit(1);
    }
    len = list_length(li1);
    free(li1);
    free(li2);
    free(li3);
    // return the length of the list
    return(len);
}

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int result = 0;
    while(n--) result = test_lists();
    printf("%d\n", result);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
 
   contributed contributed by Charlie Brej
 */

#include <stdio.h>
#include <stdlib.h>

int n=0;
int mn=0;

typedef struct FfmCache {
    int x;
    int y;
    int pm_count;
    int pm[];
    }FfmCache, *PtrFfmCache;

typedef struct Square {
    struct Square* next;
    PtrFfmCache ffm;
    int priority;
    int *grid;
    int *unused;
    }Square, *PtrSquare;


  
void SquarePrint(PtrSquare square)
{
    int x;
    int y;
    for (y=0; y<n; y++){
        for (x=0; x<n; x++){
            printf("%d ", square->grid[x+y*n]);
            }
        printf("\n");
        }
    return;
}


    
PtrSquare SquareNew(void)
{
    PtrSquare new_square = malloc(sizeof(Square));
    new_square->grid = malloc(n * n * sizeof(int));
    new_square->unused = malloc(n * n * sizeof(int));
    new_square->next=NULL;
    new_square->ffm=NULL;
    new_square->priority=0;
    return new_square;
}

PtrSquare SquareNewEmpty(void)
{
    int i;
    PtrSquare new_square = SquareNew();
    for (i=0; i<n*n; i++){
        new_square->grid[i]=0;
        new_square->unused[i]=1;
        }
    return new_square;
}


PtrSquare SquareNewCopy(PtrSquare old_square)
{
    int i;
    PtrSquare new_square = SquareNew();
    for (i=0; i<n*n; i++){
        new_square->grid[i]=old_square->grid[i];
        new_square->unused[i]=old_square->unused[i];
        }
    return new_square;
}
    
void SquareFree(PtrSquare square)
{
    free(square->ffm);
    free(square->unused);
    free(square);
    return ;
}
   
void SquareGetRow(PtrSquare square, int row, int* out_array)
{
 int i;
 for (i=0; i<n; i++){
    out_array[i] = square->grid[row*n+i];
    }
}
    
void SquareGetColumn(PtrSquare square, int column, int* out_array)
{
 int i;
 for (i=0; i<n; i++){
    out_array[i] = square->grid[n*i+column];
    }
}
    
int IntArraySum(int* data)
{
 int i;
 int sum = 0;
 for (i=0; i<n; i++){
    sum += data[i];
    }
 return sum;
}

int IntArrayCount0s(int* data)
{
 int i;
 int count = 0;
 for (i=0; i<n; i++)
    if(data[i]==0)
        count++;
 return count;
}

int SquareNumberPresent(PtrSquare square, int number)
{
    int i;
    for (i=0; i<n*n; i++){
        if (square->grid[i] == number) return 1;
        }
    return 0;
}

int SquareEmptyCount(PtrSquare square)
{
    int i;
    int count=0;
    for (i=0; i<n*n; i++){
        if (square->grid[i] == 0) count++;
        }
    return count;
}

void SquareGetPossibleMoves(PtrSquare square, int x, int y, int* ret_pm, int* ret_pm_count)
{
    int cell_groups[4][n];
    int cell_group_count=2;
    int group;
    int i, i2;
    int cur_acc;
    int highest_candidate = n*n;
    int lowest_candidate = 1;
    
    int one_possible = 0;
    
    
    SquareGetRow(square, y, cell_groups[0]);
    SquareGetColumn(square, x, cell_groups[1]);
    
    *ret_pm_count = 0;
    if (x==y) {
        for (i=0; i<n; i++)
            cell_groups[cell_group_count][i] = square->grid[n*i+i];
        cell_group_count++;
        }
    if (x + y == n - 1) {
        for (i=0; i<n; i++)
            cell_groups[cell_group_count][i] = square->grid[i + (n - 1 - i) * n];
        cell_group_count++;
        }
    
    for (group=0; group<cell_group_count; group++){
        int count = 0;
        for (i=0; i<n; i++){
            if (cell_groups[group][i] == 0){
                if (count++) break;
                }
            }
        if (count==1){
            int new_one_possible = mn - IntArraySum(cell_groups[group]);
            if (one_possible==0){
                one_possible = new_one_possible;
                if (one_possible<1 || one_possible>n*n || SquareNumberPresent(square, one_possible)) return;
                }
            if (one_possible != new_one_possible) return;
            }
        }
    if (one_possible){
        ret_pm[0] = one_possible;
        *ret_pm_count = 1;
        return;
        }
    
    
    int local_pm_count = 0;
    int zeros[cell_group_count];
    int highest_zero_count=0;
    for (i=0; i<cell_group_count; i++){
        int zero_count = IntArrayCount0s(cell_groups[i])-1;
        zeros[i] = zero_count;
        if (highest_zero_count < zero_count) highest_zero_count = zero_count;
        }
    
    int lows[highest_zero_count];
    int higs[highest_zero_count];
    
    i2=0;
    cur_acc=0;
    for (i=0; i2<highest_zero_count; i++){
        if(square->unused[i]){
            cur_acc+=(i+1);
            lows[i2]=cur_acc;
            i2++;
            }
        }
    
    i2=0;
    cur_acc=0;
    for (i=n*n-1; i2<highest_zero_count; i--){
        if(square->unused[i]){
            cur_acc+=(i+1);
            higs[i2]=cur_acc;
            i2++;
            }
        }
    
    for (group=0; group<cell_group_count; group++){
        int lft = mn - IntArraySum(cell_groups[group]);
        int k = zeros[group];
        int temp_highest_candidate = lft - lows[k-1];
        int temp_lowest_candidate = lft - higs[k-1];
        if (temp_highest_candidate<highest_candidate) highest_candidate = temp_highest_candidate;
        if (temp_lowest_candidate>lowest_candidate)   lowest_candidate =  temp_lowest_candidate;
        }
    
    for (i=lowest_candidate; i<=highest_candidate; i++){
        if(square->unused[i-1]){
            ret_pm[local_pm_count++]=i;
            
            }
            
        }
    
        
    *ret_pm_count = local_pm_count;
    return;
    
    
}


PtrFfmCache SquareGetFewestMoves(PtrSquare square)
{
    int x,y;
    int i;
    if (square->ffm){
        return square->ffm;
        }
    square->ffm = malloc(sizeof(FfmCache)+sizeof(int)*n*n);
    square->ffm->pm_count=n*n+1;
    
    for (y=0; y<n; y++)
        for (x=0; x<n; x++){
            int index = x + y * n;
            if (square->grid[index] == 0){
                int temp_list[n*n];
                int temp_list_count;
                SquareGetPossibleMoves(square,x,y,temp_list,&temp_list_count);
                if (temp_list_count<square->ffm->pm_count){
                    square->ffm->pm_count = temp_list_count;
                    square->ffm->x = x;
                    square->ffm->y = y;
                    for (i=0; i<square->ffm->pm_count; i++) square->ffm->pm[i] = temp_list[i];
                    }
                }
            }
    
    
    if (square->ffm->pm_count>n*n) square->ffm->pm_count=0;
    return square->ffm;
    
    
}

   
int SquareGetPriority(PtrSquare square)
{
    int priority;
    if (square->priority) return square->priority;
    PtrFfmCache ffm = SquareGetFewestMoves(square);
    priority = ffm->pm_count + SquareEmptyCount(square);
    square->priority = priority;
    return priority;
}

int SquareCompare(PtrSquare square1, PtrSquare square2)
{
 int c = SquareGetPriority(square1) - SquareGetPriority(square2);
 if (c==0){
    int i;
    for (i=0; c==0 && i<n*n; i++){
        c = square1->grid[i] - square2->grid[i];
        }
    }
 return c;
}

PtrSquare SquareQueueMerge(PtrSquare queue1, PtrSquare queue2)
{
    if (!queue1) return queue2;
    if (!queue2) return queue1;
    
    PtrSquare new_queue = NULL;
    PtrSquare* cur_ptr = &new_queue;
    
    while (1){
        if (SquareCompare(queue1, queue2)<0){
            *cur_ptr = queue1;
            cur_ptr = &queue1->next;
            queue1 = queue1->next;
            if (!queue1){
                *cur_ptr = queue2;
                return new_queue;
                }
            }
        else {
            *cur_ptr = queue2;
            cur_ptr = &queue2->next;
            queue2 = queue2->next;
            if (!queue2){
                *cur_ptr = queue1;
                return new_queue;
                }
            }
        }
}

PtrSquare SquareGetSuccessorNodes(PtrSquare square)
{
    int i;
    PtrSquare square_queue = NULL;
    PtrFfmCache ffm = SquareGetFewestMoves(square);
    
    for (i=0; i<ffm->pm_count; i++){
        PtrSquare new_square = SquareNewCopy(square);
        new_square->grid[ffm->x+ffm->y*n] = ffm->pm[i];
        new_square->unused[ffm->pm[i]-1]=0;
        square_queue = SquareQueueMerge(square_queue, new_square);
        }
    return square_queue;
}



int main(int argc, char **argv)
{
   
    if (argv[1]) n = atoi(argv[1]);
    else         n = 5;
    mn = n * (1 + n * n) / 2;
    
    PtrSquare queue = SquareNewEmpty();
    PtrSquare cur_square;
    
    while (queue){
        cur_square = queue;
        queue = queue->next;
        
        int priority = SquareGetPriority(cur_square);
        if (!priority) break;
        
        
        PtrSquare successor_nodes = SquareGetSuccessorNodes(cur_square);
        queue = SquareQueueMerge(queue, successor_nodes);
        SquareFree(cur_square);
        }
    
    SquarePrint(cur_square);
    return 0;
}
/*The Computer Language Benchmarks Game
  http://shootout.alioth.debian.org/

  contributed by Paolo Bonzini
  further optimized by Jason Garrett-Glaser
  pthreads added by Eckehard Berns
  further optimized by Ryan Henszey
  modified by Samy Al Bahra (use GCC atomic builtins)
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef double v2df __attribute__ ((vector_size(16))); /* vector of two doubles */
typedef int v4si __attribute__ ((vector_size(16))); /* vector of four ints */

// 4 works best on a quiet machine at nice -20
// 8 on a noisy machine at default priority
#define NWORKERS 8

int w, h;
v2df zero = { 0.0, 0.0 };
v2df four = { 4.0, 4.0 };
v2df nzero;
double inverse_w;
double inverse_h;

char *whole_data;
int y_pick;

static void * worker(void *_args) {
    char *data;
    double x, y;
    int bit_num;
    char byte_acc = 0;

    for (;;) {
	y = __sync_fetch_and_add(&y_pick, 1);
        if (y >= h)
            return NULL;
        data = &whole_data[(w >> 3) * (int)y];

        for(bit_num=0,x=0;x<w;x+=2)
        {
            v2df Crv = { (x+1.0)*inverse_w-1.5, (x)*inverse_w-1.5 };
            v2df Civ = { y*inverse_h-1.0, y*inverse_h-1.0 };
            v2df Zrv = { 0.0, 0.0 };
            v2df Ziv = { 0.0, 0.0 };
            v2df Trv = { 0.0, 0.0 };
            v2df Tiv = { 0.0, 0.0 };

            int i = 0;
	    int mask;
            do {
                Ziv = (Zrv*Ziv) + (Zrv*Ziv) + Civ;
                Zrv = Trv - Tiv + Crv;
                Trv = Zrv * Zrv;
                Tiv = Ziv * Ziv;

                /* from mandelbrot C++ GNU g++ #5 program  */
		v2df delta = (v2df)__builtin_ia32_cmplepd( (Trv + Tiv), four );
		mask = __builtin_ia32_movmskpd(delta);

            } while (++i < 50 && (mask));

            byte_acc <<= 2;
	    byte_acc |= mask;
            bit_num+=2;

            if(!(bit_num&7)) {
                data[(bit_num>>3) - 1] = byte_acc;
                byte_acc = 0;
            }
        }

        if(bit_num&7) {
            byte_acc <<= (8-w%8);
            bit_num += 8;
            data[bit_num>>3] = byte_acc;
            byte_acc = 0;
        }
    }
}


int main (int argc, char **argv)
{
    pthread_t ids[NWORKERS];
    int i;

    nzero = -zero;

    w = h = atoi(argv[1]);

    inverse_w = 2.0 / w;
    inverse_h = 2.0 / h;

    y_pick = 0;
    whole_data = malloc(w * (w >> 3));

    for (i = 0; i < NWORKERS; i++)
        pthread_create(&ids[i], NULL, worker, NULL);
    for (i = 0; i < NWORKERS; i++)
        pthread_join(ids[i], NULL);

    printf("P4\n%d %d\n",w,h);
    fwrite(whole_data, h, w >> 3, stdout);

    free(whole_data);

    return 0;
}
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Greg Buchholz
   
   for the debian (AMD) machine...
   compile flags:  -O3 -ffast-math -march=athlon-xp -funroll-loops

   for the gp4 (Intel) machine...
   compile flags:  -O3 -ffast-math -march=pentium4 -funroll-loops
*/

#include<stdio.h>

int main (int argc, char **argv)
{
    int w, h, bit_num = 0;
    char byte_acc = 0;
    int i, iter = 50;
    double x, y, limit = 2.0;
    double Zr, Zi, Cr, Ci, Tr, Ti;
    
    w = h = atoi(argv[1]);

    printf("P4\n%d %d\n",w,h);

    for(y=0;y<h;++y) 
    {
        for(x=0;x<w;++x)
        {
            Zr = Zi = Tr = Ti = 0.0;
            Cr = (2.0*x/w - 1.5); Ci=(2.0*y/h - 1.0);
        
            for (i=0;i<iter && (Tr+Ti <= limit*limit);++i)
            {
                Zi = 2.0*Zr*Zi + Ci;
                Zr = Tr - Ti + Cr;
                Tr = Zr * Zr;
                Ti = Zi * Zi;
            }
       
            byte_acc <<= 1; 
            if(Tr+Ti <= limit*limit) byte_acc |= 0x01;
                
            ++bit_num; 

            if(bit_num == 8)
            {
                putc(byte_acc,stdout);
                byte_acc = 0;
                bit_num = 0;
            }
            else if(x == w-1)
            {
                byte_acc <<= (8-w%8);
                putc(byte_acc,stdout);
                byte_acc = 0;
                bit_num = 0;
            }
        }
    }	
}

/*The Computer Language Benchmarks Game
  http://shootout.alioth.debian.org/

  contributed by Paolo Bonzini
  further optimized by Jason Garrett-Glaser
  pthreads added by Eckehard Berns
  further optimized by Ryan Henszey
  modified by Samy Al Bahra (use GCC atomic builtins)
  modified by Kenneth Jonsson
*/

#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

typedef double v2df __attribute__ ((vector_size(16))); /* vector of two doubles */
typedef int v4si __attribute__ ((vector_size(16))); /* vector of four ints */

/* 3 workers + the main thread to get a total of 4 active threads */
#define NWORKERS 3

int N;
int bytes_per_row;
double inverse_w;
double inverse_h;
const v2df zero = { 0.0, 0.0 };
const v2df four = { 4.0, 4.0 };

uint8_t *bitmap;
int next_y = 0;

static void * worker(void *_args) {
    uint8_t *row_bitmap;
    int x, y;

    for (;;) {
        y = __sync_fetch_and_add(&next_y, 1);
        if (y >= N)
            return NULL;
        row_bitmap = bitmap + (bytes_per_row * y);

        for (x=0; x<N; x+=2)
        {
            v2df Crv = { (x+1)*inverse_w-1.5, (x)*inverse_w-1.5 };
            v2df Civ = { y*inverse_h-1.0, y*inverse_h-1.0 };
            v2df Zrv = zero;
            v2df Ziv = zero;
            v2df Trv = zero;
            v2df Tiv = zero;
            int i = 0;
            int two_pixels;

            do {
                Ziv = (Zrv*Ziv) + (Zrv*Ziv) + Civ;
                Zrv = Trv - Tiv + Crv;
                Trv = Zrv * Zrv;
                Tiv = Ziv * Ziv;

                /* from mandelbrot C++ GNU g++ #5 program  */
                v2df delta = (v2df)__builtin_ia32_cmplepd( (Trv + Tiv), four);
                two_pixels = __builtin_ia32_movmskpd(delta);
            } while (++i < 50 && two_pixels);

            /*
             * The pixel bits must be in the most and second most
             * significant position
             */
            two_pixels <<= 6;

            /*
             * Add the two pixels to the bitmap, all bits are
             * initially zero since the area was allocated with
             * calloc()
             */
            row_bitmap[x >> 3] |= (uint8_t) (two_pixels >> (x & 7));
        }
    }
}

int main (int argc, char **argv)
{
    pthread_t ids[NWORKERS];
    int i;

    N = atoi(argv[1]);
    bytes_per_row = (N + 7) >> 3;

    inverse_w = 2.0 / (bytes_per_row << 3);
    inverse_h = 2.0 / N;

    bitmap = calloc(bytes_per_row, N);

    for (i = 0; i < NWORKERS; i++)
        pthread_create(&ids[i], NULL, worker, NULL);
    worker(NULL);
    for (i = 0; i < NWORKERS; i++)
        pthread_join(ids[i], NULL);

    printf("P4\n%d %d\n", N, N);
    fwrite(bitmap, bytes_per_row, N, stdout);
    free(bitmap);
    return 0;
}
/*The Computer Language Benchmarks Game
  http://shootout.alioth.debian.org/

  contributed by Paolo Bonzini
  further optimized by Jason Garrett-Glaser
  pthreads added by Eckehard Berns
  further optimized by Ryan Henszey
  modified by Samy Al Bahra (use GCC atomic builtins)
  modified by Kenneth Jonsson
*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>


typedef double v2df __attribute__ ((vector_size(16))); /* vector of two doubles */
typedef int v4si __attribute__ ((vector_size(16))); /* vector of four ints */


const v2df zero = { 0.0, 0.0 };
const v2df four = { 4.0, 4.0 };

/*
 * Constant throughout the program, value depends on N
 */
int bytes_per_row;
double inverse_w;
double inverse_h;

/*
 * Program argument: height and width of the image
 */
int N;

/*
 * Lookup table for initial real-axis value
 */
v2df *Crvs;

/*
 * Mandelbrot bitmap
 */
uint8_t *bitmap;


static void calc_row(int y) {
    uint8_t *row_bitmap = bitmap + (bytes_per_row * y);
    int x;
    const v2df Civ_init = { y*inverse_h-1.0, y*inverse_h-1.0 };

    for (x=0; x<N; x+=2)
    {
        v2df Crv = Crvs[x >> 1];
        v2df Civ = Civ_init;
        v2df Zrv = zero;
        v2df Ziv = zero;
        v2df Trv = zero;
        v2df Tiv = zero;
        int i = 50;
        int two_pixels;
        v2df is_still_bounded;

        do {
            Ziv = (Zrv*Ziv) + (Zrv*Ziv) + Civ;
            Zrv = Trv - Tiv + Crv;
            Trv = Zrv * Zrv;
            Tiv = Ziv * Ziv;

            /*
             * All bits will be set to 1 if 'Trv + Tiv' is less than 4
             * and all bits will be set to 0 otherwise. Two elements
             * are calculated in parallel here.
             */
            is_still_bounded = __builtin_ia32_cmplepd(Trv + Tiv, four);

            /*
             * Move the sign-bit of the low element to bit 0, move the
             * sign-bit of the high element to bit 1. The result is
             * that the pixel will be set if the calculation was
             * bounded.
             */
            two_pixels = __builtin_ia32_movmskpd(is_still_bounded);
        } while (--i > 0 && two_pixels);

        /*
         * The pixel bits must be in the most and second most
         * significant position
         */
        two_pixels <<= 6;

        /*
         * Add the two pixels to the bitmap, all bits are
         * initially zero since the area was allocated with
         * calloc()
         */
        row_bitmap[x >> 3] |= (uint8_t) (two_pixels >> (x & 7));
    }
}

int main (int argc, char **argv)
{
    int i;

    N = atoi(argv[1]);
    bytes_per_row = (N + 7) >> 3;

    inverse_w = 2.0 / (bytes_per_row << 3);
    inverse_h = 2.0 / N;

    /*
     * Crvs must be 16-bytes aligned on some CPU:s.
     */
    if (posix_memalign((void**)&Crvs, sizeof(v2df), sizeof(v2df) * N / 2))
        return EXIT_FAILURE;

#pragma omp parallel for
    for (i = 0; i < N; i+=2) {
        v2df Crv = { (i+1.0)*inverse_w-1.5, (i)*inverse_w-1.5 };
        Crvs[i >> 1] = Crv;
    }

    bitmap = calloc(bytes_per_row, N);
    if (bitmap == NULL)
        return EXIT_FAILURE;

#pragma omp parallel for schedule(static,1)
    for (i = 0; i < N; i++)
        calc_row(i);

    printf("P4\n%d %d\n", N, N);
    fwrite(bitmap, bytes_per_row, N, stdout);

    free(bitmap);
    free(Crvs);

    return EXIT_SUCCESS;
}
/*The Computer Language Benchmarks Game
  http://shootout.alioth.debian.org/

  contributed by Paolo Bonzini
  further optimized by Jason Garrett-Glaser
  pthreads added by Eckehard Berns
  further optimized by Ryan Henszey
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef double v2df __attribute__ ((vector_size(16))); /* vector of two doubles */
typedef int v4si __attribute__ ((vector_size(16))); /* vector of four ints */

// 4 works best on a quiet machine at nice -20
// 8 on a noisy machine at default priority 
#define NWORKERS 8

int w, h;
v2df zero = { 0.0, 0.0 };
v2df four = { 4.0, 4.0 };
v2df nzero;
double inverse_w;
double inverse_h;

char *whole_data;
int y_pick;
pthread_mutex_t y_mutex = PTHREAD_MUTEX_INITIALIZER;

static void * worker(void *_args) {
    char *data;
    double x, y;
    int bit_num;
    char byte_acc = 0;

    for (;;) {
        pthread_mutex_lock(&y_mutex);
        y = y_pick;
        y_pick++;
        pthread_mutex_unlock(&y_mutex);
        if (y >= h)
            return NULL;
        data = &whole_data[(w >> 3) * (int)y];

        for(bit_num=0,x=0;x<w;x+=2)
        {
            v2df Crv = { (x+1.0)*inverse_w-1.5, (x)*inverse_w-1.5 };
            v2df Civ = { y*inverse_h-1.0, y*inverse_h-1.0 };
            v2df Zrv = { 0.0, 0.0 };
            v2df Ziv = { 0.0, 0.0 };
            v2df Trv = { 0.0, 0.0 };
            v2df Tiv = { 0.0, 0.0 };

            int i = 0;
	    int mask;
            do {
                Ziv = (Zrv*Ziv) + (Zrv*Ziv) + Civ;
                Zrv = Trv - Tiv + Crv;
                Trv = Zrv * Zrv;
                Tiv = Ziv * Ziv;

                /* from mandelbrot C++ GNU g++ #5 program  */
		v2df delta = (v2df)__builtin_ia32_cmplepd( (Trv + Tiv), four );
		mask = __builtin_ia32_movmskpd(delta);

            } while (++i < 50 && (mask));

            byte_acc <<= 2;
	    byte_acc |= mask;
            bit_num+=2;

            if(!(bit_num&7)) {
                data[(bit_num>>3) - 1] = byte_acc;
                byte_acc = 0;
            }
        }

        if(bit_num&7) {
            byte_acc <<= (8-w%8);
            bit_num += 8;
            data[bit_num>>3] = byte_acc;
            byte_acc = 0;
        }
    }
}


int main (int argc, char **argv)
{
    pthread_t ids[NWORKERS];
    int i;

    nzero = -zero;

    w = h = atoi(argv[1]);

    inverse_w = 2.0 / w;
    inverse_h = 2.0 / h;

    y_pick = 0;
    whole_data = malloc(w * (w >> 3));

    for (i = 0; i < NWORKERS; i++)
        pthread_create(&ids[i], NULL, worker, NULL);
    for (i = 0; i < NWORKERS; i++)
        pthread_join(ids[i], NULL);
    pthread_mutex_destroy(&y_mutex);

    printf("P4\n%d %d\n",w,h);
    fwrite(whole_data, h, w >> 3, stdout);

    free(whole_data);

    return 0;
}

/* -*- mode: c -*-
 * $Id: matrix.gcc,v 1.1 2004-05-19 18:10:33 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define SIZE 30

int **mkmatrix(int rows, int cols) {
    int i, j, count = 1;
    int **m = (int **) malloc(rows * sizeof(int *));
    for (i=0; i<rows; i++) {
	m[i] = (int *) malloc(cols * sizeof(int));
	for (j=0; j<cols; j++) {
	    m[i][j] = count++;
	}
    }
    return(m);
}

void zeromatrix(int rows, int cols, int **m) {
    int i, j;
    for (i=0; i<rows; i++)
	for (j=0; j<cols; j++)
	    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
    while (--rows > -1) { free(m[rows]); }
    free(m);
}

int **mmult(int rows, int cols, int **m1, int **m2, int **m3) {
    int i, j, k, val;
    for (i=0; i<rows; i++) {
	for (j=0; j<cols; j++) {
	    val = 0;
	    for (k=0; k<cols; k++) {
		val += m1[i][k] * m2[k][j];
	    }
	    m3[i][j] = val;
	}
    }
    return(m3);
}

int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
	
    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (i=0; i<n; i++) {
	mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
    printf("%d %d %d %d\n", mm[0][0], mm[2][3], mm[3][2], mm[4][4]);

    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
    return(0);
}
/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * contributed contributed by Colin Gibbs
 */

#include <stdio.h>
#include <stdlib.h>
#include <ucontext.h>

#define STACK_SIZE 1024

struct thread_context {
   struct thread_context *next;
   ucontext_t ctx;
   int value;
   char stack[STACK_SIZE];
};

static void thread(struct thread_context *c)
{
   while (1) {
      c->next->value = c->value + 1;
      swapcontext(&c->ctx, &c->next->ctx);
   }
}

static void create_threads(struct thread_context **head, struct thread_context **tail, int n)
{
   struct thread_context *c;
   typedef void (*thread_t)(void);

   c = malloc(sizeof(*c));
   *head = c;

   getcontext(&c->ctx);
   c->ctx.uc_stack.ss_sp = c->stack;
   c->ctx.uc_stack.ss_size = sizeof(c->stack);
   makecontext(&c->ctx, (thread_t)thread, 1, c);

   if (n > 1) {
      create_threads(&c->next, tail, n - 1);
   } else {
      c->next = NULL;
      *tail = c;
   }
}

static int call_threads(struct thread_context *head, struct thread_context *tail)
{
   struct thread_context here;
   tail->next = &here;
   head->value = 0;
   swapcontext(&here.ctx, &head->ctx);
   return here.value;
}

int main(int argc, char **argv)
{
   int n, i, count;
   struct thread_context *head, *tail;

   n = atoi(argv[1]);
   create_threads(&head, &tail, 500);

   count = 0;
   for (i = 0; i < n; i++)
      count += call_threads(head, tail);

   printf("%d\n", count);

   return 0;
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 * contributed contributed by Ian Chiew
 */

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define THREADS 500
#define THREAD_STACK_SIZE (1024 * 100)

struct inbox {
    sem_t sem;
    int n;
};

struct worker {
    struct inbox inbox, *next_inbox;
    pthread_t thread;
};

void *work(void *data) {
    struct worker *worker = (struct worker *)data;

    while (1) {
        assert(sem_wait(&worker->inbox.sem) == 0);
        worker->next_inbox->n = worker->inbox.n + 1;
        assert(sem_post(&worker->next_inbox->sem) == 0);
    }

    return NULL;
}

int main(int argc, char **argv) {
    struct worker workers[THREADS];
    struct inbox main_inbox;
    pthread_attr_t attr;
    int n, i, j, sum = 0;

    assert(argc == 2 && (n = atoi(argv[1])) != -1);
    assert(sem_init(&main_inbox.sem, 0, 0) == 0);
    assert(pthread_attr_init(&attr) == 0);
    assert(pthread_attr_setstacksize(&attr, THREAD_STACK_SIZE) == 0);

    for (i = 0; i < THREADS; i++) {
        workers[i].next_inbox = i == 0 ? &main_inbox : &workers[i - 1].inbox;
        sem_init(&workers[i].inbox.sem, 0, 0);
        assert(pthread_create(&workers[i].thread, &attr, work, &workers[i]) == 0);
    }

    for (j = 0; j < n; j++)
    {
        workers[THREADS - 1].inbox.n = 0;
        assert(sem_post(&workers[THREADS - 1].inbox.sem) == 0);
        assert(sem_wait(&main_inbox.sem) == 0);
        sum += main_inbox.n;
    }

    printf("%d\n", sum);
    exit(0);
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christian Vosteen
 */

#include <stdlib.h>
#include <stdio.h>
#define TRUE 1
#define FALSE 0

/* The board is a 50 cell hexagonal pattern.  For    . . . . .
 * maximum speed the board will be implemented as     . . . . .
 * 50 bits, which will fit into a 64 bit long long   . . . . .
 * int.                                               . . . . .
 *                                                   . . . . .
 * I will represent 0's as empty cells and 1's        . . . . .
 * as full cells.                                    . . . . .
 *                                                    . . . . .
 *                                                   . . . . .
 *                                                    . . . . .
 */

unsigned long long board = 0xFFFC000000000000ULL;

/* The puzzle pieces must be specified by the path followed
 * from one end to the other along 12 hexagonal directions.
 *
 *   Piece 0   Piece 1   Piece 2   Piece 3   Piece 4
 *                   
 *  O O O O    O   O O   O O O     O O O     O   O
 *         O    O O           O       O       O O
 *                           O         O         O
 *
 *   Piece 5   Piece 6   Piece 7   Piece 8   Piece 9
 *
 *    O O O     O O       O O     O O        O O O O
 *       O O       O O       O       O O O        O
 *                  O       O O
 *
 * I had to make it 12 directions because I wanted all of the
 * piece definitions to fit into the same size arrays.  It is
 * not possible to define piece 4 in terms of the 6 cardinal
 * directions in 4 moves.
 */

#define E     0
#define ESE   1
#define SE    2
#define S     3
#define SW    4
#define WSW   5
#define W     6
#define WNW   7
#define NW    8
#define N     9
#define NE    10
#define ENE   11
#define PIVOT 12

char piece_def[10][4] = {
   {  E,  E,  E, SE},
   { SE,  E, NE,  E},
   {  E,  E, SE, SW},
   {  E,  E, SW, SE},
   { SE,  E, NE,  S},
   {  E,  E, SW,  E},
   {  E, SE, SE, NE},
   {  E, SE, SE,  W},
   {  E, SE,  E,  E},
   {  E,  E,  E, SW}
};

 
/* To minimize the amount of work done in the recursive solve function below,
 * I'm going to allocate enough space for all legal rotations of each piece
 * at each position on the board. That's 10 pieces x 50 board positions x
 * 12 rotations.  However, not all 12 rotations will fit on every cell, so
 * I'll have to keep count of the actual number that do.
 * The pieces are going to be unsigned long long ints just like the board so
 * they can be bitwise-anded with the board to determine if they fit.
 * I'm also going to record the next possible open cell for each piece and
 * location to reduce the burden on the solve function.
 */
unsigned long long pieces[10][50][12];
int piece_counts[10][50];
char next_cell[10][50][12];

/* Returns the direction rotated 60 degrees clockwise */
char rotate(char dir) {
   return (dir + 2) % PIVOT;
}

/* Returns the direction flipped on the horizontal axis */
char flip(char dir) {
   return (PIVOT - dir) % PIVOT;
}


/* Returns the new cell index from the specified cell in the
 * specified direction.  The index is only valid if the
 * starting cell and direction have been checked by the
 * out_of_bounds function first.
 */
char shift(char cell, char dir) {
   switch(dir) {
      case E:
         return cell + 1;
      case ESE:
         if((cell / 5) % 2)
            return cell + 7;
         else
            return cell + 6;
      case SE:
         if((cell / 5) % 2)
            return cell + 6;
         else
            return cell + 5;
      case S:
         return cell + 10;
      case SW:
         if((cell / 5) % 2)
            return cell + 5;
         else
            return cell + 4;
      case WSW:
         if((cell / 5) % 2)
            return cell + 4;
         else
            return cell + 3;
      case W:
         return cell - 1;
      case WNW:
         if((cell / 5) % 2)
            return cell - 6;
         else
            return cell - 7;
      case NW:
         if((cell / 5) % 2)
            return cell - 5;
         else
            return cell - 6;
      case N:
         return cell - 10;
      case NE:
         if((cell / 5) % 2)
            return cell - 4;
         else
            return cell - 5;
      case ENE:
         if((cell / 5) % 2)
            return cell - 3;
         else
            return cell - 4;
      default:
         return cell;
   }
}

/* Returns wether the specified cell and direction will land outside
 * of the board.  Used to determine if a piece is at a legal board
 * location or not.
 */
char out_of_bounds(char cell, char dir) {
   char i;
   switch(dir) {
      case E:
         return cell % 5 == 4;
      case ESE:
         i = cell % 10;   
         return i == 4 || i == 8 || i == 9 || cell >= 45;
      case SE:
         return cell % 10 == 9 || cell >= 45;
      case S:
         return cell >= 40;
      case SW:
         return cell % 10 == 0 || cell >= 45;
      case WSW:
         i = cell % 10;   
         return i == 0 || i == 1 || i == 5 || cell >= 45;
      case W:
         return cell % 5 == 0;
      case WNW:
         i = cell % 10;   
         return i == 0 || i == 1 || i == 5 || cell < 5;
      case NW:
         return cell % 10 == 0 || cell < 5;
      case N:
         return cell < 10;
      case NE:
         return cell % 10 == 9 || cell < 5;
      case ENE:
         i = cell % 10;   
         return i == 4 || i == 8 || i == 9 || cell < 5;
      default:
         return FALSE;
   }
}

/* Rotate a piece 60 degrees clockwise */
void rotate_piece(int piece) {
   int i;
   for(i = 0; i < 4; i++)
      piece_def[piece][i] = rotate(piece_def[piece][i]);
}

/* Flip a piece along the horizontal axis */
void flip_piece(int piece) {
   int i;
   for(i = 0; i < 4; i++)
      piece_def[piece][i] = flip(piece_def[piece][i]);
}

/* Convenience function to quickly calculate all of the indices for a piece */
void calc_cell_indices(char *cell, int piece, char index) {
   cell[0] = index;
   cell[1] = shift(cell[0], piece_def[piece][0]);
   cell[2] = shift(cell[1], piece_def[piece][1]);
   cell[3] = shift(cell[2], piece_def[piece][2]);
   cell[4] = shift(cell[3], piece_def[piece][3]);
}

/* Convenience function to quickly calculate if a piece fits on the board */
int cells_fit_on_board(char *cell, int piece) {
   return (!out_of_bounds(cell[0], piece_def[piece][0]) &&
         !out_of_bounds(cell[1], piece_def[piece][1]) && 
         !out_of_bounds(cell[2], piece_def[piece][2]) && 
         !out_of_bounds(cell[3], piece_def[piece][3]));
}

/* Returns the lowest index of the cells of a piece.
 * I use the lowest index that a piece occupies as the index for looking up
 * the piece in the solve function.
 */
char minimum_of_cells(char *cell) {
   char minimum = cell[0];
   minimum = cell[1] < minimum ? cell[1] : minimum;
   minimum = cell[2] < minimum ? cell[2] : minimum;
   minimum = cell[3] < minimum ? cell[3] : minimum;
   minimum = cell[4] < minimum ? cell[4] : minimum;
   return minimum;
}

/* Calculate the lowest possible open cell if the piece is placed on the board.
 * Used to later reduce the amount of time searching for open cells in the
 * solve function.
 */
char first_empty_cell(char *cell, char minimum) {
   char first_empty = minimum;
   while(first_empty == cell[0] || first_empty == cell[1] ||
         first_empty == cell[2] || first_empty == cell[3] ||
         first_empty == cell[4])
      first_empty++;
   return first_empty;
}

/* Generate the unsigned long long int that will later be anded with the
 * board to determine if it fits.
 */
unsigned long long bitmask_from_cells(char *cell) {
   unsigned long long piece_mask = 0ULL;
   int i;
   for(i = 0; i < 5; i++)
      piece_mask |= 1ULL << cell[i];
   return piece_mask;
}

/* Record the piece and other important information in arrays that will
 * later be used by the solve function.
 */
void record_piece(int piece, int minimum, char first_empty,
      unsigned long long piece_mask) {
   pieces[piece][minimum][piece_counts[piece][minimum]] = piece_mask;
   next_cell[piece][minimum][piece_counts[piece][minimum]] = first_empty;
   piece_counts[piece][minimum]++;         
}


/* Fill the entire board going cell by cell.  If any cells are "trapped"
 * they will be left alone.
 */
void fill_contiguous_space(char *board, int index) {
   if(board[index] == 1)
      return;
   board[index] = 1;
   if(!out_of_bounds(index, E))
      fill_contiguous_space(board, shift(index, E));   
   if(!out_of_bounds(index, SE))
      fill_contiguous_space(board, shift(index, SE));   
   if(!out_of_bounds(index, SW))
      fill_contiguous_space(board, shift(index, SW));   
   if(!out_of_bounds(index, W))
      fill_contiguous_space(board, shift(index, W));   
   if(!out_of_bounds(index, NW))
      fill_contiguous_space(board, shift(index, NW));   
   if(!out_of_bounds(index, NE))
      fill_contiguous_space(board, shift(index, NE));   
}


/* To thin the number of pieces, I calculate if any of them trap any empty
 * cells at the edges.  There are only a handful of exceptions where the
 * the board can be solved with the trapped cells.  For example:  piece 8 can
 * trap 5 cells in the corner, but piece 3 can fit in those cells, or piece 0
 * can split the board in half where both halves are viable.
 */
int has_island(char *cell, int piece) {
   char temp_board[50];
   char c;
   int i;
   for(i = 0; i < 50; i++)
      temp_board[i] = 0;
   for(i = 0; i < 5; i++)
      temp_board[((int)cell[i])] = 1;
   i = 49;
   while(temp_board[i] == 1)
      i--;
   fill_contiguous_space(temp_board, i);
   c = 0;
   for(i = 0; i < 50; i++)
      if(temp_board[i] == 0)
         c++;
   if(c == 0 || (c == 5 && piece == 8) || (c == 40 && piece == 8) ||
         (c % 5 == 0 && piece == 0))
      return FALSE;
   else
      return TRUE;   
}


/* Calculate all six rotations of the specified piece at the specified index.
 * We calculate only half of piece 3's rotations.  This is because any solution
 * found has an identical solution rotated 180 degrees.  Thus we can reduce the
 * number of attempted pieces in the solve algorithm by not including the 180-
 * degree-rotated pieces of ONE of the pieces.  I chose piece 3 because it gave
 * me the best time ;)
 */
 void calc_six_rotations(char piece, char index) {
   char rotation, cell[5];
   char minimum, first_empty;
   unsigned long long piece_mask;

   for(rotation = 0; rotation < 6; rotation++) {
      if(piece != 3 || rotation < 3) { 
         calc_cell_indices(cell, piece, index);
         if(cells_fit_on_board(cell, piece) && !has_island(cell, piece)) {
            minimum = minimum_of_cells(cell);
            first_empty = first_empty_cell(cell, minimum);
            piece_mask = bitmask_from_cells(cell);
            record_piece(piece, minimum, first_empty, piece_mask);
         }
      }
      rotate_piece(piece);
   }
}

/* Calculate every legal rotation for each piece at each board location. */
void calc_pieces(void) {
   char piece, index;

   for(piece = 0; piece < 10; piece++) {
      for(index = 0; index < 50; index++) {
         calc_six_rotations(piece, index);
         flip_piece(piece);
         calc_six_rotations(piece, index);
      }
   }
}



/* Calculate all 32 possible states for a 5-bit row and all rows that will
 * create islands that follow any of the 32 possible rows.  These pre-
 * calculated 5-bit rows will be used to find islands in a partially solved
 * board in the solve function.
 */
#define ROW_MASK 0x1F
#define TRIPLE_MASK 0x7FFF
char all_rows[32] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
int bad_even_rows[32][32];
int bad_odd_rows[32][32];
int bad_even_triple[32768];
int bad_odd_triple[32768];

int rows_bad(char row1, char row2, int even) {
   /* even is referring to row1 */
   int i, in_zeroes, group_okay;
   char block, row2_shift;
   /* Test for blockages at same index and shifted index */
   if(even)
      row2_shift = ((row2 << 1) & ROW_MASK) | 0x01;
   else
      row2_shift = (row2 >> 1) | 0x10;
   block = ((row1 ^ row2) & row2) & ((row1 ^ row2_shift) & row2_shift);
   /* Test for groups of 0's */
   in_zeroes = FALSE;
   group_okay = FALSE;
   for(i = 0; i < 5; i++) {
      if(row1 & (1 << i)) {
         if(in_zeroes) {
            if(!group_okay)
               return TRUE;
            in_zeroes = FALSE;
            group_okay = FALSE;
         }
      } else {
         if(!in_zeroes)
            in_zeroes = TRUE;
         if(!(block & (1 << i)))
            group_okay = TRUE;
      }
   }
   if(in_zeroes)
      return !group_okay;
   else
      return FALSE;
}

/* Check for cases where three rows checked sequentially cause a false
 * positive.  One scenario is when 5 cells may be surrounded where piece 5
 * or 7 can fit.  The other scenario is when piece 2 creates a hook shape.
 */
int triple_is_okay(char row1, char row2, char row3, int even) {
   if(even) {
      /* There are four cases:
       * row1: 00011  00001  11001  10101
       * row2: 01011  00101  10001  10001
       * row3: 011??  00110  ?????  ?????
       */
      return ((row1 == 0x03) && (row2 == 0x0B) && ((row3 & 0x1C) == 0x0C)) ||
            ((row1 == 0x01) && (row2 == 0x05) && (row3 == 0x06)) ||
            ((row1 == 0x19) && (row2 == 0x11)) ||
            ((row1 == 0x15) && (row2 == 0x11));
   } else {
      /* There are two cases:
       * row1: 10011  10101
       * row2: 10001  10001
       * row3: ?????  ?????
       */
      return ((row1 == 0x13) && (row2 == 0x11)) ||
            ((row1 == 0x15) && (row2 == 0x11));
   }
}


void calc_rows(void) {
   int row1, row2, row3;
   int result1, result2;
   for(row1 = 0; row1 < 32; row1++) {
      for(row2 = 0; row2 < 32; row2++) {
         bad_even_rows[row1][row2] = rows_bad(row1, row2, TRUE);
         bad_odd_rows[row1][row2] = rows_bad(row1, row2, FALSE);
      }
   }
   for(row1 = 0; row1 < 32; row1++) {
      for(row2 = 0; row2 < 32; row2++) {
         for(row3 = 0; row3 < 32; row3++) {
            result1 = bad_even_rows[row1][row2];
            result2 = bad_odd_rows[row2][row3];
            if(result1 == FALSE && result2 == TRUE
                  && triple_is_okay(row1, row2, row3, TRUE))
               bad_even_triple[row1+(row2*32)+(row3*1024)] = FALSE;
            else
               bad_even_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;

            result1 = bad_odd_rows[row1][row2];
            result2 = bad_even_rows[row2][row3];
            if(result1 == FALSE && result2 == TRUE
                  && triple_is_okay(row1, row2, row3, FALSE))
               bad_odd_triple[row1+(row2*32)+(row3*1024)] = FALSE;
            else
               bad_odd_triple[row1+(row2*32)+(row3*1024)] = result1 || result2;
         }
      }
   }
}



/* Calculate islands while solving the board.
 */
int boardHasIslands(char cell) {
   /* Too low on board, don't bother checking */
   if(cell >= 40)
      return FALSE;
   int current_triple = (board >> ((cell / 5) * 5)) & TRIPLE_MASK;
   if((cell / 5) % 2)
      return bad_odd_triple[current_triple];
   else
      return bad_even_triple[current_triple];
}


/* The recursive solve algorithm.  Try to place each permutation in the upper-
 * leftmost empty cell.  Mark off available pieces as it goes along.
 * Because the board is a bit mask, the piece number and bit mask must be saved
 * at each successful piece placement.  This data is used to create a 50 char
 * array if a solution is found.
 */
short avail = 0x03FF;
char sol_nums[10];
unsigned long long sol_masks[10];
signed char solutions[2100][50];
int solution_count = 0;
int max_solutions = 2100;

void record_solution(void) {
   int sol_no, index;
   unsigned long long sol_mask;
   for(sol_no = 0; sol_no < 10; sol_no++) {
      sol_mask = sol_masks[sol_no];
      for(index = 0; index < 50; index++) {
         if(sol_mask & 1ULL) {
            solutions[solution_count][index] = sol_nums[sol_no];
            /* Board rotated 180 degrees is a solution too! */
            solutions[solution_count+1][49-index] = sol_nums[sol_no];
         }
         sol_mask = sol_mask >> 1;
      }
   }
   solution_count += 2;
}

void solve(int depth, int cell) {
   int piece, rotation, max_rots;
   unsigned long long *piece_mask;
   short piece_no_mask;
   
   if(solution_count >= max_solutions)
      return;

   while(board & (1ULL << cell))
      cell++;

   for(piece = 0; piece < 10; piece++) {
      piece_no_mask = 1 << piece;
      if(!(avail & piece_no_mask))
         continue;
      avail ^= piece_no_mask;
      max_rots = piece_counts[piece][cell];
      piece_mask = pieces[piece][cell];
      for(rotation = 0; rotation < max_rots; rotation++) {
         if(!(board & *(piece_mask + rotation))) {
            sol_nums[depth] = piece;
            sol_masks[depth] = *(piece_mask + rotation);
            if(depth == 9) {
               /* Solution found!!!!!11!!ONE! */
               record_solution();
               avail ^= piece_no_mask;
               return;
            }
            board |= *(piece_mask + rotation);
            if(!boardHasIslands(next_cell[piece][cell][rotation]))
               solve(depth + 1, next_cell[piece][cell][rotation]);
            board ^= *(piece_mask + rotation);
         }
      }
      avail ^= piece_no_mask;
   }
}


/* qsort comparator - used to find first and last solutions */
int solution_sort(const void *elem1, const void *elem2) {
   signed char *char1 = (signed char *) elem1;
   signed char *char2 = (signed char *) elem2;
   int i = 0;
   while(i < 50 && char1[i] == char2[i])
      i++;
   return char1[i] - char2[i];
}


/* pretty print a board in the specified hexagonal format */
void pretty(signed char *b) {
   int i;
   for(i = 0; i < 50; i += 10) {
      printf("%c %c %c %c %c \n %c %c %c %c %c \n", b[i]+'0', b[i+1]+'0',
            b[i+2]+'0', b[i+3]+'0', b[i+4]+'0', b[i+5]+'0', b[i+6]+'0',
            b[i+7]+'0', b[i+8]+'0', b[i+9]+'0');
   }
   printf("\n");
}

int main(int argc, char **argv) {
   if(argc > 1)
      max_solutions = atoi(argv[1]);
   calc_pieces();
   calc_rows();
   solve(0, 0);
   printf("%d solutions found\n\n", solution_count);
   qsort(solutions, solution_count, 50 * sizeof(signed char), solution_sort);
   pretty(solutions[0]);
   pretty(solutions[solution_count-1]);
   return 0;
}
/* -*- mode: c -*-
 * $Id: methcall.gcc,v 1.1 2004-05-19 18:10:40 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>


enum {false, true};

#define TOGGLE \
    char state; \
    char (*value)(struct Toggle *); \
    struct Toggle *(*activate)(struct Toggle *)

#define DESTROY  free

typedef struct Toggle {
    TOGGLE;
} Toggle;

char toggle_value(Toggle *this) {
    return(this->state);
}
Toggle *toggle_activate(Toggle *this) {
    this->state = !this->state;
    return(this);
}
Toggle *init_Toggle(Toggle *this, char start_state) {
    this->state = start_state;
    this->value = toggle_value;
    this->activate = toggle_activate;
    return(this);
}
Toggle *new_Toggle(char start_state) {
    Toggle *this = (Toggle *)malloc(sizeof(Toggle));
    return(init_Toggle(this, start_state));
}


typedef struct NthToggle {
    TOGGLE;
    int count_max;
    int counter;
} NthToggle;

NthToggle *nth_toggle_activate(NthToggle *this) {
    if (++this->counter >= this->count_max) {
	this->state = !this->state;
	this->counter = 0;
    }
    return(this);
}
NthToggle *init_NthToggle(NthToggle *this, int max_count) {
    this->count_max = max_count;
    this->counter = 0;
    this->activate = (Toggle *(*)(Toggle *))nth_toggle_activate;
    return(this);
}
NthToggle *new_NthToggle(char start_state, int max_count) {
    NthToggle *this = (NthToggle *)malloc(sizeof(NthToggle));
    this = (NthToggle *)init_Toggle((Toggle *)this, start_state);
    return(init_NthToggle(this, max_count));
}


int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    Toggle *tog;
    NthToggle *ntog;
    char val = true;

    tog = new_Toggle(true);
    for (i=0; i<n; i++) {
	val = tog->activate(tog)->value(tog);
    }
    fputs(val ? "true\n" : "false\n", stdout);
    DESTROY(tog);
    
    val = true;
    ntog = new_NthToggle(val, 3);
    for (i=0; i<n; i++) {
	val = ntog->activate(ntog)->value(ntog);
    }
    fputs(val ? "true\n" : "false\n", stdout);
    DESTROY(ntog);
    return 0;
}
/* -*- mode: c -*-
 * $Id: moments.gcc,v 1.1 2004-05-19 18:10:47 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Waldek Hebisch
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXLINELEN 128

/* kmedian permutes elements of a to get
   a[i]<=a[k] for i<k
   a[i]>=a[k] for i>k
	See. N. Wirth, Algorithms+data structures = Programs
*/

void kmedian(double *a, int n, int k) 
{
	while (1){
		int j=random()%n; 
		double b = a[j];
		int i=0;
        	j = n-1;
        	while(1) {
        	    while( a[i]<b ) i++;
        	    while( a[j]>b ) j--;
        	    if(i<j) {
                	double tmp=a[i];
                	a[i]=a[j];
                	a[j]=tmp;
                	i++;
                	j--;
       		    } else {
                	if(a[j]<b) j++;
                	if(a[i]>b) i--;
			break;
        	    }
        	}
		if(i<k) {
			k-=i+1;
			n-=i+1;
			a+=i+1;
		} else if (j>k) { 
			n=j;
		} else return;
	}
}

double max(double *a, int n)
{
	int j;
	double temp=a[0];
	for(j=1;j<n;j++) { 
		if(a[j]>temp) {
			temp=a[j];
		}
	}
	return temp;
}


int
main() {
    char line[MAXLINELEN];
    int i, n = 0, mid = 0;
    double sum = 0.0;
    double mean = 0.0;
    double average_deviation = 0.0;
    double standard_deviation = 0.0;
    double variance = 0.0;
    double skew = 0.0;
    double kurtosis = 0.0;
    double median = 0.0;
    double deviation = 0.0;
    int array_size = 4096;

    double *nums = (double *)malloc(array_size * sizeof(double));

    while (fgets(line, MAXLINELEN, stdin)) {
	sum += (nums[n++] = atof(line));
	if (n == array_size) {
	    array_size *= 2;
	    nums = (double *)realloc(nums, array_size * sizeof(double));
	}
    }
    mean = sum/n;
    for (i=0; i<n; i++) {
	double dev = nums[i] - mean;
	double dev2=dev*dev;
	double dev3=dev2*dev;
	double dev4=dev3*dev;
	average_deviation += fabs(dev);
	variance += dev2 /*pow(deviation,2)*/;
	skew += dev3 /* pow(deviation,3) */;
	kurtosis += dev4 /* pow(deviation,4) */;
    }
    average_deviation /= n;
    variance /= (n - 1);
    standard_deviation = sqrt(variance);
    if (variance) {
	skew /= (n * variance * standard_deviation);
	kurtosis = (kurtosis/(n * variance * variance)) - 3.0;
    }
    mid = (n/2);
    kmedian(nums, n, mid); 
    median = n % 2 ? nums[mid] : (nums[mid] + max(nums,mid))/2;
    free(nums);
    printf("n:                  %d\n", n);
    printf("median:             %f\n", median);
    printf("mean:               %f\n", mean);
    printf("average_deviation:  %f\n", average_deviation);
    printf("standard_deviation: %f\n", standard_deviation);
    printf("variance:           %f\n", variance);
    printf("skew:               %f\n", skew);
    printf("kurtosis:           %f\n", kurtosis);

    return(0);
}
/*
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christoph Bauer
 *  
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

struct planet {
  double x, y, z;
  double vx, vy, vz;
  double mass;
};

void advance(int nbodies, struct planet * bodies, double dt)
{
  int i, j;

  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      double mag = dt / (distance * distance * distance);
      b->vx -= dx * b2->mass * mag;
      b->vy -= dy * b2->mass * mag;
      b->vz -= dz * b2->mass * mag;
      b2->vx += dx * b->mass * mag;
      b2->vy += dy * b->mass * mag;
      b2->vz += dz * b->mass * mag;
    }
  }
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    b->x += dt * b->vx;
    b->y += dt * b->vy;
    b->z += dt * b->vz;
  }
}

double energy(int nbodies, struct planet * bodies)
{
  double e;
  int i, j;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    e += 0.5 * b->mass * (b->vx * b->vx + b->vy * b->vy + b->vz * b->vz);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      e -= (b->mass * b2->mass) / distance;
    }
  }
  return e;
}

void offset_momentum(int nbodies, struct planet * bodies)
{
  double px = 0.0, py = 0.0, pz = 0.0;
  int i;
  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

#define NBODIES 5
struct planet bodies[NBODIES] = {
  {                               /* sun */
    0, 0, 0, 0, 0, 0, solar_mass
  },
  {                               /* jupiter */
    4.84143144246472090e+00,
    -1.16032004402742839e+00,
    -1.03622044471123109e-01,
    1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year,
    -6.90460016972063023e-05 * days_per_year,
    9.54791938424326609e-04 * solar_mass
  },
  {                               /* saturn */
    8.34336671824457987e+00,
    4.12479856412430479e+00,
    -4.03523417114321381e-01,
    -2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year,
    2.30417297573763929e-05 * days_per_year,
    2.85885980666130812e-04 * solar_mass
  },
  {                               /* uranus */
    1.28943695621391310e+01,
    -1.51111514016986312e+01,
    -2.23307578892655734e-01,
    2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year,
    -2.96589568540237556e-05 * days_per_year,
    4.36624404335156298e-05 * solar_mass
  },
  {                               /* neptune */
    1.53796971148509165e+01,
    -2.59193146099879641e+01,
    1.79258772950371181e-01,
    2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year,
    -9.51592254519715870e-05 * days_per_year,
    5.15138902046611451e-05 * solar_mass
  }
};

int main(int argc, char ** argv)
{
  int n = atoi(argv[1]);
  int i;

  offset_momentum(NBODIES, bodies);
  printf ("%.9f\n", energy(NBODIES, bodies));
  for (i = 1; i <= n; i++)
    advance(NBODIES, bodies, 0.01);
  printf ("%.9f\n", energy(NBODIES, bodies));
  return 0;
}

/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christoph Bauer
 * slightly sped up by Petr Prokhorenkov
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

struct planet {
  double x, y, z;
  double vx, vy, vz;
  double mass;
};

/*
 * Here's one weird thing: inlining of this function
 * decreases performance by 25%. (I.e. do not compile this with -O3)
 * Advances with dt == 1.0
 */
void advance(int nbodies, struct planet * bodies)
{
  int i, j;

  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double inv_distance = 1.0/sqrt(dx * dx + dy * dy + dz * dz);
      double mag = inv_distance * inv_distance * inv_distance;
      b->vx -= dx * b2->mass * mag;
      b->vy -= dy * b2->mass * mag;
      b->vz -= dz * b2->mass * mag;
      b2->vx += dx * b->mass * mag;
      b2->vy += dy * b->mass * mag;
      b2->vz += dz * b->mass * mag;
    }
  }
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    b->x += b->vx;
    b->y += b->vy;
    b->z += b->vz;
  }
}

double energy(int nbodies, struct planet * bodies)
{
  double e;
  int i, j;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    e += 0.5 * b->mass * (b->vx * b->vx + b->vy * b->vy + b->vz * b->vz);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      e -= (b->mass * b2->mass) / distance;
    }
  }
  return e;
}

void offset_momentum(int nbodies, struct planet * bodies)
{
  double px = 0.0, py = 0.0, pz = 0.0;
  int i;
  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

#define NBODIES 5
struct planet bodies[NBODIES] = {
  {                               /* sun */
    0, 0, 0, 0, 0, 0, solar_mass
  },
  {                               /* jupiter */
    4.84143144246472090e+00,
    -1.16032004402742839e+00,
    -1.03622044471123109e-01,
    1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year,
    -6.90460016972063023e-05 * days_per_year,
    9.54791938424326609e-04 * solar_mass
  },
  {                               /* saturn */
    8.34336671824457987e+00,
    4.12479856412430479e+00,
    -4.03523417114321381e-01,
    -2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year,
    2.30417297573763929e-05 * days_per_year,
    2.85885980666130812e-04 * solar_mass
  },
  {                               /* uranus */
    1.28943695621391310e+01,
    -1.51111514016986312e+01,
    -2.23307578892655734e-01,
    2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year,
    -2.96589568540237556e-05 * days_per_year,
    4.36624404335156298e-05 * solar_mass
  },
  {                               /* neptune */
    1.53796971148509165e+01,
    -2.59193146099879641e+01,
    1.79258772950371181e-01,
    2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year,
    -9.51592254519715870e-05 * days_per_year,
    5.15138902046611451e-05 * solar_mass
  }
};

#define DT 1e-2
#define RECIP_DT (1.0/DT)

/*
 * Rescale certain properties of bodies. That allows doing
 * consequential advance()'s as if dt were equal to 1.0.
 *
 * When all advances done, rescale bodies back to obtain correct energy.
 */
void scale_bodies(int nbodies, struct planet * bodies, double scale) {
    int i;

    for (i = 0; i < nbodies; i++) {
        bodies[i].mass *= scale*scale;
        bodies[i].vx *= scale;
        bodies[i].vy *= scale;
        bodies[i].vz *= scale;
    }
}

int main(int argc, char ** argv)
{
  int n = atoi(argv[1]);
  int i;

  offset_momentum(NBODIES, bodies);
  printf ("%.9f\n", energy(NBODIES, bodies));
  scale_bodies(NBODIES, bodies, DT);
  for (i = 1; i <= n; i++)  {
    advance(NBODIES, bodies);
  }
  scale_bodies(NBODIES, bodies, RECIP_DT);
  printf ("%.9f\n", energy(NBODIES, bodies));
  return 0;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christoph Bauer
 * slightly improved by Mark Hinds
 * SIMDified by Stefan Krause
 * translated in ANSI C by Francesco Massei
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

typedef double v2df __attribute__ (( vector_size(2*sizeof(double)) ));

#define lower(_V) (((double*)&_V)[0])

struct planet {
    v2df xy;
    v2df z0; /* z and zero */
    v2df vxvy;
    v2df vz00;	/* vz and zero */
    v2df massmass; /* the mass in both components */
};

#define NBODIES 5
static struct planet bodies[NBODIES] = {
  {                               /* sun */
      {0, 0}, {0,0}, {0, 0}, {0,0}, {solar_mass,solar_mass}
  },
  {                               /* jupiter */
      {4.84143144246472090e+00,
    -1.16032004402742839e+00},
    {-1.03622044471123109e-01, 0},
    {1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year},
    {-6.90460016972063023e-05 * days_per_year,0},
    {9.54791938424326609e-04 * solar_mass,9.54791938424326609e-04 * solar_mass}
  },
  {                               /* saturn */
      {8.34336671824457987e+00,
    4.12479856412430479e+00},
    {-4.03523417114321381e-01, 0},
    {-2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year},
    {2.30417297573763929e-05 * days_per_year,0},
    {2.85885980666130812e-04 * solar_mass,2.85885980666130812e-04 * solar_mass}
  },
  {                               /* uranus */
      {1.28943695621391310e+01,
    -1.51111514016986312e+01},
    {-2.23307578892655734e-01,0},
    {2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year},
    {-2.96589568540237556e-05 * days_per_year,0},
    {4.36624404335156298e-05 * solar_mass,4.36624404335156298e-05 * solar_mass}
  },
  {                               /* neptune */
      {1.53796971148509165e+01,
    -2.59193146099879641e+01},
    {1.79258772950371181e-01,0},
    {2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year},
    {-9.51592254519715870e-05 * days_per_year,0},
    {5.15138902046611451e-05 * solar_mass,5.15138902046611451e-05 * solar_mass}
  }
};

static v2df dtdt = {0.01, 0.01};

static void advance(int q)
{
  struct planet *b, *b2;
  v2df dxdy, dz00, tsquare, distance2, magmag;
  int i, j, k;
  for (k=1; k<=q; ++k) {
      for (i = 0; i < NBODIES; ++i) {
        b = &(bodies[i]);
        for (j = i + 1; j < NBODIES; j++) {
          b2 = &(bodies[j]);
          dxdy = b->xy - b2->xy;
          dz00 = b->z0 - b2->z0;
          /* dx*dx+dy*dy | dz*dz */
          tsquare = __builtin_ia32_haddpd(dxdy*dxdy,dz00*dz00);
          /* dx*dx+dy*dy+dz*dz | dx*dx+dy*dy+dz*dz */
          distance2 = __builtin_ia32_haddpd(tsquare,tsquare);
          magmag = dtdt / (__builtin_ia32_sqrtpd(distance2)*distance2);
          dxdy *= magmag;
          dz00 *= magmag;
          b->vxvy -= dxdy * b2->massmass;
          b->vz00 -= dz00 * b2->massmass;
          b2->vxvy += dxdy * b->massmass;
          b2->vz00 += dz00 * b->massmass;
        }
      }
      for (i = 0; i < NBODIES; i++) {
        bodies[i].xy += dtdt * bodies[i].vxvy;
        bodies[i].z0 += dtdt * bodies[i].vz00;
      }
    }
}

static double energy()
{
  v2df e = {0.0, 0.0};
  v2df half = {0.5, 0.5};
  v2df sq, dxdy, dz00, distance;
  struct planet *b, *b2;
  int i, j;

  for (i = 0; i < NBODIES; i++) {
    b = &(bodies[i]);
    /* b->mass*(vx*vx + vy*vy) | b->mass*(vz*vz + 0*0) */
    sq = b->massmass * __builtin_ia32_haddpd(b->vxvy*b->vxvy, b->vz00*b->vz00);
    sq = __builtin_ia32_haddpd(sq, sq);
    e += half * sq;
    for (j = i + 1; j < NBODIES; j++) {
      b2 = &(bodies[j]);
      dxdy = b->xy - b2->xy;
      dz00 = b->z0 - b2->z0;
      /* b->mass*(vx*vx + vy*vy) | b->mass*(vz*vz + 0*0) */
      distance = __builtin_ia32_haddpd(dxdy*dxdy, dz00*dz00);
      distance = __builtin_ia32_sqrtpd(__builtin_ia32_haddpd(distance,distance));
      e -= (b->massmass * b2->massmass) / distance;
    }
  }
  return lower(e);
}

static void offset_momentum()
{
  v2df pxpy = {0.0, 0.0};
  v2df pz00 = {0.0, 0.0};
  v2df solar_mass_inv = { 1.0 / solar_mass, 1.0 / solar_mass};
  int i;
  for (i = 0; i < NBODIES; i++) {
    pxpy += bodies[i].vxvy * bodies[i].massmass;
    pz00 += bodies[i].vz00 * bodies[i].massmass;
  }
  bodies[0].vxvy = - pxpy * solar_mass_inv;
  bodies[0].vz00 = - pz00 * solar_mass_inv;
}

int main(int argc, char ** argv)
{
  offset_momentum();
  printf ("%.9f\n", energy());
  advance(atoi(argv[1]));
  printf ("%.9f\n", energy());
  return 0;
}

/* -*- mode: c -*-
 * $Id: nestedloop.gcc,v 1.1 2004-05-19 18:10:56 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int a, b, c, d, e, f, x=0;
	
    for (a=0; a<n; a++)
	for (b=0; b<n; b++)
	    for (c=0; c<n; c++)
		for (d=0; d<n; d++)
		    for (e=0; e<n; e++)
			for (f=0; f<n; f++)
			    x++;

    printf("%d\n", x);
    return(0);
}
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// Precedent C entry modified by bearophile for speed and size, 31 Jan 2006
// Compile with:  -O3 -s -std=c99 -fomit-frame-pointer

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char boolean;


static void nsieve(int m) {
    unsigned int count = 0, i, j;
    boolean * flags = (boolean *) malloc(m * sizeof(boolean));
    memset(flags, 1, m);

    for (i = 2; i < m; ++i)
        if (flags[i]) {
            ++count;
            for (j = i << 1; j < m; j += i)
//                if (flags[j]) 
                   flags[j] = 0;
    }

    free(flags);
    printf("Primes up to %8u %8u\n", m, count);
}

int main(int argc, char * argv[]) {
    int m = atoi(argv[1]);
    for (int i = 0; i < 3; i++)
        nsieve(10000 << (m-i));
    return 0;
}
/*
** The Great Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned int bits;
#define BBITS		(sizeof(bits) * 8)
#define BSIZE(x)	(((x) / 8) + sizeof(bits))
#define BMASK(x)	(1 << ((x) % BBITS))
#define BTEST(p, x)	((p)[(x) / BBITS] & BMASK(x))
#define BFLIP(p, x)	(p)[(x) / BBITS] ^= BMASK(x)

int main(int argc, char **argv)
{
  unsigned int m, sz = 10000 << (argc > 1 ? atoi(argv[1]) : 1);
  bits *primes = (bits *)malloc(BSIZE(sz));
  if (!primes) return 1;
  for (m = 0; m <= 2; m++) {
    unsigned int i, j, count = 0, n = sz >> m;
    memset(primes, 0xff, BSIZE(n));
    for (i = 2; i <= n; i++)
      if (BTEST(primes, i)) {
	count++;
	for (j = i + i; j <= n; j += i)
	  if (BTEST(primes, j)) BFLIP(primes, j);
      }
    printf("Primes up to %8d %8d\n", n, count);
  }
  free(primes);
  return 0;
}

// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// Precedent C entry modified by bearophile for speed and size, 31 Jan 2006
// Modified to use bits to hold state by mukund
// Compile with:  gcc -pipe -Wall -O3 -funroll-all-loops -march=athlon64 -m3dnow nsieve.c -o nsieve

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#define INDEX_INT(i) ((i) >> 5)
#define INDEX_BIT(i) (1 << ((i) & 0x1f))
#define INDEX_BITMASK(i) (~INDEX_BIT(i))

int
main (int argc, char *argv[])
{
  int n = atoi (argv[1]);
  unsigned int count1 = 0, count2 = 0, count4 = 0;
  unsigned int i, j, m, m2;
  uint32_t *flags;

  m = 10000 << n;

  flags = (uint32_t *) malloc ((m / sizeof (uint32_t)) + 1);
  memset (flags, 0xff, (m / sizeof (uint32_t)) + 1);

  for (i = 2; i < m; ++i)
    {
      if (flags[INDEX_INT (i)] & INDEX_BIT (i))
        {
          for (j = i * 2; j <= m; j += i)
            flags[INDEX_INT (j)] &= INDEX_BITMASK (j);

          ++count1;
          m2 = m >> 1;
          if (i < m2)
            ++count2;
          m2 = m2 >> 1;
          if (i < m2)
            ++count4;
        }
    }

  printf ("Primes up to %8u %8u\n", m, count1);
  printf ("Primes up to %8u %8u\n", m / 2, count2);
  printf ("Primes up to %8u %8u\n", m / 4, count4);

  free (flags);

  return 0;
}
/* -*- mode: c -*-
 * $Id: objinst.gcc,v 1.1 2004-05-19 18:11:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>


enum {false, true};

#define TOGGLE \
    char state; \
    char (*value)(struct Toggle *); \
    struct Toggle *(*activate)(struct Toggle *)

#define DESTROY  free

typedef struct Toggle {
    TOGGLE;
} Toggle;

char toggle_value(Toggle *this) {
    return(this->state);
}
Toggle *toggle_activate(Toggle *this) {
    this->state = !this->state;
    return(this);
}
Toggle *init_Toggle(Toggle *this, char start_state) {
    this->state = start_state;
    this->value = toggle_value;
    this->activate = toggle_activate;
    return(this);
}
Toggle *new_Toggle(char start_state) {
    Toggle *this = (Toggle *)malloc(sizeof(Toggle));
    return(init_Toggle(this, start_state));
}


typedef struct NthToggle {
    TOGGLE;
    int count_max;
    int counter;
} NthToggle;

NthToggle *nth_toggle_activate(NthToggle *this) {
    if (++this->counter >= this->count_max) {
	this->state = !this->state;
	this->counter = 0;
    }
    return(this);
}
NthToggle *init_NthToggle(NthToggle *this, int max_count) {
    this->count_max = max_count;
    this->counter = 0;
    this->activate = (Toggle *(*)(Toggle *))nth_toggle_activate;
    return(this);
}
NthToggle *new_NthToggle(char start_state, int max_count) {
    NthToggle *this = (NthToggle *)malloc(sizeof(NthToggle));
    this = (NthToggle *)init_Toggle((Toggle *)this, start_state);
    return(init_NthToggle(this, max_count));
}


int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    Toggle *tog;
    NthToggle *ntog;

    tog = new_Toggle(true);
    for (i=0; i<5; i++) {
	fputs((tog->activate(tog)->value(tog)) ? "true\n" : "false\n", stdout);
    }
    DESTROY(tog);
    for (i=0; i<n; i++) {
	tog = new_Toggle(true);
	DESTROY(tog);
    }
    
    fputs("\n", stdout);

    ntog = new_NthToggle(true, 3);
    for (i=0; i<8; i++) {
	fputs((ntog->activate(ntog)->value(ntog)) ? "true\n" : "false\n", stdout);
    }
    DESTROY(ntog);
    for (i=0; i<n; i++) {
	ntog = new_NthToggle(true, 3);
	DESTROY(ntog);
    }
    return 0;
}
/*
** The Great Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
**
** compile with:
**   gcc -O3 -fomit-frame-pointer -ffast-math -o partialsums partialsums.c -lm
**   Adding -march=<yourcpu> may help, too.
**   On a P4/K8 or later try adding: --march=<yourcpu> -mfpmath=sse -msse2 
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(int argc, char **argv)
{
  int k, n = atoi(argv[1]);
  double sum;

/*
** Yes, I tried using a double as a primary or secondary loop variable.
** But the x86 ABI requires a cleared x87 FPU stack before every call
** (e.g. to sin()) which nullifies any performance gains.
**
** Combining all loops does not pay off because the x87 FPU has to shuffle
** stack slots and/or runs out of registers. This may not be entirely true
** for SSE2 with fully inlined FPU code (-ffast-math required). Dito for
** other CPUs with a register-based FPU and a sane FP ABI.
**
** Auto vectorization may be a bit easier with separate loops, too.
*/
#define kd ((double)k)

  sum = 0.0;
  for (k = 0; k <= n; k++) {  /* pow(2.0/3.0, kd) inlined */
    double x = 1.0, q = 2.0/3.0;
    int j = k;
    for (;;) { if (j & 1) x *= q; if ((j >>= 1) == 0) break; q = q*q; }
    sum += x;
  }
  printf("%.9f\t(2/3)^k\n", sum);

  sum = 0.0;
  for (k = 1 ; k <= n; k++) sum += 1/sqrt(kd);  /* aka pow(kd, -0.5) */
  printf("%.9f\tk^-0.5\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*(kd+1.0));
  printf("%.9f\t1/k(k+1)\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double sk = sin(kd);
    sum += 1.0/(kd*kd*kd*sk*sk);
  }
  printf("%.9f\tFlint Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double ck = cos(kd);
    sum += 1.0/((kd*kd)*kd*ck*ck);
  }
  printf("%.9f\tCookson Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/kd;
  printf("%.9f\tHarmonic\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*kd);
  printf("%.9f\tRiemann Zeta\n", sum);

  sum = 0.0;
  for (k = 1; k <= n-1; k += 2) sum += 1.0/kd;
  for (k = 2; k <= n; k += 2) sum -= 1.0/kd;
  printf("%.9f\tAlternating Harmonic\n", sum);

  sum = 0.0;
  for (k = 1; k <= 2*n-1; k += 4) sum += 1.0/kd;
  for (k = 3; k <= 2*n; k += 4) sum -= 1.0/kd;
  printf("%.9f\tGregory\n", sum);

  return 0;
}

/*
** The Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
** de-optimized by Isaac Gouy
**
** compile with:
**   gcc -O3 -fomit-frame-pointer -ffast-math -o partialsums partialsums.c -lm
**   Adding -march=<yourcpu> may help, too.
**   On a P4/K8 or later try adding: --march=<yourcpu> -mfpmath=sse -msse2 
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(int argc, char **argv)
{
  int k, n = atoi(argv[1]);
  double sum, a;

/*
** Yes, I (Mike Pall) tried using a double as a primary or secondary loop variable.
** But the x86 ABI requires a cleared x87 FPU stack before every call
** (e.g. to sin()) which nullifies any performance gains.
**
** Combining all loops does not pay off because the x87 FPU has to shuffle
** stack slots and/or runs out of registers. This may not be entirely true
** for SSE2 with fully inlined FPU code (-ffast-math required). Dito for
** other CPUs with a register-based FPU and a sane FP ABI.
**
** Auto vectorization may be a bit easier with separate loops, too.
*/

#define kd ((double)k)

  sum = 0.0;
  for (k = 0; k <= n; k++) sum += pow(2.0/3.0, kd);
  printf("%.9f\t(2/3)^k\n", sum);

  sum = 0.0;
  for (k = 1 ; k <= n; k++) sum += 1/sqrt(kd);  /* aka pow(kd, -0.5) */
  printf("%.9f\tk^-0.5\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*(kd+1.0));
  printf("%.9f\t1/k(k+1)\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double sk = sin(kd);
    sum += 1.0/(kd*kd*kd*sk*sk);
  }
  printf("%.9f\tFlint Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double ck = cos(kd);
    sum += 1.0/(kd*kd*kd*ck*ck);
  }
  printf("%.9f\tCookson Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/kd;
  printf("%.9f\tHarmonic\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*kd);
  printf("%.9f\tRiemann Zeta\n", sum);

  sum = 0.0; a = -1.0;
  for (k = 1; k <= n; k++) sum += (a = -a)/kd;
  printf("%.9f\tAlternating Harmonic\n", sum);

  sum = 0.0;  a = -1.0;
  for (k = 1; k <= n; k++) sum += (a = -a)/(2.0*kd - 1.0);
  printf("%.9f\tGregory\n", sum);

  return 0;
}

//  The Computer Language Shootout
//  http://shootout.alioth.debian.org/
//  contributed by Greg Buchholz
//  
//  compile with:  -O3 -msse2 -lm

#include<math.h>
#include<stdio.h>

typedef double v2df __attribute__ ((vector_size (16)));

v2df make_vec(double a, double b)
{
    v2df v;
    double *tmp;
    tmp = (double *)&v; *(tmp) = a; *(tmp+1) = b;
    return v;
}

double sum_vec(v2df x)
{
    double *tmp = (double *)&x; 
    return *(tmp) + *(tmp+1);
}

int main(int argc, char* argv[])
{
    double  twoThrd = 0, sqrts = 0, Flint = 0, Cookson = 0;
    v2df    Harmonic, zeta, poly, alt, Gregory;
    v2df    zero, one, two, init, m_one, kv, av;
    
    double  k, k3, s, c;
    int n;  n = atoi(argv[1]);

    zero  = make_vec( 0.0,  0.0);  one   = make_vec( 1.0,  1.0);
    two   = make_vec( 2.0,  2.0);  m_one = make_vec(-1.0, -1.0);
    init  = make_vec( 1.0,  2.0);  av    = make_vec( 1.0, -1.0);
    
    Harmonic = zeta = poly = alt = Gregory = zero; 

    for (k=1; k<=n; k++)
    {
        twoThrd += pow(2.0/3.0, k-1);
        sqrts   += 1.0/sqrt(k);
              k3 = k*k*k;
              s  = sin(k); c = cos(k); 
        Flint   += 1.0/(k3 * s*s);        
        Cookson += 1.0/(k3 * c*c);
    } 

    for (kv=init; *(double *)(&kv)<=n; kv+=two)
    {
        poly    += one /(kv*(kv+one)); 
        Harmonic+= one / kv;
        zeta    += one /(kv*kv);
        alt     +=  av / kv;  
        Gregory +=  av /(two*kv - one);
    }
    
#define psum(name,num) printf("%.9f\t%s\n",num,name)
    psum("(2/3)^k",           twoThrd); psum("k^-0.5",      sqrts);
    psum("1/k(k+1)",    sum_vec(poly)); psum("Flint Hills", Flint);
    psum("Cookson Hills",     Cookson); psum("Harmonic", sum_vec(Harmonic));  
    psum("Riemann Zeta",sum_vec(zeta)); psum("Alternating Harmonic",sum_vec(alt));
    psum("Gregory",  sum_vec(Gregory));
    
    return 0;
}
/* The Computer Language Benchmarks Game
  http://shootout.alioth.debian.org/

  contributed by Paolo Bonzini & Sean Bartlett
  modified by Michael Mellor
*/

#include <stdio.h>
#include <stdlib.h>
#include <gmp.h>

static mpz_t numer, accum, denom, tmp1, tmp2;

static int extract_digit()
{
  if (mpz_cmp(numer, accum) > 0)
    return -1;

  /* Compute (numer * 3 + accum) / denom */
  mpz_mul_2exp(tmp1, numer, 1);
  mpz_add(tmp1, tmp1, numer);
  mpz_add(tmp1, tmp1, accum);
  mpz_fdiv_qr(tmp1, tmp2, tmp1, denom);

  /* Now, if (numer * 4 + accum) % denom... */
  mpz_add(tmp2, tmp2, numer);

  /* ... is normalized, then the two divisions have the same result.  */
  if (mpz_cmp(tmp2, denom) >= 0)
    return -1;

  return mpz_get_ui(tmp1);
}

static void next_term(unsigned int k)
{
  unsigned int y2 = k*2 + 1;

  mpz_mul_2exp(tmp1, numer, 1);
  mpz_add(accum, accum, tmp1);
  mpz_mul_ui(accum, accum, y2);
  mpz_mul_ui(numer, numer, k);
  mpz_mul_ui(denom, denom, y2);
}

static void eliminate_digit(unsigned int d)
{
  mpz_submul_ui(accum, denom, d);
  mpz_mul_ui(accum, accum, 10);
  mpz_mul_ui(numer, numer, 10);
}

static void pidigits(unsigned int n)
{
  int d;
  unsigned int i = 0, k = 0, m;
  mpz_init(tmp1);
  mpz_init(tmp2);
  mpz_init_set_ui(numer, 1);
  mpz_init_set_ui(accum, 0);
  mpz_init_set_ui(denom, 1);

  for(;;)
  {
    do {
      k++;
      next_term(k);
      d = extract_digit();
    } while(d == -1);

    putchar(d + '0');

    i++;
    m = i%10;
    if(m == 0)
      printf("\t:%d\n", i);
    if(i >= n)
      break;
    eliminate_digit(d);
  }

  if(m) {
    m = 10 - m;
    while(m--)
      putchar(' ');
    printf("\t:%d\n", n);
  }
}

int main(int argc, char **argv)
{
  pidigits(argc > 1 ? atoi(argv[1]) : 27);
  return 0;
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Steven Noonan
*/
 
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int
isPrime ( unsigned long _candidate )
{
    unsigned long i, limit;

	/* 0 and 1 aren't prime. */
    if ( _candidate < 2 ) return 0;

    /* All numbers less than 4 are prime, except '1' */
    if ( _candidate < 4 ) return -1;

    /* Other than 2, even numbers are not prime */
    if ( _candidate % 2 == 0 ) return 0;

	/* All primes are of the form 6k+i (where i = -1 or 1), except for 2 or 3. */
    if ( ( _candidate + 1 ) % 6 != 0
      && ( _candidate - 1 ) % 6 != 0 )
    	return 0;

    /*
       if n is composite then it can be factored into two values,
       at least one of which is less than or equal to sqrt(n)
     */
    limit = (unsigned long)sqrt ((double)_candidate);

    /* Now test all other odd numbers up to sqrt(n) */
    for ( i = 3; i <= limit; i += 2 ) if ( _candidate % i == 0 ) return 0;

    return 1;
}

unsigned long
nthPrime ( unsigned long _primeToFind )
{
    unsigned long count = 0, num;
    for ( num = 1; count < _primeToFind; num++ )
    {
        if ( isPrime ( num ) )
        {
            count++;
        }
    }
    
    /* Returning num-1 because we hit a num++ between isPrime and here. */
    return num - 1;
}

int
main ( int argc, char **argv )
{
	unsigned long i, n;
	
	if ( argc < 2 ) return -1;

	n = atoi(argv[1]);
	
	printf ( "1st prime is %d\n", nthPrime ( 1 ) );
	printf ( "2nd prime is %d\n", nthPrime ( 2 ) );

    for ( i = 10 * n; i <= 50 * n; i += 10 * n )
    {
        printf ( "%uth prime is %u\n", i, nthPrime ( i ) );
    }

    return 0;
}
/* -*- mode: c -*-
 * $Id: prodcons.gcc,v 1.1 2004-05-19 18:11:09 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t control;
void producer(int *arg);
void consumer(int *arg);
int count, data, consumed, produced;


int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    pthread_t t1, t2;
    
    count = data = consumed = produced = 0;

    if (pthread_mutex_init(&mutex, NULL)) {
	perror("pthread_mutex_init");
	exit(1);
    }
    if (pthread_cond_init(&control, NULL)) {
	perror("pthread_cond_init");
	exit(1);
    }
    if (pthread_create(&t1, (pthread_attr_t *)NULL,
		       (void * (*)(void *))producer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
    if (pthread_create(&t2, (pthread_attr_t *)NULL,
		       (void * (*)(void *))consumer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
  
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    fprintf(stdout, "%d %d\n", produced, consumed);
    return(0);
}


void producer(int *arg) {
    int i, n = *arg;
    for (i=1; i<=n; i++) {
	pthread_mutex_lock(&mutex);
	while (count == 1) {
	    pthread_cond_wait(&control, &mutex);
	}
	data = i;
	count = 1;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	produced++;
    }
}
 

void consumer(int *arg) {
    int i = 0, n = *arg;
    while (1) {
	pthread_mutex_lock(&mutex);
	while (count == 0) {
	    pthread_cond_wait(&control, &mutex);
	}
	i = data;
	count = 0;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	consumed++;
	if (i == n) return;
    }
}

/* -*- mode: c -*-
 * $Id: random.gcc,v 1.1 2004-05-19 18:11:15 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define IM 139968
#define IA 3877
#define IC 29573

inline double gen_random(double max) {
    static long last = 42;
    
    last = (last * IA + IC) % IM;
    return( max * last / IM );
}

int main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1) - 1;
    
    while (N--) {
	gen_random(100.0);
    }
    printf("%.9f\n", gen_random(100.0));
    return(0);
}
/* -*- mode: c -*-
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Jon Harrop, 2005
 * Compile: gcc -Wall -O3 -ffast-math -lm -std=c99 raytracer.c -o raytracer
 */


#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>

double delta;

typedef struct { double x, y, z; } Vec;
Vec vec(double ix, double iy, double iz)
{ Vec a; a.x = ix; a.y = iy; a.z = iz; return a; }
Vec add(Vec a, Vec b) { return vec(a.x + b.x, a.y + b.y, a.z + b.z); }
Vec sub(Vec a, Vec b) { return vec(a.x - b.x, a.y - b.y, a.z - b.z); }
Vec scale(double a, Vec b) { return vec(a * b.x, a * b.y, a * b.z); }
double dot(Vec a, Vec b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
Vec unitise(Vec a) { return scale(1 / sqrt(dot(a, a)), a); }

typedef struct { Vec orig, dir; } Ray;
Ray ray(Vec o, Vec d) { Ray r; r.orig = o; r.dir = d; return r; }

typedef enum {SphereTag, GroupTag} Tag;
typedef struct { Vec center; double radius; } Sphere;
Sphere sphere(Vec c, double r) { Sphere s; s.center=c; s.radius=r; return s; }
typedef struct { Sphere bound; int n; void *child; } Group;
typedef struct { Tag tag; union { Sphere s; Group g; } data; } Scene;

double ray_sphere(const Ray *r, const Sphere *s) {
  Vec v = sub(s->center, r->orig);
  double b = dot(v, r->dir), disc = b*b - dot(v, v) + s->radius * s->radius;
  if (disc < 0) return INFINITY;
  double d = sqrt(disc), t2 = b + d;
  if (t2 < 0) return INFINITY;
  double t1 = b - d;
  return (t1 > 0 ? t1 : t2);
}

void intersect(double *lambda, Vec *normal, const Ray *r, const Scene scene) {
  switch (scene.tag) {
  case SphereTag : {
    Sphere s = scene.data.s;
    double l = ray_sphere(r, &s);
    if (l >= *lambda) return;
    *lambda = l;
    *normal = unitise(add(r->orig, sub(scale(l, r->dir), s.center)));
    break;
  }
  case GroupTag : {
    Group g = scene.data.g;
    if (ray_sphere(r, &g.bound) >= *lambda) return;
    for (int i=0; i<g.n; ++i)
      intersect(lambda, normal, r, ((Scene *)g.child)[i]);
    break;
  }
  }
}

double ray_trace(Vec light, Ray r, Scene scene) {
  double lambda = INFINITY;
  Vec n = vec(0, 0, 0);
  intersect(&lambda, &n, &r, scene);
  if (lambda == INFINITY) return 0;
  double g = dot(n, light), l = INFINITY;
  if (g <= 0) return 0.;
  Ray r2 = ray(add(r.orig, scale(lambda, add(r.dir, scale(delta, n)))),
	       light);
  intersect(&l, &n, &r2, scene);
  return (l == INFINITY ? g : 0);
}

Scene create(int level, double r, double x, double y, double z) {
  Scene scene;
  if (level == 1) {
    scene.tag = SphereTag;
    scene.data.s = sphere(vec(x, y, z), r);
  } else {
    Group *g = &scene.data.g;
    Scene *cs;
    scene.tag = GroupTag;
    g->bound = sphere(vec(x, y, z), 3*r);
    g->n = 5;
    g->child = cs = (Scene *)malloc(g->n * sizeof(Scene));
    double rn = 3*r/sqrt(12.);
    for (int i=0; i<4; ++i)
      cs[i] = create(level-1, r/2,
		     x - ((i&1)*2-1)*rn, y + rn, z - ((i/2)*2-1)*rn);
    cs[g->n - 1] = create(1, r, x, y, z);
  }
  return scene;
}

void destroy(Scene scene) {
  if (scene.tag == GroupTag) {
    for (int i=0; i<scene.data.g.n; ++i)
      destroy(((Scene *)scene.data.g.child)[i]);
    free(scene.data.g.child);
  }
}

int main(int argc, char *argv[]) {
  delta = sqrt(DBL_EPSILON);
  int level = 6, n = (argc==2 ? atoi(argv[1]) : 256), ss = 4;
  Vec light = sub(vec(0, 0, 0), unitise(vec(-1, -3, 2)));
  Scene scene = create(level, 1, 0, -1, 0); // Build the scene
  printf("P5\n%d %d\n255\n", n, n);
  for (int y=n-1; y>=0; --y)
    for (int x=0; x<n; ++x) {
      double g=0;
      for (int dx=0; dx<ss; ++dx)
	for (int dy=0; dy<ss; ++dy) {
	  Vec d=vec(x+(double)dx/ss-n/2., y+(double)dy/ss-n/2., n);
	  g += ray_trace(light, ray(vec(0, 0, -4), unitise(d)), scene);
	}
      printf("%c", (char)(.5 + 255*g/(ss*ss)));
    }
  destroy(scene);
  return 0;
}
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>

#ifndef INFINITY
# define INFINITY DBL_MAX
#endif

#define DELTA 1.49012e-08

typedef struct { double x, y, z; } Vec;
static __inline__ Vec vec(double ix, double iy, double iz)
{ Vec a; a.x = ix; a.y = iy; a.z = iz; return a; }
static __inline__ Vec add(Vec a, Vec b) { return vec(a.x + b.x, a.y + b.y, a.z + b.z); }
static __inline__ Vec sub(Vec a, Vec b) { return vec(a.x - b.x, a.y - b.y, a.z - b.z); }
static __inline__ Vec scale(double a, Vec b) { return vec(a * b.x, a * b.y, a * b.z); }
static __inline__ double dot(Vec a, Vec b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
static __inline__ Vec unitise(Vec a) { return scale(1 / sqrt(dot(a, a)), a); }

typedef struct { Vec orig, dir; } Ray;
static __inline__ Ray ray(Vec o, Vec d) { Ray r; r.orig = o; r.dir = d; return r; }

typedef struct _tSphere Sphere;
typedef struct _tGroup Group;
typedef struct _tScene_Object Scene;

#define SCENE_OBJECT(T) \
   void (*intersect) (T*, double *, Vec *, const Ray *); \
   void (*destroy) (T *)

struct _tScene_Object
{
   SCENE_OBJECT(Scene);
};
static Scene *scene_new (int, double, double, double, double);

struct _tSphere
{ 
   SCENE_OBJECT(Sphere);
   Vec center; double radius; 
};

static __inline__ double ray_sphere (const Ray *r, const Sphere *s) 
{
   double d, t1, t2;
   Vec v = sub(s->center, r->orig);
   double b = dot(v, r->dir), disc = b*b - dot(v, v) + s->radius * s->radius;
   if (disc < 0) return INFINITY;
   d = sqrt(disc), t2 = b + d;
   if (t2 < 0) return INFINITY;
   t1 = b - d;
   return (t1 > 0 ? t1 : t2);
}

static void sphere_intersect (Sphere *s, double *lambda, Vec *normal, const Ray *r)
{
   double l = ray_sphere(r, s);
   if (l >= *lambda) return;
   *lambda = l;
   *normal = unitise (add(r->orig, sub(scale(l, r->dir), s->center)));
}

static void sphere_destroy (Sphere *s)
{
   free ((char *)s);
}

static Sphere *sphere_new (double r, double x, double y, double z)
{
   Sphere *s = (Sphere *) calloc (1, sizeof (Sphere));
   s->intersect = sphere_intersect;
   s->destroy = sphere_destroy;
   s->center=vec(x,y,z); s->radius=r; 
   return s; 
}

struct _tGroup
{
   SCENE_OBJECT(Group);
   Sphere *bound;
#define NUM_GROUP_MEMBERS 5
   Scene *members[NUM_GROUP_MEMBERS];
};

static void group_intersect (Group *g, double *lambda, Vec *normal, const Ray *r)
{
   int i;

   if (ray_sphere (r, g->bound) >= *lambda) 
     return;

   for (i = 0; i < NUM_GROUP_MEMBERS; i++)
     {
	Scene *s = g->members[i];
	(*s->intersect) (s, lambda, normal, r);
     }
}

static void group_destroy (Group *g)
{
   int i;

   (*g->bound->destroy) (g->bound);
   for (i = 0; i < NUM_GROUP_MEMBERS; i++)
     {
	Scene *s = g->members[i];
	(*s->destroy) (s);
     }
   free ((char *)g);
}

static Group *group_new (int level, double r, double x, double y, double z)
{
   static double dz[NUM_GROUP_MEMBERS] = {-1, -1, 1, 1, 0};
   static double dx[NUM_GROUP_MEMBERS] = {-1, 1, -1, 1, 0};
   double rn;
   int i;
   Group *g = (Group *)calloc (1, sizeof (Group));
   g->intersect = group_intersect;
   g->destroy = group_destroy;
   g->bound = sphere_new (3*r, x, y, z);
   rn = 3*r/sqrt(12.0);
   for (i = 0; i < NUM_GROUP_MEMBERS-1; i++)
     g->members[i] = scene_new (level, 0.5*r, x-dx[i]*rn, y+rn, z-dz[i]*rn);
   g->members[NUM_GROUP_MEMBERS-1] = scene_new (1, r, x, y, z);
   
   return g;
}

static Scene *scene_new (int level, double r, double x, double y, double z)
{
   if (level == 1)
     return (Scene *) sphere_new (r, x, y, z);
   return (Scene *) group_new (level-1, r, x, y, z);
}


static double ray_trace (Vec light, Ray r, Scene *scene) 
{
   double lambda = INFINITY, l, g;
   Ray r2;
   Vec n = vec(0, 0, 0);
   (*scene->intersect) (scene, &lambda, &n, &r);
   if (lambda == INFINITY) return 0.0;
   if ((g = dot(n, light)) <= 0.0)
     return 0.0;
   l = INFINITY;
   r2 = ray(add(r.orig, scale(lambda, add(r.dir, scale(DELTA, n)))), light);
   (*scene->intersect) (scene, &l, &n, &r2);
   return (l == INFINITY ? g : 0.0);
}

int main (int argc, char *argv[]) 
{
   int x, y, dx, dy, level, n, ss;
   Vec light;
   Scene *scene;
   level = 6, n = (argc==2 ? atoi(argv[1]) : 256), ss = 4;
   light = sub(vec(0, 0, 0), unitise(vec(-1, -3, 2)));
   scene = scene_new (level, 1, 0, -1, 0);  /* Build the scene */
   fprintf (stdout, "P5\n%d %d\n255\n", n, n);
   for (y=n-1; y>=0; --y)
     {
	for (x=0; x<n; ++x) 
	  {
	     double g=0.0;
	     for (dx=0; dx<ss; ++dx)
	       {
		  for (dy=0; dy<ss; ++dy) 
		    {
		       Vec d=vec(x+(double)dx/ss-n/2., y+(double)dy/ss-n/2., n);
		       g += ray_trace(light, ray(vec(0, 0, -4), unitise(d)), scene);
		    }
	       }
	     putc ((char)(.5 + 255*g/(ss*ss)),stdout);
	  }
    }
   (*scene->destroy)(scene);
   return 0;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/

 * contributed by bearophile, Jan 24 2006
 * modified by wolfjb, Feb 28 2007
 * modified by alex burlyga, may 16, 2008
 */
#include <stdio.h>
#include <stdlib.h>

static inline int ack(register int x, register int y) __attribute__((const));
static inline int fib(int n) __attribute__((const));
static inline double fibFP(double n) __attribute__((const));
static inline int tak(int x, int y, int z) __attribute__((const));
static inline double takFP(double x, double y, double z) __attribute__((const));

static inline int ack(register int x, register int y){
  if (x == 0) {
    return y + 1;
  }

  return ack(x - 1, ((y | 0) ? ack(x, y - 1) : 1));
}

static inline int fib(register int n) {
  if (n < 2) {
    return 1;
  }
  return fib(n - 2) + fib(n - 1);
}

static inline double fibFP(double n) {
  if (n < 2.0) {
    return 1.0;
  }
  return fibFP(n - 2.0) + fibFP(n - 1.0);
}

static inline int tak(register int x, register int y, register int z) {
  if (y < x) {
    return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y));
  }
  return z;
}

static inline double takFP(double x, double y, double z) {
    if (y < x)
        return takFP( takFP(x-1.0, y, z), takFP(y-1.0, z, x), takFP(z-1.0, x, y) );
    return z;
}

int
main(int argc, char ** argv) {
  int n = 3;

  if(argc > 1) {
    n = strtol(argv[1], NULL, 10) - 1;
  }

  printf("Ack(3,%d): %d\n", n + 1, ack(3, n+1));
  printf("Fib(%.1f): %.1f\n", 28.0 + n, fibFP(28.0+n));
  printf("Tak(%d,%d,%d): %d\n", 3 * n, 2 * n, n, tak(3*n, 2*n, n));
  printf("Fib(3): %d\n", fib(3));
  printf("Tak(3.0,2.0,1.0): %.1f\n", takFP(3.0, 2.0, 1.0));

  return 0;
}
/*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/

 * contributed by bearophile, Jan 24 2006
 * modified by wolfjb, Feb 28 2007
 */
#include <stdio.h>

int ack(int x, int y) {
  if (x == 0) {
    return y + 1;
  }

  return ack(x - 1, ((y | 0) ? ack(x, y - 1) : 1));
}

int fib(int n) {
  if (n < 2) {
    return 1;
  }
  return fib(n - 2) + fib(n - 1);
}

double fibFP(double n) {
  if (n < 2.0) {
    return 1.0;
  }
  return fibFP(n - 2.0) + fibFP(n - 1.0);
}

int tak(int x, int y, int z) {
  if (y < x) {
    return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y));
  }
  return z;
}

double takFP(double x, double y, double z) {
    if (y < x)
        return takFP( takFP(x-1.0, y, z), takFP(y-1.0, z, x), takFP(z-1.0, x, y) );
    return z;
}

int main(int argc, char ** argv) {
  int n = atoi(argv[1]) - 1;

  printf("Ack(3,%d): %d\n", n + 1, ack(3, n+1));
  printf("Fib(%.1f): %.1f\n", 28.0 + n, fibFP(28.0+n));
  printf("Tak(%d,%d,%d): %d\n", 3 * n, 2 * n, n, tak(3*n, 2*n, n));
  printf("Fib(3): %d\n", fib(3));
  printf("Tak(3.0,2.0,1.0): %.1f\n", takFP(3.0, 2.0, 1.0));

  return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Paul Serice
*/

#include <sys/types.h>
#include <pthread.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <tcl.h>

/*************************************************************************
 * Data Structures and Typedefs
 *************************************************************************/

/* Mapping of a nucleic acid code to its meaning.  This is used with
 * regsub() to substitute each occurrence of "code" in the main input
 * string with its "meaning." */
static struct nucleic_acid_code {
    char* code;
    char* meaning;
} nacodes[] = {{"B", "(c|g|t)"},
               {"D", "(a|g|t)"},
               {"H", "(a|c|t)"},
               {"K", "(g|t)"},
               {"M", "(a|c)"},
               {"N", "(a|c|g|t)"},
               {"R", "(a|g)"},
               {"S", "(c|g)"},
               {"V", "(a|c|g)"},
               {"W", "(a|t)"},
               {"Y", "(c|t)"},
               {NULL, NULL}
};

/* The variants are used with regcount() to count the number of times
 * each variant appears in the main input string. */
static const char* variants[] = {
  "agggtaaa|tttaccct",
  "[cgt]gggtaaa|tttaccc[acg]",
  "a[act]ggtaaa|tttacc[agt]t",
  "ag[act]gtaaa|tttac[agt]ct",
  "agg[act]taaa|ttta[agt]cct",
  "aggg[acg]aaa|ttt[cgt]ccct",
  "agggt[cgt]aa|tt[acg]accct",
  "agggta[cgt]a|t[acg]taccct",
  "agggtaa[cgt]|[acg]ttaccct",
  NULL
};


/* To process the variants, a small thread pool is created.  Each
 * thread is passed an array of these tasks.  The threads combine to
 * perform the tasks.  When there are no more tasks, the threads exit
 * and the parent joins with them before continuing. */
typedef struct variant_worker_task {

    /* input: which variant to process */
    const char* variant;

    /* input: string against which "variant" will be matched */
    Tcl_Obj* s;

    /* output: number of times "variant" matched against "s" */
    unsigned long int count;

} *variant_worker_task_t;


/* Data passed into each thread that process the variants.  All the
 * threads in the pool share one copy of this data structure and must
 * use "lock" to synchronize access to it. */
typedef struct variant_worker_data {

    /* shared: lock that protects this structure */
    pthread_mutex_t lock;

    /* shared: array of tasks that the threads are trying to complete */
    variant_worker_task_t tasks;

    /* shared: pointer to shared index into "tasks" */
    volatile int next_task;

    /* shared: total number of tasks in the "tasks" array */
    int total_tasks;

} *variant_worker_data_t;


/* Data passed into each thread that substitutes nucleic acid codes. */
typedef struct nacodes_worker_data {

    /* input/output: String object that is input to the thread as a
     * copy of the range of characters from the main input string over
     * which the thread should work.  The thread should call
     * Tcl_SetStringObj() to set "range" to hold the result of the
     * substitutions. */
    Tcl_Obj* range;

} *nacodes_worker_data_t;


/* Create an explicit typedef for the pthread start functions. */
typedef void* (*thread_start_t)(void*);

/*************************************************************************
 * regcount()
 *************************************************************************/

/* Return the number of times the regular expression "regexp_cstr"
 * uniquely matches against the input string "s". */
static unsigned long
regcount(const char* regexp_cstr,
         Tcl_Obj* s)
{
    int regexec_rv = 0;
    int index = 0;
    int index_max = 0;
    unsigned long rv = 0;
    Tcl_Obj* regexp_cstr_obj = NULL;
    Tcl_RegExp regexp = NULL;
    struct Tcl_RegExpInfo info = {0};

    /* Get "regexp_cstr" as a Tcl string object. */
    regexp_cstr_obj = Tcl_NewStringObj(regexp_cstr, strlen(regexp_cstr));
    Tcl_IncrRefCount(regexp_cstr_obj);

    /* Compile the regular expression. */
    regexp = Tcl_GetRegExpFromObj(NULL, regexp_cstr_obj,
                 TCL_REG_ADVANCED | TCL_REG_NOCASE | TCL_REG_NEWLINE);
    if (!regexp) {
        fprintf(stderr, "*** Error: Tcl_GetRegExpFromObj: failed");
        exit(1);
    }

    /* Iterate over each match. */
    index = 0;
    index_max = Tcl_GetCharLength(s);
    while (index < index_max) {

        /* Test for a match. */
        regexec_rv = Tcl_RegExpExecObj(NULL, regexp, s, index, 1, 0);
        if (regexec_rv == -1) {
            fprintf(stderr, "*** Error: Tcl_RegExpExecObj: failed");
            exit(1);
        }
        if (regexec_rv == 0) {
            /* No matches. */
            break;
        }

        /* Get the match information. */
        Tcl_RegExpGetInfo(regexp, &info);

        /* Advance curr. */
        index += info.matches[0].end;

        /* Increment the match count. */
        ++rv;
    }

    /* Clean up.  Note that "regexp" is owned by "regexp_cstr_obj" so
     * it does not need explicit clean up. */
    Tcl_DecrRefCount(regexp_cstr_obj);

    return rv;
}

/*************************************************************************
 * regsub()
 *************************************************************************/

/* Substitute each occurrence of the regular expression "regex" in "s"
 * with "subst".  The result is returned in a newly allocate string
 * that must be freed with g_free(). */
static char*
regsub(const char* regex,
       const char* s,
       const char* subst,
       GError** err)
{
    char* rv = NULL;
    GRegex* prog = NULL;

    /* How glib propagates exceptions. */
    if (err && *err) {
        goto out;
    }

    /* Compile regex. */
    prog = g_regex_new(regex,
                       G_REGEX_CASELESS |
                       G_REGEX_RAW |
                       G_REGEX_NO_AUTO_CAPTURE |
                       G_REGEX_OPTIMIZE,
                       0,
                       err);
    if (err && *err) {
        goto out;
    }

    /* Substitute. */
    rv = g_regex_replace_literal(prog, s, -1, 0, subst, 0, err);
    if (err && *err) {
        goto out;
    }

 out:

    /* Clean up. */
    if (prog) {
        g_regex_unref(prog);
    }

    return rv;
}

/*************************************************************************
 * load_file()
 *************************************************************************/

/* Load the file f into the string s. */
static void
load_file(FILE* f,
          Tcl_Obj* s)
{
    char* block = NULL;
    size_t block_size = 16384;
    size_t rcount = 0;

    /* Allocate a block for I/O. */
    block = malloc(block_size);
    if (!block) {
        perror("malloc");
        exit(1);
    }

    /* Iterate over each block of input. */
    for (;;) {

        /* Read a block. */
        rcount = fread(block, 1, block_size, f);
        if (rcount == 0) {
            /* Check for errors. */
            if (ferror(f)) {
                perror("fread");
                exit(1);
            }
            /* EOF */
            break;
        }

        /* Append a block. */
        Tcl_AppendToObj(s, block, rcount);
    }

    /* Free block. */
    free(block);
}

/*************************************************************************
 * process_variant_worker() and process_variants()
 *************************************************************************/

/* This is a helper function for process_variant_worker() which is the
 * start routine for the threads that count how many times a variant
 * matches the main input string.  This routing locks "data" and
 * attempts to get the index of the next task.  If successful, it
 * takes ownership of that index by incrementing "data->next_task" so
 * that the next thread that comes along will get the next task.
 * Before returning, this routine releases the lock.  This routine
 * returns true if successful and false otherwise. */
static int
get_variant_index(variant_worker_data_t data,
                  int* index)
{
    int rv = 0;

    /* Lock "data". */
    pthread_mutex_lock(&data->lock);

    /* Get the index for the next task if any remain. */
    if (data->next_task < data->total_tasks) {
        *index = data->next_task++;
        rv = 1;
    }

    /* Unlock "data". */
    pthread_mutex_unlock(&data->lock);

    return rv;
}

/* This is the worker routine for the thread pool that processes the
 * variants.  This routine atomically gets the next task which holds
 * all the information needed to count the number of times the task's
 * "variant" value matches the main input string and stores the result
 * in the task's "count" value.  The main input string is passed in as
 * the task's read-only "s" value. */
static void*
process_variant_worker(variant_worker_data_t data)
{
    int index = 0;

    /* Carefully get the index for the next task. */
    while (get_variant_index(data, &index)) {
        /* Perform the task of counting regex matches. */
        data->tasks[index].count
            = regcount(data->tasks[index].variant,
                       data->tasks[index].s);
    }

    return NULL;
}

/* Process the list of variants by counting the frequency of each
 * regexp in the main input string "s" and printing the results. */
static void
process_variants(int cpu_count,
                 Tcl_Obj* s)
{
    int i = 0;
    int s_length = 0;
    int thread_rv = 0;
    int thread_count = 0;
    int task_count = 0;
    pthread_t* threads = NULL;
    variant_worker_task_t tasks = NULL;
    struct variant_worker_data data = {PTHREAD_MUTEX_INITIALIZER,};

    /* WARNING: Tcl_RegExpExecObj() always does an internal conversion
     * of "s" to a UCS-2 Unicode string if "s" is in UTF-8 format.
     * Normally, this is a nice feature, but as of tcl-8.5, it doesn't
     * appear to be thread-safe.  As a work-around, force the
     * conversion now before starting the threads. */
    Tcl_GetUnicodeFromObj(s, &s_length);

    /* Determine the total number of variants (minus the NULL sentinel). */
    task_count = (int)(sizeof(variants) / sizeof(variants[0]) - 1);

    /* Determine the number of threads to start. */
    thread_count = cpu_count * 2;
    if (thread_count > task_count) {
        thread_count = task_count;
    }

    /* Allocate the "threads" array which holds the thread IDs. */
    threads = calloc(thread_count, sizeof(*threads));
    if (!threads) {
        perror("calloc");
        exit(1);
    }

    /* Allocate the "tasks" array which holds one unit of work per
     * element in the array. */
    tasks = calloc(task_count, sizeof(*tasks));
    if (!tasks) {
        perror("calloc");
        exit(1);
    }

    /* Initialize the task array. */
    for (i = 0 ; i < task_count ; ++i) {
        tasks[i].variant = variants[i];
        tasks[i].s = s;
        tasks[i].count = 0;
    }

    /* Initialize the data shared by the threads. */
    data.tasks = tasks;
    data.next_task = 0;
    data.total_tasks = task_count;

    /* Start the threads. */
    for (i = 0 ; i < thread_count ; ++i) {
        thread_rv = pthread_create(&threads[i],
                                   NULL,
                                   (thread_start_t)process_variant_worker,
                                   &data);
        if (thread_rv) {
            fprintf(stderr, "*** Error: pthread_create: failed");
            exit(1);
        }
    }

    /* Wait for each thread to finish. */
    for (i = 0 ; i < thread_count ; ++i) {
        thread_rv = pthread_join(threads[i], NULL);
        if (thread_rv) {
            fprintf(stderr, "*** Error: pthread_join: failed");
            exit(1);
        }
    }

    /* Print results. */
    for (i = 0 ; i < task_count ; ++i) {
        printf("%s %lu\n", variants[i], tasks[i].count);
    }

    /* Clean up. */
    free(tasks);
    free(threads);
}

/*************************************************************************
 * process_nacodes_worker() and process_nacodes()
 *************************************************************************/

/* This is the worker routing for the threads that process the
 * substitution of the nucleic acid codes with their meanings.  These
 * threads are not in a thread pool because the work can be divided
 * exactly into one thread per cpu.  So the parent just starts each
 * thread and waits for them all to finish.
 *
 * Each worker gets a range of characters from the main input string
 * and is responsible for calling regsub() once for each nucleic acid
 * code.  Thus, if there are 11 nucleic acid codes, each thread calls
 * regsub() 11 times but the scope of the regsub() call is limited to
 * just the range of characters it has been assigned. */
static void*
process_nacodes_worker(nacodes_worker_data_t data)
{
    char* s_in = NULL;
    char* s_out = NULL;
    struct nucleic_acid_code* nacode = NULL;

    /* Get the character range as a C-style string. */
    s_in = Tcl_GetString(data->range);

    /* Iterate over the nucleic acid codes. */
    for (nacode = nacodes ; nacode->code ; ++nacode) {

        /* Perform the substitution. */
        s_out = regsub(nacode->code, s_in, nacode->meaning, NULL);

        /* Free s_in on all but the first pass because s_in
         * belongs to Tcl on the first pass. */
        if (nacode != nacodes) {
            g_free(s_in);
            s_in = NULL;
        }
        /* If this is the last pass, save the result and clean up. */
        if ((nacode + 1)->code == NULL) {
            Tcl_SetStringObj(data->range, s_out, strlen(s_out));
            g_free(s_out);
            s_out = NULL;
        } else {
            /* Otherwise, prepare for the next iteration. */
            s_in = s_out;
            s_out = NULL;
        }
    }

    return NULL;
}

/* Process the nucleic acid codes by substituting each nucleic acid
 * code in "s" with its meaning as defined in the static "nacodes"
 * structure (see top of file).  On return, "s" will hold the
 * substituted string. */
static void
process_nacodes(int cpu_count,
                Tcl_Obj* s)
{
    int i = 0;
    int first = 0;
    int last = 0;
    int s_length = 0;
    int range_length = 0;
    int thread_rv = 0;
    nacodes_worker_data_t data = NULL;
    pthread_t* threads = NULL;

    /* Sanity check to make sure we don't divide by zero. */
    if (cpu_count == 0) {
        return;
    }

    /* Get the total length of s. */
    s_length = Tcl_GetCharLength(s);
    if (s_length == 0) {
        return;
    }

    /* Allocate the "data" array which is used to pass data to and
     * from the threads. */
    data = calloc(cpu_count, sizeof(*data));

    /* Allocate the "threads" array which holds the thread IDs. */
    threads = calloc(cpu_count, sizeof(*threads));

    /* Calculate the number of characters to feed each thread.  Note
     * that we checked above to make sure cpu_count is not zero. */
    range_length = s_length / cpu_count;

    /* Start one thread for each cpu. */
    for (i = 0 ; i < cpu_count ; ++i) {

        /* First, initialize the thread's client data. */

        /* Calculate the first and last index for the range.  Both
         * "first" and "last" indexes are inclusive because that is
         * what Tcl_GetRange() requires.  We also need to make sure
         * the very last range has all the characters in case
         * range_length does not divide s_length evenly. */
        first = range_length * i;
        last = range_length * (i + 1) - 1;
        if (i + 1 == cpu_count) {
            last = s_length - 1;
        }

        /* Pack the data for the worker thread. */
        data[i].range = Tcl_GetRange(s, first, last);
        Tcl_IncrRefCount(data[i].range);

        /* Second, start the thread. */
        thread_rv = pthread_create(&threads[i],
                                   NULL,
                                   (thread_start_t)process_nacodes_worker,
                                   &data[i]);
        if (thread_rv) {
            fprintf(stderr, "*** Error: pthread_create: failed");
            exit(1);
        }
    }

    /* Wait for each thread to finish. */
    for (i = 0 ; i < cpu_count ; ++i) {
        thread_rv = pthread_join(threads[i], NULL);
        if (thread_rv) {
            fprintf(stderr, "*** Error: pthread_join: failed");
            exit(1);
        }
    }

    /* Merge results. */
    Tcl_SetObjLength(s, 0);
    for (i = 0 ; i < cpu_count ; ++i) {
        Tcl_AppendObjToObj(s, data[i].range);
    }

    /* Clean up. */
    for (i = 0 ; i < cpu_count ; ++i) {
        Tcl_DecrRefCount(data[i].range);
    }
    free(threads);
    free(data);
}

/*************************************************************************
 * get_cpu_count()
 *************************************************************************/

/* Return the number of cpus.  If an error occurs, 0 cpus will be
 * reported.  There are other ways to do this, but this is a program
 * to test regexp processing so ... */
static int
get_cpu_count(void)
{
    int rv = 0;
    FILE* f = NULL;
    Tcl_Obj* s = NULL;

    /* Allocate a string. */
    s = Tcl_NewStringObj("", 0);
    Tcl_IncrRefCount(s);

    /* Open /proc/cpuinfo. */
    f = fopen("/proc/cpuinfo", "r");
    if (!f) {
        goto out;
    }

    /* Load file into s. */
    load_file(f, s);

    /* Count the number of cpus.  "\M" matches at the end of a word. */
    rv = regcount("^processor\\M", s);

 out:

    /* Clean up. */
    if (f) {
        fclose(f);
    }
    if (s) {
        Tcl_DecrRefCount(s);
    }

    return rv;
}

/*************************************************************************
 * main()
 *************************************************************************/

int
main(int argc,
     char* argv[])
{
    int rv = 0;
    int cpu_count = 0;
    int init_length = 0;
    int code_length = 0;
    int seq_length = 0;
    char* s_cstr = NULL;
    Tcl_Interp *tcl = NULL;
    Tcl_Obj* s = NULL;

    /* Initialize Tcl. */
    Tcl_FindExecutable(argv[0]);
    tcl = Tcl_CreateInterp();
    Tcl_Preserve((ClientData)tcl);

    /* Count the number of cpus.  If the cpu count could not be
     * determined, assume 4 cpus. */
    cpu_count = get_cpu_count();
    if (!cpu_count) {
        cpu_count = 4;
    }

    /* Allocate s. */
    s = Tcl_NewStringObj("", 0);
    Tcl_IncrRefCount(s);

    /* Load stdin into s. */
    load_file(stdin, s);

    /* Get the length of s. */
    init_length = Tcl_GetCharLength(s);

    /* Strip off section headers and EOLs from s.  This is a little
     * messy because we have to go from Tcl-string to C-string and
     * back to Tcl-string. */
    s_cstr = regsub("(>.*)|\n", Tcl_GetString(s), "", NULL);
    Tcl_SetStringObj(s, s_cstr, strlen(s_cstr));
    g_free(s_cstr);
    s_cstr = NULL;

    /* Get the length of s. */
    code_length = Tcl_GetCharLength(s);

    /* Process the variants by counting them and printing the results. */
    process_variants(cpu_count, s);

    /* Substitute nucleic acid codes in s with their meanings. */
    process_nacodes(cpu_count, s);

    /* Get the length of s. */
    seq_length = Tcl_GetCharLength(s);

    /* Print the lengths. */
    printf("\n%d\n%d\n%d\n", init_length, code_length, seq_length);

    /* Clean up. */
    Tcl_DecrRefCount(s);

    /* Finalize Tcl. */
    Tcl_Release((ClientData)tcl);
    Tcl_Exit(rv);

    /* Not reached. */
    return rv;
}
/*
** The Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
**
** regex-dna benchmark using PCRE
**
** compile with:
**   gcc -O3 -fomit-frame-pointer -o regexdna regexdna.c -lpcre
*/

#define __USE_STRING_INLINES
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pcre.h>

typedef struct fbuf {
  char *buf;
  size_t size, len;
} fbuf_t;

static void fb_init(fbuf_t *b)
{
  b->buf = NULL;
  b->len = b->size = 0;
}

static char *fb_need(fbuf_t *b, size_t need)
{
  need += b->len;
  if (need > b->size) {
    if (b->size == 0) b->size = need;
    else while (need > b->size) b->size += b->size;
    if (!(b->buf = realloc(b->buf, b->size))) exit(1);
  }
  return b->buf+b->len;
}

#define FB_MINREAD	(3<<16)

/* Read all of a stdio stream into dst buffer. */
static size_t fb_readall(fbuf_t *dst, FILE *fp)
{
  char *dp;
  int n;
  for (dp = fb_need(dst, FB_MINREAD);
       (n = fread(dp, 1, dst->size-dst->len, fp)) > 0;
       dp = fb_need(dst, FB_MINREAD)) dst->len += n;
  if (ferror(fp)) exit(1);
  return dst->len;
}

/* Substitute pattern p with replacement r, copying from src to dst buffer. */
static size_t fb_subst(fbuf_t *dst, fbuf_t *src, const char *p, const char *r)
{
  pcre *re;
  pcre_extra *re_ex;
  const char *re_e;
  char *dp;
  int re_eo, m[3], pos, rlen, clen;
  if (!(re = pcre_compile(p, PCRE_CASELESS, &re_e, &re_eo, NULL))) exit(1);
  re_ex = pcre_study(re, 0, &re_e);
  for (dst->len = 0, rlen = strlen(r), pos = 0;
       pcre_exec(re, re_ex, src->buf, src->len, pos, 0, m, 3) >= 0;
       pos = m[1]) {
    clen = m[0]-pos;
    dp = fb_need(dst, clen+rlen);
    dst->len += clen+rlen;
    memcpy(dp, src->buf+pos, clen);
    memcpy(dp+clen, r, rlen);
  }
  clen = src->len-pos;
  dp = fb_need(dst, clen);
  dst->len += clen;
  memcpy(dp, src->buf+pos, clen);
  return dst->len;
}

/* Count all matches with pattern p in src buffer. */
static int fb_countmatches(fbuf_t *src, const char *p)
{
  pcre *re;
  pcre_extra *re_ex;
  const char *re_e;
  int re_eo, m[3], pos, count;
  if (!(re = pcre_compile(p, PCRE_CASELESS, &re_e, &re_eo, NULL))) exit(1);
  re_ex = pcre_study(re, 0, &re_e);
  for (count = 0, pos = 0;
       pcre_exec(re, re_ex, src->buf, src->len, pos, 0, m, 3) >= 0;
       pos = m[1]) count++;
  return count;
}

static const char *variants[] = {
  "agggtaaa|tttaccct",         "[cgt]gggtaaa|tttaccc[acg]",
  "a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
  "agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
  "agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
  "agggtaa[cgt]|[acg]ttaccct", NULL
};

static const char *subst[] = {
  "B", "(c|g|t)", "D", "(a|g|t)",   "H", "(a|c|t)", "K", "(g|t)",
  "M", "(a|c)",   "N", "(a|c|g|t)", "R", "(a|g)",   "S", "(c|g)",
  "V", "(a|c|g)", "W", "(a|t)",     "Y", "(c|t)",   NULL
};

int main(int argc, char **argv)
{
  fbuf_t seq[2];
  const char **pp;
  size_t ilen, clen, slen;
  int flip;
  fb_init(&seq[0]);
  fb_init(&seq[1]);
  ilen = fb_readall(&seq[0], stdin);
  clen = fb_subst(&seq[1], &seq[0], ">.*|\n", "");
  for (pp = variants; *pp; pp++)
    printf("%s %d\n", *pp, fb_countmatches(&seq[1], *pp));
  for (slen = 0, flip = 1, pp = subst; *pp; pp += 2, flip = 1-flip)
    slen = fb_subst(&seq[1-flip], &seq[flip], *pp, pp[1]);
  printf("\n%zu\n%zu\n%zu\n", ilen, clen, slen);
  return 0;
}

// The Computer Language Benchmarks Game
// http://shootout.alioth.debian.org/
//
// Based on C contribution of Mike Pall
// Contributed by The Anh Tran

#define _GNU_SOURCE
#include <omp.h>
#include <sched.h>
#include <pcre.h>

#include <assert.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>


// read all redirected data from stdin
// strip DNA headers and newline characters
char*
ReadInput_StripHeader(   size_t *file_size, size_t *strip_size )
{
   // get input size
   *file_size = ftell(stdin);
   fseek(stdin, 0, SEEK_END);
   *file_size = ftell(stdin) - *file_size;
   fseek(stdin, 0, SEEK_SET);
    *strip_size = 0;

   // load original content into memory
   char* input = (char*)malloc(*file_size +1);
   assert(input != 0);
   {
      size_t sz = fread(input, 1, *file_size, stdin);
      assert(sz == *file_size);
      input[*file_size] = 0;
   }

   // alloc space for regex_replace
   char* output = (char*)malloc(*file_size);
   assert(output != 0);


   const char*   re_error;
   int         re_erroff;

   // compile pattern
   pcre* re = pcre_compile(">.*\\n|\\n", 0, &re_error, &re_erroff, 0);
   pcre_extra*   re_extra = pcre_study(re, 0, &re_error);
   assert(re != 0);

   int         position;
   int         match[3];

   // regex_replace
   for(   position = 0;
         pcre_exec(re, re_extra, input, *file_size, position, 0, match, 3) >= 0;
         position = match[1]   )
   {
      int char_to_copy = match[0] - position;
      memcpy(output + (*strip_size), input + position, char_to_copy);
      *strip_size += char_to_copy;
   }

   // copy remain part
   int char_to_copy = *file_size - position;
   memcpy(output + (*strip_size), input + position, char_to_copy);
   *strip_size += char_to_copy;
      
   free(input);
   pcre_free(re_extra);
   pcre_free(re);
   
   return output;
}



void 
Count_Patterns(char const* input, size_t input_len, char* result)
{
   static char const* ptns[] = 
   {
      "agggtaaa|tttaccct",   
      "[cgt]gggtaaa|tttaccc[acg]",   
      "a[act]ggtaaa|tttacc[agt]t",   
      "ag[act]gtaaa|tttac[agt]ct",   
      "agg[act]taaa|ttta[agt]cct",   
      "aggg[acg]aaa|ttt[cgt]ccct",   
      "agggt[cgt]aa|tt[acg]accct",   
      "agggta[cgt]a|t[acg]taccct",   
      "agggtaa[cgt]|[acg]ttaccct"
   };
   static const int n_ptns = sizeof(ptns) / sizeof(ptns[0]);
   static size_t counters[9];

   int i;
   #pragma omp for schedule(dynamic, 1) nowait
   for (i = 0; i < n_ptns; ++i)
   {
      const char*   re_error   = 0;
      int         re_erroff   = 0;

      pcre*       re          = pcre_compile(ptns[i], 0, &re_error, &re_erroff, 0);
      pcre_extra*   re_extra    = pcre_study(re, 0, &re_error);
      assert(re != 0);
   
      int         position, count;
      int         match[3];

      // regex_search
      for(   position = count = 0;
            pcre_exec(re, re_extra, input, input_len, position, 0, match, 3) >= 0;
            position = match[1]   )
         ++count;
         
      counters[i] = count;
      pcre_free(re_extra);
      pcre_free(re);
   }

   // we want the last thread, reaching this code block, to print result
   static size_t thread_passed = 0;
   if (__sync_add_and_fetch(&thread_passed, 1) == (size_t)omp_get_num_threads() )
   {
      int plen = 0;
      int i;

      for (i = 0; i < n_ptns; ++i)
         plen += sprintf(result + plen, "%s %d\n", ptns[i], counters[i]);

      thread_passed = 0;
   }
}


typedef struct IUB_T
{
   const char*   iub;
   int         len;
} IUB;

 
IUB const iub_table[] = 
{
   {0}, 
   {"(c|g|t)",   7}, 
   {0}, 
   {"(a|g|t)",   7}, 
   {0}, {0}, {0}, 
   {"(a|c|t)",   7}, 
   {0}, {0}, 
   {"(g|t)",   5}, 
   {0}, 
   {"(a|c)",   5}, 
   {"(a|c|g|t)",   9}, 
   {0}, {0}, {0}, 
   {"(a|g)",   5}, 
   {"(c|t)",   5}, 
   {0}, {0}, 
   {"(a|c|g)",   7}, 
   {"(a|t)",   5}, 
   {0}, 
   {"(c|t)",   5}
};
int const n_iub = sizeof(iub_table)/sizeof(iub_table[0]);


void
Replace_Patterns(char const* input, size_t input_len, size_t* repl_len)
{
   #pragma omp single nowait
   {
      // input_len * 1.5
      char*      output       = (char*)malloc(input_len + (input_len >> 1));
      assert(output != 0);
      
      const char*   re_error   = 0;
      int         re_erroff   = 0;

      pcre*       re          = pcre_compile("[BDHKMNRSVWY]", 0, &re_error, &re_erroff, 0);
      pcre_extra*   re_extra    = pcre_study(re, 0, &re_error);
      assert(re != 0);
   
      int         position;
      int         match[3];
      int         replace_len   = 0;

      // regex_replace
      for(   position = 0;
            pcre_exec(re, re_extra, input, input_len, position, 0, match, 3) >= 0;
            position = match[1]   )
      {
         int char_to_copy = match[0] - position;
         memcpy(output + replace_len, input + position, char_to_copy);
         replace_len += char_to_copy;

         IUB const* i_r = iub_table + (input[match[0]] - 'A'); 

         char_to_copy = i_r->len;
         memcpy(output + replace_len, i_r->iub, char_to_copy);
         replace_len += char_to_copy;
         
      }
   
      // copy remain part
      int char_to_copy = input_len - position;
      memcpy(output + replace_len, input + position, char_to_copy);
      replace_len += char_to_copy;

      free(output);
      pcre_free(re_extra);
      pcre_free(re);

      *repl_len = replace_len;
   }
}



// Detect single - multi thread benchmark
int 
GetThreadCount()
{
   cpu_set_t cs;
   int count = 0;
   int i;

   CPU_ZERO(&cs);
   sched_getaffinity(0, sizeof(cs), &cs);

   for (i = 0; i < CPU_SETSIZE; ++i)
   {
      if (CPU_ISSET(i, &cs))
      ++count;
   }
   return count;
}


int 
main()
{
   size_t initial_length = 0;
   size_t striped_length = 0;
   size_t replace_length = 0;
   
   char* input = ReadInput_StripHeader (&initial_length, &striped_length);

   
   char match_result[1024];
   #pragma omp parallel default(shared) num_threads(GetThreadCount())
   {
      Count_Patterns   (input, striped_length, match_result);
      Replace_Patterns(input, striped_length, &replace_length);
   }
   
   printf("%s\n%d\n%d\n%d\n", 
      match_result,
      initial_length,
      striped_length,
      replace_length );

   free(input);
   return 0;
}

/* -*- mode: c -*-
 * $Id: regexmatch.gcc,v 1.1 2004-05-19 18:11:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <pcre.h>
#include <string.h>

#define MAXLINES   100
#define MAXLINELEN 132

char *pattern = 
"(?:^|[^\\d\\(])"		/* must be preceeded by non-digit */
"(\\()?"			/* match 1: possible initial left paren */
"(\\d\\d\\d)"			/* match 2: area code is 3 digits */
"(?(1)\\))"			/* if match1 then match right paren */
"[ ]"				/* area code followed by one space */
"(\\d\\d\\d)"			/* match 3: prefix of 3 digits */
"[ -]"				/* separator is either space or dash */
"(\\d\\d\\d\\d)"		/* match 4: last 4 digits */
"\\D"				/* must be followed by a non-digit */
;


int
main(int argc, char *argv[]) {
    int NUM = ((argc == 2) ? atoi(argv[1]) : 1);
    int count;
    char *cptr = "";
    char **phones;
    pcre *re;
    int erroffset;
    const char *errptr;
    int n, lines = 0;
    char num[256];
    int i, j, k, matchlen;
    char *matchoffset;
    int nmatches;
    int *ovec, ovecsize;
    pcre_extra *study;

    phones = (char **)malloc(MAXLINES * sizeof(char *));
    if (!phones) {
	fprintf(stderr, "malloc for phones array failed\n");
	exit(1);
    }
    lines = 0;
    while (cptr) {
	phones[lines] = (char *)malloc(MAXLINELEN);
	if (!phones[lines]) {
	    fprintf(stderr, "malloc to hold line #%d failed\n", lines);
	    exit(1);
	}
	cptr = fgets(phones[lines], MAXLINELEN, stdin);
	lines++;
	if (lines > MAXLINES) {
	    fprintf(stderr, "MAXLINES is too small\n");
	    exit(1);
	}
    }

    re = pcre_compile(pattern, 0, &errptr, &erroffset, NULL);
    if (!re) {
	fprintf(stderr, "can't open compile regexp\n");
	exit(1);
    }

    study = pcre_study(re, 0, &errptr);

    if (pcre_fullinfo(re, NULL, PCRE_INFO_CAPTURECOUNT, &nmatches) != 0) {
	fprintf(stderr, "pcre_fullinfo failed\n");
	exit(1);
    }
    nmatches++;			/* add match of entire pattern */

    ovecsize = sizeof(int) * nmatches * 3;
    ovec = (int *)malloc(ovecsize);
    if (!ovec) {
	fprintf(stderr, "malloc for ovec array failed\n");
	exit(1);
    }

    count = 0;
    while (NUM--) {
	for (i=0; i<lines; i++) {
	    n = pcre_exec(re, study,
			  phones[i], strlen(phones[i]), 0,
			  0, ovec, ovecsize);
	    if (n == nmatches) {
		/* stuff the match into the buffer "num" */
		k = 2*2;	/* initial offset into ovec */
		/* areacode */
		j = 0;
		num[j++] = '(';
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		num[j++] = ')';
		/* space separator */
		num[j++] = ' ';
		/* exchange */
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		/* dash */
		num[j++] = '-';
		/* last 4 digits */
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		/* with a cherry on top */
		num[j] = 0;
		if (0 == NUM) {
		    count++;
		    printf("%d: %s\n", count, num);
		}
	    }
	}
    }

    for (i=0; i<MAXLINES; i++) {
	free(phones[i]);
    }
    free(phones);
    free(ovec);

    return(0);
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Petr Prokhorenkov
*/
#define _GNU_SOURCE

#include <assert.h>
#include <ctype.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

#define LINE_LENGTH 60 
#define STDOUT 1

typedef struct lookup {
    uint8_t bytes[256];
    uint16_t pairs[256*256];
} lookup_t;

void
init_lookup(const uint8_t *from, const uint8_t *to, lookup_t *lookup) {
    for (int i = 0; i < 256; ++i) {
        lookup->bytes[i] = i;
    }
    for (; *from && *to; ++from, ++to) {
        lookup->bytes[tolower(*from)] = *to;
        lookup->bytes[toupper(*from)] = *to;
    }

    for (int i = 0; i != 256; ++i) {
        for (int j = 0; j != 256; ++j) {
            lookup->pairs[(i << 8) + j] =
                ((uint16_t)lookup->bytes[j] << 8) + lookup->bytes[i];
        }
    }
}

typedef struct job {
    struct job *prev_job;

    pthread_mutex_t *io_mutex;
    pthread_cond_t condition;
    int finished;

    const uint8_t *header_begin;
    const uint8_t *header_end;
    const uint8_t *body_begin;
    const uint8_t *body_end;
    const lookup_t *lookup;
    pthread_t thread;
    uint8_t *buffer;
    int free_buffer;
} job_t;

off_t get_file_size(FILE *f) {
    long begin = ftell(f);
    fseek(f, 0, SEEK_END);
    long size = ftell(f) - begin;
    fseek(f, begin, SEEK_SET);

    return size;
}

void
persistent_write(int fd, const void *ptr, size_t size) {
    while (size > 0) {
        ssize_t result = write(fd, ptr, size);

        assert(result >= 0);

        size -= result;
    }
}

size_t
reverse_complement(
        const uint8_t *begin,
        const uint8_t *end,
        const lookup_t *lookup,
        uint8_t *buffer) {
    size_t size = end - begin;
    const uint8_t *read_p = (const uint8_t *)end;
    uint8_t *buffer_begin = buffer;

    while (size >= LINE_LENGTH) {
        uint16_t *pair_buffer = (uint16_t *)buffer;
        const uint16_t *read_pair = (const uint16_t *)read_p;

        for (size_t i = 0; i < LINE_LENGTH; i += 2) {
            *pair_buffer++ = lookup->pairs[*--read_pair];
        }

        read_p -= LINE_LENGTH&(~1);
        buffer += LINE_LENGTH&(~1);

        if (LINE_LENGTH % 2 != 0) {
            *buffer++ = *--read_p;
        }

        *buffer++ = '\n';
        size -= LINE_LENGTH;
    }

    if (size > 0) {
       while (read_p > begin) {
           *buffer++ = lookup->bytes[*--read_p];
       }
       *buffer++ = '\n';
    }

    return buffer - buffer_begin;
}

size_t round_by(size_t a, size_t b) {
    return a - a%b;
}

void
process_block(
        job_t *job) {
    const uint8_t *header_begin = job->header_begin;
    const uint8_t *header_end = job->header_end;
    const uint8_t *body_begin = job->body_begin;
    const uint8_t *body_end = job->body_end;
    const lookup_t *lookup = job->lookup;
    pthread_mutex_t *io_mutex = job->io_mutex;
    pthread_cond_t *condition = &job->condition;
    uint8_t *buffer = job->buffer;

    size_t size = reverse_complement(
            body_begin, body_end,
            lookup,
            buffer);

    pthread_mutex_lock(io_mutex);
    if (job->prev_job) {
        if (!job->prev_job->finished) {
            pthread_cond_wait(
                    &job->prev_job->condition, io_mutex);
        }
    }
    
    if (header_begin && header_end) {
        persistent_write(
                STDOUT, header_begin, header_end - header_begin);
    }
    persistent_write(STDOUT, buffer, size);
    job->finished = 1;
    pthread_cond_signal(condition);
    pthread_mutex_unlock(io_mutex);
}

job_t *detach_job(
        const uint8_t *header_begin, const uint8_t *header_end,
        const uint8_t *body_begin, const uint8_t *body_end,
        const lookup_t *lookup,
        pthread_mutex_t *mutex,
        job_t *prev_job,
        uint8_t *buffer,
        int free_buffer) {
    job_t *job = calloc(1, sizeof(*job));
    assert(job);

    job->io_mutex = mutex;
    pthread_cond_init(&job->condition, 0);
    job->header_begin = header_begin;
    job->header_end = header_end;
    job->body_begin = body_begin;
    job->body_end = body_end;
    job->lookup = lookup;
    job->buffer = buffer;
    job->prev_job = prev_job;
    job->free_buffer = free_buffer;

    pthread_create(&job->thread, 0, (void *(*)(void *))&process_block, job);

    return job;
}

job_t *
do_process_block(
        const uint8_t *header_begin, const uint8_t *header_end,
        const uint8_t *body_begin, const uint8_t *body_end,
        const lookup_t *lookup,
        pthread_mutex_t *mutex,
        job_t *prev_job) {
    uint64_t body_size = body_end - body_begin;
    uint64_t tail_len = round_by(body_size/2, LINE_LENGTH);
    const uint8_t *split_at = body_end - tail_len;

    uint8_t *buffer = malloc(
            body_size*(LINE_LENGTH + 1)/LINE_LENGTH + LINE_LENGTH);
    assert(buffer);

    prev_job = detach_job(
            header_begin, header_end,
            split_at, body_end,
            lookup,
            mutex,
            prev_job,
            buffer,
            1);
    prev_job = detach_job(
            0, 0,
            body_begin, split_at,
            lookup,
            mutex,
            prev_job,
            buffer + tail_len*(LINE_LENGTH + 1)/LINE_LENGTH,
            0);

    return prev_job;
}

int
main(void) {
    setvbuf(stdin, 0, _IOFBF, 1024*1024);

    long stdin_size = get_file_size(stdin);
    uint8_t *buffer = calloc(stdin_size + LINE_LENGTH, 1);
    assert(buffer);
    lookup_t lookup;
    pthread_mutex_t mutex;
    job_t *job = 0;

    init_lookup(
            (const uint8_t *)"acbdghkmnsrutwvy",
            (const uint8_t *)"TGVHCDMKNSYAAWBR",
            &lookup);

    pthread_mutex_init(&mutex, 0);

    uint8_t *current = buffer;
    uint8_t *end = buffer + stdin_size;
    uint8_t *header_begin = 0;
    uint8_t *header_end = 0;
    uint8_t *body_begin = 0;

    while (fgets_unlocked((char *)current, end - current, stdin)) {
        if (current[0] == '>') {
            if (body_begin != 0) {
                job = do_process_block(
                        header_begin, header_end,
                        body_begin, current,
                        &lookup,
                        &mutex,
                        job); 
            }
            size_t len = strlen((const char *)current);
            header_begin = current;
            header_end = current + len;
            current += len;
            body_begin = current;
        } else {
            if (current[LINE_LENGTH] == '\n') {
                current += LINE_LENGTH;
            } else {
                size_t len = strlen((const char *)current);
                if (current[len - 1] == '\n') {
                    --len;
                }
                current += len;
            }
        }
    }

    if (body_begin != 0) {
        job = do_process_block(
                header_begin, header_end,
                body_begin, current,
                &lookup,
                &mutex,
                job); 
    }

    while (job) {
        pthread_join(job->thread, 0);

        if (job->free_buffer) {
            free(job->buffer);
        }
        job = job->prev_job;
    }
    
    free(buffer);

    return 0;
}
/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org
 *
 * contributed by Bob W 
 */

#include <stdio.h>
#include <stdlib.h>

#define JBFSIZE 82      // line input buffer size
#define QBFSIZE 5200     // output buffer initial size
#define Z16     "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
#define V32     "\0TVGH\0\0CD\0\0M\0KN\0\0\0YSA\0BW\0R\0\0\0\0\0\0"
#define VALL    Z16 Z16 Z16 Z16 V32 V32 Z16 Z16 Z16 Z16 Z16 Z16 Z16 Z16

int errex(char *s, int n) {      // error message+value, return 1
  fprintf(stderr,"\n*** Error: %s [%d]!\n", s, n);
  return 1;
}

int main () {                    // ***** main *****
  char *pj, *pq, *pr;            // buffer pointers: inp,out,/out
  char *jjj = malloc(JBFSIZE);   // allocate input line buffer
  char *qqq = malloc(QBFSIZE);   // output buffer (dyn. size)
  char *pqstop = qqq+QBFSIZE;    // end-of-buffer pointer
  char xtab[256] = VALL;         // char conversion table

  if (!jjj || !qqq)
    return errex("Buffer allocation", !jjj + !qqq);
  pj = fgets(jjj,JBFSIZE,stdin);         // fetch 1st line
  if (!pj)
    return errex("No input data",0);
  if (*jjj != '>')
    return errex("1st char not '>'", 0);

  while (pj) {                           // MAIN LOOP: process data
    fputs(jjj, stdout);                  // output ID line

    for (pq=qqq+1, pr=pqstop; ; pq++) {  // LOOP: fill output buffer
      pj = fgets(jjj, JBFSIZE, stdin);   // get line from stdin
      if (!pj || (*jjj=='>'))  break;    // EOF or new ID line
      if (pr <= (pq+61)) {               // need to resize buffer
        char *newstop = pqstop + 12777888;
        char *newptr  = realloc(qqq, newstop-qqq);
        if (!newptr)
          return errex("Out of memory", 0);
        if (newptr != qqq) {             // new base: adj. pointers
          size_t x = newptr-qqq;         // offset for pointer update
          pq+=x;  pr+=x;  qqq+=x;
          newstop+=x;  pqstop+=x;
        }
        pr = __builtin_memmove(newstop-(pqstop-pr), pr, pqstop-pr);
        pqstop = newstop;                // buffer resize complete
      }
      while (*pj) {                      // LOOP: conv. & revert line
        char c = xtab[(unsigned char)(*pj++)];
        if (c)                           // conversion valid
          *(--pr) = c;
      }
    }

    for (pq = qqq; pr<pqstop; ) {        // LOOP: format output
      size_t x = (pqstop-pr)<60 ? pqstop-pr : 60;
      __builtin_memmove(pq,pr,x);        // move line to free space
      pr+=x;  pq+=x;  *(pq++) = 0xA;     // adjust pointers, add LF
    }
    fwrite(qqq, 1, pq-qqq, stdout);      // output converted data
  }
  return 0;
}
/* -*- mode: c -*-
 * $Id: reversefile.gcc-2.gcc,v 1.1 2004-11-10 06:51:38 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

/* this version attempts to read the file line by line instead of
   all at once. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BLKSIZE 16 * 1024

int main(int argc, char *argv[]) {
    int nread, size, len;
    char *cp, *offset, *buf = malloc(BLKSIZE + 1);

    offset = buf;
    size = len = BLKSIZE;
    while (1) {
	nread = read(0, offset, len);
	if (0 == nread) break;
	if (-1 == nread) {
	    perror("read");
	    exit(1);
	}
	offset += nread;
	len -= nread;
	if (0 == len) {
	    len = size;
	    size *= 2;
	    if (0 == (cp = realloc(buf, size + 1))) {
		fprintf(stderr, "realloc failed\n");
		exit(1);
	    }
	    buf = cp;
	    offset = buf + len;
	}
    }
    *offset = 0;
    for (cp = offset; cp > buf; --cp) {
	if ('\n' == *cp) {
	    *offset = 0;
	    if (cp < offset)
		printf(offset = cp+1);
	}
    }
    if (cp < offset) {
	*offset = 0;
	printf(cp);
    }
    free(buf);
    return(0);
}
/* -*- mode: c -*-
 * $Id: reversefile.gcc,v 1.5 2004-10-18 07:15:07 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * 
 * from Alan Post <apost@recalcitrant.org>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <limits.h>
#include <sys/uio.h>

#define MAXREAD 4096
#define IOV_MAX 1024

typedef struct buf_t { char d[MAXREAD];
                       size_t len;
                       struct buf_t *next;} buf_t;

static print_string( char *data, size_t len,
                     struct iovec *vec, size_t *p_ivec )
{
    vec[ *p_ivec ].iov_base = data;
    vec[ *p_ivec ].iov_len = (int) len;
    ++ *p_ivec;
    if ( *p_ivec == IOV_MAX )
    {
        writev( STDOUT_FILENO, vec, *p_ivec );
        *p_ivec = 0;
    }
}

static print_line( char *pos, char *end, buf_t **p_loh,
                   struct iovec *vec, size_t *p_ivec )
{
    print_string( pos, end - pos, vec, p_ivec );
    for (; *p_loh != NULL; *p_loh = (*p_loh)->next )
        print_string( (*p_loh)->d, (*p_loh)->len, vec, p_ivec );
}

static void rev_print( buf_t *head )
{
    buf_t *loh = NULL;
    buf_t *curr = head;

    struct iovec vec[ IOV_MAX ];
    size_t ivec = 0;

    while ( 1 )
    {
        char *buf = curr->d;
        char *end = buf + curr->len;
        char *pos = end;
        for (;; pos--)
        {
            if ( pos <= buf )
            {
                buf_t *new_curr = curr->next;

                if ( new_curr == NULL )
                {
                    print_line( pos, end, &loh, vec, &ivec );
                    writev( STDOUT_FILENO, vec, ivec );
                    return;
                }

                curr->len = end - buf;
                curr->next = loh;
                loh = curr;
                
                curr = new_curr;
                break;
            }
            if ( *(pos-1) == '\n' )
            {
                print_line( pos, end, &loh, vec, &ivec );
                end = pos;
            }
        }
    }
    assert( NULL == "unreachable" );
}

static void f( buf_t *tail )
{
    buf_t head;

    head.next = tail;
    head.len = read( STDIN_FILENO, head.d, MAXREAD );

    if ( head.len == MAXREAD ) f( &head );
    else rev_print( &head );
}

int main(int argc, char *argv[])
{
    f( NULL );
    return EXIT_SUCCESS;
}

/* -*- mode: c -*-
 * $Id: sieve.gcc,v 1.1 2004-05-19 18:12:27 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[]) {
    int NUM = ((argc == 2) ? atoi(argv[1]) : 1);
    static char flags[8192 + 1];
    long i, k;
    int count = 0;

    while (NUM--) {
	count = 0; 
	for (i=2; i <= 8192; i++) {
	    flags[i] = 1;
	}
	for (i=2; i <= 8192; i++) {
	    if (flags[i]) {
		// remove all multiples of prime: i
		for (k=i+i; k <= 8192; k+=i) {
		    flags[k] = 0;
		}
		count++;
	    }
	}
    }
    printf("Count: %d\n", count);
    return(0);
}

/* -*- mode: c -*-
 * 
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double eval_A(int i, int j) { return 1.0/((i+j)*(i+j+1)/2+i+1); }

void eval_A_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(i,j)*u[j];
    }
}

void eval_At_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(j,i)*u[j];
    }
}

void eval_AtA_times_u(int N, const double u[], double AtAu[])
{ double v[N]; eval_A_times_u(N,u,v); eval_At_times_u(N,v,AtAu); }

int main(int argc, char *argv[])
{
  int i;
  const int N = ((argc == 2) ? atoi(argv[1]) : 2000);
  double u[N],v[N],vBv,vv;
  for(i=0;i<N;i++) u[i]=1;
  for(i=0;i<10;i++)
    {
      eval_AtA_times_u(N,u,v);
      eval_AtA_times_u(N,v,u);
    }
  vBv=vv=0;
  for(i=0;i<N;i++) { vBv+=u[i]*v[i]; vv+=v[i]*v[i]; }
  printf("%0.9f\n",sqrt(vBv/vv));
  return 0;
}

/* 
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Modified by Alex Belits
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double *A_global=NULL;
int N_global;

double eval_A(int i, int j) { return 1.0/((i+j)*(i+j+1)/2+i+1); }

int prepare_A(int N)
{
  int i,j;

  N_global=N;
  A_global=(double*)malloc(N*N*sizeof(double));

  if(A_global==NULL) return -1;

  for(i=0;i<N;i++)
    {
      for(j=0;j<N;j++)
	{
	  A_global[i*N+j]=eval_A(i,j);
	}
    }
  return 0;
}

double get_A(int i, int j) { return A_global[i*N_global+j]; }

void eval_A_times_u(int N, const double u[], double Au[])
{
  int i,j,n2;
  double t0,t1;

  n2=N&~1;
  for(i=0;i<n2;i+=2)
    {
      t0=0;
      t1=0;
      for(j=0;j<N;j++)
	{
	  t0+=get_A(i,j)*u[j];
	  t1+=get_A(i+1,j)*u[j];
	}
      Au[i]=t0;
      Au[i+1]=t1;
    }

  if(i!=N)
    {
      t0=0;
      for(j=0;j<N;j++)
        {
	  t0+=get_A(i,j)*u[j];
	}
      Au[i]=t0;
    }
}

void eval_At_times_u(int N, const double u[], double Au[])
{
  int i,j,n4;
  double t0,t1,t2,t3;

  n4=N&~3;
  for(i=0;i<n4;i+=4)
    {
      t0=0;
      t1=0;
      t2=0;
      t3=0;
      for(j=0;j<N;j++)
        {
	  t0+=get_A(j,i)*u[j];
	  t1+=get_A(j,i+1)*u[j];
	  t2+=get_A(j,i+2)*u[j];
	  t3+=get_A(j,i+3)*u[j];
        }
      Au[i]=t0;
      Au[i+1]=t1;
      Au[i+2]=t2;
      Au[i+3]=t3;
    }

  for(;i<N;i++)
    {
      t0=0;
      for(j=0;j<N;j++)
        {
	  t0+=get_A(j,i)*u[j];
	}
      Au[i]=t0;
    }
}

void eval_AtA_times_u(int N, const double u[], double AtAu[])
{ double v[N]; eval_A_times_u(N,u,v); eval_At_times_u(N,v,AtAu); }

int main(int argc, char *argv[])
{
  int i;
  int N = ((argc == 2) ? atoi(argv[1]) : 2000);
  double u[N],v[N],vBv,vv;

  if(prepare_A(N)){
    printf("Insufficient memory\n");
    return 1;
  }

  for(i=0;i<N;i++) u[i]=1;
  for(i=0;i<10;i++)
    {
      eval_AtA_times_u(N,u,v);
      eval_AtA_times_u(N,v,u);
    }
  vBv=vv=0;
  for(i=0;i<N;i++) { vBv+=u[i]*v[i]; vv+=v[i]*v[i]; }
  printf("%0.9f\n",sqrt(vBv/vv));
  free(A_global);
  return 0;
}

/*
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Original C contributed by Sebastien Loisel
 * Conversion to C++ by Jon Harrop
 * OpenMP parallelize by The Anh Tran
 * Add SSE by The Anh Tran
 * Reconversion into C by Dan Farina
 */

#define _GNU_SOURCE
#include <omp.h>
#include <math.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>

#define false 0
#define true  1

/* define SIMD data type. 2 doubles encapsulated in one XMM register */
typedef double v2dt __attribute__((vector_size(16)));
static const v2dt v1 = {1.0, 1.0};

/* parameter for evaluate functions */
struct Param
{
    double* u;          /* source vector */
    double* tmp;        /* temporary */
    double* v;          /* destination vector */

    int N;              /* source/destination vector length */
    int N2;             /* = N/2 */

    int r_begin;        /* working range of each thread */
    int r_end;
};

/* Return: 1.0 / (i + j) * (i + j +1) / 2 + i + 1; */
static double
eval_A(int i, int j)
{
    /*
     * 1.0 / (i + j) * (i + j +1) / 2 + i + 1;
     * n * (n+1) is even number. Therefore, just (>> 1) for (/2)
     */
    int d = (((i+j) * (i+j+1)) >> 1) + i+1;

    return 1.0 / d;
}

/*
 * Return type: 2 doubles in xmm register [double1, double2]
 *  double1 = 1.0 / (i + j) * (i + j +1) / 2 + i + 1;
 *  double2 = 1.0 / (i+1 + j) * (i+1 + j +1) / 2 + i+1 + 1;
 */
static v2dt
eval_A_i(int i, int j)
{
    int d1 = (((i+j) * (i+j+1)) >> 1) + i+1;
    int d2 = (((i+1 +j) * (i+1 +j+1)) >> 1) + (i+1) +1;
    v2dt r = {d1, d2};

    return v1 / r;
}

/*
 * Return type: 2 doubles in xmm register [double1, double2]
 *  double1 = 1.0 / (i + j) * (i + j +1) / 2 + i + 1;
 *  double2 = 1.0 / (i + j+1) * (i + j+1 +1) / 2 + i + 1;
 */
static v2dt
eval_A_j(int i, int j)
{
    int d1 = (((i+j) * (i+j+1)) >> 1) + i+1;
    int d2 = (((i+ j+1) * (i+ j+1 +1)) >> 1) + i+1;
    v2dt r = {d1, d2};

    return v1 / r;
}


/* This function is called by many threads */
static void
eval_A_times_u(struct Param *p)
{
    /* alias of source vector */
    const v2dt  *pU = (void *) p->u;
    int          i;
    int          ie;

    for (i = p->r_begin, ie = p->r_end; i < ie; i++)
    {
        v2dt sum = {0, 0};

        /* xmm = 2 doubles. This loop run from [0 .. N/2) */
        int j;
        for (j = 0; j < p->N2; j++)
            sum += pU[j] * eval_A_j(i, j*2);

        /* write result */
        {
            double *mem = (void *) &sum;

            p->tmp[i] = mem[0] + mem[1];
        }

        /* If source vector is odd size. This should be called <= 1 time */
        for (j = j*2; __builtin_expect(j < p->N, false); j++)
            p->tmp[i] += eval_A(i, j) * p->u[j];
    }
}

static void
eval_At_times_u(struct Param *p)
{
    const v2dt  *pT = (void *) p->tmp;
    int          i;
    int          ie;

    for (i = p->r_begin, ie = p->r_end; i < ie; i++)
    {
        v2dt    sum = {0, 0};
        int     j;

        for (j = 0; j < p->N2; j++)
            sum += pT[j] * eval_A_i(j*2, i);

        {
            double *mem = (void *) &sum;

            p->v[i] = mem[0] + mem[1];
        }

        /* odd size array */
        for (j = j*2; __builtin_expect(j < p->N, false); j++)
            p->v[i] += eval_A(j, i) * p->tmp[j];
    }
}

/*
 * Called by N threads.
 *
 * Each thread modifies its portion in destination vector -> barrier needed to
 * sync access
 */
static void
eval_AtA_times_u(struct Param *p)
{
    eval_A_times_u(p);
#pragma omp barrier

    eval_At_times_u(p);
#pragma omp barrier
}

/*
 * Shootout bench uses affinity to emulate single core processor.  This
 * function searches for appropriate number of threads to spawn.
 */
static int
GetThreadCount()
{
    cpu_set_t   cs;
    int         i;
    int         count = 0;

    CPU_ZERO(&cs);
    sched_getaffinity(0, sizeof(cs), &cs);

    for (i = 0; i < 16; i++)
        if (CPU_ISSET(i, &cs))
            count++;

    return count;
}

static double
spectral_game(int N)
{
    /* Align 64 byte for L2 cache line */
    __attribute__((aligned(64))) double u[N];
    __attribute__((aligned(64))) double tmp[N];
    __attribute__((aligned(64))) double v[N];

    double      vBv = 0.0;
    double      vv  = 0.0;

#pragma omp parallel default(shared) num_threads(GetThreadCount())
    {
        int i;

#pragma omp for schedule(static)
        for (i = 0; i < N; i++)
            u[i] = 1.0;

        /*
         * this block will be executed by NUM_THREADS variable declared in this
         * block is private for each thread
         */
        int             threadid    = omp_get_thread_num();
        int             threadcount = omp_get_num_threads();
        int             chunk       = N / threadcount;
        int             ite;
        struct Param    my_param;

        my_param.tmp = tmp;
        my_param.N   = N;
        my_param.N2  = N/2;

        /*
         * calculate each thread's working range [range1 .. range2) => static
         * schedule here
         */
        my_param.r_begin   = threadid * chunk;
        my_param.r_end  = (threadid < (threadcount -1)) ?
            (my_param.r_begin + chunk) : N;

        for (ite = 0; ite < 10; ite++)
        {
            my_param.u = u;     /* source vec is u */
            my_param.v = v;     /* destination vec is v */
            eval_AtA_times_u(&my_param);

            my_param.u = v;     /* source is v */
            my_param.v = u;     /* destination is u */
            eval_AtA_times_u(&my_param);
        }

        /* multi thread adding */
        {
            int i;

#pragma omp for schedule(static) reduction( + : vBv, vv ) nowait

            for (i = 0; i < N; i++)
            {
                vv  += v[i] * v[i];
                vBv += u[i] * v[i];
            }
        }
    }
    /* end parallel region */

    return sqrt(vBv/vv);
}

int
main(int argc, char *argv[])
{
    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);

    printf("%.9f\n", spectral_game(N));
    return 0;
}
/* -*- mode: c -*-
 * $Id: spellcheck.gcc-2.gcc,v 1.1 2004-11-10 06:47:52 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "../../Include/simple_hash.h"

int main(int argc, char *argv[]) {
    int i, wordbufsize = 80;
    char c, *wordbuf = (char *)malloc(wordbufsize + 1);
    struct ht_ht *dict = ht_create(40000);
    FILE *fh;
    
    if ((fh = fopen("Usr.Dict.Words", "r")) == NULL) {
	perror("fopen");
	exit(1);
    }
    i = 0;
    while ((c = getc(fh)) > 0) {
        if (isspace(c)) {
	    if (i > 0) {
		wordbuf[i] = '\0';
		ht_find_new(dict, wordbuf)->val = 1;
		i = 0;
	    }
        } else {
            wordbuf[i++] = c;
	    if (i == wordbufsize) {
		wordbufsize *= 2;
		wordbuf = realloc(wordbuf, wordbufsize + 1);
	    } 
        }
    }
    fclose(fh);

    i = 0;
    while ((c = getchar()) > 0) {
        if (isspace(c)) {
	    if (i > 0) {
		wordbuf[i] = '\0';
		if (ht_find(dict, wordbuf) == NULL) {
		    printf("%s\n", wordbuf);
		}
		i = 0;
	    }
        } else {
            wordbuf[i++] = c;
	    if (i == wordbufsize) {
		wordbufsize *= 2;
		wordbuf = realloc(wordbuf, wordbufsize + 1);
	    } 
        }
    }
    free(wordbuf);
    ht_destroy(dict);
    return(0);
}
/* -*- mode: c -*-
 * $Id: spellcheck.gcc,v 1.1 2004-05-19 18:13:26 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Brad Knotwell
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "simple_hash.h"

#define MAXLINELEN 128

struct ht_ht *dict = NULL;

int handleInput(FILE *input,void (*hashManipFn)(char *))
{
    int wordbufsize = 80,i = 0;
    char *cp, *wordbuf = (char *)malloc(wordbufsize + 1);
    char line[MAXLINELEN];
    
    if((wordbuf = malloc(wordbufsize+1)) == NULL) 
        return(fprintf(stderr,"malloc\n"),0);

    while (fgets(line, MAXLINELEN, input))
	for (cp=line; *cp > 0; cp++) {
	    if (isspace(*cp)) {
		if (i) {
		    wordbuf[i] = '\0';
                    hashManipFn(wordbuf);
		    i = 0;
		}
	    } else {
		wordbuf[i++] = *cp;
		if (i == wordbufsize) {
		    wordbufsize *= 2;
		    if((wordbuf = realloc(wordbuf, wordbufsize + 1)) == NULL)
                        return(fprintf(stderr, "realloc\n"), 0);
		}
	    }
        }

    free(wordbuf);
    return(1);
}

void spellCheck(char *key) { 
    if (ht_find_new(dict,key)->val != 1) printf("%s\n",key);
}

void hashLoad(char *key) { ht_find_new(dict,key)->val = 1; }
 
int main(int argc, char *argv[]) {
    FILE *fh;
    int rc;

    /*  
        ht_create doesn't handle malloc and calloc failures 
        so this is superfluous 
    */
    if((dict = ht_create(40000)) == NULL)
        return(fprintf(stderr,"hash creation failed\n"),EXIT_FAILURE);
    
    if ((fh = fopen("Usr.Dict.Words", "r")) == NULL) 
        return(fprintf(stderr,"couldn't open dictionary\n"),EXIT_FAILURE);

    rc = ((handleInput(fh,hashLoad) && handleInput(stdin,spellCheck)) ? EXIT_SUCCESS : EXIT_FAILURE);

    ht_destroy(dict);
    return(rc);
}
/* -*- mode: c -*-
 * $Id: strcat.gcc,v 1.1 2004-05-19 18:13:34 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define STUFF "hello\n"

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int i, buflen = 32;
    char *strbuf = calloc(sizeof(char), buflen);
    char *strend = strbuf;
    int stufflen = strlen(STUFF);

    if (!strbuf) { perror("calloc strbuf"); exit(1); }
    for (i=0; i<n; i++) {
	if (((strbuf+buflen)-strend) < (stufflen+1)) {
	    buflen = 2*buflen;
	    strbuf = realloc(strbuf, buflen);
	    if (!strbuf) { perror("realloc strbuf"); exit(1); }
	    strend = strbuf + strlen(strbuf);
	}
	/* much faster to strcat to strend than to strbuf */
	strcat(strend, STUFF);
	strend += stufflen;
    }
    fprintf(stdout, "%d\n", strlen(strbuf));
    free(strbuf);

    sleep(1);
    return(0);
}
/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by CTips (ctips@bestweb.net)
 * modified by 
 */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>

#define MAXLINELEN	128

/* the progam sums each digit position separately; the formula below gives
 * a coservative estimate of the number of digits required
 */
#define MAXDIGITS 	((int)(1+((sizeof(int)*CHAR_BIT)/3)))

/* stdin is may be unbuffered by default in the operating system. 
 * Provide a buffer as shown below to make sure that it is buffered
 */
#ifndef IOBUFSIZE
#define IOBUFSIZE	(16*1024)
#endif

/* according to the benchmark requiremnents, we need to use "line-oriented"
 * I/O functions. I'm going to assume that requires line-buffering as well,
 * but we can override the behavior here
 */
#define IOBUFMODE	_IOLBF

/* gets or fgets */
#ifndef USE_GETS
#define USE_GETS	1
#endif

#if USE_GETS
#define IOGET(_line)	gets(_line)
#else
#define IOGET(_line)	fgets(_line, sizeof(_line), stdin)
#endif

int
main(void)
{
  char		line[MAXLINELEN];
  int		digitsum[MAXDIGITS];
  char		iobuf[IOBUFSIZE];
  int 		sum;
  int		i;

  setvbuf(stdin, iobuf, IOBUFMODE, sizeof(iobuf));

  for( i = 0; i < MAXDIGITS; i++ ) {
    digitsum[i] = 0;
  }

  while( IOGET(line) ) {
    char *	p = line;
    char	digits[15];
    int		ndigits;
    int		isneg;

    while( isspace(*p) ) {
      p++;
    }

    isneg = 0;
    if( *p == '-' ) {
      p++;
      isneg = 1;
    }

    ndigits = 0;
    while( isdigit(*p) ) {
      digits[ndigits] = *p;
      ndigits++;
      p++;
    }
    if( isneg ) {
      for( i = 0; i < ndigits; i++ ) {
	digitsum[i] -= digits[ndigits-1-i] - '0';
      }
    }
    else {
      for( i = 0; i < ndigits; i++ ) {
	digitsum[i] += digits[ndigits-1-i] - '0';
      }
    }
  }

  sum = 0;
  for( i = MAXDIGITS-1; i >= 0; i-- ) {
    sum = sum*10 + digitsum[i];
  }
  printf("%d\n", sum);
  return(0);
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   modified by  James Antill - 2007-06-14
 */

#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>

#define MAXLINELEN 128

int
main() {
    int sum = 0;
    char line[MAXLINELEN];

    while (fgets_unlocked(line, MAXLINELEN, stdin)) {
	sum += atoi(line);
    }
    printf("%d\n", sum);
    return(0);
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   modified by Jorge Peixoto
 */
 
#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>

#define MAXLINELEN 128
int main (void) {
    int sum = 0;
    char line[MAXLINELEN];
    while (fgets_unlocked (line, MAXLINELEN, stdin))
	sum += strtol (line, NULL, 0);
    printf ("%d\n", sum);
    return 0;
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   modified by  James Antill - 2007-06-14
   modified by Arek Bochinski - 2008-05-04
 */

#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>

#define MAXLINELEN 128

int matoi(char *c) {
      int res = 0,n=1;
      if(*c=='-'){n=-1;*c++;}
      while (*c >= '0' && *c <= '9')
      	 res = res * 10 + *c++ - '0';
      return res*n;
    }

int
main() {
    int sum = 0;
    char line[MAXLINELEN];

    while (fgets_unlocked(line, MAXLINELEN, stdin)) {
	sum += matoi(line);
    }
    printf("%d\n", sum);
    return(0);
}

/* $Id: takfp.gcc,v 1.3 2004-12-10 08:09:21 bfulgham Exp $
 * http://shootout.alioth.debian.org/ 
 * Contributed by Brent Fulgham 
 */
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

/* Make Brent's life easier...
 * vim: ts=4 ft=c
 */
/* 
 The Great Computer Language Shootout
  http://shootout.alioth.debian.org/

  contributed by John O'Hare 05 August 2005.
*/


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PORT_NUMBER 12340
#define M 6400
#define REPLY_SIZE 64
#define REQUEST_SIZE 64
#define BUFFER_SIZE 1024

void server()
{
	int sock;
	int conn;
	struct sockaddr_in servaddr;
	struct sockaddr_in cliaddr;
	unsigned int cliaddr_len;
	char* reply = malloc(REPLY_SIZE);
	char* buf = malloc(BUFFER_SIZE);

	memset(reply, '<', REPLY_SIZE);

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		exit(10);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (bind(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(11);

	if (listen(sock, 1) < 0)
		exit(12);

	if ((conn = accept(sock, (struct sockaddr *) &cliaddr, &cliaddr_len)) < 0)
		exit(13);

	while (recv(conn, buf, BUFFER_SIZE, 0) > 0) {
		if (send(conn, reply, REPLY_SIZE, 0) != REPLY_SIZE)
			exit(14);
	}

	close(conn);
	close(sock);

	free(buf);
}

void client(int n)
{
	int sock;
	struct sockaddr_in servaddr;
	char* request = malloc(REQUEST_SIZE);
	char* buf = malloc(BUFFER_SIZE);
	int tmpbytes;
	int bytes = 0;
	int replies = 0;

	memset(request, '>', REQUEST_SIZE);

	sleep(2); //wait for server to start

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
		exit(2);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(3);

	while (n-- > 0) {
		tmpbytes = 0;

		if (send(sock, request, REQUEST_SIZE, 0) != REQUEST_SIZE)
			exit(4);

		while (tmpbytes < REPLY_SIZE)
			tmpbytes += recv(sock, buf, BUFFER_SIZE - 1, 0);
		bytes += tmpbytes;
		replies++;
	}
	close(sock);

	printf("replies: %d\tbytes: %d\n", replies, bytes);

	free(request);
	free(buf);
}

int main (int argc, char** argv)
{	
	int pid;
	int n;

	n = (argc == 2 ? atoi(argv[1]) : 1);

	if ((pid = fork()) < 0) {
		return 1;
	}
	if (pid == 0) {
		client(M * n);
	} else {
		server();
	}
	return 0;
}
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Rodrigo Queiro
*/

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/wait.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define M 6400
#define REPLY_SIZE 64
#define REQUEST_SIZE 64
#define MAX_SIZE 64 // max(REPLY_SIZE, REQUEST_SIZE)
#define PORT 11000
#define BUFSIZE 512

int main(int argc, char **argv)
{
    int i;

    int n;
    char buf[BUFSIZE], text[MAX_SIZE];

    pid_t child_pid;

    /* server variables */

    int sockfd, newfd;
    struct sockaddr_in my_addr, new_addr;
    int sin_size;
    int yes=1;

    /* client variables */

    int theirfd, nreplies = 0, nbytes = 0;
    struct hostent *he;
    struct sockaddr_in their_addr;

    assert(argc > 1);
    n = atoi(argv[1]);

    child_pid = fork();

    if(child_pid)
    {
        /* server code */

        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        if (setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {
            perror("setsockopt");
            exit(1);
        }

        my_addr.sin_family = AF_INET;         // host byte order
        my_addr.sin_port = htons(PORT);     // short, network byte order
        my_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP
        memset(&(my_addr.sin_zero), '\0', 8); // zero the rest of the struct

        if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr))
                == -1) {
            perror("bind");
            exit(1);
        }

        if (listen(sockfd, 2) == -1) {
            perror("listen");
            exit(1);
        }
        sin_size = sizeof(struct sockaddr_in);
        if ((newfd = accept(sockfd, (struct sockaddr *)&new_addr,
                        &sin_size)) == -1) {
            perror("accept");
            exit(1);
        }

        for (i = 0; i < REPLY_SIZE; i++)
            text[i] = ' ';

        for (i = 0; i < n * M; i++)
        {
            recv(newfd, buf, BUFSIZE-1, 0);
            send(newfd, text, REPLY_SIZE, 0);
        }

        wait(NULL);
    }
    else
    {
        if ((he=gethostbyname("localhost")) == NULL) {  // get the host info 
            perror("gethostbyname");
            exit(1);
        }

        if ((theirfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket");
            exit(1);
        }

        their_addr.sin_family = AF_INET;    // host byte order 
        their_addr.sin_port = htons(PORT);  // short, network byte order 
        their_addr.sin_addr = *((struct in_addr *)he->h_addr);
        memset(&(their_addr.sin_zero), '\0', 8);  // zero the rest of the struct 

        while (connect(theirfd, (struct sockaddr *)&their_addr,
                    sizeof(struct sockaddr)) == -1);

        for (i = 0; i < REQUEST_SIZE; i++)
            text[i] = ' ';

        for (i = 0; i < n * M; i++)
        {
            send(theirfd, text, REQUEST_SIZE, 0);
            nbytes += recv(theirfd, buf, BUFSIZE-1, 0);
            nreplies++;
        }

        printf("replies: %d\tbytes: %d\n", nreplies, nbytes);
    }

    return 0;
}
/* 
 The Great Computer Language Shootout
  http://shootout.alioth.debian.org/

  contributed by John O'Hare 05 August 2005.
*/


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PORT_NUMBER 12341
#define M 100
#define REPLY_SIZE 4096
#define REQUEST_SIZE 64
#define BUFFER_SIZE 1024

void server()
{
	int sock;
	int conn;
	struct sockaddr_in servaddr;
	struct sockaddr_in cliaddr;
	unsigned int cliaddr_len;
	char* reply = malloc(REPLY_SIZE);
	char* buf = malloc(BUFFER_SIZE);

	memset(reply, '<', REPLY_SIZE);

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		exit(10);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (bind(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(11);

	if (listen(sock, 1) < 0)
		exit(12);

	if ((conn = accept(sock, (struct sockaddr *) &cliaddr, &cliaddr_len)) < 0)
		exit(13);

	while (recv(conn, buf, BUFFER_SIZE, 0) > 0) {
		if (send(conn, reply, REPLY_SIZE, 0) != REPLY_SIZE)
			exit(14);
	}

	close(conn);
	close(sock);

	free(buf);
}

void client(int n)
{
	int sock;
	struct sockaddr_in servaddr;
	char* request = malloc(REQUEST_SIZE);
	char* buf = malloc(BUFFER_SIZE);
	int tmpbytes;
	int bytes = 0;
	int replies = 0;

	memset(request, '>', REQUEST_SIZE);

	sleep(2); //wait for server to start

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
		exit(2);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(3);

	while (n-- > 0) {
		tmpbytes = 0;

		if (send(sock, request, REQUEST_SIZE, 0) != REQUEST_SIZE)
			exit(4);

		while (tmpbytes < REPLY_SIZE)
			tmpbytes += recv(sock, buf, BUFFER_SIZE - 1, 0);
		bytes += tmpbytes;
		replies++;
	}
	close(sock);

	printf("replies: %d\tbytes: %d\n", replies, bytes);

	free(request);
	free(buf);
}

int main (int argc, char** argv)
{	
	int pid;
	int n;

	n = (argc == 2 ? atoi(argv[1]) : 1);

	if ((pid = fork()) < 0) {
		return 1;
	}
	if (pid == 0) {
		client(M * n);
	} else {
		server();
	}
	return 0;
}
/* 
 The Great Computer Language Shootout
  http://shootout.alioth.debian.org/

  contributed by John O'Hare 05 August 2005.
*/


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PORT_NUMBER 12342
#define M 1
#define REPLY_SIZE 409600
#define REQUEST_SIZE 64
#define BUFFER_SIZE 1024

void server()
{
	int sock;
	int conn;
	struct sockaddr_in servaddr;
	struct sockaddr_in cliaddr;
	unsigned int cliaddr_len;
	char* reply = malloc(REPLY_SIZE);
	char* buf = malloc(BUFFER_SIZE);

	memset(reply, '<', REPLY_SIZE);

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		exit(10);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (bind(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(11);

	if (listen(sock, 1) < 0)
		exit(12);

	if ((conn = accept(sock, (struct sockaddr *) &cliaddr, &cliaddr_len)) < 0)
		exit(13);

	while (recv(conn, buf, BUFFER_SIZE, 0) > 0) {
		if (send(conn, reply, REPLY_SIZE, 0) != REPLY_SIZE)
			exit(14);
	}

	close(conn);
	close(sock);

	free(buf);
}

void client(int n)
{
	int sock;
	struct sockaddr_in servaddr;
	char* request = malloc(REQUEST_SIZE);
	char* buf = malloc(BUFFER_SIZE);
	int tmpbytes;
	int bytes = 0;
	int replies = 0;

	memset(request, '>', REQUEST_SIZE);

	sleep(2); //wait for server to start

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
		exit(2);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(3);

	while (n-- > 0) {
		tmpbytes = 0;

		if (send(sock, request, REQUEST_SIZE, 0) != REQUEST_SIZE)
			exit(4);

		while (tmpbytes < REPLY_SIZE)
			tmpbytes += recv(sock, buf, BUFFER_SIZE - 1, 0);
		bytes += tmpbytes;
		replies++;
	}
	close(sock);

	printf("replies: %d\tbytes: %d\n", replies, bytes);

	free(request);
	free(buf);
}

int main (int argc, char** argv)
{	
	int pid;
	int n;

	n = (argc == 2 ? atoi(argv[1]) : 1);

	if ((pid = fork()) < 0) {
		return 1;
	}
	if (pid == 0) {
		client(M * n);
	} else {
		server();
	}
	return 0;
}
/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/

* contributed by Premysl Hruby
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <limits.h>

#define THREADS (503)


struct stack {
   char x[PTHREAD_STACK_MIN];
};


/* staticaly initialize mutex[0] mutex */
static pthread_mutex_t mutex[THREADS]; 
static int data[THREADS];
static struct stack stacks[THREADS];
/* stacks must be defined staticaly, or my i386 box run of virtual memory for this
 * process while creating thread +- #400 */

static void* thread(void *num)
{
   int l = (int)num;
   int r = (l+1) % THREADS;
   int token;

   while(1) {
      pthread_mutex_lock(mutex + l);
      token = data[l];
      if (token) {
         data[r] = token - 1;
         pthread_mutex_unlock(mutex + r);
      }
      else {
         printf("%i\n", l+1);
         exit(0);
      }
   }
}



int main(int argc, char **argv)
{
   int i;
   pthread_t cthread;
   pthread_attr_t stack_attr;

   if (argc != 2)
      exit(255);
   data[0] = atoi(argv[1]);

   pthread_attr_init(&stack_attr);
      
   for (i = 0; i < THREADS; i++) {
      pthread_mutex_init(mutex + i, NULL);
      pthread_mutex_lock(mutex + i);

      pthread_attr_setstack(&stack_attr, &stacks[i], sizeof(struct stack)); 
      pthread_create(&cthread, &stack_attr, thread, (void*)i);
   }

   pthread_mutex_unlock(mutex + 0);
   pthread_join(cthread, NULL);   
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Ricardo Garcia
 */

#include <assert.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define NUM_THREADS (503)

pthread_t threads[NUM_THREADS];   /* Threads. */
int names[NUM_THREADS];      /* Thread "names". */
long mailboxes[NUM_THREADS];   /* Read tokens from here. */
sem_t greenlights[NUM_THREADS];   /* Semaphores to signal token presence. */

void *ring_routine(void *myname)
{
   int name = *(int *)(myname);   /* My name (1..NUM_THREADS). */
   int index = name - 1;      /* My index for the arrays. */
   int next = (index + 1) % NUM_THREADS;
   long token;

   for (;;) {
      sem_wait(greenlights + index);   /* Wait for a new token. */
      token = mailboxes[index];   /* Get token. */
      if (token == 0) {      /* Game over. */
         printf("%d\n", name);
         exit(EXIT_SUCCESS);
      }
      mailboxes[next] = token - 1;   /* Decrement and pass. */
      sem_post(greenlights + next);   /* Green ligh for next thr. */
   }
   return NULL;
}

int main(int argc, char *argv[])
{
   long first_token;
   int ii;
   pthread_attr_t attributes;
   sem_t permanent_red;
   
   /* Read first token. */
   first_token = strtol(argv[1], NULL, 10);

   /* Initialize attributes. */
   pthread_attr_init(&attributes);
   pthread_attr_setdetachstate(&attributes, PTHREAD_CREATE_DETACHED);
   pthread_attr_setstacksize(&attributes, PTHREAD_STACK_MIN);

   /* Initialize arrays and create threads. */
   for (ii = 0; ii < NUM_THREADS; ++ii) {
      names[ii] = ii + 1;
      sem_init(greenlights + ii, 0, 0);
      pthread_create(threads + ii, &attributes, ring_routine, names + ii);
   }

   /* Pass first token. */
   mailboxes[0] = first_token;
   sem_post(greenlights + 0);

   /* Wait forever. */
   sem_init(&permanent_red, 0, 0);
   sem_wait(&permanent_red);
   return 0;
}
/* -*- mode: c -*-
 * $Id: wc.gcc-2.gcc,v 1.1 2004-11-10 06:42:03 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * this program is modified from:
 *   http://cm.bell-labs.com/cm/cs/who/bwk/interps/pap.html
 * Timing Trials, or, the Trials of Timing: Experiments with Scripting
 * and User-Interface Languages</a> by Brian W. Kernighan and
 * Christopher J. Van Wyk.
 *
 */

#include <stdio.h>
#include <stdlib.h>

enum {
    OUT,			/* outside a word */
    IN				/* inside a word */
};

int
main() {
    int c, nl, nw, nc, state;

    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
	++nc;
	if (c == '\n')
	    ++nl;
	if (c == ' ' || c == '\n' || c == '\t')
	    state = OUT;
	else if (state == OUT) {
	    state = IN;
	    ++nw;
	}
    }
    printf("%d %d %d\n", nl, nw, nc);
    return(0);
}
/* -*- mode: c -*-
 * $Id: wc.gcc-3.gcc,v 1.1 2004-11-10 06:42:03 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * this program is modified from:
 *   http://cm.bell-labs.com/cm/cs/who/bwk/interps/pap.html
 * Timing Trials, or, the Trials of Timing: Experiments with Scripting
 * and User-Interface Languages</a> by Brian W. Kernighan and
 * Christopher J. Van Wyk.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

enum {
    OUT,			/* outside a word */
    IN				/* inside a word */
};


int
main() {
    int i, c, nl, nw, nc, state, nread;
    char buf[4096];

    state = OUT;
    nl = nw = nc = 0;
    while ((nread = read(0, buf, sizeof(buf))) > 0) {
	nc += nread;
	for (i=0; i<nread; i++) {
	    c = buf[i];
	    if (c == '\n')
		++nl;
	    if (c == ' ' || c == '\n' || c == '\t')
		state = OUT;
	    else if (state == OUT) {
		state = IN;
		++nw;
	    }
	}
    }
    printf("%d %d %d\n", nl, nw, nc);
    return(0);
}
/* -*- mode: c -*-
 * $Id: wc.gcc,v 1.2 2004-06-18 07:02:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * Author: Waldemar Hebisch (hebisch@math.uni.wroc.pl)
 * Optimizations: Michael Herf (mike@herfconsulting.com)
 * Further Revisions: Paul Hsieh (qed@pobox.com)
 */

#include <stdio.h>
#include <unistd.h>
#include <limits.h>

#define BSIZ 4096

unsigned long ws[UCHAR_MAX + 1];
unsigned long nws[UCHAR_MAX + 1];
char buff[BSIZ];

int main(void) {
    unsigned long prev_nws = 0x10000L, w_cnt = 0, l_cnt = 0, b_cnt = 0, cnt;

    /* Fill tables */
    for (cnt = 0; cnt <= UCHAR_MAX; cnt++) {
         ws[cnt] =  (cnt == ' ' || cnt == '\n' || cnt == '\t') + (0x10000L & -(cnt == '\n'));
	nws[cnt] = !(cnt == ' ' || cnt == '\n' || cnt == '\t') +  0x10000L;
    }

    
    /* Main loop */
    while (0 != (cnt = read (0, buff, BSIZ))) {
        unsigned long vect_count = 0;
	unsigned char *pp, *pe;

	b_cnt += cnt;
	pe = buff + cnt;
	pp = buff;

	while (pp < pe) {
	    vect_count +=  ws[*pp] & prev_nws;
	    prev_nws    = nws[*pp];
	    pp ++;
	}
	w_cnt += vect_count  & 0xFFFFL;
	l_cnt += vect_count >> 16;
    }

    w_cnt += 1 & prev_nws;

    printf ("%d %d %d\n", l_cnt, w_cnt, b_cnt);
    return 0;
}
/* -*- mode: c -*-
 * $Id: wordfreq.gcc-2.gcc,v 1.1 2004-11-10 06:40:32 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * From Kerry Clendinning
 */

#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>

#define NALPHA 26		/* number of letters in the alphabet */
struct onebytehash {
    int count;
    struct onebytehash *next_chain,*next_hash[NALPHA];
    char string[1];		/* one of those stretchy string-things */
};

int compare(struct onebytehash **a, struct onebytehash **b);
typedef int (*comparator)(const void *, const void *);

int
main()
{
    int c, nextc, i = 0, curbufsz = 200, used_hash_count = 0;
    struct onebytehash the_hash = {0,NULL},
	*current_hash = &the_hash, *chain = NULL;
    struct onebytehash **sort_array, **sort_tmp;
    char *buf;

    buf = malloc(curbufsz + 1);
    c = getchar();
    while ( (nextc = getchar()) > 0 ) {
        if (isalpha(c)) {
            buf[i++] = tolower(c);
            buf[i] = '\0';
            c = tolower(c) - 'a';
            if (!current_hash->next_hash[c]) {
                if (i >= curbufsz) {
		    curbufsz *= 2;
		    buf = realloc(buf,curbufsz + 1);
                } 
                current_hash->next_hash[c] =
		    malloc(sizeof(struct onebytehash) + i+1);
                bzero(current_hash->next_hash[c],sizeof(struct onebytehash));
                current_hash->next_hash[c]->next_chain = chain;
                chain = current_hash->next_hash[c];
                strcpy(chain->string,buf);
            }
            current_hash = current_hash->next_hash[c];
            if (!isalpha(nextc)) {
                if (!current_hash->count) used_hash_count++;
                current_hash->count++;
            }
        } else {
            current_hash = &the_hash;
            i = 0;
        }
        c = nextc;
    }

    sort_array = sort_tmp =
	malloc(sizeof(struct onebytehash *) * used_hash_count);
    while (chain) {
	if (chain->count) *sort_tmp++ = chain;
	chain = chain->next_chain;
    }

    qsort(sort_array, used_hash_count, sizeof(struct onebytehash *),
	  (comparator) compare);

    for (i=0;i<used_hash_count;i++)
	printf("%7d\t%s\n", sort_array[i]->count,sort_array[i]->string); 

    /* don't forget to free allocated memory here */

    return(0);
}

int compare(struct onebytehash **a, struct onebytehash **b)
{
    if ((*b)->count == (*a)->count) return (strcmp((*b)->string,(*a)->string));
    return ((*b)->count - (*a)->count);
}
/* -*- mode: c -*-
 * $Id: wordfreq.gcc-2.gcc,v 1.1 2005-05-01 21:44:53 igouy-guest Exp $
 * http://shootout.alioth.debian.org/
 * Changed by Adrian Merrill 2001/08/22 
 * Changed by Adrian Merrill 2001/09/21
 */

#include <stdio.h>
#include <ctype.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include "../../Include/simple_hash2.h"
//#include "../../Include/simple_hash.h"

#define QUICKIE_STRCMP(a, b)  (*(a) != *(b) ? *(a) - *(b) : strcmp((a), (b)))

typedef int (*comparator)(const void *, const void *);

static int cmp_hash(struct ht_node **a, struct ht_node **b) {
    int val = (*b)->val - (*a)->val; 
    return((val == 0) ? QUICKIE_STRCMP((*b)->key, (*a)->key) : val);
}

int main() {
    unsigned long  hash_code=0;
    int readbufsize = 4096;
    int wordbufsize=16;
    char *readbuf = (char *)malloc(readbufsize + 1);
    char *wordbuf = (char *)malloc(wordbufsize + 1);
    int i = 0;
    struct ht_ht *ht = ht_create(2048); 
    struct ht_node **sort_array, **sort_tmp, *node;
    /*new code*/
    int nread =0; 
    int wordlen=0; 
    readbuf[0]=0; 
    while (readbuf[i] > 0 ||
	   (nread = fread(readbuf, sizeof(char), readbufsize, stdin),
	    readbuf[nread] = '\0',i=0,nread > 0) ) {
	if (isalpha(readbuf[i])){
	    wordbuf[wordlen] = tolower(readbuf[i]);
	    /*calculate the hash code byte by byte, to prevent looping through the word twice */
	    HASHCODE_BYTE(hash_code,wordbuf[wordlen++]);
	    if (wordlen == wordbufsize) {
		wordbufsize *= 2;
		wordbuf = realloc(wordbuf, wordbufsize + 1);
	    }
	}
	else{ 
	    if (wordlen > 0) {  
		wordbuf[wordlen] = '\0'; 
		hash_code=HASHCODE_FINALIZE(hash_code,ht); 
		++(ht_find_new_prehashed(ht, wordbuf,hash_code)->val);
		wordlen = 0;
		hash_code=0;
	    }
	}
	i++;
    }
    free(readbuf); 
    free(wordbuf);
    sort_array = sort_tmp =
	malloc(sizeof(struct ht_node *) * ht_count(ht));

    for (node=ht_first(ht); (*sort_tmp++ = node) != 0; node=ht_next(ht)) ;

    qsort(sort_array, ht_count(ht), sizeof(struct ht_node *),
	  (comparator)cmp_hash);

    for (i=0; i<ht_count(ht); i++)
	printf("%7d %s\n", ht_val(sort_array[i]), ht_key(sort_array[i])); 

    ht_destroy(ht);
    return(0);
}
