/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org   
 
   contributed by Isaac Gouy */

using System;

class Ackermann
{
   public static int Ack(int m, int n) {
      if (m == 0) return n + 1;
      if (n == 0) return Ack(m-1, 1);
      else return Ack(m-1, Ack(m, n-1));
   }

   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Console.WriteLine("Ack(3,{0}): {1}", n, Ack(3, n));
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class Ary {

   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int[] x = new int[n];
      int[] y = new int[n];
        
      for (int i = 0; i < n; i++)
         x[i] = i + 1;
      for (int k = 0; k < 1000; k++ )
         for (int j = n-1; j >= 0; j--)
            y[j] += x[j];
        
      Console.WriteLine("{0} {1}", y[0], y[n-1]);
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/ 

   contributed by Marek Safar  
*/

using System;

class BinaryTrees
{
   const int minDepth = 4;

   public static void Main(String[] args)
   {
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int maxDepth = Math.Max(minDepth + 2, n);
      int stretchDepth = maxDepth + 1;

      int check = (TreeNode.bottomUpTree(0,stretchDepth)).itemCheck();
      Console.WriteLine("stretch tree of depth {0}\t check: {1}", stretchDepth, check);

      TreeNode longLivedTree = TreeNode.bottomUpTree(0,maxDepth);

      for (int depth=minDepth; depth<=maxDepth; depth+=2){
         int iterations = 1 << (maxDepth - depth + minDepth);

         check = 0;
         for (int i=1; i<=iterations; i++)
         {
            check += (TreeNode.bottomUpTree(i,depth)).itemCheck();
            check += (TreeNode.bottomUpTree(-i,depth)).itemCheck();
         }

         Console.WriteLine("{0}\t trees of depth {1}\t check: {2}",
            iterations*2, depth, check);
      }

      Console.WriteLine("long lived tree of depth {0}\t check: {1}",
         maxDepth, longLivedTree.itemCheck());
   }


   struct TreeNode
   {
      class Next
   	  {
	      public TreeNode left, right;
      }
   	
      private Next next;
      private int item;

      TreeNode(int item){
         this.item = item;
         this.next = null;
      }

      internal static TreeNode bottomUpTree(int item, int depth){
         if (depth>0){
            return new TreeNode(
                 bottomUpTree(2*item-1, depth-1)
               , bottomUpTree(2*item, depth-1)
               , item
               );
         }
         else {
            return new TreeNode(item);
         }
      }

      TreeNode(TreeNode left, TreeNode right, int item){
      	 this.next = new Next ();
         this.next.left = left;
         this.next.right = right;
         this.item = item;
      }

      internal int itemCheck(){
         // if necessary deallocate here
         if (next==null) return item;
         else return item + next.left.itemCheck() - next.right.itemCheck();
      }
   }
}
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Alp Toker
*/

using System;
using Thread = System.Collections.IEnumerator;

class Chameneos
{
   static Color other, first, second;
   static int n, meetings;

   static Thread Creature (Color me)
   {
      int met = 0;

      while (true) {
         //wait until meeting place clears
         while (second != Color.Faded)
            yield return null;

         other = first;

         if (other != Color.Faded)
            second = me;
         else {
            if (n <= 0) {
               meetings += met;
               yield return null;

               //all faded
               yield break;
            }

            n--;
            first = me;

            //wait for another creature
            while (second == Color.Faded)
               yield return null;

            other = second;

            first = Color.Faded;
            second = Color.Faded;
            yield return null;
         }

         //perform meeting
         met++;
         if (me != other)
            me = Complement (me);
      }
   }

   static Color Complement (Color me)
   {
      switch (me)
      {
         case Color.Blue:
            return other == Color.Red ? Color.Yellow : Color.Red;
         case Color.Red:
            return other == Color.Blue ? Color.Yellow : Color.Blue;
         case Color.Yellow:
            return other == Color.Blue ? Color.Red : Color.Blue;
         default: return me;
      }
   }

   static int Schedule (Thread[] threads)
   {
      while (true)
         foreach (Thread thread in threads)
            if (!thread.MoveNext ())
               return meetings;
   }

   enum Color { Faded, Blue, Red, Yellow }

   static void Main (string[] args)
   {
      n = Int32.Parse (args[0]);

      Thread[] threads = new Thread[] {Creature (Color.Blue), Creature (Color.Red), Creature (Color.Yellow), Creature (Color.Blue)};

      Console.WriteLine (Schedule (threads));
   }
}
/* The Computer Language Benchmarks Game
 http://shootout.alioth.debian.org/

 contributed by Patrick Perry
 
 ported from the Java 6 -server #3 program
 which was contributed by Luzius Meisser
 based on a contribution by Keenan Tims
 that was modified by Michael Barker
 */

using System;
using System.Threading;


public class Chameneos 
{
    public enum Color { Red, Blue, Yellow, Faded }

    public static Color Complement (Color color, Color other) 
    {
        if (color == other) {
            return color;
        } else if (color == Color.Blue) {
            return color == Color.Red ? Color.Yellow : Color.Red;
        } else if (color == Color.Yellow) {
            return color == Color.Blue ? Color.Red : Color.Blue;
        } else {
            return color == Color.Yellow ? Color.Blue : Color.Yellow;
        }
    }

    public class Future<T>
    {
        private volatile T t;
        private volatile bool hasValue;
        
        public T Value {
            get {
                while (!hasValue) {
                    Thread.Sleep(0);
                }
            
                return t;
            }
        
            set {
                t = value;
                hasValue = true;
            }
        }
    }

    public class InterruptedException : Exception { }

    public class Creature 
    {
        private MeetingPlace mp;
        private Color color;
        private int met;

        public Creature (Color initialColor, MeetingPlace mp) 
        {
            this.color = initialColor;
            this.mp = mp;
            this.met = 0;
        }

        public void Be () 
        {
            try {
                while (true) {
                    color = mp.Meet(color);
                    met++;
                }
            } catch (InterruptedException) {
                color = Color.Faded;
            }
        }
   
        public int CreaturesMet 
        {
            get { return met; }
        }

        public Color Color 
        {
            get { return color; }
        }
    }

    public class MeetingPlace 
    {
        private int meetingsLeft;
        private Color first;
        private bool hasFirst = false;
        private Future<Color> current;

        public MeetingPlace (int meetings) 
        {
            this.meetingsLeft = meetings;
        }

        public Color Meet (Color myColor)
        {
            Future<Color> newColor;

            lock (this) {
                if (meetingsLeft == 0) {
                    throw new InterruptedException();
                } else {
                    if (!hasFirst) {
                        first = myColor;
                        hasFirst = true;
                        current = new Future<Color>();
                    } else {
                        current.Value = Chameneos.Complement(myColor, first);
                        hasFirst = false;
                        meetingsLeft--;
                    }
                    newColor = current;
                }
            }
        
            return newColor.Value;
        }
    }
    
    public static readonly Color[] Colors = { 
        Color.Blue, Color.Red, Color.Yellow, Color.Blue };

    private MeetingPlace mp;
    private Creature[] creatures;
    private Thread[] threads;

    public Chameneos (int meetings) 
    {
        this.mp = new MeetingPlace(meetings);
        this.creatures = new Creature[Colors.Length];
        this.threads = new Thread[Colors.Length];
    }

    public void Run ()
    {
        for (int i = 0; i < Colors.Length; i++) {
            creatures[i] = new Creature(Colors[i], mp);
            threads[i] = new Thread(creatures[i].Be);
            threads[i].Start();
        }

        for (int i = 0; i < Colors.Length; i++) {
            threads[i].Join();
        }
    }

    public void PrintResult () 
    {
        int meetings = 0;
        
        for (int i = 0; i < Colors.Length; i++) {
            meetings += creatures[i].CreaturesMet;
        }
        
        Console.WriteLine(meetings);
    }

    public static void Main (String[] args)
    {
        if (args.Length < 1) {
            throw new ArgumentException();
        } else {
            Chameneos cham = new Chameneos(Int32.Parse(args[0]));
            cham.Run();
            cham.PrintResult();
        }
    }
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Adapted by Pascal Fresnay from Java version that was:
      contributed by Michael Barker
      based on a contribution by Luzius Meisser
*/

/**
 * This implementation uses standard C# threading (native threads).
 *
 * This implementation simply adds the new functionality to the orginal
 * implementation by Luzius Meisser from old chameneos shootout.  The interesting
 * part of this implementation, is that while a creature is waiting it does not
 * block its thread, rather it spins in a loop using a Thread.Sleep(0).
 */


using System;
using System.Threading;
using System.Text;
public class chameneosredux {

   public enum Colour {
      blue,
      red,
      yellow
   }

   private static Colour doCompliment(Colour c1, Colour c2) {
      switch (c1) {
      case Colour.blue:
         switch (c2) {
         case Colour.blue:
            return Colour.blue;
         case Colour.red:
            return Colour.yellow;
         case Colour.yellow:
            return Colour.red;
         default: break;
         }
         break;
      case Colour.red:
         switch (c2) {
         case Colour.blue:
            return Colour.yellow;
         case Colour.red:
            return Colour.red;
         case Colour.yellow:
            return Colour.blue;
         default: break;
         }
         break;
      case Colour.yellow:
         switch (c2) {
         case Colour.blue:
            return Colour.red;
         case Colour.red:
            return Colour.blue;
         case Colour.yellow:
            return Colour.yellow;
         default: break;
         }
         break;
      default: break;
      }
      throw new Exception();
   }

   sealed class MeetingPlace {

      private int meetingsLeft;

      public MeetingPlace(int meetings) {
         this.meetingsLeft = meetings;
      }

      private Colour? firstColour = null;
      private int firstId = 0;
      Future current;

      public Pair meet(int id, Colour c){
         Future newPair;
         lock (this) {
            if (meetingsLeft == 0) {
               throw new Exception("Finished");
            } else {
               if (firstColour == null) {
                  firstColour = c;
                  firstId = id;
                  current = new Future();
               } else {
                  Colour newColour = doCompliment(c, firstColour.Value);
                  current.Item = new Pair(id == firstId, newColour);
                  firstColour = null;
                  meetingsLeft--;
               }
               newPair = current;
            }
         }
         return newPair.Item;
      }
   }

   public sealed class Future {

      private Pair? t;
      
      public Pair Item
      {
         get
         {
            while (t == null)
            {
               Thread.Sleep(0);
            }
            return t.Value;
         }
         // need synchronization ?
         set
         {
            t = value;
         }
      }
   }

   sealed class Creature{

      private readonly MeetingPlace place;
      private int count = 0;
      private int sameCount = 0;
      private Colour colour;
      private int id;

      public Creature(MeetingPlace place, Colour colour) {
         this.place = place;
         this.id = this.GetHashCode();
         this.colour = colour;
      }

      public void run() {
         try {

            while (true) {
               Pair p = place.meet(id, colour);
               colour = p.colour;
               if (p.sameId) {
                  sameCount++;
               }
               count++;
            }

         } catch (Exception) {}
      }

      public int Count {
         get
         {
            return count;
         }
      }

      public override String ToString() {
         return count.ToString() + getNumber(sameCount);
      }
   }

   private static void run(int n, params Colour[] colours) {
      MeetingPlace place = new MeetingPlace(n);
      Creature[] creatures = new Creature[colours.Length];
      for (int i = 0; i < colours.Length; i++) {
         Console.Write(" " + colours[i]);
         creatures[i] = new Creature(place, colours[i]);
      }
      Console.WriteLine();
      Thread[] ts = new Thread[colours.Length];
      for (int i = 0; i < colours.Length; i++) {
         ts[i] = new Thread(creatures[i].run);
         ts[i].Start();
      }

      foreach (Thread t in ts) {
            t.Join();
      }

      int total = 0;
      foreach (Creature creature in creatures) {
         Console.WriteLine(creature);
         total += creature.Count;
      }
      Console.WriteLine(getNumber(total));
      Console.WriteLine();
   }

   public static void Main(String[] args) {

      int n = 600;
      if(args.Length > 0)
         n = Int32.Parse(args[0]);

      printColours();
      Console.WriteLine();
      run(n, Colour.blue, Colour.red, Colour.yellow);
      run(n, Colour.blue, Colour.red, Colour.yellow, Colour.red, Colour.yellow,
            Colour.blue, Colour.red, Colour.yellow, Colour.red, Colour.blue);
   }

   public struct Pair {
      public readonly bool sameId;
      public readonly Colour colour;

      public Pair(bool sameId, Colour c) {
         this.sameId = sameId;
         this.colour = c;
      }
   }

   private static String[] NUMBERS = {
      "zero", "one", "two", "three", "four", "five",
      "six", "seven", "eight", "nine"
   };

   private static String getNumber(int n) {
      StringBuilder sb = new StringBuilder();
      String nStr = n.ToString();
      for (int i = 0; i < nStr.Length; i++) {
         sb.Append(" ");
         sb.Append(NUMBERS[(int)Char.GetNumericValue(nStr[i])]);
      }

      return sb.ToString();
   }

   private static void printColours() {
      printColours(Colour.blue, Colour.blue);
      printColours(Colour.blue, Colour.red);
      printColours(Colour.blue, Colour.yellow);
      printColours(Colour.red, Colour.blue);
      printColours(Colour.red, Colour.red);
      printColours(Colour.red, Colour.yellow);
      printColours(Colour.yellow, Colour.blue);
      printColours(Colour.yellow, Colour.red);
      printColours(Colour.yellow, Colour.yellow);
   }

   private static void printColours(Colour c1, Colour c2) {
      Console.WriteLine(c1 + " + " + c2 + " -> " + doCompliment(c1, c2));
   }


}

/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   unoptimised reference implementation
   
   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class Dispatch
{

   public static void Main(String[] args) 
   {        
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Bottle 
         b1 = new Bottle(1), b2 = new Bottle(2), 
         b3 = new Bottle(3), b4 = new Bottle(4), 
         b5 = new Bottle(5), b6 = new Bottle(6),
         b7 = new Bottle(7), b8 = new Bottle(8), 
         b9 = new Bottle(9), b0 = new Bottle(0);

      PressurizedBottle 
         p1 = new PressurizedBottle(1), p2 = new PressurizedBottle(2), 
         p3 = new PressurizedBottle(3), p4 = new PressurizedBottle(4), 
         p5 = new PressurizedBottle(5), p6 = new PressurizedBottle(6),
         p7 = new PressurizedBottle(7), p8 = new PressurizedBottle(8),
         p9 = new PressurizedBottle(9), p0 = new PressurizedBottle(0);

      int check = 0;
      for (int i=1; i<=n; i++){
         check += bottleCheck(b1,b2,b3,b4,b5,i);
         check += bottleCheck(b6,b7,b8,b9,b0,i);

         check += bottleCheck(p1,p2,p3,p4,p5,i);
         check -= bottleCheck(p6,p7,p8,p9,p0,i);
      }
      Console.WriteLine("{0}", check);
   }


   public static int bottleCheck(Bottle a1, Bottle a2, Bottle a3, Bottle a4, Bottle a5, int i){ 
      a1.cycle(); a2.cycle(); a3.cycle(); a4.cycle(); a5.cycle();

      int c = 0;
      Math.DivRem(i, 2, out c);
      return a1.check(c) + a2.check(c) + a3.check(c) + a4.check(c) + a5.check(c); 
   }


   internal interface IBottle 
   {
      void state(BottleState s);
   }

   internal abstract class BottleState 
   {
      internal static EmptyState Empty = new EmptyState();
      internal static FullState Full = new FullState();
      internal static SealedState Sealed = new SealedState();

      abstract internal void next(IBottle b);  
      abstract internal int tag(); 
      internal static BottleState initialState(){ return Empty; }    

      internal class EmptyState : BottleState {
         override internal void next(IBottle b){ b.state(Full); }  
         override internal int tag(){ return 1; }  
      }

      internal class FullState : BottleState {
         override internal void next(IBottle b){ b.state(Sealed); }
         override internal int tag(){ return 2; }    
      }

      internal class SealedState : BottleState {
         override internal void next(IBottle b){ b.state(Empty); }  
         override internal int tag(){ return 3; }  
      }
   }


   abstract internal class PressurizedBottleState : BottleState 
   {
      internal static UnpressurizedEmptyState UnpressurizedEmpty = new UnpressurizedEmptyState();
      internal static UnpressurizedFullState UnpressurizedFull = new UnpressurizedFullState();
      internal static PressurizedUnsealedState PressurizedUnsealed = new PressurizedUnsealedState();
      internal static PressurizedSealedState PressurizedSealed = new PressurizedSealedState();

      new internal static BottleState initialState(){ 
         return UnpressurizedEmpty; 
      }      

      internal class UnpressurizedEmptyState : PressurizedBottleState {
         override internal void next(IBottle b){ b.state(UnpressurizedFull); } 
         override internal int tag(){ return 4; }  
      }

      internal class UnpressurizedFullState : PressurizedBottleState {
         override internal void next(IBottle b){ b.state(PressurizedUnsealed); } 
         override internal int tag(){ return 5; }  
      }

      internal class PressurizedUnsealedState : PressurizedBottleState { 
         override internal void next(IBottle b){ b.state(PressurizedSealed); } 
         override internal int tag(){ return 6; }  
      }

      internal class PressurizedSealedState : PressurizedBottleState { 
         override internal void next(IBottle b){ b.state(UnpressurizedEmpty); } 
         override internal int tag(){ return 7; }  
      }
   }



   internal class Bottle : IBottle
   {
      protected BottleState s;
      protected int id;

      public Bottle(int id){
         this.id = id;
         s = initialState();
      }

      public void state(BottleState s){ this.s = s; }

      internal virtual void cycle(){
         fill(); seal(); empty();
      }

      internal static BottleState initialState(){ 
         return BottleState.initialState(); 
      }

      protected void empty(){ s.next(this); }
      protected void fill(){ s.next(this); }
      protected void seal(){ s.next(this); }

      internal int check(int c){ return s.tag() + id + c; }
   }


   class PressurizedBottle : Bottle
   {
      public PressurizedBottle(int id) : base(id){}

      new internal static BottleState initialState(){ 
         return PressurizedBottleState.initialState(); 
      }

      void pressurize(){ s.next(this); } 

      internal override void cycle(){
         fill(); pressurize(); seal(); empty();
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy */

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Diagnostics;

class Echo
{
   static void Main(string[] args)
   {
      int n = 1;
      if (args.Length > 0){
         n = Int32.Parse(args[0]);

         Process p = new Process();
         ProcessStartInfo i = p.StartInfo;
         i.FileName = "mono";
         i.Arguments = "echo.csharp_run";
         i.UseShellExecute = false;
         p.Start();

         Client.Start(n);
      }
      else {
         Listener.Start();
      }
   }
}


public class Listener 
{
   public static void Start() 
   {
      TcpListener listener = new TcpListener(11000);
      listener.Start();
      
      using (TcpClient client = listener.AcceptTcpClient()){
         NetworkStream s = client.GetStream();

         byte[] buffer = new byte[32];
         int count = 0;
         while (true) {
            int bytesRec = s.Read(buffer, 0, buffer.Length);

            if (bytesRec > 0) {
               s.Write(buffer, 0, bytesRec);
               count += bytesRec;
            }
            else break; 
         }
         Console.WriteLine("server processed {0} bytes", count);
         listener.Stop();
      } 
   }
}


public class Client 
{
   private const string data = "Hello there sailor\n";

   public static void Start(int n) 
   {
      byte[] msg = Encoding.ASCII.GetBytes(data);
      byte[] buffer = new byte[32];

      using (TcpClient client = new TcpClient("127.0.0.1",11000)){     
         NetworkStream s = client.GetStream();         

         while (n-- > 0){
            s.Write(msg, 0, msg.Length);
            int bytesRec = s.Read(buffer, 0, buffer.Length);
            bool responseOK = msg.Length == bytesRec;
            if (responseOK)
               for (int i=0; i < bytesRec; i++)
                  if ( !(responseOK = msg[i] == buffer[i]) )
                     break;

            if (!responseOK) Console.WriteLine("Response doesn't match message.");
         }
      } 
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy */

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Diagnostics;

class Echo
{
   static void Main(string[] args)
   {
      int n = 1;
      if (args.Length > 0){
         n = Int32.Parse(args[0]);

         Process p = new Process();
         ProcessStartInfo i = p.StartInfo;
         i.FileName = "mono";
         i.Arguments = "echo.csharp_run";
         i.UseShellExecute = false;
         p.Start();

         EchoClient.Start(n);
      }
      else {
         EchoListener.Start();
      }
   }
}


public class EchoListener 
{
   public static void Start() 
   {
      IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
      IPAddress ipAddress = ipHostInfo.AddressList[0];
      IPEndPoint localEndPoint = new IPEndPoint(ipAddress, 11000);

      Socket listener = new Socket(AddressFamily.InterNetwork,
         SocketType.Stream, ProtocolType.Tcp );

      try {
         listener.Bind(localEndPoint);
         listener.Listen(10);
         Socket handler = listener.Accept();

         byte[] buffer = new byte[32];
         int count = 0;

         int bytesRec;
         while (true) {
            bytesRec = handler.Receive(buffer);
            if (bytesRec > 0) {
               handler.Send(buffer, 0, bytesRec, SocketFlags.None);
               count += bytesRec;
            }
            else break; 
         }
         Console.WriteLine("server processed {0} bytes", count);

         handler.Shutdown(SocketShutdown.Both);
         handler.Close();
      } 
      catch (Exception e){
         Console.WriteLine(e.ToString());
      }
   }
}


public class EchoClient 
{
   private const string data = "Hello there sailor\n";

   public static void Start(int n) 
   {
      byte[] bytes = new byte[32];

      try {
         IPHostEntry ipHostInfo = Dns.Resolve(Dns.GetHostName());
         IPAddress ipAddress = ipHostInfo.AddressList[0];
         IPEndPoint remoteEP = new IPEndPoint(ipAddress, 11000);

         Socket sender = new Socket(AddressFamily.InterNetwork, 
         SocketType.Stream, ProtocolType.Tcp );
         sender.Connect(remoteEP);

         byte[] msg = Encoding.ASCII.GetBytes(data);
         int bytesSent, bytesRec;
         bool responseOK;
         while (n-- > 0){
            bytesSent = sender.Send(msg);

            bytesRec = sender.Receive(bytes);
            responseOK = msg.Length == bytesRec;
            if (responseOK)
               for (int i=0; i < bytesRec; i++)
                  if ( !(responseOK = msg[i] == bytes[i]) )
                     break;
            if (!responseOK) Console.WriteLine("Response doesn't match message.");
         }

         sender.Shutdown(SocketShutdown.Both);
         sender.Close();

      } 
      catch (Exception e){
         Console.WriteLine( e.ToString());
      }
   }
}
// $Id: except.csharp,v 1.4 2005-02-22 19:05:07 igouy-guest Exp $
// http://shootout.alioth.debian.org
// contributed by Erik Saltwell
// Some clean-ups based on suggestions by Isaac Gouy

using System;

class LoException : System.Exception
{
    public LoException() {}
}

class HiException : System.Exception 
{
    public HiException() {}
}

public class except
{
    static int Lo = 0;
    static int Hi = 0;
    static int count=0;
    
    public static void Main(string[] args)
    {
        int n = int.Parse(args[0]);
        for (count=0; count<n; count++) 
        {
            SomeFunction();
        }
        Console.WriteLine("Exceptions: HI={0} / LO={1}", Hi, Lo);
    }

    public static void SomeFunction() 
    {
        try 
        {
            HiFunction();
        } 
        catch (Exception e) 
        {
            Console.WriteLine("We shouldn't get here: {0}", e.Message);
        }
    }

    public static void HiFunction() 
    {
        try 
        {
            LoFunction();
        } 
        catch (HiException) 
        {
            Hi++;
        }
    }

    public static void LoFunction()
    {
        try 
        {
            BlowUp();
        } 
        catch (LoException) 
        {
            Lo++;
        }
    }
    
    public static void BlowUp() 
    {
        if ((count & 1) == 0) 
        {
            throw new LoException();
        } 
        else 
        {
            throw new HiException();
        }
    }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class Fannkuch
{
   public static int fannkuch(int n) {
      int check = 0;
      int[] perm = new int[n];
      int[] perm1 = new int[n];
      int[] count = new int[n];
      int[] maxPerm = new int[n];
      int maxFlipsCount = 0;
      int m = n - 1;
 
      for(int i=0; i<n; i++) perm1[i] = i;
      int r = n;

      while (true) {
         // write-out the first 30 permutations 
         if (check < 30){
           for(int i=0; i<n; i++) Console.Write("{0}", perm1[i]+1); 
           Console.WriteLine();
           check++;
         }

         while (r != 1){ count[r-1] = r; r--; } 
         if (! (perm1[0]==0 || perm1[m] == m)){       
            for(int i=0; i<n; i++) perm[i] = perm1[i]; 
            int flipsCount = 0;
            int k;

            while ( !((k=perm[0]) == 0) ) {
               int k2 = (k+1) >> 1;
               for(int i=0; i<k2; i++) {
                  int temp = perm[i]; perm[i] = perm[k-i]; perm[k-i] = temp;
               }
               flipsCount++;
            }

            if (flipsCount > maxFlipsCount) {
               maxFlipsCount = flipsCount;
               for(int i=0; i<n; i++) maxPerm[i] = perm1[i];
            }
         } 

         // Use incremental change to generate another permutation
         while (true) {        
            if (r == n) return maxFlipsCount;
            int perm0 = perm1[0];
            int i = 0;
            while (i < r) {
               int j = i + 1;
               perm1[i] = perm1[j];
               i = j;
            }
            perm1[r] = perm0;

            count[r] = count[r] - 1;
            if (count[r] > 0) break;
            r++;
         }
      }
   }

   static void Main(string[] args){
      int n = 7;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Console.WriteLine("Pfannkuchen({0}) = {1}", n, fannkuch(n));
   }
}
/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
*
* Based on contribution of Isaac Gouy
* Based on contribution of Eckehard Berns
* Based on code by Heiner Marxen
* and the ATS version by Hongwei Xi
* convert to C# by The Anh Tran
*/

using System;
using System.Threading;

sealed class fannkuch
{
    private readonly int n;
    private readonly int[] flip_max_arr;
    private int remain_task = -1;

    static void Main(string[] args)
    {
        int x = (args.Length > 0) ? Int32.Parse(args[0]) : 7;

        fannkuch f = new fannkuch(x);
        Console.WriteLine("Pfannkuchen({0}) = {1}", x, f.fank_game());
    }
    
    public fannkuch(int N)
    {
    	n = N;
        // hold flip_count result for each swapping index
        flip_max_arr = new int[n];
    }

    private int fank_game()
    {
        Thread[] th = new Thread[Environment.ProcessorCount];

        for (int i = 0; i < th.Length; i++)
        {
            th[i] = new Thread(worker);
            th[i].Start();
        }

        print_30_permut();

        foreach (Thread t in th)
            t.Join();

        int mx = 0;
        foreach (int i in flip_max_arr)
            if (mx < i)
                mx = i;
        return mx;
    }
    
    // In order to divide tasks 'equally' for many threads, permut generation 
    // strategy is different than that of original single thread.
    // this function will 'correctly' print first 30 permutations
    void print_30_permut()
    {
	    // declare and initialize
	    int[] permutation = new int[n];
	    for ( int i = 0; i < n; i++ )
	    {
		    permutation[i] = i;
		    Console.Write("{0}", (1 + i));
		}
	    Console.WriteLine();

	    int[] perm_remain = new int[n];
	    for ( int i = 1; i <= n; i++ )
		    perm_remain[i -1] = i;

	    int numPermutationsPrinted = 1;
	    for ( int pos_right = 2; pos_right <= n; pos_right++ )
	    {
		    int pos_left = pos_right -1;
		    while (pos_left < pos_right)
		    {
			    // rotate down perm[0..prev] by one
			    next_perm(permutation, pos_left);

			    if (--perm_remain[pos_left] > 0)
			    {
				    if (numPermutationsPrinted++ < 30)
				    {
					    for (int i = 0; i < n; ++i)
	                        Console.Write("{0}", (1 + permutation[i]));
                        Console.WriteLine();
				    }
				    else
				    	return;

				    for ( ; pos_left != 1; --pos_left)
					    perm_remain[pos_left -1] = pos_left;
			    }
			    else
				    ++pos_left;
		    }
	    }
    }

    private void worker()
    {
        int[] permutation = new int[n];
        int[] perm_remain = new int[n];
        int[] perm_flip = new int[n];

        int pos_right;
        while ((pos_right = Interlocked.Increment(ref remain_task)) < (n - 1))
        {
            int flip_max = 0;

            for (int i = 0; i < n - 1; i++)
                permutation[i] = i;

            permutation[pos_right] = (n - 1);
            permutation[n - 1] = (pos_right);

            for (int i = 1; i <= n; i++)
                perm_remain[i - 1] = i;

            int pos_left = n - 2;
            while (pos_left < n - 1)
            {
                // rotate down perm[0..r] by one
                next_perm(permutation, pos_left);

                if (--perm_remain[pos_left] > 0)
                {
                    for (; pos_left != 1; --pos_left)
                        perm_remain[pos_left - 1] = pos_left;

                    if ((permutation[0] != 0) && (permutation[n - 1] != (n - 1)))
                    {
				        permutation.CopyTo(perm_flip, 0);
                        int flipcount = count_flip(perm_flip);
                        if (flip_max < flipcount)
                            flip_max = flipcount;
                    }
                }
                else
                    pos_left++;
            }

            // update max_flip foreach flipping position
            flip_max_arr[pos_right] = flip_max;
        }
    }


    // Take a permut array, continuously flipping until first element is '1'
    // Return flipping times
    private static int count_flip(int[] perm_flip)
    {	
        // cache first element, avoid swapping perm[0] and perm[k]
        int v0 = perm_flip[0];
        int tmp;

        int flip_count = 0;
        do
        {
            for (int i = 1, j = v0 - 1; i < j; ++i, --j)
            {
                tmp = perm_flip[i];
                perm_flip[i] = perm_flip[j];
                perm_flip[j] = tmp;
            }

            tmp = perm_flip[v0];
            perm_flip[v0] = v0;
            v0 = tmp;

            flip_count++;
        } while (v0 != 0); // first element == '1'

        return flip_count;
    }

    // Return next permut, by rotating elements [0 - position] one 'step'
    // next_perm('1234', 2) -> '2314'
    private void next_perm(int[] permutation, int position)
    {
        int perm0 = permutation[0];

        for (int i = 0; i < position; ++i)
            permutation[i] = permutation[i + 1];
        permutation[position] = perm0;
    }

};

/*
* The Computer Language Benchmarks Game
* http://shootout.alioth.debian.org/
*
* Based on contribution of Isaac Gouy
* Based on contribution of Eckehard Berns
* Based on code by Heiner Marxen
* and the ATS version by Hongwei Xi
* convert to C# by The Anh Tran
* optimized for speed by bearophile. Compile with \unsafe
*/

using System;
using System.Threading;

unsafe sealed class fannkuch
{
    private readonly int n;
    private readonly int[] flip_max_arr;

    private int remain_task = -1;

    static void Main(string[] args)
    {
        int x = (args.Length > 0) ? Int32.Parse(args[0]) : 7;

        fannkuch f = new fannkuch(x);
        Console.WriteLine("Pfannkuchen({0}) = {1}", x, f.fank_game());
    }

    public fannkuch(int N)
    {
        n = N;
        // hold flip_count result for each swapping index
        flip_max_arr = new int[n];
    }

    private int fank_game()
    {
        Thread[] th = new Thread[Environment.ProcessorCount];

        for (int i = 0; i < th.Length; i++)
        {
            th[i] = new Thread(worker);
            th[i].Start();
        }

        print_30_permut();

        foreach (Thread t in th)
            t.Join();

        int mx = 0;
        foreach (int i in flip_max_arr)
            if (mx < i)
                mx = i;
        return mx;
    }

    // In order to divide tasks 'equally' for many threads, permut generation
    // strategy is different than that of original single thread.
    // this function will 'correctly' print first 30 permutations
    void print_30_permut()
    {
        // declare and initialize
        int* permutation = stackalloc int[n];

        for (int i = 0; i < n; i++)
        {
            permutation[i] = i;
            Console.Write("{0}", (1 + i));
        }
        Console.WriteLine();

        int[] perm_remain = new int[n];
        for (int i = 1; i <= n; i++)
            perm_remain[i - 1] = i;

        int numPermutationsPrinted = 1;
        for (int pos_right = 2; pos_right <= n; pos_right++)
        {
            int pos_left = pos_right - 1;
            while (pos_left < pos_right)
            {
                // rotate down perm[0..prev] by one
                next_perm(permutation, pos_left);

                if (--perm_remain[pos_left] > 0)
                {
                    if (numPermutationsPrinted++ < 30)
                    {
                        for (int i = 0; i < n; ++i)
                            Console.Write("{0}", (1 + permutation[i]));
                        Console.WriteLine();
                    }
                    else
                        return;

                    for (; pos_left != 1; --pos_left)
                        perm_remain[pos_left - 1] = pos_left;
                }
                else
                    ++pos_left;
            }
        }
    }

    private unsafe void worker()
    {
        int* permutation = stackalloc int[n];
        int* perm_remain = stackalloc int[n];
        int* perm_flip = stackalloc int[n];

        int pos_right;
        while ((pos_right = Interlocked.Increment(ref remain_task)) < (n - 1))
        {
            int flip_max = 0;

            for (int i = 0; i < n - 1; i++)
                permutation[i] = i;

            permutation[pos_right] = (n - 1);
            permutation[n - 1] = (pos_right);

            for (int i = 1; i <= n; i++)
                perm_remain[i - 1] = i;

            int pos_left = n - 2;
            while (pos_left < n - 1)
            {
                // rotate down perm[0..r] by one
                next_perm(permutation, pos_left);

                if (--perm_remain[pos_left] > 0)
                {
                    for (; pos_left != 1; --pos_left)
                        perm_remain[pos_left - 1] = pos_left;

                    if ((permutation[0] != 0) && (permutation[n - 1] != (n - 1)))
                    {
                        for (int ip = 0; ip < n; ip++)
                            perm_flip[ip] = permutation[ip];
                        int flipcount = count_flip(perm_flip);
                        if (flip_max < flipcount)
                            flip_max = flipcount;
                    }
                }
                else
                    pos_left++;
            }

            // update max_flip foreach flipping position
            flip_max_arr[pos_right] = flip_max;
        }
    }


    // Take a permut array, continuously flipping until first element is '1'
    // Return flipping times
    private static int count_flip(int* perm_flip)
    {
        // cache first element, avoid swapping perm[0] and perm[k]
        int v0 = perm_flip[0];
        int tmp;

        int flip_count = 0;
        do
        {
            for (int i = 1, j = v0 - 1; i < j; ++i, --j)
            {
                tmp = perm_flip[i];
                perm_flip[i] = perm_flip[j];
                perm_flip[j] = tmp;
            }

            tmp = perm_flip[v0];
            perm_flip[v0] = v0;
            v0 = tmp;

            flip_count++;
        } while (v0 != 0); // first element == '1'

        return flip_count;
    }

    // Return next permut, by rotating elements [0 - position] one 'step'
    // next_perm('1234', 2) -> '2314'
    private void next_perm(int* permutation, int position)
    {
        int perm0 = permutation[0];

        for (int i = 0; i < position; ++i)
            permutation[i] = permutation[i + 1];
        permutation[position] = perm0;
    }

};
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy, transliterated from Rex Kerr's Scala program
*/

using System;

class FannkuchRedux
{
   public static int fannkuch(int n) {
      int[] perm = new int[n], perm1 = new int[n], count = new int[n];
      for(int j=0; j<n; j++) perm1[j] = j;
      int f = 0, i = 0, k = 0, r = 0, flips = 0, nperm = 0, checksum = 0;

      r = n;
      while (r>0) {
         i = 0;
         while (r != 1) { count[r-1] = r; r -= 1; }
         while (i < n) { perm[i] = perm1[i]; i += 1; }
      
         // Count flips and update max  and checksum
         f = 0;
         k = perm[0];
         while (k != 0) {
           i = 0;
           while (2*i < k) {
             var t = perm[i]; perm[i] = perm[k-i]; perm[k-i] = t;
             i += 1;
           }
           k = perm[0];
           f += 1;
         }
         if (f>flips) flips = f;
         if ((nperm&0x1)==0) checksum += f;
         else checksum -= f;
                      
         // Use incremental change to generate another permutation
         var go = true;
         while (go) {
            if (r == n) {
               Console.WriteLine(checksum);
               return flips;
            }
            var p0 = perm1[0];
            i = 0;
            while (i < r) {
               var j = i+1;
               perm1[i] = perm1[j];
               i = j;
            }
            perm1[r] = p0;

            count[r] -= 1;
            if (count[r] > 0) go = false;
            else r += 1;
         }
         nperm += 1;
      }
      return flips;
   }

   static void Main(string[] args){
      int n = 7;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      Console.WriteLine("Pfannkuchen({0}) = {1}", n, fannkuch(n));
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy, transliterated from Mike Pall's Lua program 
*/

using System;

class FannkuchRedux
{
   public static int[] fannkuch(int n) {
      int[] p = new int[n], q = new int[n], s = new int[n]; 
      int sign = 1, maxflips = 0, sum = 0, m = n-1;
      for(int i=0; i<n; i++){ p[i] = i; q[i] = i; s[i] = i; }      
      do {
         // Copy and flip.
         var q0 = p[0];                                     // Cache 0th element.
         if (q0 != 0){
            for(int i=1; i<n; i++) q[i] = p[i];             // Work on a copy.
            var flips = 1;
            do { 
               var qq = q[q0]; 
               if (qq == 0){                                // ... until 0th element is 0.
                  sum += sign*flips;
	          if (flips > maxflips) maxflips = flips;   // New maximum?
                  break; 
               } 
 	       q[q0] = q0; 
	       if (q0 >= 3){
	          int i = 1, j = q0 - 1, t;
                  do { t = q[i]; q[i] = q[j]; q[j] = t; i++; j--; } while (i < j); 
               }
	       q0 = qq; flips++;
            } while (true); 
         }
         // Permute.
         if (sign == 1){
            var t = p[1]; p[1] = p[0]; p[0] = t; sign = -1; // Rotate 0<-1.
         } else { 
            var t = p[1]; p[1] = p[2]; p[2] = t; sign = 1;  // Rotate 0<-1 and 0<-1<-2.
            for(int i=2; i<n; i++){ 
	       var sx = s[i];
	       if (sx != 0){ s[i] = sx-1; break; }
	       if (i == m) return new int[]{sum,maxflips};  // Out of permutations.
	       s[i] = i;
	       // Rotate 0<-...<-i+1.
	       t = p[0]; for(int j=0; j<=i; j++){ p[j] = p[j+1]; } p[i+1] = t;
            }
         }
      } while (true);
   }

   static void Main(string[] args){
      int n = (args.Length > 0) ? Int32.Parse(args[0]) : 7;
      var pf = fannkuch(n);
      Console.Write("{0}\nPfannkuchen({1}) = {2}\n", pf[0], n, pf[1]);
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy, transliterated from Oleg Mazurov's Java program
*/

using System;
using System.Threading;


class FannkuchRedux
{
   private static int NCHUNKS = 150;
   private static int CHUNKSZ;
   private static int NTASKS;
   private static int n;
   private static int[] Fact;
   private static int[] maxFlips;
   private static int[] chkSums;
   private static int taskId;

   int[] p, pp, count;


   void FirstPermutation( int idx )
   {
       for ( int i=0; i<p.Length; ++i ) {
          p[i] = i;
       }

       for ( int i=count.Length-1; i>0; --i ) {
           int d = idx / Fact[i];
           count[i] = d;
           idx = idx % Fact[i];

           Array.Copy( p, 0, pp, 0, i+1 );
           for ( int j=0; j<=i; ++j ) {
               p[j] = j+d <= i ? pp[j+d] : pp[j+d-i-1];
           }
       }
   }


   bool NextPermutation()
   {
      int first = p[1];
      p[1] = p[0];
      p[0] = first;

      int i=1;
      while ( ++count[i] > i ) {
         count[i++] = 0;
         int next = p[0] = p[1];
         for ( int j=1; j<i; ++j ) {
            p[j] = p[j+1];
         }
         p[i] = first;
         first = next;
      }
      return true;
   }


   int CountFlips()
   {
      int flips = 1;
      int first = p[0];
      if ( p[first] != 0 ) {
         Array.Copy( p, 0, pp, 0, pp.Length );
         do {
            ++flips;
            for ( int lo = 1, hi = first - 1; lo < hi; ++lo, --hi ) {
               int t = pp[lo];
               pp[lo] = pp[hi];
               pp[hi] = t;
            }
            int tp = pp[first];
            pp[first] = first;
            first = tp;
         } while ( pp[first] != 0 );
      }
      return flips;
   }


   void RunTask( int task )
   {
      int idxMin = task*CHUNKSZ;
      int idxMax = Math.Min( Fact[n], idxMin+CHUNKSZ );

      FirstPermutation( idxMin );

      int maxflips = 1;
      int chksum = 0;
      for ( int i=idxMin;; ) {

         if ( p[0] != 0 ) {
            int flips = CountFlips();
            maxflips = Math.Max( maxflips, flips );
            chksum += i%2 ==0 ? flips : -flips;
         }

         if ( ++i == idxMax ) {
	    break;
	 }

         NextPermutation();
      }
      maxFlips[task] = maxflips;
      chkSums[task]  = chksum;
   }


   public void Run()
   {
      p     = new int[n];
      pp    = new int[n];
      count = new int[n];

      int task;
      while ( (task = taskId++) < NTASKS ) { // NOT SAFE - need PFX
	 RunTask( task );       
      } 
   }


   static void Main(string[] args)
   {
      n = 7;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Fact = new int[n+1];
      Fact[0] = 1;
      for ( int i=1; i<Fact.Length; ++i ) {
         Fact[i] = Fact[i-1] * i;
      }

      CHUNKSZ = (Fact[n] + NCHUNKS - 1) / NCHUNKS;
      NTASKS = (Fact[n] + CHUNKSZ - 1) / CHUNKSZ;
      maxFlips = new int[NTASKS];
      chkSums  = new int[NTASKS];
      taskId = 0;

      int nthreads = Environment.ProcessorCount;
      Thread[] threads = new Thread[nthreads];
      for ( int i=0; i<nthreads; ++i ) {
         threads[i] = new Thread( new ThreadStart(new FannkuchRedux().Run) );
         threads[i].Start();
      }
      foreach ( Thread t in threads ) {
         t.Join();
      }

      int res = 0;
      foreach ( int v in maxFlips ) {
         res = Math.Max( res, v );
      }
      int chk = 0;
      foreach ( int v in chkSums ) {
         chk += v;
      }

      Console.WriteLine("{0}\nPfannkuchen({1}) = {2}", chk, n, res);
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Robert F. Tobler
   optimized based on java & C# by Enotus, Isaac Gouy, and Alp Toker
*/

using System;
using System.IO;
using System.Text;

static class Fasta
{
   static void Main (string[] args) {
		AccumulateAndScale(HomoSapiens);
		AccumulateAndScale(IUB);
		int n = args.Length > 0 ? Int32.Parse (args[0]) : 2500000;
		using (Stream s = Console.OpenStandardOutput ()) {
         s.WriteRepeatFasta("ONE", "Homo sapiens alu",
                        Encoding.ASCII.GetBytes(ALU), n*2);
			s.WriteRandomFasta("TWO", "IUB ambiguity codes",
			               IUB, n*3);
			s.WriteRandomFasta("THREE", "Homo sapiens frequency",
			               HomoSapiens, n*5);
		}
	}

   const int LINE_LEN = 60;
   const int BUF_LEN = 64 * 1024;
   const byte LF = (byte)'\n';

   const int LOOKUP_LEN = 1024;
   const double LOOKUP_SCALE = LOOKUP_LEN - 1;

	static readonly string ALU =
		"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" +
		"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" +
		"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" +
		"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" +
		"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" +
		"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" +
		"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

   struct Freq {
      public double P;
      public byte C;

      public Freq (char c, double p) { C = (byte)c; P = p; }
	}

	static Freq[] IUB = {
      new Freq('a', 0.27), new Freq('c', 0.12), new Freq('g', 0.12),
      new Freq('t', 0.27), new Freq('B', 0.02), new Freq('D', 0.02),
      new Freq('H', 0.02), new Freq('K', 0.02), new Freq('M', 0.02),
      new Freq('N', 0.02), new Freq('R', 0.02), new Freq('S', 0.02),
      new Freq('V', 0.02), new Freq('W', 0.02), new Freq('Y', 0.02),
	};

	static Freq[] HomoSapiens = {
      new Freq ('a', 0.3029549426680), new Freq ('c', 0.1979883004921),
      new Freq ('g', 0.1975473066391), new Freq ('t', 0.3015094502008),
	};

	static void AccumulateAndScale(Freq[] a) {
		double cp = 0.0;
		for (int i = 0; i < a.Length; i++)
         a[i].P = (cp += a[i].P) * LOOKUP_SCALE;
      a[a.Length - 1].P = LOOKUP_SCALE;
	}

   static byte[] buf = new byte[BUF_LEN];

   static int WriteDesc(this byte[] buf, string id, string desc)
   {
		var ds = Encoding.ASCII.GetBytes (">" + id + " " + desc + "\n");
      for (int i = 0; i < ds.Length; i++) buf[i] = ds[i];
      return BUF_LEN - ds.Length;
   }

   static int Min(int a, int b) { return a < b ? a : b; }

   static void WriteRepeatFasta(
         this Stream s, string id, string desc, byte[] alu, int nr)
   {
      int alen = alu.Length;
      int ar = alen, br = buf.WriteDesc(id, desc), lr = LINE_LEN;
      while (nr > 0)
      {
         int r = Min(Min(nr, lr), Min(ar, br));
         for (int ai = alen - ar, bi = BUF_LEN - br, be = bi + r;
             bi < be; bi++, ai++) buf[bi] = alu[ai];
         nr -= r; lr -= r; br -= r; ar -= r;
         if (ar == 0) ar = alen;
         if (br == 0) { s.Write(buf, 0, BUF_LEN); br = BUF_LEN; }
         if (lr == 0) { buf[BUF_LEN - (br--)] = LF; lr = LINE_LEN; }
         if (br == 0) { s.Write(buf, 0, BUF_LEN); br = BUF_LEN; }
      }
      if (lr < LINE_LEN) buf[BUF_LEN - (br--)] = LF;
      if (br < BUF_LEN) s.Write(buf, 0, BUF_LEN - br);
   } 

   static Freq[] lookup = new Freq[LOOKUP_LEN];

   static void CreateLookup(Freq[] fr) {
      for (int i = 0, j = 0; i < LOOKUP_LEN; i++) {
         while (fr[j].P < i) j++;
         lookup[i] = fr[j];
      }
   }

	const int IM = 139968;
	const int IA = 3877;
	const int IC = 29573;
   const double SCALE = LOOKUP_SCALE / IM;

	static int last = 42;

   static void WriteRandomFasta(
         this Stream s, string id, string desc, Freq[] fr, int nr)
   {
      CreateLookup(fr);
      int br = buf.WriteDesc(id, desc), lr = LINE_LEN;      
      while (nr > 0)
      {
         int r = Min(Min(nr, lr), br);
         for (int bi = BUF_LEN - br, be = bi + r; bi < be; bi++)
         {
            double p = SCALE * (last = (last * IA + IC) % IM);
            int ai = (int)p; if (lookup[ai].P < p) ai++;
            buf[bi] = lookup[ai].C;
         }
         nr -= r; lr -= r; br -= r;
         if (br == 0) { s.Write(buf, 0, BUF_LEN); br = BUF_LEN; }
         if (lr == 0) { buf[BUF_LEN - (br--)] = LF; lr = LINE_LEN; }
         if (br == 0) { s.Write(buf, 0, BUF_LEN); br = BUF_LEN; }
      }
      if (lr < LINE_LEN) buf[BUF_LEN - (br--)] = LF;
      if (br < BUF_LEN) s.Write(buf, 0, BUF_LEN - br);
   } 

}
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy
   optimizations by Alp Toker <alp@atoker.com>
*/

using System;
using System.IO;
using System.Text;

class Fasta
{
	static void Main (string[] args) {
		MakeCumulative (HomoSapiens);
		MakeCumulative (IUB);

		int n = args.Length > 0 ? Int32.Parse (args[0]) : 1000;

		using (Stream s = Console.OpenStandardOutput ()) {
			MakeRepeatFasta ("ONE", "Homo sapiens alu", Encoding.ASCII.GetBytes (ALU), n*2, s);
			MakeRandomFasta ("TWO", "IUB ambiguity codes", IUB, n*3, s);
			MakeRandomFasta ("THREE", "Homo sapiens frequency", HomoSapiens, n*5, s);
		}
	}

	// The usual pseudo-random number generator

	const int IM = 139968;
	const int IA = 3877;
	const int IC = 29573;
	static int seed = 42;

	static double random (double max)
	{
		return max * ((seed = (seed * IA + IC) % IM) * (1.0 / IM));
	}

	// Weighted selection from alphabet

	static string ALU =
		"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" +
		"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" +
		"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" +
		"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" +
		"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" +
		"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" +
		"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

	class Frequency {
		public byte c;
		public double p;

		public Frequency (char c, double p) {
			this.c = (byte)c;
			this.p = p;
		}
	}

	static Frequency[] IUB = {
		new Frequency ('a', 0.27)
			,new Frequency ('c', 0.12)
			,new Frequency ('g', 0.12)
			,new Frequency ('t', 0.27)

			,new Frequency ('B', 0.02)
			,new Frequency ('D', 0.02)
			,new Frequency ('H', 0.02)
			,new Frequency ('K', 0.02)
			,new Frequency ('M', 0.02)
			,new Frequency ('N', 0.02)
			,new Frequency ('R', 0.02)
			,new Frequency ('S', 0.02)
			,new Frequency ('V', 0.02)
			,new Frequency ('W', 0.02)
			,new Frequency ('Y', 0.02)
	};

	static Frequency[] HomoSapiens = {
		new Frequency ('a', 0.3029549426680)
			,new Frequency ('c', 0.1979883004921)
			,new Frequency ('g', 0.1975473066391)
			,new Frequency ('t', 0.3015094502008)
	};

	static void MakeCumulative (Frequency[] a) {
		double cp = 0.0;
		for (int i=0; i < a.Length; i++) {
			cp += a[i].p;
			a[i].p = cp;
		}
	}

	// naive
	static byte SelectRandom (Frequency[] a) {
		double r = random (1.0);

		for (int i=0 ; i < a.Length ; i++)
			if (r < a[i].p)
				return a[i].c;

		return a[a.Length-1].c;
	}

	const int LineLength = 60;
	static int index = 0;
	static byte[] buf = new byte[1024];

	static void MakeRandomFasta (string id, string desc, Frequency[] a, int n, Stream s) {
		index = 0;
		int m = 0;

		byte[] descStr = Encoding.ASCII.GetBytes (">" + id + " " + desc + "\n");
		s.Write (descStr, 0, descStr.Length);

		while (n > 0) {
			m = n < LineLength ? n : LineLength;

			if (buf.Length - index < m) {
				s.Write (buf, 0, index);
				index = 0;
			}

			for (int i = 0 ; i < m ; i++) {
				buf[index++] = SelectRandom (a);
			}

			buf[index++] = (byte)'\n';
			n -= LineLength;
		}

		if (index != 0)
			s.Write (buf, 0, index);
	}

	static void MakeRepeatFasta (string id, string desc, byte[] alu, int n, Stream s) {
		index = 0;
		int m = 0;
		int k = 0;
	 	int kn = alu.Length;

		byte[] descStr = Encoding.ASCII.GetBytes (">" + id + " " + desc + "\n");
		s.Write (descStr, 0, descStr.Length);

		while (n > 0) {
			m = n < LineLength ? n : LineLength;

			if (buf.Length - index < m) {
				s.Write (buf, 0, index);
				index = 0;
			}

			for (int i = 0; i < m ; i++) {
				if (k == kn)
					k = 0;

				buf[index++] = alu[k];
				k++;
			}

			buf[index++] = (byte)'\n';
			n -= LineLength;
		}

		if (index != 0)
			s.Write (buf, 0, index);
	}
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org   

   contributed by Isaac Gouy */

using System;

class Fibo
{
   public static int Fib(int n) {
      if (n < 2) return 1;
      else return Fib(n-2) + Fib(n-1);
   }

   static void Main(string[] args){
      int n = 32;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Console.WriteLine("{0}", Fib(n));
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class Harmonic
{
   public static void Main(String[] args) {        
      int n = 10000000;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      double partialSum = 0.0;    
      for (int i=1; i<=n; i++) partialSum += 1.0/i;
     
      Console.WriteLine("{0:f9}", partialSum);
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class Hash
{
   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int count = 0;
      Hashtable table = new Hashtable(n); 
      for(int i=1; i<=n; i++) 
         table.Add( i.ToString("x"), i );
    
      for(int i=n; i>0; i--) 
         if( table.ContainsKey(i.ToString()) ) count++;

      Console.WriteLine(count);
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class Hash2
{
   static void Main(string[] args)
   {
      const int nKeys = 10000;
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Hashtable table1 = new Hashtable(nKeys); 
      Hashtable table2 = new Hashtable(); 

      for(int i=0; i<nKeys; i++) 
         table1.Add( "foo_" + i.ToString(), i );
        
      Cell table2Value;
      while (n-- > 0) {
         IDictionaryEnumerator item = table1.GetEnumerator();
         while(item.MoveNext()) 
            if ((table2Value = (Cell)table2[item.Key]) != null)
               table2Value.value += (int)item.Value;
            else
               table2[item.Key] = new Cell((int)item.Value);
      }
      Console.WriteLine("{0} {1} {2} {3}", 
         table1["foo_1"], table1["foo_9999"], table2["foo_1"], table2["foo_9999"]);
   }
}


class Cell { 
   internal int value; 

   public Cell(int intialValue){
      value = intialValue;
   }

   public override string ToString(){ 
      return value.ToString();
   }

}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   Unoptimised reference implementation
   
   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class health 
{
   public static void Main(String[] args) {        
      int n = 100;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      HealthcareRegion healthcareSystem = HealthcareRegion.Create();

      for (int i=0; i<n; i++) 
         healthcareSystem.TransferPatients();

      Totals t = healthcareSystem.AccumulateTotals();

      Console.WriteLine("Patients: {0}", t.patients ); 
      Console.WriteLine("Time:     {0}", t.hospitalTime ); 
      Console.WriteLine("Visits:   {0}", t.hospitalVisits ); 

      Console.WriteLine("\nTreatment Queue - Remaining Treatment Time"); 
      foreach (Patient p in healthcareSystem.TreatmentQueue()){
         Console.WriteLine("{0}\tanonymous patient", p.remainingTime ); 
      }
   }
}


class HealthcareRegion 
{
   private const int LEVELS = 5;
   private const int DISTRICTS = 4;

   private HealthcareRegion[] districts;
   private Hospital localHospital;


   static public HealthcareRegion Create() {			
      return HealthcareRegion.Create(LEVELS, 0, 42);
   }


   static HealthcareRegion Create(int level, int seed1, int seed2) {			
      HealthcareRegion r = null;

      if (level > 0) {
         r = new HealthcareRegion(level, seed1*seed2);

         for (int i = r.districts.Length-1; i >= 0; i--)
            r.districts[i] = Create(level-1, (seed1*4)+i+1, seed2);
      }
      return r;
   }


   public HealthcareRegion(int level, int s) {			
      districts = new HealthcareRegion[DISTRICTS];
      localHospital = new Hospital(level==LEVELS, level, s);
   }


   internal SimpleList TransferPatients() {
      for (int i = districts.Length-1; i >= 0; i--)
         if (districts[i] != null)
            foreach (Patient p in districts[i].TransferPatients()) 
               localHospital.NewArrival(p);

      localHospital.TriageExaminationTreatment(); 

      return localHospital.RegionalTransferPatients();
   }


   internal Totals AccumulateTotals() {
      Totals t = new Totals();
      for (int i = districts.Length-1; i >= 0; i--)
         if (districts[i] != null)
            t += districts[i].AccumulateTotals();

      localHospital.AccumulateTotals(ref t);
      return t;
   }

   internal SimpleList TreatmentQueue() {
      return localHospital.TreatmentQueue();
   }
}



class Hospital 
{
   private SimpleList triage = new SimpleList();
   private SimpleList examination = new SimpleList();
   private SimpleList treatment = new SimpleList();
   private Totals discharged = new Totals();

   private int availableStaff;
   private int seed;
   private bool hasNoRegionalHospital;
   private SimpleList transfers = new SimpleList();


   public Hospital(bool hasNoRegionalHospital, int level, int seed) {			
      this.hasNoRegionalHospital = hasNoRegionalHospital;
      availableStaff = 1 << (level - 1);	  
      this.seed = seed;
   }
	

   internal void TriageExaminationTreatment() {
      DischargePatients();
      TreatOrTransferPatients();
      TriagePatients();

      if (Random(1.0) > 0.7) NewArrival( new Patient() ); 
   }


   internal SimpleList RegionalTransferPatients() {
      return transfers;
   }


   internal void AccumulateTotals(ref Totals  t) {
      foreach (Patient p in triage) t.Plus(p);
      foreach (Patient p in examination) t.Plus(p);
      foreach (Patient p in treatment) t.Plus(p);
      t += discharged;
   }


   internal void NewArrival(Patient p) {	
      p.hospitalVisits++;
      if (availableStaff > 0) {
         availableStaff--;
         examination.Add(p);
         p.remainingTime = 3;
         p.hospitalTime += 3;
      } 
      else {
         triage.Add(p);
      }
   }


   void DischargePatients() {	
      foreach (Patient p in treatment){
         p.remainingTime -= 1;

         if (p.remainingTime == 0) {
            availableStaff++;
            treatment.Remove(p);

            discharged.Plus(p);
         }
      }
   }


   void TreatOrTransferPatients() {	
      transfers.Clear();

      foreach (Patient p in examination){
         p.remainingTime -= 1;

         if (p.remainingTime == 0) { 
            // no transfer
            if ((Random(1.0) > 0.1) || hasNoRegionalHospital) {
               examination.Remove(p);
               treatment.Add(p);
               p.remainingTime = 10;
               p.hospitalTime += 10;
            } 
            // transfer
            else {
               availableStaff++;
               examination.Remove(p);
               transfers.Add(p);
            }
         }
      }
   }


   void TriagePatients() {	
      foreach (Patient p in triage){
         if (availableStaff > 0) {
            availableStaff--;
            p.remainingTime = 3;
            p.hospitalTime += 3;
            triage.Remove(p);
            examination.Add(p);
         } 
         else {
            p.hospitalTime++;
         }
      }
   }


   internal SimpleList TreatmentQueue() {
      return treatment;
   }


   // Normally we'd use a Poisson distribution, but this will do.
   // The usual pseudo-random number generator

   private const int IM = 139968;
   private const int IA = 3877;
   private const int IC = 29573;

   private double Random(double max) {        
      seed = (seed * IA + IC) % IM;
      return( max * seed / IM );
   }	
}


class Patient 
{
   internal int remainingTime;
   internal int hospitalTime;
   internal int hospitalVisits;
}

struct Totals 
{
   internal long patients;
   internal long hospitalTime;
   internal long hospitalVisits;

   internal void Plus(Patient p){
      patients++;
      hospitalTime += p.hospitalTime;
      hospitalVisits += p.hospitalVisits;
   }

   public static Totals operator +(Totals a, Totals b){
      Totals answer = new Totals();
      answer.patients = a.patients + b.patients;
      answer.hospitalTime = a.hospitalTime + b.hospitalTime;
      answer.hospitalVisits = a.hospitalVisits + b.hospitalVisits;
      return answer;
   }

}


class SimpleList 
{
   private SimpleNode first, last;

   internal void Add(object o){
      SimpleNode a = new SimpleNode();
      a.item = o; 
      if (first==null){ first = a; } 
      else { last.next = a; }      
      last = a;   
   }

   internal void Remove(object o){
      if (first!=null)
      {
         SimpleNode t = first.next;
         if (first.item==o)
         { 
            if (last==first){ last = null; }
            first.next = null; 
            first = t;         
         }
         else 
         {
            SimpleNode p = first;
            while (t!=null && t.item!=o){ p = t; t = t.next; }
            if (t!=null && t.item==o)
            { 
               p.next = t.next; 
               t.next = null; 
               if (last==t){ last = p; }
            }
         }
      }
   }

   internal void Clear(){
      first = null;
      last = null;      
   }

   public Enumerator GetEnumerator(){
      return new SimpleList.Enumerator(this);
   }


   class SimpleNode
   {
      internal object item;
      internal SimpleNode next;
   }


   public class Enumerator 
   {
      private SimpleList list;
      private SimpleNode node;

      internal Enumerator(SimpleList list){
         this.list = list;
         this.node = list.first;
      }

      public object Current 
      {
         get {
            if (node==null){ throw new InvalidOperationException(); }
            object o = node.item;
            node=node.next;
            return o;
         }
      }

      public bool MoveNext(){  
         return node!=null;
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy 
*/


using System;

class Heapsort
{
   static void Main(string[] args)
   {
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      if (n > 0){
         double[] numbers = new double[n+1];
         for (int i = 1; i <= n; i++) numbers[i] = gen_random(1);
         heapsort(n, numbers);
         Console.WriteLine("{0:f10}", numbers[n]);
      }
   }

   public static void heapsort(int n, double[] ra) 
   {
      int l, j, ir, i;
      double rra;

      l = (n >> 1) + 1;
      ir = n;
      for (;;) 
      {
         if (l > 1) 
         {
            rra = ra[--l];
         } 
         else 
         {
            rra = ra[ir];
            ra[ir] = ra[1];
            if (--ir == 1) 
            {
               ra[1] = rra;
               return;
            }
         }
         i = l;
         j = l << 1;
         while (j <= ir) 
         {
            if (j < ir && ra[j] < ra[j+1]) { ++j; }
            if (rra < ra[j]) 
            {
               ra[i] = ra[j];
               j += (i = j);
            } 
            else 
            {
               j = ir + 1;
            }
         }
         ra[i] = rra;
      }
   }

   const int IM = 139968;
   const int IA = 3877;
   const int IC = 29573;
   static int last = 42;

   static double gen_random(double max) {        
      last = (last * IA + IC) % IM;
      return( max * last / IM );
   }
}
// $Id: hello.csharp,v 1.3 2004-06-21 07:24:00 bfulgham Exp $
// http://shootout.alioth.debian.org

using System;

class hello {
    public static void Main(String[] args) {
        Console.WriteLine("hello world");
    }
}
/* The Computer Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * byte processing version using C# *3.0 idioms by Robert F. Tobler
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

public struct ByteString : IEquatable<ByteString>
{
    public byte[] Array;
    public int Start;
    public int Length;

    public ByteString(byte[] array, int start, int length)
    {
        Array = array; Start = start; Length = length;
    }
    
    public ByteString(string text)
    {
        Start = 0; Length = text.Length;
        Array = Encoding.ASCII.GetBytes(text);
    }
    
    public override int GetHashCode()
    {
        if (Length < 1) return 0;
        int hc = Length ^ (Array[Start] << 24); if (Length < 2) return hc;
        hc ^= Array[Start+Length-1] << 20;      if (Length < 3) return hc;
        for (int c = Length-2; c > 0; c--)
            hc ^= Array[Start + c] << (c & 0xf);
        return hc;
    }

    public bool Equals(ByteString other)
    {
        if (Length != other.Length) return false;
        for (int i = 0; i < Length; i++)
            if (Array[Start+i] != other.Array[other.Start+i]) return false;
        return true;
    }
    
    public override string ToString()
    {
        return Encoding.ASCII.GetString(Array, Start, Length);
    }
}

public static class Extensions
{
    public static byte[] GetBytes(this List<string> input)
    {
        int count = 0;
        for (int i = 0; i < input.Count; i++) count += input[i].Length;        
        var byteArray = new byte[count];
        count = 0;
        for (int i = 0; i < input.Count; i++)
        {
            string line = input[i];
            Encoding.ASCII.GetBytes(line, 0, line.Length, byteArray, count);
            count += line.Length;
        }
        return byteArray;
    }
}

public class program {


    public static void Main(string[] args) {
        string line;
        StreamReader source = new StreamReader(Console.OpenStandardInput());
        var input = new List<string>();
    
        while ( (line = source.ReadLine() ) != null )
            if (line[0] == '>' && line.Substring(1, 5) == "THREE")
                break;
    
        while ( (line = source.ReadLine()) != null ) {
            char c = line[0];
            if (c == '>') break;
            if (c != ';') input.Add(line.ToUpper());
        }
    
        KNucleotide kn = new KNucleotide(input.GetBytes());
        input = null;
        for (int f = 1; f < 3; f++) kn.WriteFrequencies(f);
        foreach (var seq in
                 new[] { "GGT", "GGTA", "GGTATT", "GGTATTTTAATT",
                         "GGTATTTTAATTTATAGT"})
            kn.WriteCount(seq);

    }
}

public class KNucleotide {

    private class Count {
	   public int V;
	   public Count(int v) { V = v; }
    }

    private Dictionary<ByteString, Count> frequencies
        = new Dictionary<ByteString, Count>();
    private byte[] sequence;

    public KNucleotide(byte[] s) { sequence = s; }

    public void WriteFrequencies(int length) {
        GenerateFrequencies(length);
        var items = new List<KeyValuePair<ByteString, Count>>(frequencies);
        items.Sort(SortByFrequencyAndCode);    
        double percent = 100.0 / (sequence.Length - length + 1);
        foreach (var item in items)
            Console.WriteLine("{0} {1:f3}",
                        item.Key.ToString(), item.Value.V * percent);
        Console.WriteLine();
    }

    public void WriteCount(string fragment) {
        GenerateFrequencies(fragment.Length);
        Count count;
        if (!frequencies.TryGetValue(new ByteString(fragment), out count))
            count = new Count(0);
        Console.WriteLine("{0}\t{1}", count.V, fragment);
    }

    private void GenerateFrequencies(int length) {
        frequencies.Clear();
        for (int frame = 0; frame < length; frame++)
            KFrequency(frame, length);
    }

    private void KFrequency(int frame, int k) {
        int n = sequence.Length - k + 1;
        for (int i = frame; i < n; i += k) {
            var key = new ByteString(sequence, i, k);
            Count count;
            if (frequencies.TryGetValue(key, out count))
                count.V++;
            else
                frequencies[key] = new Count(1);
        }
    }

    int SortByFrequencyAndCode(
            KeyValuePair<ByteString, Count> i0,
            KeyValuePair<ByteString, Count> i1) {
        int order = i1.Value.V.CompareTo(i0.Value.V);
        if (order != 0) return order;
        return i0.Key.ToString().CompareTo(i1.Key.ToString());
    }
}
/* The Computer Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Isaac Gouy
 * modified by Antti Lankila for generics
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

public class program {
    public static void Main(string[] args) {
	string line;
	StreamReader source = new StreamReader(Console.OpenStandardInput());
	StringBuilder input = new StringBuilder();

	while ( (line = source.ReadLine() ) != null ) {
	    if (line[0] == '>' && line.Substring(1, 5) == "THREE")
		break;
	}
	 
	while ( (line = source.ReadLine()) != null ) {
            char c = line[0];
            if (c == '>')
               break;
            if (c != ';')
               input.Append(line.ToUpper());
	}

	KNucleotide kn = new KNucleotide(input.ToString());
        input = null;
	kn.WriteFrequencies(1);
	kn.WriteFrequencies(2);

	kn.WriteCount("GGT");
	kn.WriteCount("GGTA");
	kn.WriteCount("GGTATT");
	kn.WriteCount("GGTATTTTAATT");
	kn.WriteCount("GGTATTTTAATTTATAGT");
    }
}

public class KNucleotide {
    /* freq[foo] ++ implies a get and a set. */
    internal class Value {
	internal int v;

	internal Value(int v)
	{
	    this.v = v;
	}
    }

    private Dictionary<string, Value> frequencies = new Dictionary<string, Value>();
    private string sequence;

    public KNucleotide(string s)
    {
	sequence = s;
    }

    public void WriteFrequencies(int nucleotideLength) {
	GenerateFrequencies(nucleotideLength);

	List<KeyValuePair<string, Value>> items = new List<KeyValuePair<string, Value>>(frequencies);
	items.Sort(SortByFrequencyAndCode);

	int sum = sequence.Length - nucleotideLength + 1;
	foreach (KeyValuePair<string, Value> each in items) {
	    double percent = each.Value.v * 100.0 / sum;
	    Console.WriteLine("{0} {1:f3}", each.Key, percent);
	}
	Console.WriteLine("");
    }

    public void WriteCount(string nucleotideFragment) {
	GenerateFrequencies(nucleotideFragment.Length);

	int count = 0;
	if (frequencies.ContainsKey(nucleotideFragment))
	    count = frequencies[nucleotideFragment].v;
	Console.WriteLine("{0}\t{1}", count, nucleotideFragment);
    }

    private void GenerateFrequencies(int length) {
	frequencies.Clear();
	for (int frame = 0; frame < length; frame++)
	    KFrequency(frame, length);
    }

    private void KFrequency(int readingFrame, int k) {
	int n = sequence.Length - k + 1;
	/* string.Substring is a malloc monster :( */
	if (k > 6) {
	    for (int i = readingFrame; i < n; i += k) {
		string knucleo = sequence.Substring(i, k);
		if (frequencies.ContainsKey(knucleo))
		    frequencies[knucleo].v ++;
		else
		    frequencies[knucleo] = new Value(1);
	    }
	} else {
	    for (int i = readingFrame; i < n; i += k) {
		string knucleo = sequence.Substring(i, k);
		try {
		    frequencies[knucleo].v ++;
		}
		catch (KeyNotFoundException) {
		    frequencies[knucleo] = new Value(1);
		}
	    }
	}
    }

    int SortByFrequencyAndCode(KeyValuePair<string, Value> item1, KeyValuePair<string, Value> item2) {
	int comparison = item2.Value.v.CompareTo(item1.Value.v);
	if (comparison == 0) return item1.Key.CompareTo(item2.Key);
	else return comparison;
    }
}
/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Isaac Gouy
 * modified by Antti Lankila for generics
 * modified by A.Nahr for performance and throwing unneccesary stuff out
 * remove unsafe code & add multithread by The Anh Tran
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Threading;

public class knucleotide
{
    static private string   input;
    static private int      task_count = 7;
    static private string[] result = new string[7];

   public static void Main(/*string[] arg*/)
   {
      StreamReader source = new StreamReader(Console.OpenStandardInput());
        
        string line;
      while ((line = source.ReadLine()) != null)
      {
         if (line.StartsWith(">THREE", StringComparison.CurrentCultureIgnoreCase))
            break;
      }

      StringBuilder buf = new StringBuilder(64 * 1024 * 1024); // 64mb
      while ((line = source.ReadLine()) != null)
         buf.Append(line);

        input = buf.ToString();
      buf = null;

        Thread[] threads = new Thread[Environment.ProcessorCount];
        for (int i = 0; i < threads.Length; i++)
        {
            threads[i] = new Thread(worker);
            threads[i].Start();
        }

        foreach (Thread t in threads)
            t.Join();
        foreach (string s in result)
            Console.Out.WriteLine(s);
   }

    private static void worker()
    {
        int j;
        while ((j = Interlocked.Decrement(ref task_count)) >= 0)
        {
            switch (j)
            {
                case 0:
                    result[j] = WriteFrequencies(1);
                    break;
                case 1:
                    result[j] = WriteFrequencies(2);
                    break;
                case 2:
                    result[j] = WriteCount("ggt");
                    break;
                case 3:
                    result[j] = WriteCount("ggta");
                    break;
                case 4:
                    result[j] = WriteCount("ggtatt");
                    break;
                case 5:
                    result[j] = WriteCount("ggtattttaatt");
                    break;
                case 6:
                    result[j] = WriteCount("ggtattttaatttatagt");
                    break;
            }
        }
    }

    private static string WriteFrequencies(int nucleotideLength)
   {
        Dictionary<Key, Value> frequencies = GenerateFrequencies(nucleotideLength);

        List<KeyValuePair<Key, Value>> items = new List<KeyValuePair<Key, Value>>(frequencies);
      items.Sort(SortByFrequencyAndCode);

        StringBuilder buf = new StringBuilder();
      int sum = input.Length - nucleotideLength + 1;

        foreach (KeyValuePair<Key, Value> element in items)
      {
         float percent = element.Value.value * 100.0f / sum;
            buf.AppendFormat("{0} {1:f3}\n", element.Key, percent);
      }

        return buf.ToString();
   }

   private static string WriteCount(string nucleotideFragment)
   {
        Dictionary<Key, Value> frequencies = GenerateFrequencies(nucleotideFragment.Length);
        Key specific = new Key(nucleotideFragment);
      
        int count = 0;
      if (frequencies.ContainsKey(specific))
         count = frequencies[specific].value;
      
        return string.Format("{0}\t{1}", count, nucleotideFragment.ToUpper());
   }

    private static Dictionary<Key, Value> GenerateFrequencies(int frame_size)
   {
        Dictionary<Key, Value> frequencies = new Dictionary<Key, Value>();
        
        Key k = new Key(frame_size);
        Value val;

        int end = input.Length - frame_size + 1;
        for (int index = 0; index < end; index++)
        {
            k.ReHash(input, index);

            frequencies.TryGetValue(k, out val);
            if (val != null)   // must use a class type in order to compare reference with null
                val.value++;   // if we use 'int', this step require 1 more lookup
            else
                frequencies.Add(new Key(k), new Value());
        }
        return frequencies;
   }

   private static int SortByFrequencyAndCode(KeyValuePair<Key, Value> item1, KeyValuePair<Key, Value> item2)
   {
      int comparison = item2.Value.value - item1.Value.value;
      if (comparison == 0) 
            return item1.Key.key.ToString().CompareTo(item2.Key.key.ToString());
      else 
            return comparison;
   }

    internal class Key
    {
        internal int    hash;
        internal char[] key;

        public Key(int frame)
        {
            key = new char[frame];
        }

        public Key(Key k)
        {
            hash = k.hash;
            this.key = (char[])k.key.Clone();
        }
        
        public Key(string s)
        {
            key = new char[s.Length];
            ReHash(s, 0);
        }
        public void ReHash(string k, int offset)
        {
            hash = 0;
            for (int i = 0; i < key.Length; i++)
            {
                key[i] = k[offset + i];
                hash = hash * 31 + key[i];
            }
        }

        public override int GetHashCode()
        {
            return hash;
        }

        public override string ToString()
        {
            return new string(key).ToUpper();
        }

        public override bool Equals(object k)
        {
            return this.hash == ((Key)k).hash;
        }
        /*
        public bool Equals (Key k)
        {
         return this.hash == k.hash;
        }
        */
    }

    internal class Value
    {
        internal int value;

        public Value()
        {
            value = 1;
        }
    }
}

/* The Computer Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * byte processing, C# 3.0 idioms, frame level paralellism by Robert F. Tobler
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

public struct ByteString : IEquatable<ByteString>
{
    public byte[] Array;
    public int Start;
    public int Length;

    public ByteString(byte[] array, int start, int length)
    {
        Array = array; Start = start; Length = length;
    }
    
    public ByteString(string text)
    {
        Start = 0; Length = text.Length;
        Array = Encoding.ASCII.GetBytes(text);
    }
    
    public override int GetHashCode()
    {
        int hc = 0;
        for (int i = 0; i < Length; i++)
            hc = hc * 31 + Array[Start + i];
        return hc;
    }

    public bool Equals(ByteString other)
    {
        if (Length != other.Length) return false;
        for (int i = 0; i < Length; i++)
            if (Array[Start+i] != other.Array[other.Start+i]) return false;
        return true;
    }
    
    public override string ToString()
    {
        return Encoding.ASCII.GetString(Array, Start, Length);
    }
}

public static class Extensions
{
    public static byte[] GetBytes(this List<string> lines)
    {
        int count = lines.Aggregate(0, (cnt, str) => cnt + str.Length);
        var array = new byte[count];
        lines.Aggregate(0, (pos, str) => {
                Encoding.ASCII.GetBytes(str, 0, str.Length, array, pos);
                return pos + str. Length;
            });
        return array;
    }
}

public class Program
{
    public static int TaskCount;
    public static int Current = -1;
    public static KNucleotide[] kna;

    public static void Main(string[] args) {
        string line;
        StreamReader source = new StreamReader(Console.OpenStandardInput());
        var input = new List<string>();
    
        while ( (line = source.ReadLine() ) != null )
            if (line[0] == '>' && line.Substring(1, 5) == "THREE")
                break;
    
        while ( (line = source.ReadLine()) != null ) {
            char c = line[0];
            if (c == '>') break;
            if (c != ';') input.Add(line.ToUpper());
        }
    
        var lengths = new [] { 1, 2, 3, 4, 6, 12, 18 };
        
        TaskCount = lengths.Aggregate(0, (cnt, len) => cnt + len);
        kna = new KNucleotide[TaskCount];

        var bytes = input.GetBytes();        
        lengths.Aggregate(0, (cnt, len) => 
            {
                for (int i = 0; i < len; i++)
                    kna[cnt + i] = new KNucleotide(bytes, len, i); 
                return cnt + len;
            });

        var threads = new Thread[Environment.ProcessorCount];
        for (int i = 0; i < threads.Length; i++)
            (threads[i] = new Thread(CountFrequencies)).Start();

        foreach (var t in threads)
            t.Join();

        var seqs = new[] { null, null,
                "GGT", "GGTA", "GGTATT", "GGTATTTTAATT",
                "GGTATTTTAATTTATAGT"};

        int index = 0;
        lengths.Aggregate(0, (cnt, len) =>
            {
                if (len < 3)
                {
                    for (int i = 1; i < len; i++)
                        kna[cnt].AddFrequencies(kna[cnt+i]);
                    kna[cnt].WriteFrequencies();                    
                }
                else
                {
                    var fragment = seqs[index];
                    int freq = 0;
                    for (int i = 0; i < len; i++)
                        freq += kna[cnt + i].GetCount(fragment);
                    Console.WriteLine("{0}\t{1}", freq, fragment);
                }
                index++;
                return cnt + len;
            });
    }
    
    static void CountFrequencies()
    {
        int index;
        while ((index = Interlocked.Increment(ref Current)) < TaskCount)
            kna[index].KFrequency();
    }
    
}

public class KNucleotide {

    private class Count {
       public int V;
       public Count(int v) { V = v; }
    }

    private Dictionary<ByteString, Count> frequencies
        = new Dictionary<ByteString, Count>();
    private byte[] sequence;
    int length;
    int frame;

    public KNucleotide(byte[] s, int l, int f)
    {   
        sequence = s; length = l; frame = f;
    }

    public void AddFrequencies(KNucleotide other)
    {
        foreach(var kvp in other.frequencies)            
        {
            Count count;
            if (frequencies.TryGetValue(kvp.Key, out count))
                count.V += kvp.Value.V;
            else
                frequencies[kvp.Key] = kvp.Value;
        }
    }

    public void WriteFrequencies() {
        var items = new List<KeyValuePair<ByteString, Count>>(frequencies);
        items.Sort(SortByFrequencyAndCode);    
        double percent = 100.0 / (sequence.Length - length + 1);
        foreach (var item in items)
            Console.WriteLine("{0} {1:f3}",
                        item.Key.ToString(), item.Value.V * percent);
        Console.WriteLine();
    }

    public int GetCount(string fragment) {
        Count count;
        if (!frequencies.TryGetValue(new ByteString(fragment), out count))
            count = new Count(0);
        return count.V;
    }

    public void KFrequency() {
        int n = sequence.Length - length + 1;
        for (int i = frame; i < n; i += length) {
            var key = new ByteString(sequence, i, length);
            Count count;
            if (frequencies.TryGetValue(key, out count))
                count.V++;
            else
                frequencies[key] = new Count(1);
        }
    }

    int SortByFrequencyAndCode(
            KeyValuePair<ByteString, Count> i0,
            KeyValuePair<ByteString, Count> i1) {
        int order = i1.Value.V.CompareTo(i0.Value.V);
        if (order != 0) return order;
        return i0.Key.ToString().CompareTo(i1.Key.ToString());
    }
}
// $Id: lists.csharp,v 1.5 2005-02-22 19:05:07 igouy-guest Exp $
// http://shootout.alioth.debian.org/
// contributed by Erik Saltwell
// Some cleanups by Brent Fulgham
// Note:  C# standard libraries don't provide a DeQueue class, so this
//  implementation includes one.
using System;

class IntDeQueue : ICloneable
{
    private int[] data = null;
    private int start = 0;
    private int end = 0;
    private int size = 0;
    private int temp = 0;

    public bool Empty {
        get {return start == end;}
    }

    public object Clone()
    {
        IntDeQueue temp = new IntDeQueue(size-1);
        temp.start = start;
        temp.end = end;
        data.CopyTo(temp.data, 0);
        return temp;
    }

    public bool Equals(IntDeQueue other)
    {
        if (Count != other.Count)
            return false;

        int i = this.start;
        int iOther = other.start;

        while (i != this.end)
        {
            if(data[i] != other.data[iOther])
                return false;

            Advance(ref i);
            other.Advance(ref iOther);
        }
        return true;
    }

    public int Count
    {
        get
        {
            if(end >= start) 
                return end - start;
            else 
                return size + end - start; 
        }
    }

    public void Reverse()
    {
        if (Count < 2)
            return;
        Array.Reverse(data);
        int endEnd = size-1;
        int startEnd = 0;
        if (end < start)
        {
            endEnd = 0;
            startEnd = size-1;
        }
        int temp = start;
        Regress(ref end);
        start = Math.Abs(startEnd - Math.Abs(end - endEnd));
        end = Math.Abs(endEnd - Math.Abs(temp - startEnd));
        Advance(ref end);
    }

    public void PushFront(int i)
    {
        temp = start;
        Regress(ref start);
        if (start == end)
        {
            start = temp;
            throw new System.Exception("Invalid operation");
        }
        data[start] = i;
    }

    public int PopFront()
    {
        int i = data[start];
        if (start != end)
            Advance(ref start);
        else
            throw new System.Exception("Invalid operation");
        return i;
    }

    public int PeekFront() 
    {
        if (start==end)
            throw new System.Exception("Invalid Operation");
        return data[start];
    }

    public int PeekBack() 
    {
        if (start == end)
            throw new System.Exception("Invalid Operation");
        int temp = end;
        Regress(ref temp);
        return data[temp];
    }

    public void PushBack(int i)
    {
        temp = end;
        Advance(ref end);
        if (start == end)
        {
            end = temp;
            throw new System.Exception("Invalid operation");
        }
        data[temp] = i;
    }

    public int PopBack()
    {
        if (start!=end)
            Regress(ref end);
        else
            throw new System.Exception("Invalid operation");
        return data[end];
    }

    public IntDeQueue (int Size) {
        data = new int[Size+1];
	this.size=Size+1;
    }
    
    private void Advance(ref int item)
    {
        if ((++item) == size)
            item=0;
    }

    private void Regress (ref int item)
    {
        if (item != 0)
            --item;
        else
            item = (size-1);
    }

    public void Clear()
    {
        start = 0;
        end = 0;
    }
}

class lists
{
    public const int SIZE=10000;
    [STAThread]
    static void Main(string[] args)
    {
        int n = int.Parse(args[0]);
        int result = 0;
        for(int i = 0; i < n; ++i)
            result = RunLists();
        Console.WriteLine(result);
    }

    static public int RunLists()
    {
        IntDeQueue q = new IntDeQueue(SIZE);
        for(int i=0;i<SIZE;++i)
            q.PushBack(i+1);
        IntDeQueue q2 = (IntDeQueue)q.Clone();
        IntDeQueue q3=new IntDeQueue(SIZE);
        while(!q2.Empty)
            q3.PushBack(q2.PopFront());
        while(!q3.Empty)
            q2.PushBack(q3.PopBack());
        q.Reverse();
        if(q.PeekFront() != SIZE)
        {
            Console.WriteLine("q.PeekFront()!=SIZE");
            return 0;
        }
        if(!q.Equals(q2))
        {
            Console.WriteLine("q!=q2");
            return 0;
        }

        return q.Count;
    }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class Lists
{

   static void Main(string[] args)
   {         
      const int nSize = 10000;
      int L1Count = 0;
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      while (n-- > 0)
      {
         // initialize L1
         ArrayList L1 = new ArrayList(nSize);
         for (int j = 1; j <= nSize; j++) L1.Add(j);

         // copy L1 to L2
         ArrayList L2 = (ArrayList)L1.Clone();

         // remove from left of L2 add to right of L3
         Object item;
         ArrayList L3 = new ArrayList(nSize);
         while (L2.Count > 0) {
            item = L2[0];
            L2.RemoveAt(0);
            L3.Add(item);
         }

         // remove from right of L3 add to right of L2
         int index;
         while ( (index = L3.Count) > 0) {
            index = index - 1;
            item = L3[index];
            L3.RemoveAt(index);
            L2.Add(item);
         }

         // reverse L1
         L1.Reverse();

         // check that first item is now SIZE
         if ((int)L1[0] != nSize) Console.WriteLine("First item of L1 != SIZE");

         // check that L1 == L2
         if (!Lists.areEqual(L1,L2)) Console.WriteLine("L1 != L2");

         L1Count = L1.Count;
      }
      Console.WriteLine(L1Count);
   }

   static bool areEqual(ArrayList list1, ArrayList list2){
      if (list1.Count == list2.Count){
         for (int i=0; i<list1.Count; i++)
            if ((int)list1[i] != (int)list2[i]) return false;
         return true;
      }
      else
         return false;
   }

}
/*   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Adapted by Antti Lankila from the earlier Isaac Gouy's implementation
   Add multithread & tweaks from C++ by The Anh Tran
*/

using System;
using System.Threading;
using System.IO;

public class MandelBrot
{
    private static int      N = 200;
    private static int      width_bytes;
    
    private static byte[][] data;
   private static int[]    nbyte_each_line;


   public static void Main (String[] args)
   {
      if (args.Length > 0)
         N = Int32.Parse(args[0]);
      Console.Out.WriteLine("P4\n{0} {0}", N);

      width_bytes = N/8;
      if (width_bytes*8 < N)
         width_bytes += 1;

      nbyte_each_line = new int[N];

        data = new byte[N][];
        for (int i = 0; i < N; i++)
            data[i] = new byte[width_bytes];

      Thread[] threads = new Thread[Environment.ProcessorCount];
      for (int i = 0; i < threads.Length; i++)
      {
         threads[i] = new Thread(MandelBrot.Calculate);
            threads[i].Start();
      }

      foreach (Thread t in threads)
         t.Join();

        Stream s = Console.OpenStandardOutput();
      for (int y = 0; y < N; y++)
         s.Write( data[y], 0, nbyte_each_line[y]);
   }


   private static int current_line = -1;

   private static void Calculate()
   {
      double inverse_n = 2.0 / N;

      int y;
      while ((y = Interlocked.Increment(ref current_line)) < N) // fetch a line
      {
            byte[] pdata = data[y];

         int byte_count  = 0;
            int bit_num     = 0;
            int byte_acc    = 0;

            double Civ = y * inverse_n - 1.0;

         for (int x = 0; x < N; x++)
         {
            double Crv = x * inverse_n - 1.5;

            double Zrv   = Crv;
            double Ziv   = Civ;
            double Trv   = Crv * Crv;
            double Tiv   = Civ * Civ;

            int i = 49;
            do
            {
               Ziv = (Zrv*Ziv) + (Zrv*Ziv) + Civ;
               Zrv = Trv - Tiv + Crv;

               Trv = Zrv * Zrv;
               Tiv = Ziv * Ziv;
            }   while ( ((Trv + Tiv) <= 4.0) && (--i > 0) );

            byte_acc <<= 1;
            byte_acc |= (i == 0) ? 1 : 0;

            if (++bit_num == 8)
            {
                    pdata[byte_count] = (byte)byte_acc;
               byte_count++;
               bit_num = byte_acc = 0;
            }
         } // end foreach (column)

         if (bit_num != 0) // write left over bits
         {
            byte_acc <<= (8 - (N & 7));
            pdata[byte_count] = (byte)byte_acc;
            byte_count++;
         }

         nbyte_each_line[y] = byte_count;
      }
   }
};
/* The Computer Language Benchmarks Game
 *    http://shootout.alioth.debian.org/
 *
 * Adapted by Antti Lankila from the earlier Isaac Gouy's implementation
 */

using System;
using System.IO;

class Mandelbrot {

   public static void Main(String[] args) {

      int width = 100;
      if (args.Length > 0)
	 width = Int32.Parse(args[0]);

      int height = width;
      int maxiter = 50;
      double limit = 4.0;

      Console.WriteLine("P4");
      Console.WriteLine("{0} {1}", width,height);
      Stream s = Console.OpenStandardOutput(1024);

      for (int y = 0; y < height; y++) {
	 int bits = 0;
	 int xcounter = 0;
	 double Ci = 2.0*y/height - 1.0;

         for (int x = 0; x < width; x++){
	    double Zr = 0.0;
	    double Zi = 0.0;
	    double Cr = 2.0*x/width - 1.5;
            int i = maxiter;

            bits = bits << 1;
            do {
               double Tr = Zr*Zr - Zi*Zi + Cr;
               Zi = 2.0*Zr*Zi + Ci;
               Zr = Tr;
               if (Zr*Zr + Zi*Zi > limit) {
		  bits |= 1;
		  break;
	       }
            } while (--i > 0);

            if (++xcounter == 8) {
	       s.WriteByte((byte) (bits ^ 0xff));
	       bits = 0;
	       xcounter = 0;
            }
         }
         if (xcounter != 0)
	    s.WriteByte((byte) ((bits << (8 - xcounter)) ^ 0xff));
      }
   }
}
/*   The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   Adapted by Antti Lankila from the earlier Isaac Gouy's implementation
   Add multithread & tweaks from C++ by The Anh Tran
   Simplified bit logic and cleaned code by Robert F. Tobler
*/

using System;
using System.Threading;
using System.IO;

public class MandelBrot
{
    private static int n = 200;
    private static byte[][] data;
    private static int lineCount = -1;
    private static double[] xa;

    public static void Main (String[] args)
    {
        if (args.Length > 0) n = Int32.Parse(args[0]);
        Console.Out.WriteLine("P4\n{0} {0}", n);
        
        int lineLen = (n-1)/8 + 1;
        data = new byte[n][];
        for (int i = 0; i < n; i++) data[i] = new byte[lineLen];

        xa = new double[n];
        for (int x = 0; x < n; x++) xa[x] = x * 2.0/n - 1.5;

        var threads = new Thread[Environment.ProcessorCount];
        for (int i = 0; i < threads.Length; i++)
            (threads[i] = new Thread(MandelBrot.Calculate)).Start();

        foreach (var t in threads) t.Join();

        var s = Console.OpenStandardOutput();
        for (int y = 0; y < n; y++) s.Write(data[y], 0, lineLen);
    }

    private static void Calculate()
    {
        int y;
        while ((y = Interlocked.Increment(ref lineCount)) < n)
        {
            var line = data[y];
            int xbyte = 0, bits = 1;
            double ci = y * 2.0/n - 1.0;

            for (int x = 0; x < n; x++)
            {
                double cr = xa[x];
                if (bits > 0xff) { line[xbyte++] = (byte)bits; bits = 1; }
                double zr = cr, zi = ci, tr = cr * cr, ti = ci * ci;  
                int i = 49;
                do
                {
                    zi = zr * zi + zr * zi + ci; zr = tr - ti + cr;
                    tr = zr * zr; ti = zi * zi;
                }
                while ((tr + ti <= 4.0) && (--i > 0));
                bits = (bits << 1) | (i == 0 ? 1 : 0);
            }
            while (bits < 0x100) bits = (bits << 1);
            line[xbyte] = (byte)bits;
        }
    }
}
/* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *  
 * contributed by Isaac Gouy 
 */

using System;

class Matrix
{
   const int mSize = 30;

   static int[][] MkMatrix() {
      int count = 1;
      int[][] m = new int[mSize][];
      for (int i = 0; i < mSize; i++){ 
         m[i] = new int[mSize];
         for (int j = 0; j < mSize; j++) m[i][j] = count++;
         }
      return m;
   }

   static void MMult(int[][] m1, int[][] m2, int[][] m3) {
      for (int i=0; i < mSize; i++) 
         for (int j = 0; j < mSize; j++) {
            int val = 0;
            for (int k = 0; k < mSize; k++) val += m1[i][k] * m2[k][j];
            m3[i][j] = val;
         }
   }

   static void Main(String[] args) {         
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      int[][] m1 = MkMatrix();
      int[][] m2 = MkMatrix();
      int[][] mm = new int[mSize][];
      for (int i = 0; i < mSize; i++) mm[i] = new int[mSize];

      while (n-- > 0) MMult(m1, m2, mm);

      Console.WriteLine("{0} {1} {2} {3}", 
         mm[0][0], mm[2][3], mm[3][2], mm[4][4]);
   }
}
/*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by: Alexandre Alapetite http://alexandre.alapetite.net/
 * Date: 2006-08-13
 */

using System;
using System.Collections.Generic;
using System.Threading;

namespace cheap_concurrency
{
   public sealed class MyMessage
   {
      private const int numberOfThreads = 500;
      internal static int numberOfMessagesToSend;

      public static void Main(string[] args)
      {
         numberOfMessagesToSend = int.Parse(args[0]);

         MessageThread chain = null;
         for (int i = numberOfThreads; i > 0; i--)
         {
            chain = new MessageThread(chain);
            new Thread(new ThreadStart(chain.Run)).Start();
         }

         for (int i = 0; i < numberOfMessagesToSend; i++)
            chain.Enqueue(0);
      }
   }

   internal sealed class MessageThread
   {
      private MessageThread nextThread;
      private Queue<int> list = new Queue<int>();
      private int numberOfMessagesToSend;

      internal MessageThread(MessageThread nextThread)
      {
         this.nextThread = nextThread;
         this.numberOfMessagesToSend = MyMessage.numberOfMessagesToSend;
      }

      internal void Run()
      {
         if (nextThread == null)
         {
            int sum = 0;
            while (numberOfMessagesToSend > 0)
            {
               lock (list)
                  while (list.Count > 0)
                  {
                     sum += list.Dequeue();
                     numberOfMessagesToSend--;
                  }
               Thread.Sleep(0);
            }
            Console.WriteLine(sum);
         }
         else
         {
            while (numberOfMessagesToSend > 0)
            {
               lock (list)
                  while (list.Count > 0)
                  {
                     nextThread.Enqueue((int)list.Dequeue());
                     numberOfMessagesToSend--;
                  }
               Thread.Sleep(0);
            }
         }
      }

      internal void Enqueue(int mess)
      {
         lock (list)
            list.Enqueue(mess + 1);
      }
   }
}
// $Id: methcall.csharp,v 1.5 2005-02-22 19:05:07 igouy-guest Exp $
// http://shootout.alioth.debian.org/

using System;

class Toggle {
    public bool state = true;
    public Toggle(bool start_state) {
        state = start_state;
    }
    
    public bool value() {
        return state;
    }
    
    public Toggle activate() {
        state = !state;
        return this;
    }
}

class NthToggle : Toggle {
    int count_max = 0;
    int counter = 0;

    public NthToggle(bool start_state, int max_counter) : base(start_state) {
        count_max = max_counter;
        counter = 0;
    }

    public new NthToggle activate() {
        counter += 1;
        if (counter >= count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
}

class methcall {
    public static int Main(String[] args) {
        bool val = true;

        Toggle toggle = new Toggle(val);
        NthToggle ntoggle = new NthToggle(true, 3);

        int n = System.Convert.ToInt32(args[0]);
        if(n < 1) n = 1;

        for (int i=0; i<n; i++) {
            val = toggle.activate().value();
        }
        Console.WriteLine(val ? "true" : "false");
        
        for (int i=0; i<n; i++) {
            val = ntoggle.activate().value();
        }
        Console.WriteLine(val ? "true" : "false");
        
        return 0;
    }
}
// $Id: moments.csharp,v 1.6 2005-03-02 06:28:40 igouy-guest Exp $
// http://shootout.alioth.debian.org/
// 
// Transliterated from the Java implementation.  
//
// contributed by Isaac Gouy

using System;
using System.Collections;
using System.IO;

class Moments
{
   static void Main()
   {      
      ArrayList numbers = new ArrayList();
      double sum = 0.0;
      double mean = 0.0;
      double average_deviation = 0.0;
      double standard_deviation = 0.0;
      double variance = 0.0;
      double skew = 0.0;
      double kurtosis = 0.0;
      double median = 0.0;
      double deviation = 0.0;
      int i, n, mid = 0;


      using (StreamReader s = new StreamReader(Console.OpenStandardInput())){
         string line;
         while ((line = s.ReadLine()) != null) {
            double x = Double.Parse(line);
            sum += x;
            numbers.Add(x);
         }
      }

      n = numbers.Count;
      mean = sum / n;

      foreach (double x in numbers){
         deviation = x - mean;
         average_deviation += Math.Abs(deviation);
         variance += Math.Pow(deviation,2);
         skew += Math.Pow(deviation,3);
         kurtosis += Math.Pow(deviation,4);
      }
      average_deviation /= n;
      variance /= (n - 1);
      standard_deviation = Math.Sqrt(variance);
      if (variance != 0.0) {
         skew /= (n * variance * standard_deviation);
         kurtosis = kurtosis/(n * variance * variance) - 3.0;
      }

      numbers.Sort();

      mid = n / 2;
      median = (n % 2 != 0) ?
         (double)numbers[mid] :
         ((double)numbers[mid] + (double)numbers[mid-1]) / 2;

      Console.WriteLine("n:                  {0}", n);
      Console.WriteLine("median:             {0:f6}", median);
      Console.WriteLine("mean:               {0:f6}", mean);
      Console.WriteLine("average_deviation:  {0:f6}", average_deviation);
      Console.WriteLine("standard_deviation: {0:f6}", standard_deviation);
      Console.WriteLine("variance:           {0:f6}", variance);
      Console.WriteLine("skew:               {0:f6}", skew);
      Console.WriteLine("kurtosis:           {0:f6}", kurtosis);
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class NBody {
   public static void Main(String[] args) {        
      int n = 10000;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      NBodySystem bodies = new NBodySystem();

      Console.WriteLine("{0:f9}",bodies.Energy());
      for (int i=0; i<n; i++) 
         bodies.Advance(0.01);
      Console.WriteLine("{0:f9}",bodies.Energy());
   }
}


class NBodySystem {
   private Body[] bodies;
	   	  	
   public NBodySystem() {			
      bodies = new Body[]{
         Body.Sun(),		
         Body.Jupiter(),
         Body.Saturn(),
         Body.Uranus(),
         Body.Neptune()		      		      		      
      };
		
      double px = 0.0;
      double py = 0.0;	
      double pz = 0.0;				
      foreach (Body body in bodies) {			   		         					
         px += body.vx * body.mass;
         py += body.vy * body.mass;		
         pz += body.vz * body.mass;				
      }		
      bodies[0].OffsetMomentum(px,py,pz);
   }
						   	
   public void Advance(double dt) {
      double dx, dy, dz, distance, mag;	
	
      for (int i=0; i < bodies.Length; i++) {
         for (int j=i+1; j < bodies.Length; j++) {	
            dx = bodies[i].x - bodies[j].x;
            dy = bodies[i].y - bodies[j].y;
            dz = bodies[i].z - bodies[j].z;
				
            distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);				   
            mag = dt / (distance * distance * distance);
				
            bodies[i].vx -= dx * bodies[j].mass * mag;
            bodies[i].vy -= dy * bodies[j].mass * mag;
            bodies[i].vz -= dz * bodies[j].mass * mag;
                                
            bodies[j].vx += dx * bodies[i].mass * mag;
            bodies[j].vy += dy * bodies[i].mass * mag;
            bodies[j].vz += dz * bodies[i].mass * mag;
         }
      }		
		
      foreach (Body body in bodies) {
         body.x += dt * body.vx;
         body.y += dt * body.vy;
         body.z += dt * body.vz;
      }		
   }			
	
   public double Energy() {		
      double dx, dy, dz, distance;	
      double e = 0.0;		   
		
      for (int i=0; i < bodies.Length; i++) {
         e += 0.5 * bodies[i].mass * 
            ( bodies[i].vx * bodies[i].vx 
            + bodies[i].vy * bodies[i].vy 
            + bodies[i].vz * bodies[i].vz );
			   
         for (int j=i+1; j < bodies.Length; j++) {
            dx = bodies[i].x - bodies[j].x;
            dy = bodies[i].y - bodies[j].y;
            dz = bodies[i].z - bodies[j].z;
                                
            distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);
            e -= (bodies[i].mass * bodies[j].mass) / distance;
         }
      }
      return e;
   }		      	   	   	      	   		   														           		
}


class Body {
   const double PI = 3.141592653589793;	
   const double SOLAR_MASS = 4 * PI * PI;
   const double DAYS_PER_YEAR = 365.24;

   public double x, y, z, vx, vy, vz, mass;
	
   public Body(){}	
	
   internal static Body Jupiter() {
      Body p = new Body();
      p.x = 4.84143144246472090e+00;
      p.y = -1.16032004402742839e+00;
      p.z = -1.03622044471123109e-01;
      p.vx = 1.66007664274403694e-03 * DAYS_PER_YEAR;
      p.vy = 7.69901118419740425e-03 * DAYS_PER_YEAR;
      p.vz = -6.90460016972063023e-05 * DAYS_PER_YEAR;
      p.mass = 9.54791938424326609e-04 * SOLAR_MASS;	   	   	   
      return p;
   }	
	
   internal static Body Saturn() {
      Body p = new Body();
      p.x = 8.34336671824457987e+00;
      p.y = 4.12479856412430479e+00;
      p.z = -4.03523417114321381e-01;
      p.vx = -2.76742510726862411e-03 * DAYS_PER_YEAR;
      p.vy = 4.99852801234917238e-03 * DAYS_PER_YEAR;
      p.vz = 2.30417297573763929e-05 * DAYS_PER_YEAR;
      p.mass = 2.85885980666130812e-04 * SOLAR_MASS;	   	   	   
      return p;
   }	
	
   internal static Body Uranus() {
      Body p = new Body();
      p.x = 1.28943695621391310e+01;
      p.y = -1.51111514016986312e+01;
      p.z = -2.23307578892655734e-01;
      p.vx = 2.96460137564761618e-03 * DAYS_PER_YEAR;
      p.vy = 2.37847173959480950e-03 * DAYS_PER_YEAR;
      p.vz = -2.96589568540237556e-05 * DAYS_PER_YEAR;
      p.mass = 4.36624404335156298e-05 * SOLAR_MASS;		   	   	   
      return p;
   }		

   internal static Body Neptune() {
      Body p = new Body();
      p.x = 1.53796971148509165e+01;
      p.y = -2.59193146099879641e+01;
      p.z = 1.79258772950371181e-01;
      p.vx = 2.68067772490389322e-03 * DAYS_PER_YEAR;
      p.vy = 1.62824170038242295e-03 * DAYS_PER_YEAR;
      p.vz = -9.51592254519715870e-05 * DAYS_PER_YEAR;
      p.mass = 5.15138902046611451e-05 * SOLAR_MASS;	   	   	   
      return p;
   }
	
   internal static Body Sun() {
      Body p = new Body();
      p.mass = SOLAR_MASS;	   	   	   
      return p;
   }			
	
   internal Body OffsetMomentum(double px, double py, double pz) {
      vx = -px / SOLAR_MASS;
      vy = -py / SOLAR_MASS;
      vz = -pz / SOLAR_MASS;	   
      return this;   
   }			           			
}


/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class NBody {
   public static void Main(String[] args) {        
      int n = 10000;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      NBodySystem bodies = new NBodySystem();

      Console.WriteLine("{0:f9}",bodies.Energy());
      for (int i=0; i<n; i++) 
         bodies.Advance(0.01);
      Console.WriteLine("{0:f9}",bodies.Energy());
   }
}


class NBodySystem {
   private Body[] bodies;
	   	  	
   public NBodySystem() {			
      bodies = new Body[]{
         Body.Sun(),		
         Body.Jupiter(),
         Body.Saturn(),
         Body.Uranus(),
         Body.Neptune()		      		      		      
      };
		
      double px = 0.0;
      double py = 0.0;	
      double pz = 0.0;				
      foreach (Body body in bodies) {			   		         					
         px += body.vx * body.mass;
         py += body.vy * body.mass;		
         pz += body.vz * body.mass;				
      }		
      bodies[0].OffsetMomentum(px,py,pz);
   }
						   	
   public void Advance(double dt) {
      double dx, dy, dz, distance, mag;	
	
      for (int i=0; i < bodies.Length; i++) {
         Body bodyi = bodies[i];
         for (int j=i+1; j < bodies.Length; j++) {	
            Body bodyj = bodies[j];

            dx = bodyi.x - bodyj.x;
            dy = bodyi.y - bodyj.y;
            dz = bodyi.z - bodyj.z;
				
            distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);				   
            mag = dt / (distance * distance * distance);
				
            bodyi.vx -= dx * bodyj.mass * mag;
            bodyi.vy -= dy * bodyj.mass * mag;
            bodyi.vz -= dz * bodyj.mass * mag;
				
            bodyj.vx += dx * bodyi.mass * mag;
            bodyj.vy += dy * bodyi.mass * mag;
            bodyj.vz += dz * bodyi.mass * mag;
         }
      }		
		
      foreach (Body body in bodies) {
         body.x += dt * body.vx;
         body.y += dt * body.vy;
         body.z += dt * body.vz;
      }		
   }			
	
   public double Energy() {		
      double dx, dy, dz, distance;	
      double e = 0.0;		   
		
      for (int i=0; i < bodies.Length; i++) {
         Body bodyi = bodies[i];

         e += 0.5 * bodyi.mass * 
            ( bodyi.vx * bodyi.vx 
            + bodyi.vy * bodyi.vy 
            + bodyi.vz * bodyi.vz );
			   
         for (int j=i+1; j < bodies.Length; j++) {
            Body bodyj = bodies[j];

            dx = bodyi.x - bodyj.x;
            dy = bodyi.y - bodyj.y;
            dz = bodyi.z - bodyj.z;
				
            distance = Math.Sqrt(dx*dx + dy*dy + dz*dz);
            e -= (bodyi.mass * bodyj.mass) / distance;
         }
      }
      return e;
   }		      	   	   	      	   		   														           		
}


class Body {
   const double PI = 3.141592653589793;	
   const double SOLAR_MASS = 4 * PI * PI;
   const double DAYS_PER_YEAR = 365.24;

   public double x, y, z, vx, vy, vz, mass;
	
   public Body(){}	
	
   internal static Body Jupiter() {
      Body p = new Body();
      p.x = 4.84143144246472090e+00;
      p.y = -1.16032004402742839e+00;
      p.z = -1.03622044471123109e-01;
      p.vx = 1.66007664274403694e-03 * DAYS_PER_YEAR;
      p.vy = 7.69901118419740425e-03 * DAYS_PER_YEAR;
      p.vz = -6.90460016972063023e-05 * DAYS_PER_YEAR;
      p.mass = 9.54791938424326609e-04 * SOLAR_MASS;	   	   	   
      return p;
   }	
	
   internal static Body Saturn() {
      Body p = new Body();
      p.x = 8.34336671824457987e+00;
      p.y = 4.12479856412430479e+00;
      p.z = -4.03523417114321381e-01;
      p.vx = -2.76742510726862411e-03 * DAYS_PER_YEAR;
      p.vy = 4.99852801234917238e-03 * DAYS_PER_YEAR;
      p.vz = 2.30417297573763929e-05 * DAYS_PER_YEAR;
      p.mass = 2.85885980666130812e-04 * SOLAR_MASS;	   	   	   
      return p;
   }	
	
   internal static Body Uranus() {
      Body p = new Body();
      p.x = 1.28943695621391310e+01;
      p.y = -1.51111514016986312e+01;
      p.z = -2.23307578892655734e-01;
      p.vx = 2.96460137564761618e-03 * DAYS_PER_YEAR;
      p.vy = 2.37847173959480950e-03 * DAYS_PER_YEAR;
      p.vz = -2.96589568540237556e-05 * DAYS_PER_YEAR;
      p.mass = 4.36624404335156298e-05 * SOLAR_MASS;		   	   	   
      return p;
   }		

   internal static Body Neptune() {
      Body p = new Body();
      p.x = 1.53796971148509165e+01;
      p.y = -2.59193146099879641e+01;
      p.z = 1.79258772950371181e-01;
      p.vx = 2.68067772490389322e-03 * DAYS_PER_YEAR;
      p.vy = 1.62824170038242295e-03 * DAYS_PER_YEAR;
      p.vz = -9.51592254519715870e-05 * DAYS_PER_YEAR;
      p.mass = 5.15138902046611451e-05 * SOLAR_MASS;	   	   	   
      return p;
   }
	
   internal static Body Sun() {
      Body p = new Body();
      p.mass = SOLAR_MASS;	   	   	   
      return p;
   }			
	
   internal Body OffsetMomentum(double px, double py, double pz) {
      vx = -px / SOLAR_MASS;
      vy = -py / SOLAR_MASS;
      vz = -pz / SOLAR_MASS;	   
      return this;   
   }			           			
}


/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy, optimization and use of more C# idioms by Robert F. Tobler
*/

using System;

class NBody {
    public static void Main(String[] args) {
        int n = args.Length > 0 ? Int32.Parse(args[0]) : 10000;
        NBodySystem bodies = new NBodySystem();
        Console.WriteLine("{0:f9}", bodies.Energy());
        for (int i = 0; i < n; i++) bodies.Advance(0.01);
        Console.WriteLine("{0:f9}", bodies.Energy());
    }
}

class Body { public double x, y, z, vx, vy, vz, mass; }
class Pair { public Body bi, bj; }

class NBodySystem {
    private Body[] bodies;
    private Pair[] pairs;

    const double Pi = 3.141592653589793;
    const double Solarmass = 4 * Pi * Pi;
    const double DaysPeryear = 365.24;

    public NBodySystem() {
        bodies = new Body[] {
            new Body() { // Sun
                mass = Solarmass,
            },
            new Body() { // Jupiter
                x = 4.84143144246472090e+00,
                y = -1.16032004402742839e+00,
                z = -1.03622044471123109e-01,
                vx = 1.66007664274403694e-03 * DaysPeryear,
                vy = 7.69901118419740425e-03 * DaysPeryear,
                vz = -6.90460016972063023e-05 * DaysPeryear,
                mass = 9.54791938424326609e-04 * Solarmass,
            },
            new Body() { // Saturn
                x = 8.34336671824457987e+00,
                y = 4.12479856412430479e+00,
                z = -4.03523417114321381e-01,
                vx = -2.76742510726862411e-03 * DaysPeryear,
                vy = 4.99852801234917238e-03 * DaysPeryear,
                vz = 2.30417297573763929e-05 * DaysPeryear,
                mass = 2.85885980666130812e-04 * Solarmass,
            },
            new Body() { // Uranus
                x = 1.28943695621391310e+01,
                y = -1.51111514016986312e+01,
                z = -2.23307578892655734e-01,
                vx = 2.96460137564761618e-03 * DaysPeryear,
                vy = 2.37847173959480950e-03 * DaysPeryear,
                vz = -2.96589568540237556e-05 * DaysPeryear,
                mass = 4.36624404335156298e-05 * Solarmass,
            },
            new Body() { // Neptune
                x = 1.53796971148509165e+01,
                y = -2.59193146099879641e+01,
                z = 1.79258772950371181e-01,
                vx = 2.68067772490389322e-03 * DaysPeryear,
                vy = 1.62824170038242295e-03 * DaysPeryear,
                vz = -9.51592254519715870e-05 * DaysPeryear,
                mass = 5.15138902046611451e-05 * Solarmass,
            },
        };
        
        pairs = new Pair[bodies.Length * (bodies.Length-1)/2];        
        int pi = 0;
        for (int i = 0; i < bodies.Length-1; i++)
            for (int j = i+1; j < bodies.Length; j++)
                pairs[pi++] = new Pair() { bi = bodies[i], bj = bodies[j] };        

        double px = 0.0, py = 0.0, pz = 0.0;
        foreach (var b in bodies) {
            px += b.vx * b.mass; py += b.vy * b.mass; pz += b.vz * b.mass;
        }
        var sol = bodies[0];
        sol.vx = -px/Solarmass; sol.vy = -py/Solarmass; sol.vz = -pz/Solarmass;
    }

    public void Advance(double dt) {
        foreach (var p in pairs) {
            Body bi = p.bi, bj = p.bj;
            double dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
            double d2 = dx * dx + dy * dy + dz * dz;
            double mag = dt / (d2 * Math.Sqrt(d2));
            bi.vx -= dx * bj.mass * mag; bj.vx += dx * bi.mass * mag;
            bi.vy -= dy * bj.mass * mag; bj.vy += dy * bi.mass * mag;
            bi.vz -= dz * bj.mass * mag; bj.vz += dz * bi.mass * mag;
        }
        foreach (var b in bodies) {
            b.x += dt * b.vx; b.y += dt * b.vy; b.z += dt * b.vz;
        }
    }

    public double Energy() {
        double e = 0.0;
        for (int i = 0; i < bodies.Length; i++) {
            var bi = bodies[i];
            e += 0.5 * bi.mass * (bi.vx*bi.vx + bi.vy*bi.vy + bi.vz*bi.vz);
            for (int j = i+1; j < bodies.Length; j++) {
                var bj = bodies[j];
                double dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
                e -= (bi.mass * bj.mass) / Math.Sqrt(dx*dx + dy*dy + dz*dz);
            }
        }
        return e;
    }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy, optimization and use of more C# idioms by Robert F. Tobler
   simdified by Konrad M. Kruczynski and Jaroslaw M. Gliwinski
*/
using System;
using Mono.Simd;

namespace NBody
{
   class NBody
   {
      public static void Main(String[] args)
      {
         var n = args.Length > 0 ? Int32.Parse(args[0]) : 10000;
         var bodies = new NBodySystem();
         var dtdt = new Vector2d(0.01);
         Console.WriteLine("{0:f9}", bodies.Energy());
         for (var i = 0; i < n; i++) bodies.Advance(ref dtdt);
         Console.WriteLine("{0:f9}", bodies.Energy());
      }
   }

   class Body
   {
      public Vector2d Pxy;
      public Vector2d Pz0;
      public Vector2d Vxy;
      public Vector2d Vz0;
      public Vector2d MassMass;

   }

   class Pair
   {
      public Body Bi, Bj;
   }

   class NBodySystem
   {
      private readonly Body[] bodies;
      private readonly Pair[] pairs;

      const double Pi = 3.141592653589793;
      const double SolarMass = 4 * Pi * Pi;
      const double DaysPerYear = 365.24;

      public NBodySystem()
      {
         bodies = new[] {
                        new Body
                           { // Sun
                              MassMass = new Vector2d(SolarMass, SolarMass)
                           },
                        new Body
                           { // Jupiter
                              Pxy = new Vector2d(4.84143144246472090e+00, -1.16032004402742839e+00),
                              Pz0 = new Vector2d( -1.03622044471123109e-01, 0),
                              Vxy = new Vector2d(1.66007664274403694e-03 * DaysPerYear,  7.69901118419740425e-03 * DaysPerYear),
                              Vz0 = new Vector2d(-6.90460016972063023e-05 * DaysPerYear, 0),
                              MassMass = new Vector2d(9.54791938424326609e-04 * SolarMass)
                           },
                        new Body
                           { // Saturn
                              Pxy = new Vector2d(8.34336671824457987e+00, 4.12479856412430479e+00),
                              Pz0 = new Vector2d(-4.03523417114321381e-01, 0),
                              Vxy = new Vector2d(-2.76742510726862411e-03 * DaysPerYear, 4.99852801234917238e-03 * DaysPerYear),
                              Vz0 = new Vector2d(2.30417297573763929e-05 * DaysPerYear, 0),
                              MassMass = new Vector2d(2.85885980666130812e-04 * SolarMass)
                           },
                        new Body
                           { // Uranus
                              Pxy = new Vector2d(1.28943695621391310e+01, -1.51111514016986312e+01),
                              Pz0 = new Vector2d(-2.23307578892655734e-01, 0),
                              Vxy = new Vector2d(2.96460137564761618e-03 * DaysPerYear, 2.37847173959480950e-03 * DaysPerYear),
                              Vz0 = new Vector2d(-2.96589568540237556e-05 * DaysPerYear, 0),
                              MassMass = new Vector2d(4.36624404335156298e-05 * SolarMass)
                           },
                        new Body
                           { // Neptune
                              Pxy = new Vector2d(1.53796971148509165e+01, -2.59193146099879641e+01),
                              Pz0 = new Vector2d(1.79258772950371181e-01, 0),
                              Vxy = new Vector2d(2.68067772490389322e-03 * DaysPerYear, 1.62824170038242295e-03 * DaysPerYear),
                              Vz0 = new Vector2d(-9.51592254519715870e-05 * DaysPerYear, 0),
                              MassMass = new Vector2d(5.15138902046611451e-05 * SolarMass)
                           },
                     };

         pairs = new Pair[bodies.Length * (bodies.Length - 1) / 2];
         var pi = 0;
         for (var i = 0; i < bodies.Length - 1; i++)
         {
            for (var j = i + 1; j < bodies.Length; j++)
            {
               pairs[pi++] = new Pair { Bi = bodies[i], Bj = bodies[j] };
            }
         }

         var pxy = new Vector2d(0);
         var pz0 = new Vector2d(0);
         for (var i = 0; i < bodies.Length; i++ )
         {
            var b = bodies[i];
            pxy += b.Vxy * b.MassMass;
            pz0 += b.Vz0 * b.MassMass;
         }
         var sol = bodies[0];
         var minusOne = new Vector2d(-1);
         var solarMass = new Vector2d(SolarMass);
         sol.Vxy = minusOne * pxy / solarMass;
         sol.Vz0 = minusOne * pz0 / solarMass;
      }

      public void Advance(ref Vector2d dtdt)
      {
         foreach (var p in pairs)
         {
            var bi = p.Bi;
            var bj = p.Bj;
            var dxdy = bi.Pxy - bj.Pxy;
            var dzd0 = bi.Pz0 - bj.Pz0;
            var distvec = (dxdy * dxdy).HorizontalAdd(dzd0 * dzd0);
            var d2 = distvec.HorizontalAdd(distvec);
            var mag = dtdt / (d2.Sqrt() * d2);
            bi.Vxy -= dxdy * bj.MassMass * mag;
            bj.Vxy += dxdy * bi.MassMass * mag;
            bi.Vz0 -= dzd0 * bj.MassMass * mag;
            bj.Vz0 += dzd0 * bi.MassMass * mag;
         }
         foreach(var b in bodies)
         {
            b.Pxy += dtdt * b.Vxy;
            b.Pz0 += dtdt * b.Vz0;
         }
         
      }

      public double Energy()
      {
         var half = new Vector2d(0.5);
         var e = new Vector2d(0.0);
         for (var i = 0; i < bodies.Length; i++)
         {
            var bi = bodies[i];
            var sq = (bi.Vxy*bi.Vxy).HorizontalAdd(bi.Vz0*bi.Vz0);
            e += half * bi.MassMass * sq.HorizontalAdd(sq);
            for (var j = i + 1; j < bodies.Length; j++)
            {
               var bj = bodies[j];
               var dxdy = bi.Pxy - bj.Pxy;
               var dzd0 = bi.Pz0 - bj.Pz0;
               var sqvec = (dxdy * dxdy).HorizontalAdd(dzd0 * dzd0);
               e -= (bi.MassMass * bj.MassMass) / (sqvec.HorizontalAdd(sqvec)).Sqrt();
            }
         }
         return e.X;
      }
   }
}
// $Id: nestedloop.csharp,v 1.5 2005-02-22 19:05:07 igouy-guest Exp $
// http://shootout.alioth.debian.org/
// Some cleanups by Brent Fulgham

using System;

class nestedloop
{
    public static int Main(String[] args)
    {
        int a, b, c, d, e, f, x=0;
        int n = System.Convert.ToInt32(args[0]);
        if(n < 1) n = 1;

        for (a=0; a<n; a++) {
	    for (b=0; b<n; b++) {
	        for (c=0; c<n; c++) {
		    for (d=0; d<n; d++) {
		        for (e=0; e<n; e++) {
			    for (f=0; f<n; f++) {
			        x++;
			    }
			}
		    }
		}
	    }
	}

        Console.WriteLine(x);
	return 0;
    }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/
 
   contributed by Isaac Gouy 
*/

using System;

class NSieve
{
   static int nsieve(int m, bool[] isPrime) {
      for (int i=2; i <= m; i++) isPrime[i] = true;
      int count = 0;

      for (int i=2; i <= m; i++){ 
         if (isPrime[i]){
            for (int k=i+i; k <= m; k+=i) isPrime[k] = false;
            count++;
         }
      }
      return count;
   }

   public static void Main(String[] args) 
   {        
      int n = 2;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      if (n < 2) n = 2;

      int m = (1<<n)*10000; 
      bool[] flags = new bool[m+1];       
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));

      m = (1<<n-1)*10000;     
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));

      m = (1<<n-2)*10000;     
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));
   }
}

/*
  vim: ts=4 ft=cs
 */
 
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;
using System.Collections;

class NSieveBits
{
   static int nsieve(int m, BitArray isPrime) {
      isPrime.SetAll(true);
      int count = 0;

      for (int i=2; i <= m; i++){ 
         if (isPrime.Get(i)){
            for (int k=i+i; k <= m; k+=i) isPrime.Set(k,false);
            count++;
         }
      }
      return count;
   }

   public static void Main(String[] args) 
   {        
      int n = 2;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      if (n < 2) n = 2;

      int m = (1<<n)*10000; 
      BitArray flags = new BitArray(m+1);       
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));

      m = (1<<n-1)*10000;     
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));

      m = (1<<n-2)*10000;     
      Console.WriteLine("Primes up to {0,8:D} {1,8:D}", m, nsieve(m,flags));
   }
}
// $Id: objinst.csharp,v 1.3 2004-06-24 07:38:14 bfulgham Exp $
// http://shootout.alioth.debian.org/

using System;

class Toggle {
    public bool state = true;
    public Toggle(bool start_state) {
        state = start_state;
    }
    
    public bool value() {
        return state;
    }
    
    public Toggle activate() {
        state = !state;
        return this;
    }
}

class NthToggle : Toggle {
    int count_max = 0;
    int counter = 0;

    public NthToggle(bool start_state, int max_counter) : base(start_state) {
        count_max = max_counter;
        counter = 0;
    }

    public new NthToggle activate() {
        counter += 1;
        if (counter >= count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
}

class objinst {
    public static void Main(String[] args) {

        int n = System.Convert.ToInt32(args[0]);
        if(n < 1) n = 1;

        Toggle toggle1 = new Toggle(true);
        for (int i = 0; i < 5; i++) {
            Console.WriteLine((toggle1.activate().value()) ? "true" : "false");
        }

        for (int i = 0; i < n; i++) {
            Toggle toggle = new Toggle(true);
        }
        Console.WriteLine();
        
        
        NthToggle ntoggle1 = new NthToggle(true, 3);
        for (int i = 0; i < 8; i++) {
            Console.WriteLine((ntoggle1.activate().value()) ? "true" : "false");
        }
        for (int i = 0; i < n; i++) {
            NthToggle toggle = new NthToggle(true, 3);
        }
    }
}
//   The Computer Language Shootout
//   http://shootout.alioth.debian.org/
//   contributed by Isaac Gouy

using System;

class partialsums {
   const double twothirds = 2.0/3.0;

   static void Main(string[] args){
      int n = Int32.Parse(args[0]);

      double a1 = 0.0, a2 = 0.0, a3 = 0.0, a4 = 0.0, a5 = 0.0;
      double a6 = 0.0, a7 = 0.0, a8 = 0.0, a9 = 0.0, alt = -1.0;

      for (int k=1; k<=n; k++){
         double k2 = Math.Pow(k,2), k3 = k2*k;
         double sk = Math.Sin(k), ck = Math.Cos(k);
         alt = -alt;

         a1 += Math.Pow(twothirds,k-1);
         a2 += Math.Pow(k,-0.5);
         a3 += 1.0/(k*(k+1.0));
         a4 += 1.0/(k3 * sk*sk);
         a5 += 1.0/(k3 * ck*ck);
         a6 += 1.0/k;
         a7 += 1.0/k2;
         a8 += alt/k;
         a9 += alt/(2.0*k -1.0);
      }
      Console.WriteLine("{0:f9}\t(2/3)^k", a1);
      Console.WriteLine("{0:f9}\tk^-0.5", a2);
      Console.WriteLine("{0:f9}\t1/k(k+1)", a3);       
      Console.WriteLine("{0:f9}\tFlint Hills", a4);
      Console.WriteLine("{0:f9}\tCookson Hills", a5);
      Console.WriteLine("{0:f9}\tHarmonic", a6);
      Console.WriteLine("{0:f9}\tRiemann Zeta", a7);      
      Console.WriteLine("{0:f9}\tAlternating Harmonic", a8);
      Console.WriteLine("{0:f9}\tGregory", a9);
   }
}
/* The Computer Language Benchmarks Game
 *    http://shootout.alioth.debian.org/
 *
 * Contributed by Alp Toker <alp@atoker.com>
 * Modified by Antti Lankila <alankila@bel.fi>
 */

using System;
using UBigInteger = Mono.Math.BigInteger;

public class pidigits
{
    const int L = 10;

    public static void Main (string[] args)
    {
	if (args.Length != 1)
	    return;

	int n = Int32.Parse(args[0]);
	int j = 0;

	PiDigitSpigot pds = new PiDigitSpigot();
	while (j < n) {
	    string output = "";
	    for (int i = 0; i != L && j != n; i++, j++)
		output += pds.Next();
            Console.WriteLine("{0,-" + L + "}\t:{1}", output, j);
	}
    }
}

class PiDigitSpigot
{
    private BigInteger z0 = 1, z1 = 0, z2 = 1;
    private int k = 0;

    private int ExtractDigit(int digit)
    {
	return ((z0 * digit + z1) / z2).IntValue();
    }

    private void Compose_k(int k)
    {
	int k2 = 2 * k + 1;
	z1 = k2 * z1 + 2 * k2 * z0;
	z0 *= k;
	z2 *= k2;
    }

    private void Compose_d(int d)
    {
	z1 = 10 * z1 + -10 * d * z2;
	z0 *= 10;
    }

    public int Next()
    {
	int d;
	while (z0 == z2 || (d = ExtractDigit(3)) != ExtractDigit(4))
	    Compose_k(++k);
	Compose_d(d);
	return d;
    }
}

class BigInteger
{
    private UBigInteger bi;
    private int sign = 1;
    private static readonly BigInteger zero = 0;

    private BigInteger () {}

    public static implicit operator BigInteger(int i)
    {
	return new BigInteger(i);
    }

    public BigInteger(int value)
    {
	if (value == 0)
	    sign = 0;
	else if (value < 0) {
	    sign = -1;
	    value = -value;
	}
	bi = new UBigInteger(value);
    }

    public int IntValue()
    {
	return sign * bi.GetBytes()[0];
    }

    public override string ToString ()
    {
	return (sign == -1 ? "-" : "") + bi.ToString ();
    }

    public static BigInteger operator * (BigInteger bi1, BigInteger bi2)
    {
	BigInteger ret = new BigInteger();
	ret.bi = bi1.bi * bi2.bi;
	ret.sign = bi1.sign * bi2.sign;
	return ret;
    }

    public static BigInteger operator / (BigInteger bi1, BigInteger bi2)
    {
	BigInteger ret = new BigInteger();
	ret.bi = bi1.bi / bi2.bi;
	ret.sign = bi1.sign * bi2.sign;
	return ret;
    }

    public static BigInteger operator + (BigInteger bi1, BigInteger bi2)
    {
	if (bi1.sign == 0)
	    return bi2;

	if (bi2.sign == 0)
	    return bi1;
	
	if (bi1.sign == bi2.sign) {
	    BigInteger ret = new BigInteger();
	    ret.bi = bi1.bi + bi2.bi;
	    ret.sign = bi1.sign;
	    return ret;
	}
	
	
	if (bi1.bi == bi2.bi)
	    return zero;

	if (bi1.bi < bi2.bi) {
	    BigInteger ret = new BigInteger();
	    ret.bi = bi2.bi - bi1.bi;
	    ret.sign = bi2.sign;
	    return ret;
	} else {
	    BigInteger ret = new BigInteger();
	    ret.bi = bi1.bi - bi2.bi;
	    ret.sign = -1 * bi2.sign;
	    return ret;
	}
    }
}
/**
 * The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * Port of the Java port that uses native GMP to use native GMP with C#
 * contributed by Miguel de Icaza, based on the Java version, that was:
 * 	contributed by Mike Pall
 * 	java port by Stefan Krause
*/
using System;
using System.Text;
using System.Runtime.InteropServices;

public class pidigits {

   GmpInteger q = new GmpInteger(), r = new GmpInteger(), s = new GmpInteger(), t = new GmpInteger();
   GmpInteger u = new GmpInteger(), v = new GmpInteger(), w = new GmpInteger();

   int i;
   StringBuilder strBuf = new StringBuilder (40);
   int n;

   pidigits (int n)
   {
      this.n=n;
   }

   private void compose_r(int bq, int br, int bs, int bt)
   {
     u.mul(r, bs);
     r.mul(r, bq);
     v.mul(t, br);
     r.add(r, v);
     t.mul(t, bt);
     t.add(t, u);
     s.mul(s, bt);
     u.mul(q, bs);
     s.add(s, u);
     q.mul(q, bq);
   }

   /* Compose matrix with numbers on the left. */
   private void compose_l(int bq, int br, int bs, int bt)
   {
     r.mul(r, bt);
     u.mul(q, br);
     r.add(r, u);
     u.mul(t, bs);
     t.mul(t, bt);
     v.mul(s, br);
     t.add(t, v);
     s.mul(s, bq);
     s.add(s, u);
     q.mul(q, bq);
   }

   /* Extract one digit. */
   private int extract(int j)
   {
     u.mul(q, j);
     u.add(u, r);
     v.mul(s, j);
     v.add(v, t);
     w.div(u, v);
     return w.intValue();
   }

   /* Print one digit. Returns 1 for the last digit. */
   private bool prdigit(int y)
   {
      strBuf.Append(y);
      if (++i % 10 == 0 || i == n) {
         if (i%10!=0) for (int j=10-(i%10);j>0;j--) { strBuf.Append(" "); }
         strBuf.Append("\t:");
         strBuf.Append(i);
         Console.WriteLine(strBuf);
         strBuf = new StringBuilder(40);
      }
      return i == n;
   }

   /* Generate successive digits of PI. */
   void Run()
   {
     int k = 1;
     i = 0;
     q.set(1);
     r.set(0);
     s.set(0);
     t.set(1);
     for (;;) {
       int y = extract(3);
       if (y == extract(4)) {
         if (prdigit(y)) return;
         compose_r(10, -10*y, 0, 1);
       } else {
         compose_l(k, 4*k+2, 0, 2*k+1);
         k++;
       }
     }
   }

   public static void Main(String[] args) {
       pidigits m = new pidigits(Int32.Parse (args[0]));
       m.Run();
   }
}

[StructLayout (LayoutKind.Sequential)]
struct mpz_t {
    public int _mp_alloc;
    public int _mp_size;
    public IntPtr ptr;
}

class GmpInteger {

   // Public methods

   public GmpInteger() {
      mpz_init(ref pointer);
   }

   public GmpInteger(int value) {
      mpz_set_si(ref pointer, value);
   }

   public void set(int value) { mpz_set_si(ref pointer, value); }

   public void mul(GmpInteger src, int val) { mpz_mul_si(ref pointer, ref src.pointer, val); }

   public void add(GmpInteger op1, GmpInteger op2) { mpz_add(ref pointer, ref op1.pointer, ref op2.pointer); }

   public void div(GmpInteger op1, GmpInteger op2) { mpz_tdiv_q(ref pointer, ref op1.pointer, ref op2.pointer); }

   public int intValue() { return mpz_get_si(ref pointer); }

   public double doubleValue() { return mpz_get_d(ref pointer); }

   // Non public stuff

   mpz_t pointer;

    [DllImport ("gmp", EntryPoint="__gmpz_init")]
    extern static void mpz_init(ref mpz_t value);

    [DllImport ("gmp", EntryPoint="__gmpz_mul_si")]
    extern static void mpz_mul_si(ref mpz_t dest, ref mpz_t src, int val);

    [DllImport ("gmp", EntryPoint="__gmpz_add")]
    extern static void mpz_add(ref mpz_t dest, ref mpz_t src, ref mpz_t src2);

    [DllImport ("gmp", EntryPoint="__gmpz_tdiv_q")]
    extern static void mpz_tdiv_q(ref mpz_t dest, ref mpz_t src, ref mpz_t src2);

    [DllImport ("gmp", EntryPoint="__gmpz_set_si")]
    extern static void mpz_set_si(ref mpz_t src, int value);

    [DllImport ("gmp", EntryPoint="__gmpz_get_si")]
    extern static int mpz_get_si(ref mpz_t src);

    [DllImport ("gmp", EntryPoint="__gmpz_get_d")]
    extern static double mpz_get_d(ref mpz_t src);
}
/*
   The Great Computer Language Shootout
   http://shootout.alioth.debian.org/
   contributed by Isaac Gouy
*/

using System;
using System.Threading;

class prodcons
{
   private class Buffer 
   {
      private int m_contents = -1;
      private bool m_available = false;

      public int Get(){
         lock(this)
         {
            if (!m_available) Monitor.Wait(this);
            m_available = false;
            Monitor.Pulse(this);
         }
         return m_contents;
      }

      public void Put(int value){
         lock(this)
         {
            if (m_available) Monitor.Wait(this);
            m_contents = value;
            m_available = true;
            Monitor.Pulse(this);
         }
      }
   }


   // Could create separate Producer and Consumer classes
   // Instead add the members and methods to ProdCons class
   private Buffer b;
   private int n = 0;
   private static int produced = 0, consumed = 0;

   private prodcons(Buffer sharedBuffer, int nTimes) {
      b = sharedBuffer;
      n = nTimes;
   }

   private void Produce() {
      for (int i = 0; i < n; i++){
         b.Put(i);
         ++produced;
      }
   }

   private void Consume() {
      for (int i = 0; i < n; i++){
         b.Get();
         ++consumed;
      }
   }


   static void Main(string[] args)
   {
      // Get the number of iterations
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]); 

      Buffer sharedBuffer = new Buffer();
      //create producer and consumer
      prodcons producer = new prodcons(sharedBuffer, n);
      prodcons consumer = new prodcons(sharedBuffer, n);

      //start producer and consumer threads
      Thread tProducer = new Thread(new ThreadStart( producer.Produce ));
      Thread tConsumer = new Thread(new ThreadStart( consumer.Consume ));
      tProducer.Start();
      tConsumer.Start();

      // wait on both threads
      tProducer.Join();
      tConsumer.Join();

        Console.WriteLine("{0} {1}", prodcons.produced, prodcons.consumed);
   }
}
/* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *  
 * contributed by Isaac Gouy 
 */

using System;

class Random
{
   const int IM = 139968;
   const int IA = 3877;
   const int IC = 29573;
   static int last = 42;

   public static double gen_random(double max) {        
      last = (last * IA + IC) % IM;
      return( max * last / IM );
   }

   public static void Main(String[] args) {
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      while (n-- > 1) gen_random(100.0);
      Console.WriteLine("{0:f9}", gen_random(100.0));
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/
   
   contributed by Isaac Gouy
*/

using System;
using System.Collections;
using System.IO;


class RayTracer
{
   const int levels = 6, ss = 4;
   const double Epsilon = 1.49012e-08; // Normally we'd use double.Epsilon

   public static void Main(String[] args){        
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Scene scene = Scene.SphereScene(levels, new Vector(0.0, -1.0, 0.0), 1.0);

      Console.WriteLine("P5");
      Console.WriteLine("{0} {1}", n,n);
      Console.WriteLine("255");

      Stream stream = Console.OpenStandardOutput(1024);
      byte[] temp = new byte[1];

      for (int y=n-1; y>=0; --y){
         for (int x=0; x<n; ++x){

            double greyscale = 0.0;
            for (int dx=0; dx<ss; ++dx){
               for (int dy=0; dy<ss; ++dy){

                  Vector v = new Vector(
                       x + dx/(double)ss - n/2.0
                     , y + dy/(double)ss - n/2.0
                     , n);

                  Ray ray = new Ray(new Vector(0.0, 0.0, -4.0), v.Normalized());

                  greyscale += scene.TraceRay(ray, 
                     new Vector(-1.0, -3.0, 2.0).Normalized() );
               }
            }

            temp[0] = (byte)(0.5 + 255.0*greyscale/(ss*ss));
            stream.Write(temp,0,1);
         }
      }
   }


   abstract class Scene
   {     
      abstract internal IntersectionPoint Intersect(Ray ray, IntersectionPoint p);

      internal static Scene SphereScene(int level, Vector center, double radius){
         Sphere sphere = new Sphere(center, radius);
         if (level == 1){ 
            return sphere;
         }
         else {
            Group scene = new Group(new Sphere(center, 3.0*radius));
            scene.Add(sphere);
            double rn = 3.0*radius / Math.Sqrt(12.0);

            for (int dz=-1; dz<=1; dz+=2){
               for (int dx=-1; dx<=1; dx+=2){

                  Vector c2 = new Vector(
                       center.x - dx*rn
                     , center.y + rn
                     , center.z - dz*rn
                     );

                  scene.Add( SphereScene(level-1, c2, radius/2.0) );
               }
            }
            return scene;
         }
      }


      internal double TraceRay (Ray ray, Vector light){
         IntersectionPoint p = Intersect(ray,
            new IntersectionPoint(
                 double.PositiveInfinity, new Vector(0.0, 0.0, 0.0)) );
                 
         if (double.IsInfinity(p.distance)) return 0.0;

         double greyscale = -(p.normal * light);
         if (greyscale <= 0.0) return 0.0;

         Vector o = ray.origin + 
            (p.distance * ray.direction) + (Epsilon * p.normal);
            
         Ray shadowRay = new Ray(o, new Vector(0.0, 0.0, 0.0) - light);
         IntersectionPoint shadowp = Intersect(shadowRay,
            new IntersectionPoint(double.PositiveInfinity, p.normal) );

         return double.IsInfinity(shadowp.distance) ? greyscale : 0.0;
      }
   }


   // a leaf node in the scene tree
   class Sphere : Scene 
   {
      private Vector center;
      private double radius;

      internal Sphere(Vector center, double radius){ 
         this.center = center; this.radius = radius; 
      }

      internal double Distance(Ray ray){
         Vector v = center - ray.origin;
         double b = v * ray.direction;
         double disc = b*b - v*v + radius*radius;         
         if (disc < 0) return double.PositiveInfinity; // No intersection

         double d = Math.Sqrt(disc);
         double t1 = b + d;
         if (t1 < 0) return double.PositiveInfinity;

         double t2 = b - d;
         return t2 > 0 ? t2 : t1;
      }

      override internal IntersectionPoint Intersect(Ray r, IntersectionPoint p){
         double d = Distance(r);
         if (d < p.distance){ 
            Vector v = r.origin + ((d * r.direction) - center);
            p = new IntersectionPoint(d, v.Normalized());
         }
         return p;
      }
   }


   // non-leaf node in the scene tree
   class Group : Scene 
   {
      private Sphere bound;
      private ArrayList scenes = new ArrayList();

      internal Group(Sphere bound){
         this.bound = bound;
      }

      override internal IntersectionPoint Intersect(Ray r, IntersectionPoint p){
         if (bound.Distance(r) < p.distance){ 
            foreach (Scene each in scenes)
               p = each.Intersect(r, p);
         }
         return p;
      }

      internal void Add(Scene s){
         scenes.Insert(0,s);
      }
   }
}


struct Vector
{     
   private double _x, _y, _z;

   internal Vector(double x, double y, double z){
      _x = x; _y = y; _z = z;
   }

   public static Vector operator +(Vector a, Vector b){
      return new Vector(a._x + b._x, a._y + b._y, a._z + b._z);
   }

   public static Vector operator -(Vector a, Vector b){
      return new Vector(a._x - b._x, a._y - b._y, a._z - b._z);
   }

   public static double operator *(Vector a, Vector b){
      return (a._x * b._x) + (a._y * b._y) + (a._z * b._z);
   }

   public static Vector operator *(double s, Vector b){
      return new Vector(s * b._x, s * b._y, s * b._z);
   }

   public static Vector operator *(Vector a, double s){
      return new Vector(a._x * s, a._y * s, a._z * s);
   }

   internal Vector Normalized(){
      return (1.0 / Math.Sqrt(this * this)) * this;
   }

   internal double x {
      get { return _x; }
   }

   internal double y {
      get { return _y; }
   }

   internal double z {
      get { return _z; }
   }
}


struct Ray
{     
   private Vector _origin, _direction; 

   internal Ray(Vector origin, Vector direction){
      _origin = origin; _direction = direction;
   }

   internal Vector origin {
      get { return _origin; }
   }

   internal Vector direction {
      get { return _direction; }
   }
}


struct IntersectionPoint
{     
   private double _distance; 
   private Vector _normal; 

   internal IntersectionPoint(double distance, Vector normal){
      _distance = distance; _normal = normal;
   }

   internal double distance {
      get { return _distance; }
   }

   internal Vector normal {
      get { return _normal; }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/
   
   contributed by Isaac Gouy 
*/

using System;
using System.Collections;
using System.IO;


class RayTracer
{
   const int levels = 6, ss = 4;
   const double Epsilon = 1.49012e-08; // Normally we'd use double.Epsilon

   public static void Main(String[] args){        
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Scene scene = Scene.SphereScene(levels, new Vector(0.0, -1.0, 0.0), 1.0);

      Console.WriteLine("P5");
      Console.WriteLine("{0} {1}", n,n);
      Console.WriteLine("255");

      Stream stream = Console.OpenStandardOutput(1024);
      byte[] temp = new byte[1];

      for (int y=n-1; y>=0; --y){
         for (int x=0; x<n; ++x){

            double greyscale = 0.0;
            for (int dx=0; dx<ss; ++dx){
               for (int dy=0; dy<ss; ++dy){

                  Vector v = new Vector(
                       x + dx/(double)ss - n/2.0
                     , y + dy/(double)ss - n/2.0
                     , n);

                  Ray ray = new Ray(new Vector(0.0, 0.0, -4.0), v.Normalized());

                  greyscale += scene.TraceRay(ray, 
                     new Vector(-1.0, -3.0, 2.0).Normalized() );
               }
            }

            temp[0] = (byte)(0.5 + 255.0*greyscale/(ss*ss));
            stream.Write(temp,0,1);
         }
      }
   }


   abstract class Scene
   {     
      abstract internal IntersectionPoint Intersect(Ray ray, IntersectionPoint p);

      internal static Scene SphereScene(int level, Vector center, double radius){
         Sphere sphere = new Sphere(center, radius);
         if (level == 1){ 
            return sphere;
         }
         else {
            Group scene = new Group(new Sphere(center, 3.0*radius));
            scene.Add(sphere);
            double rn = 3.0*radius / Math.Sqrt(12.0);

            for (int dz=-1; dz<=1; dz+=2){
               for (int dx=-1; dx<=1; dx+=2){

                  Vector c2 = new Vector(
                       center.x - dx*rn
                     , center.y + rn
                     , center.z - dz*rn
                     );

                  scene.Add( SphereScene(level-1, c2, radius/2.0) );
               }
            }
            return scene;
         }
      }


      internal double TraceRay (Ray ray, Vector light){
         IntersectionPoint p = Intersect(ray,
            new IntersectionPoint(
                 double.PositiveInfinity, new Vector(0.0, 0.0, 0.0)) );
                 
         if (double.IsInfinity(p.distance)) return 0.0;

         double greyscale = -(p.normal * light);
         if (greyscale <= 0.0) return 0.0;

         Vector o = ray.origin + 
            (p.distance * ray.direction) + (Epsilon * p.normal);
            
         Ray shadowRay = new Ray(o, new Vector(0.0, 0.0, 0.0) - light);
         IntersectionPoint shadowp = Intersect(shadowRay,
            new IntersectionPoint(double.PositiveInfinity, p.normal) );

         return double.IsInfinity(shadowp.distance) ? greyscale : 0.0;
      }
   }


   // a leaf node in the scene tree
   class Sphere : Scene 
   {
      private Vector center;
      private double radius;

      internal Sphere(Vector center, double radius){ 
         this.center = center; this.radius = radius; 
      }

      internal double Distance(Ray ray){
         Vector v = center - ray.origin;
         double b = v * ray.direction;
         double disc = b*b - v*v + radius*radius;         
         if (disc < 0) return double.PositiveInfinity; // No intersection

         double d = Math.Sqrt(disc);
         double t1 = b + d;
         if (t1 < 0) return double.PositiveInfinity;

         double t2 = b - d;
         return t2 > 0 ? t2 : t1;
      }

      override internal IntersectionPoint Intersect(Ray r, IntersectionPoint p){
         double d = Distance(r);
         if (d < p.distance){ 
            Vector v = r.origin + ((d * r.direction) - center);
            p = new IntersectionPoint(d, v.Normalized());
         }
         return p;
      }
   }


   // non-leaf node in the scene tree
   class Group : Scene 
   {
      private Sphere bound;
      private ArrayList scenes = new ArrayList();

      internal Group(Sphere bound){
         this.bound = bound;
      }

      override internal IntersectionPoint Intersect(Ray r, IntersectionPoint p){
         if (bound.Distance(r) < p.distance){ 
            foreach (Scene each in scenes)
               p = each.Intersect(r, p);
         }
         return p;
      }

      internal void Add(Scene s){
         scenes.Insert(0,s);
      }
   }
}


class Vector
{     
   private double _x, _y, _z;

   internal Vector(double x, double y, double z){
      _x = x; _y = y; _z = z;
   }

   public static Vector operator +(Vector a, Vector b){
      return new Vector(a._x + b._x, a._y + b._y, a._z + b._z);
   }

   public static Vector operator -(Vector a, Vector b){
      return new Vector(a._x - b._x, a._y - b._y, a._z - b._z);
   }

   public static double operator *(Vector a, Vector b){
      return (a._x * b._x) + (a._y * b._y) + (a._z * b._z);
   }

   public static Vector operator *(double s, Vector b){
      return new Vector(s * b._x, s * b._y, s * b._z);
   }

   public static Vector operator *(Vector a, double s){
      return new Vector(a._x * s, a._y * s, a._z * s);
   }

   internal Vector Normalized(){
      return (1.0 / Math.Sqrt(this * this)) * this;
   }

   internal double x {
      get { return _x; }
   }

   internal double y {
      get { return _y; }
   }

   internal double z {
      get { return _z; }
   }
}


class Ray
{     
   private Vector _origin, _direction; 

   internal Ray(Vector origin, Vector direction){
      _origin = origin; _direction = direction;
   }

   internal Vector origin {
      get { return _origin; }
   }

   internal Vector direction {
      get { return _direction; }
   }
}


class IntersectionPoint
{     
   private double _distance; 
   private Vector _normal; 

   internal IntersectionPoint(double distance, Vector normal){
      _distance = distance; _normal = normal;
   }

   internal double distance {
      get { return _distance; }
   }

   internal Vector normal {
      get { return _normal; }
   }
}
/* The Computer Language Shootout 
   http://shootout.alioth.debian.org/
   contributed by Isaac Gouy 
*/

using System;

class recursive
{
   static void Main(string[] args){
      int n = Int32.Parse(args[0]);
      Console.WriteLine("Ack(3,{0}): {1}", n, Ack(3, n));
      Console.WriteLine("Fib({0:f1}): {1:f1}", 27.0+n, Fib(27.0+n));
      n--; Console.WriteLine("Tak({0},{1},{2}): {3}", 3*n,2*n,n, Tak(3*n,2*n,n)); 

      Console.WriteLine("Fib(3): {0}", Fib(3));
      Console.WriteLine("Tak(3.0,2.0,1.0): {0:f1}",Tak(3.0,2.0,1.0));
   }


   public static int Ack(int m, int n) {
      if (m == 0) return n + 1;
      if (n == 0) return Ack(m-1, 1);
      else return Ack(m-1, Ack(m, n-1));
   }

   public static int Fib(int n) {
      if (n < 2) return 1;
      else return Fib(n-2) + Fib(n-1);
   }

   public static int Tak(int x, int y, int z) {
      if (y < x) return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
      else return z;
   }

   public static double Fib(double n) {
      if (n < 2.0) return 1.0;
      else return Fib(n-2.0) + Fib(n-1.0);
   }

   public static double Tak(double x, double y, double z) {
      if (y < x) return Tak(Tak(x-1.0,y,z), Tak(y-1.0,z,x), Tak(z-1.0,x,y));
      else return z;
   }
}
/* The Great Computer Language Shootout 
 * http://shootout.alioth.debian.org/
 * 
 * contributed by Isaac Gouy */

using System;
using System.Text.RegularExpressions;

class regexdna
{
   static void Main(string[] args){
                   
      // read FASTA sequence
      String sequence = Console.In.ReadToEnd();
      int initialLength = sequence.Length;

      // remove FASTA sequence descriptions and new-lines
      Regex r = new Regex(">.*\n|\n", RegexOptions.Compiled);
      sequence = r.Replace(sequence,"");
      int codeLength = sequence.Length;


      // regex match
      string[] variants = {
         "agggtaaa|tttaccct"
         ,"[cgt]gggtaaa|tttaccc[acg]"
         ,"a[act]ggtaaa|tttacc[agt]t"
         ,"ag[act]gtaaa|tttac[agt]ct"
         ,"agg[act]taaa|ttta[agt]cct"
         ,"aggg[acg]aaa|ttt[cgt]ccct"
         ,"agggt[cgt]aa|tt[acg]accct"
         ,"agggta[cgt]a|t[acg]taccct"
         ,"agggtaa[cgt]|[acg]ttaccct"
      }; 

      int count;
      foreach (string v in variants){
         count = 0;
         r = new Regex(v, RegexOptions.Compiled);

         for (Match m = r.Match(sequence); m.Success; m = m.NextMatch()) count++;
         Console.WriteLine("{0} {1}", v, count);
      }


      // regex substitution
      IUB[] codes = {
          new IUB("B", "(c|g|t)")
         ,new IUB("D", "(a|g|t)")
         ,new IUB("H", "(a|c|t)")
         ,new IUB("K", "(g|t)")
         ,new IUB("M", "(a|c)")
         ,new IUB("N", "(a|c|g|t)")
         ,new IUB("R", "(a|g)")
         ,new IUB("S", "(c|g)")
         ,new IUB("V", "(a|c|g)")
         ,new IUB("W", "(a|t)")
         ,new IUB("Y", "(c|t)")
      }; 

      foreach (IUB iub in codes) {
         r = new Regex(iub.code, RegexOptions.Compiled);
         sequence = r.Replace(sequence,iub.alternatives);
      }
      Console.WriteLine("\n{0}\n{1}\n{2}", 
         initialLength, codeLength, sequence.Length);
   }


   struct IUB 
   {
      public string code;
      public string alternatives;

      public IUB(string code, string alternatives) {
         this.code = code;
         this.alternatives = alternatives;
      }
   }
}

/* The Computer Language Benchmarks Game
 * http://shootout.alioth.debian.org/
 *
 * contributed by Jimmy Tang
 */

using System;
using System.Linq;
using System.Threading;
using System.Collections.Generic;
using System.Text.RegularExpressions;

class regexdna {
    static void Main() {

        string sequence = Console.In.ReadToEnd();
        int initialLength = sequence.Length;
                
        sequence = Regex.Replace(sequence, ">.*\n|\n", "");
        int codeLength = sequence.Length;

        string[] variants = {
           "agggtaaa|tttaccct"
          ,"[cgt]gggtaaa|tttaccc[acg]"
          ,"a[act]ggtaaa|tttacc[agt]t"
          ,"ag[act]gtaaa|tttac[agt]ct"
          ,"agg[act]taaa|ttta[agt]cct"
          ,"aggg[acg]aaa|ttt[cgt]ccct"
          ,"agggt[cgt]aa|tt[acg]accct"
          ,"agggta[cgt]a|t[acg]taccct"
          ,"agggtaa[cgt]|[acg]ttaccct"
        };

        var flags = variants.Select((v, i) => {
            var flag = new ManualResetEvent(false);
            ThreadPool.QueueUserWorkItem(x => {
                variants[i] += " " + Regex.Matches(sequence, v).Count;
                flag.Set();
            });
            return flag;
        });
        WaitHandle.WaitAll(flags.ToArray());
        Console.WriteLine(string.Join("\n", variants));

        var dict = new Dictionary<string, string> {
            {"B", "(c|g|t)"}, {"D", "(a|g|t)"},   {"H", "(a|c|t)"}, {"K", "(g|t)"},
            {"M", "(a|c)"},   {"N", "(a|c|g|t)"}, {"R", "(a|g)"},   {"S", "(c|g)"},
            {"V", "(a|c|g)"}, {"W", "(a|t)"},     {"Y", "(c|t)"} 
        };
        sequence = new Regex("[WYKMSRBDVHN]").Replace(sequence, m => dict[m.Value]);
        Console.WriteLine("\n{0}\n{1}\n{2}", initialLength, codeLength, sequence.Length);
    }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
   fixed by TJ Fontaine   
*/

using System;
using System.Text.RegularExpressions;

class regexmatch
{
   static void Main(string[] args){
      // Get the number of iterations
      int n = 0;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Regex r = new Regex(
         "(?: ^ | [^\\d\\(])" +   // must be preceeded by non-digit
         "( \\( )?" +         // match 1: possible initial left paren
         "(\\d\\d\\d)" +         // match 2: area code is 3 digits
         "(?(1) \\) )" +         // if match1 then match right paren
         "[ ]" +               // area code followed by one space
         "(\\d\\d\\d)" +         // match 3: prefix of 3 digits
         "[ -]" +            // separator is either space or dash
         "(\\d\\d\\d\\d)" +      // match 4: last 4 digits
         "\\D"               // must be followed by a non-digit
         ,RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled | RegexOptions.Multiline);

      String phoneNumbers = Console.In.ReadToEnd();
      int count = 0;
      Match m;
   		
      while (n-- > 0)
         for (m = r.Match(phoneNumbers); m.Success; m = m.NextMatch()) {
            if (n == 1) // counting-down 1 is the last iteration
               Console.WriteLine("{0}: ({1}) {2}-{3}",
                  ++count, m.Groups[2].Value, m.Groups[3].Value, m.Groups[4].Value);
         }
   }
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Robert F. Tobler to process large blocks of byte arrays
*/

using System;
using System.IO;
using System.Collections.Generic;

static class revcomp
{
   struct Block {
      public byte[] Data; public int Count;
      public int Read(BinaryReader r) {
         Data = r.ReadBytes(16384); Count++; return Data.Length;
      }
      public Index IndexOf(byte b, int o) {
         return new Index { Block = Count, Pos = Array.IndexOf(Data, b, o) };
      }
   }

   struct Index {
      public int Block; public int Pos;
      public static readonly Index None = new Index { Block = -1, Pos = -1 };
      public bool InBlock(Block b) { return Block == b.Count; }
   }

   const byte Gt = (byte)'>';
   const byte Lf = (byte)'\n';

   static void Main(string[] args) {
      InitComplements();
      var seq = new List<byte[]>();
      var b = new Block { Count = -1 };
      Index line = Index.None, start = Index.None, end = Index.None;
      using (var r = new BinaryReader(Console.OpenStandardInput())) {
         using (var w = Console.OpenStandardOutput()) {
            while (b.Read(r) > 0) {
               seq.Add(b.Data);
               if (line.Pos < 0) line = b.IndexOf(Gt, 0);
               while (line.Pos >= 0) {
                  if (start.Pos < 0) {
                     var off = line.InBlock(b) ? line.Pos : 0;
                     start = b.IndexOf(Lf, off);
                     if (start.Pos < 0) {
                         w.Write(b.Data, off, b.Data.Length - off);
                         seq.Clear(); break;
                     }
                     w.Write(b.Data, off, start.Pos + 1 - off);
                  }
                  if (end.Pos < 0) {
                     end = b.IndexOf(Gt, start.InBlock(b) ? start.Pos : 0);
                     if (end.Pos < 0) break;
                  }
                  w.Reverse(start.Pos, end.Pos, seq);
                  if (seq.Count > 1) seq.RemoveRange(0, seq.Count - 1);
                  line = end; end = Index.None; start = Index.None;
               }
            }
            if (start.Pos >= 0 && end.Pos < 0)
               w.Reverse(start.Pos, seq[seq.Count -1].Length, seq);
         }
      }
   }

   const string Seq = "ABCDGHKMRTVYabcdghkmrtvy";
   const string Rev = "TVGHCDMKYABRTVGHCDMKYABR";
   static byte[] comp = new byte[256];

   static void InitComplements() {
      for (byte i = 0; i < 255; i++) comp[i] = i;
      for (int i = 0; i < Seq.Length; i++)
         comp[(byte)Seq[i]] = (byte)Rev[i];
      comp[Lf] = 0;  comp[(byte)' '] = 0;
   }

   const int LineLen = 61;
   const int BufSize = LineLen * 269;
   static byte[] buf = new byte[BufSize];

   static void Reverse(this Stream w, int si, int ei, List<byte[]> bl) {
      int bi = 0, line = LineLen - 1;
      for (int ri = bl.Count-1; ri >= 0; ri--) {
         var b = bl[ri]; int off = ri == 0 ? si : 0;
         for (int i = (ri == bl.Count-1 ? ei : b.Length)-1; i >= off; i--) {
            var c = comp[b[i]]; if (c > 0) buf[bi++] = c;
            if (bi == line) {
               buf[bi++] = Lf; line += LineLen;
               if (bi == BufSize) {
                  w.Write(buf, 0, BufSize); bi = 0; line = LineLen - 1;
               }
            }
         }
      }
      if (bi > 0) {
          if (buf[bi-1] != Lf) buf[bi++] = Lf; w.Write(buf, 0, bi);
      }
   }
}
/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy
   modified by Robert F. Tobler to perform actual computations on byte arrays
   modified again by Robert F. Tobler to use BinaryWriter with larger buffers
*/

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;

class revcomp
{
   static byte[] ByteArray(string line)
   {
      byte[] array = new byte[line.Length];
      for (int i = 0; i < line.Length; i++)
         array[i] = (byte)line[i];
      return array;
   }

   const byte Gt = (byte)'>';

   static void Main(string[] args){
      InitializeComplements();

      List<byte[]> builder = new List<byte[]>();
      string line;
      byte[] array, desc = new byte[0];

      using (StreamReader r = new StreamReader(Console.OpenStandardInput())) {
         using (BinaryWriter w = new BinaryWriter(Console.OpenStandardOutput())) {
            while ((line = r.ReadLine()) != null) {
               array = ByteArray(line);
               byte c = array[0];
               if (c == Gt) {
                  if (desc.Length > 0) {
                     WriteReverseFasta(desc, builder, w);
                     builder.Clear();
                  }
                  desc = array;
               }
               else if (c != ';') {
                  builder.Add(array);
               }
            }
            if (builder.Count > 0) {
               WriteReverseFasta(desc, builder, w);
            }
         }
      }
   }

   static byte[] iubComp = new byte[256];
   static void InitializeComplements(){
      for (byte i = 0; i < 255; i++) iubComp[i] = i;
          
      iubComp[(byte)'A'] = (byte)'T'; iubComp[(byte)'a'] = (byte)'T';
      iubComp[(byte)'B'] = (byte)'V'; iubComp[(byte)'b'] = (byte)'V';
      iubComp[(byte)'C'] = (byte)'G'; iubComp[(byte)'c'] = (byte)'G';
      iubComp[(byte)'D'] = (byte)'H'; iubComp[(byte)'d'] = (byte)'H';
      iubComp[(byte)'G'] = (byte)'C'; iubComp[(byte)'g'] = (byte)'C';
      iubComp[(byte)'H'] = (byte)'D'; iubComp[(byte)'h'] = (byte)'D';
      iubComp[(byte)'K'] = (byte)'M'; iubComp[(byte)'k'] = (byte)'M';
      iubComp[(byte)'M'] = (byte)'K'; iubComp[(byte)'m'] = (byte)'K';
      iubComp[(byte)'R'] = (byte)'Y'; iubComp[(byte)'r'] = (byte)'Y';
      iubComp[(byte)'T'] = (byte)'A'; iubComp[(byte)'t'] = (byte)'A';
      iubComp[(byte)'V'] = (byte)'B'; iubComp[(byte)'v'] = (byte)'B';
      iubComp[(byte)'Y'] = (byte)'R'; iubComp[(byte)'y'] = (byte)'R';
   }

   const byte Lf = (byte)'\n';
   const int LineLength = 61;
   const int BufferSize = LineLength * 269; // about 16k
   static byte[] buffer = new byte[BufferSize];

   static void WriteReverseFasta(byte[] desc, List<byte[]> b, BinaryWriter w) {
      w.Write(desc); w.Write(Lf);
      int bi = 0;
      int trigger = LineLength - 1;
      for (int rli = b.Count-1; rli >= 0; rli--) {
         byte[] line = b[rli];
         for (int rci = line.Length-1; rci >= 0; rci--) {
            buffer[bi++] = iubComp[line[rci]];
            if (bi == trigger) {
               buffer[bi++] = Lf; trigger += LineLength;
               if (bi >= BufferSize) {
                  w.Write(buffer); bi = 0; trigger = LineLength - 1;
               }
            }
         }
      }
      if (bi > 0) {
          if (buffer[bi-1] != Lf) buffer[bi++] = Lf;
          w.Write(buffer, 0, bi);
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;
using System.IO;
using System.Collections;

class reversefile
{
   static void Main(string[] args)
   {
      Stack lines = new Stack();
      using (StreamReader s = new StreamReader(Console.OpenStandardInput())){
         String line;
         while ((line = s.ReadLine()) != null) lines.Push(line);
      }

      using (StreamWriter s = new StreamWriter(Console.OpenStandardOutput()))
         foreach (string line in lines) s.WriteLine(line);
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy 
*/

using System;

class Sieve
{
   public static void Main(String[] args) 
   {        
      const int start = 2;
      const int stop = 8192;
      const byte isPrime = 0;
      const byte isNotPrime = 1;
      byte[] number = new byte[stop+1];
      int count = 0;
        
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      while(n-- > 0) {
         count = 0;
         Array.Clear(number, 0, stop+1);
         for(int i=start; i <= stop; i++) 
            if(number[i] == isPrime) {
               // remove all multiples of prime: i
               for(int k=i+i; k <= stop; k+=i) number[k] = isNotPrime;
               count++;
            }
      }
      Console.WriteLine("Count: {0}", count);
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/
 
   contributed by Isaac Gouy 
*/

using System;

class SpectralNorm
{
   public static void Main(String[] args) {        
      int n = 100;
      if (args.Length > 0) n = Int32.Parse(args[0]);

      Console.WriteLine("{0:f9}", new SpectralNorm().Approximate(n));
   }

   double Approximate(int n) {
      // create unit vector
      double[] u = new double[n];       
      for (int i=0; i<n; i++) u[i] =  1;

      // 20 steps of the power method
      double[] v = new double[n];  
      for (int i=0; i<n; i++) v[i] = 0;

      for (int i=0; i<10; i++) {
         MultiplyAtAv(n,u,v);
         MultiplyAtAv(n,v,u);
      }

      // B=AtA         A multiplied by A transposed
      // v.Bv /(v.v)   eigenvalue of v 
      double vBv = 0, vv = 0;
      for (int i=0; i<n; i++) {
         vBv += u[i]*v[i];
         vv  += v[i]*v[i];
      }

      return Math.Sqrt(vBv/vv);
   }


   /* return element i,j of infinite matrix A */
   double A(int i, int j){
      return 1.0/((i+j)*(i+j+1)/2 +i+1); 
   }

   /* multiply vector v by matrix A */
   void MultiplyAv(int n, double[] v, double[] Av){
      for (int i=0; i<n; i++){
         Av[i] = 0;
         for (int j=0; j<n; j++) Av[i] += A(i,j)*v[j];
      }
   }

   /* multiply vector v by matrix A transposed */
   void MultiplyAtv(int n, double[] v, double[] Atv){
      for (int i=0;i<n;i++){
         Atv[i] = 0;
         for (int j=0; j<n; j++) Atv[i] += A(j,i)*v[j];
      }
   }

   /* multiply vector v by matrix A and then by matrix A transposed */
   void MultiplyAtAv(int n, double[] v, double[] AtAv){
      double[] u = new double[n];
      MultiplyAv(n,v,u);
      MultiplyAtv(n,u,AtAv);
   }
}
///* The Computer Language Benchmarks Game
//   http://shootout.alioth.debian.org/

//   contributed by Isaac Gouy
//   parallel by The Anh Tran
//   Updated by Alan McGovern
//*/

using System;
using System.Threading;

class SpectralNorm
{
    public class BarrierHandle : System.Threading.WaitHandle
    {
        int current;
        int threads;
        ManualResetEvent handle = new ManualResetEvent (false);

        public BarrierHandle (int threads)
        {
	    this.current = threads;
            this.threads = threads;
        }

        public override bool WaitOne()
        {
            ManualResetEvent h = handle;
            if (Interlocked.Decrement (ref current) > 0) {
                h.WaitOne ();
            }
            else {
                handle = new ManualResetEvent (false);
                Interlocked.Exchange (ref current, threads);
                h.Set ();
                h.Close ();
            }

            return true;
        }
    }
	
    public static void Main(String[] args)
    {
        int n = 2500;
        if (args.Length > 0)
            n = Int32.Parse(args[0]);

        Console.WriteLine("{0:f9}", RunGame(n));
    }
	
    private static double RunGame(int n)
    {
        // create unit vector
        double[] u = new double[n];
        double[] tmp = new double[n];
        double[] v = new double[n];

        for (int i = 0; i < n; i++)
            u[i] = 1.0;

        int nthread = Environment.ProcessorCount;

		BarrierHandle barrier = new BarrierHandle (nthread);
        // objects contain result of each thread
        Approximate[] apx = new Approximate[nthread];

        // thread handle for waiting/joining
        Thread[] threads = new Thread[nthread];

        // create thread and hand out tasks
        int chunk = n / nthread;
        for (int i = 0; i < nthread; i++)
        {
            int r1 = i * chunk;
            int r2 = (i < (nthread - 1)) ? r1 + chunk : n;

            apx[i] = new Approximate(u, v, tmp, r1, r2);
			apx[i].Barrier = barrier;
            threads[i] = new Thread(new ThreadStart(apx[i].Evaluate));
            threads[i].Start();
        }

        // collect results
        double vBv = 0, vv = 0;
        for (int i = 0; i < nthread; i++)
        {
            threads[i].Join();

            vBv += apx[i].m_vBv;
            vv += apx[i].m_vv;
        }

        return Math.Sqrt(vBv / vv);
    }

    private class Approximate
    {
        internal BarrierHandle Barrier;
        private double[] m_u;
        private double[] m_v;
        private double[] m_tmp;
        private int m_range_begin, m_range_end;

        public double m_vBv = 0, m_vv = 0;

        public Approximate(double[] u, double[] v, double[] tmp, int rbegin, int rend)
        {
            m_u = u;
            m_v = v;
            m_tmp = tmp;

            m_range_begin = rbegin;
            m_range_end = rend;
        }

        public void Evaluate()
        {
            for (int i = 0; i < 10; i++)
            {
                MultiplyAtAv(m_u, m_tmp, m_v);
                MultiplyAtAv(m_v, m_tmp, m_u);
            }

            for (int i = m_range_begin; i < m_range_end; i++)
            {
                m_vBv += m_u[i] * m_v[i];
                m_vv += m_v[i] * m_v[i];
            }
        }

        /* return element i,j of infinite matrix A */
        private static double eval_A(int i, int j)
        {
            int div = (((i + j) * (i + j + 1) >> 1) + i + 1);
            return 1.0 / div;
        }

        /* multiply vector v by matrix A */
        private void MultiplyAv(double[] v, double[] Av)
        {
            for (int i = m_range_begin; i < m_range_end; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < v.Length; j++)
                    sum += eval_A(i, j) * v[j];
                Av[i] = sum;
            }
        }

        /* multiply vector v by matrix A transposed */
        private void MultiplyAtv(double[] v, double[] Atv)
        {
            for (int i = m_range_begin; i < m_range_end; i++)
            {
                double sum = 0.0;
                for (int j = 0; j < v.Length; j++)
                    sum += eval_A(j, i) * v[j];
                Atv[i] = sum;
            }
        }

        /* multiply vector v by matrix A and then by matrix A transposed */
        private void MultiplyAtAv(double[] v, double[] tmp, double[] AtAv)
        {
            MultiplyAv(v, tmp);
            Barrier.WaitOne ();

            MultiplyAtv(tmp, AtAv);
            Barrier.WaitOne ();
        }
    }
}

/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy */

using System;
using System.Collections;
using System.IO;

class SpellCheck
{
   static void Main(string[] args)
   {   
      String word;

      Hashtable dictionary = new Hashtable(); 
      using (StreamReader r = new StreamReader("Usr.Dict.Words")) {
         while ((word = r.ReadLine()) != null) dictionary.Add(word, null);
      }

      using (StreamReader r = new StreamReader(Console.OpenStandardInput())) {
         while ((word = r.ReadLine()) != null)
            if (!dictionary.ContainsKey(word)) Console.WriteLine(word);
      }
   }   
}
// $Id: strcat.csharp,v 1.3 2005-02-22 19:05:07 igouy-guest Exp $
// http://shootout.alioth.debian.org/
//
// code contributed by Erik Saltwell  
// Some clean-ups by Brent Fulgham

using System;

class strcat {

    public static void Main(String[] args)
    {
        int N = int.Parse(args[0]);
        if(N < 1) N = 1;

        System.Text.StringBuilder sb = new System.Text.StringBuilder(32);

        for (int i = 0; i < N; i++) {
            sb.Append("hello\n");
        }

        Console.WriteLine(sb.Length);
    }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;
using System.IO;

class SumCol 
{
   static void Main(){
      int sum = 0;

      using (StreamReader r = new StreamReader(Console.OpenStandardInput())){
         string line;
         while ((line = r.ReadLine()) != null) sum += Int32.Parse(line);
      }
      Console.WriteLine(sum);
   }
}

/* The Computer Language Benchmarks Game
   http://shootout.alioth.debian.org/
   contributed by Jeffrey Stedfast
*/

using System;
using System.IO;

class sumcol {
   static int SumStream (Stream stream)
   {
      byte[] buf = new byte [4097];
      int nread, n, v = 0;
      bool negate = false;
      bool first = true;
      int sum = 0;
      char c;
      
      do {
         if ((nread = stream.Read (buf, 0, 4096)) <= 0)
            break;
         
         buf[nread] = (byte) '\n';
         n = 0;
         
         do {
            if (first) {
               if (buf[n] == (byte) '-') {
                  negate = true;
                  first = false;
                  n++;
               } else if (buf[n] != (byte) '\n')
                  first = false;
            }
            
            while (buf[n] != (byte) '\n') {
               c = (char) buf[n];
               if (c < '0' || c > '9') {
                  Console.WriteLine ("{0} not a digit, v is {1}", c, v);
                  throw new Exception ();
               }
               
               v = v * 10 + (c - '0');
               n++;
            }
            
            if (n == nread)
               break;
            
            if (negate)
               sum -= v;
            else
               sum += v;
            
            negate = false;
            first = true;
            v = 0;
            
            n++;
         } while (true);
      } while (true);
      
      if (negate)
         sum -= v;
      else
         sum += v;
      
      return sum;
   }
   
   static void Main ()
   {
      Stream stdin = Console.OpenStandardInput ();
      int sum;
      
      try {
         sum = SumStream (stdin);
         Console.WriteLine (sum);
      } catch {
         Console.WriteLine ("Invalid input");
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   contributed by Isaac Gouy 
*/

using System;

class Takfp
{
   public static float Tak(float x, float y, float z) {
      if (y >= x) return z;
      return Tak(Tak(x-1.0f,y,z), Tak(y-1.0f,z,x), Tak(z-1.0f,x,y)); 
   }

   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0) n = Int32.Parse(args[0]);
      Console.WriteLine("{0:f1}", Tak(n*3.0f, n*2.0f, n*1.0f));
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy */

using System;
using System.Net.Sockets;
using System.Diagnostics;

class tcpecho
{
   const int M = 6400; // multiplier
   const int REPLY_SIZE = 64;
   const int REQUEST_SIZE = 64;
   const int BUFFER_SIZE = 1024;

   static byte[] REPLY = new byte[REPLY_SIZE];
   static byte[] REQUEST = new byte[REQUEST_SIZE];


   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0){
         n = Int32.Parse(args[0]) * M;

         Process p = new Process();
         ProcessStartInfo i = p.StartInfo;
         i.FileName = "mono";
         i.Arguments = "tcpecho.csharp_run";
         i.UseShellExecute = false;
         p.Start();

         Client.Start(n);
      }
      else {
         Listener.Start();
      }
   }


   class Listener 
   {
      public static void Start() {
         TcpListener listener = new TcpListener(11000);
         listener.Start();
      
         using (TcpClient client = listener.AcceptTcpClient()){
            NetworkStream s = client.GetStream();
            byte[] buffer = new byte[BUFFER_SIZE];

            while (s.Read(buffer, 0, REQUEST_SIZE) > 0)
               s.Write(REPLY, 0, REPLY_SIZE);
         } 
         listener.Stop();
      }
   }


   class Client 
   {
      public static void Start(int n) {
         byte[] buffer = new byte[BUFFER_SIZE];
         int replies = 0, bytes = 0;

         using (TcpClient client = new TcpClient("127.0.0.1",11000)){     
            int byteCount = 0;
            NetworkStream s = client.GetStream();         

            while (n-- > 0){
               s.Write(REQUEST, 0, REQUEST.Length);
               while ((byteCount += s.Read(buffer, 0, buffer.Length)) < REPLY_SIZE){}

               bytes += byteCount;
               byteCount = 0;
               replies++;
            }
         } 
         Console.WriteLine("replies: {0}\tbytes: {1}", replies, bytes);
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org
 
   contributed by Isaac Gouy */

using System;
using System.Net.Sockets;
using System.Diagnostics;

class tcprequest
{
   const int M = 100; // multiplier
   const int REPLY_SIZE = 4096;
   const int REQUEST_SIZE = 64;
   const int BUFFER_SIZE = 1024;

   static byte[] REPLY = new byte[REPLY_SIZE];
   static byte[] REQUEST = new byte[REQUEST_SIZE];


   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0){
         n = Int32.Parse(args[0]) * M;

         Process p = new Process();
         ProcessStartInfo i = p.StartInfo;
         i.FileName = "mono";
         i.Arguments = "tcprequest.csharp_run";
         i.UseShellExecute = false;
         p.Start();

         Client.Start(n);
      }
      else {
         Listener.Start();
      }
   }


   class Listener 
   {
      public static void Start() {
         TcpListener listener = new TcpListener(11000);
         listener.Start();
      
         using (TcpClient client = listener.AcceptTcpClient()){
            NetworkStream s = client.GetStream();
            byte[] buffer = new byte[BUFFER_SIZE];

            while (s.Read(buffer, 0, REQUEST_SIZE) > 0)
               s.Write(REPLY, 0, REPLY_SIZE);
         } 
         listener.Stop();
      }
   }


   class Client 
   {
      public static void Start(int n) {
         byte[] buffer = new byte[BUFFER_SIZE];
         int replies = 0, bytes = 0;

         using (TcpClient client = new TcpClient("127.0.0.1",11000)){     
            int byteCount = 0;
            NetworkStream s = client.GetStream();         

            while (n-- > 0){
               s.Write(REQUEST, 0, REQUEST.Length);
               while ((byteCount += s.Read(buffer, 0, buffer.Length)) < REPLY_SIZE){}

               bytes += byteCount;
               byteCount = 0;
               replies++;
            }
         } 
         Console.WriteLine("replies: {0}\tbytes: {1}", replies, bytes);
      }
   }
}
/* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org
 
   contributed by Isaac Gouy */

using System;
using System.Net.Sockets;

class tcpsocket
{
   const string HOST = "127.0.0.1";
   const int PORT = 11000, REQUEST_SIZE = 64, BUFFER_SIZE = 1024;

   static Reply[] replyTypes = 
      { new Reply(2,64)
      , new Reply(7,4096)
      , new Reply(1,409600) 
      }; 


   static void Main(string[] args){
      int n = Int32.Parse(args[0]);
      if (n > 0)
         MakeRequests(n);
      else 
         ReplyToRequests(n);
   }


   static void MakeRequests(int n) {
      byte[] requestContents = new byte[REQUEST_SIZE]; // use the same contents for every request
      byte[] replyBuffer = new byte[BUFFER_SIZE];
      int replies = 0, bytes = 0;

      using (TcpClient client = new TcpClient()){     
         int byteCount = 0;

         client.Connect(HOST,PORT); 
         NetworkStream s = client.GetStream();       

         foreach (Reply reply in replyTypes){
            int requests = n * reply.multiplier;
            while (requests-- > 0){
               s.Write(requestContents, 0, requestContents.Length);
               while ((byteCount += s.Read(replyBuffer, 0, replyBuffer.Length)) < reply.size){}

               bytes += byteCount;
               byteCount = 0;
               replies++;
            }
            s.Write(requestContents, 0, requestContents.Length); // stop listener
         }
         client.Close();

         Console.WriteLine("replies: {0}\tbytes: {1}", replies, bytes);
      } 
   }


   static void ReplyToRequests(int n) {
      byte[] requestBuffer = new byte[BUFFER_SIZE];

      TcpListener listener = new TcpListener(PORT);
      listener.Start();

      using (TcpClient client = listener.AcceptTcpClient()){ 
         NetworkStream s = client.GetStream();

         foreach (Reply reply in replyTypes)
         {
            reply.contents = new byte[reply.size];
            int requests = n * reply.multiplier;

            while ((s.Read(requestBuffer, 0, REQUEST_SIZE) > 0)&&(requests++ < 0))
               s.Write(reply.contents, 0, reply.size);
         }
      } 

      listener.Stop();
   }


   class Reply { 
      internal int multiplier, size;
      internal byte[] contents;
   
      internal Reply(int multiplier, int size){
         this.multiplier = multiplier;
         this.size = size;
      }
   }
}
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org

   contributed by Isaac Gouy */

using System;
using System.Net.Sockets;
using System.Diagnostics;

class tcprequest
{
   const int M = 1; // multiplier
   const int REPLY_SIZE = 409600;
   const int REQUEST_SIZE = 64;
   const int BUFFER_SIZE = 1024;

   static byte[] REPLY = new byte[REPLY_SIZE];
   static byte[] REQUEST = new byte[REQUEST_SIZE];


   static void Main(string[] args){
      int n = 1;
      if (args.Length > 0){
         n = Int32.Parse(args[0]) * M;

         Process p = new Process();
         ProcessStartInfo i = p.StartInfo;
         i.FileName = "mono";
         i.Arguments = "tcpstream.csharp_run";
         i.UseShellExecute = false;
         p.Start();

         Client.Start(n);
      }
      else {
         Listener.Start();
      }
   }


   class Listener 
   {
      public static void Start() {
         TcpListener listener = new TcpListener(11000);
         listener.Start();
      
         using (TcpClient client = listener.AcceptTcpClient()){
            NetworkStream s = client.GetStream();
            byte[] buffer = new byte[BUFFER_SIZE];

            while (s.Read(buffer, 0, REQUEST_SIZE) > 0)
               s.Write(REPLY, 0, REPLY_SIZE);
         } 
         listener.Stop();
      }
   }


   class Client 
   {
      public static void Start(int n) {
         byte[] buffer = new byte[BUFFER_SIZE];
         int replies = 0, bytes = 0;

         using (TcpClient client = new TcpClient("127.0.0.1",11000)){     
            int byteCount = 0;
            NetworkStream s = client.GetStream();         

            while (n-- > 0){
               s.Write(REQUEST, 0, REQUEST.Length);
               while ((byteCount += s.Read(buffer, 0, buffer.Length)) < REPLY_SIZE){}

               bytes += byteCount;
               byteCount = 0;
               replies++;
            }
         } 
         Console.WriteLine("replies: {0}\tbytes: {1}", replies, bytes);
      }
   }
}
/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * contributed by Isaac Gouy
 */

using System;
using System.Threading;


internal class NamedThread
{
   private int name;
   private AutoResetEvent signal = new AutoResetEvent(false);
   private int token = 0;

   internal NamedThread(int name) {
      this.name = name;
   }

   internal void Run() {
      while (TokenNotDone()) 
         NextThread().TakeToken(token-1);

      if (token == 0) Console.WriteLine(name);
      NextThread().TakeToken(-1);
   }

   private bool TokenNotDone() {
      signal.WaitOne();
      return token > 0;
   }

   internal NamedThread NextThread() {
      return ThreadRing.threadRing[ name % ThreadRing.numberOfThreads ];
   }

   internal void TakeToken(int x) {
      token = x;
      signal.Set();
   }
}


public class ThreadRing
{
   internal const int numberOfThreads = 503;
   internal static NamedThread[] threadRing = new NamedThread[503];

   public static void Main(string[] args) {
      for (int i = 0; i < numberOfThreads; i++){ 
         threadRing[i] = new NamedThread(i+1);
      }

      foreach (NamedThread t in threadRing) 
         new Thread(new ThreadStart(t.Run)).Start(); 

      threadRing[0].TakeToken( int.Parse(args[0]) );
   }
}
/* The Great Computer Language Shootout 
 * http://shootout.alioth.debian.org
 * 
 *  contributed by Isaac Gouy */

using System;
using System.IO;
using System.Text;

class Wc
{
   static void Main(string[] args)
   {
      int nc = 0, nl = 0, nw = 0; 

      using (BinaryReader r = new BinaryReader(Console.OpenStandardInput(4096))){      
         bool insideWord = false;
         byte[] buffer = new byte[4096];
         int bytesRead;         
         
         while ( (bytesRead = r.Read(buffer,0,4096)) > 0  ) {
            nc += bytesRead;
            for (int i = 0; i < bytesRead; i++) {
               char c = (char)buffer[i];

               if (c == '\n') nl++;
               if (c == ' ' || c == '\n' || c == '\t') 
                  insideWord = false;
               else if (!insideWord) {
                  insideWord = true;
                  nw++;
               }
            }
         }
      }
      Console.WriteLine("{0} {1} {2}", nl, nw, nc);
   }
}
/* The Great Computer Language Shootout
 *    http://shootout.alioth.debian.org/
 *
 * contributed by Isaac Gouy 
 * modified by Joshua Tauberer */

using System;
using System.Globalization;
using System.IO;
using System.Collections;

class WordFreq
{
   static void Main()
   {
      const int size = 4096;
      Hashtable wordCounts = new Hashtable(4000);
      CultureInfo culture = CultureInfo.InvariantCulture;

      using (StreamReader r = new StreamReader(Console.OpenStandardInput(size)))
      {
         char[] buffer = new char[size];
         int charsRead;

         bool insideWord = false;
         string prefix = null;

         while ((charsRead = r.Read(buffer,0,size)) > 0) {
            int i = 0;
            for (int j=0; j<charsRead; j++){
               if (Char.IsLetter(buffer[j])){
                  if (!insideWord){
                     insideWord = true;
                     i = j;
                  }
               }
               else if (insideWord){
                  insideWord = false;
                  string w = (new String(buffer,i,j-i));

                  if (prefix != null){
                     w = string.Concat(prefix,w);
                     prefix = null;
                  }
                  w = w.ToLower(culture);

                  object item;
                  if ((item = wordCounts[w]) != null)
                     ((KeyValue)item).v++;
                  else
                     wordCounts[w] = new KeyValue(w,1);
               }
            }
            if (insideWord) prefix = (new String(buffer,i,charsRead-i));
         }
      }

      KeyValue[] items = new KeyValue[wordCounts.Count];
      wordCounts.Values.CopyTo(items, 0);

      Array.Sort(items, new SortByFrequencyAndWord() );

      foreach (KeyValue each in items) {
         string frequency = each.v.ToString().PadLeft(7);
         Console.WriteLine("{0} {1}", frequency, each.k);
      }
   }


   private class KeyValue
   {
      internal String k;
      internal int v;

      internal KeyValue(String k, int v) {
         this.k = k;
         this.v = v;
      }
   }


   private class SortByFrequencyAndWord : IComparer
   {
      CompareInfo comparer = CultureInfo.InvariantCulture.CompareInfo;
	   
      public SortByFrequencyAndWord() {}

      // sort DictionaryEntry by Frequency, then by Word
      int IComparer.Compare(object o1, object o2) {
         KeyValue item1 = (KeyValue)o1;
         KeyValue item2 = (KeyValue)o2;

         int comparison = item2.v.CompareTo(item1.v);
         if (comparison == 0) return comparer.Compare(item2.k, item1.k, CompareOptions.Ordinal);
         else return comparison;
      }
   }
}

