-- $Id: ackermann.gnat,v 1.4 2005-03-25 07:59:06 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- by James S. Rogers
-- revised by Vasiliy Fofanov
--
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Fixed;
with Ack_F;

procedure Ackermann is
  Num : Natural;
  function L_Trim(Source : String; Side : Ada.Strings.Trim_End := Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
begin
  if Argument_Count = 1 then
    Num := Natural'Value(Argument(1));
  else
    Num := 1;
  end if;

  Put("Ack(3,");
  Put(L_Trim ( Natural'Image (Num)));
  Put("):");
  Put(Natural'Image (Ack_F (3, Num)));
end Ackermann;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural is
pragma Suppress(All_Checks);
begin
   if M = 0 then
      return N + 1;
   elsif N = 0 then
      return Ack_F (M - 1, 1);
   else
      return Ack_F (M - 1, Ack_F (M, N - 1));
   end if;
end Ack_F;

-- $Id: ary.gnat,v 1.2 2004-08-14 08:19:16 bfulgham Exp $
-- http://shootout.alioth.debian.org/
-- Ada 95 code by C.C.
-- Revised with suggestions by James S. Rogers

with Text_IO, Ada.Command_Line, Ada.Strings.Fixed;

procedure Ary is
   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Positive := 1;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   declare
      pragma suppress (All_Checks);
      type Vect is array (1 .. N) of Integer;
      X : Vect;
      Y : Vect := (Others => 0);
   begin
      for K in Vect'Range loop
         X (K) := K;
      end loop;

      for Iter in 1 .. 1000 loop
         for K in reverse Vect'Range loop
	    Y(K) := Y(K) + X(K);
         end loop;
      end loop;
      Text_IO.Put_Line (L_Trim (Integer'Image (Y (1))) &
               Integer'Image (Y (N)));
   end;
end Ary;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers

with Treenodes; use Treenodes;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_Io; use Ada.Integer_Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;

procedure Binarytrees is
   Min_Depth : constant Positive := 4;
   N : Natural := 1;
   Stretch_Tree : TreeNode;
   Long_Lived_Tree : TreeNode;
   Short_Lived_Tree_1 : TreeNode;
   Short_Lived_Tree_2 : TreeNode;
   Max_Depth : Positive;
   Stretch_Depth : Positive;
   Check : Integer;
   Sum : Integer;
   Depth : Natural;
   Iterations : Positive;
begin
   if Argument_Count > 0 then
      N := Positive'Value(Argument(1));
   end if;
   Max_Depth := Positive'Max(Min_Depth + 2, N);
   Stretch_Depth := Max_Depth + 1;
   Stretch_Tree := Bottom_Up_Tree(0, Stretch_Depth);
   Item_Check(Stretch_Tree, Check);
   Put("stretch tree of depth ");
   Put(Item => Stretch_Depth, Width => 1);
   Put(Ht & " check: ");
   Put(Item => Check, Width => 1);
   New_Line;
   
   Long_Lived_Tree := Bottom_Up_Tree(0, Max_Depth);
   
   Depth := Min_Depth;
   while Depth <= Max_Depth loop
      Iterations := 2**(Max_Depth - Depth + Min_Depth);
      Check := 0;
      for I in 1..Iterations loop
         Short_Lived_Tree_1 := Bottom_Up_Tree(Item => I, Depth => Depth);
         Short_Lived_Tree_2 := Bottom_Up_Tree(Item =>-I, Depth => Depth);
         Item_Check(Short_Lived_Tree_1, Sum);
         Check := check + Sum;
         Item_Check(Short_Lived_Tree_2, Sum);
         Check := Check + Sum;
      end loop;
      Put(Item => Iterations * 2, Width => 0);
      Put(Ht & " trees of depth ");
      Put(Item => Depth, Width => 0);
      Put(Ht & " check: ");
      Put(Item => Check, Width => 0);
      New_Line;
      Depth := Depth + 2;
   end loop;
   Put("long lived tree of depth ");
   Put(Item => Max_Depth, Width => 0);
   Put(Ht & " check: ");
   Item_Check(Long_Lived_Tree, Check);
   Put(Item => Check, Width => 0);
   New_Line;
end BinaryTrees;
----------------------------------------------------------------
-- BinaryTrees
--
-- Ada 95 (GNAT)
--
-- Contributed by Jim Rogers
----------------------------------------------------------------

package Treenodes is
   type Treenode is private;
   function Bottom_Up_Tree(Item : Integer; Depth : Integer) return Treenode;
   procedure Item_Check(This : in out Treenode; Sum : out Integer);
private
   type Node;
   type Treenode is access Node;
   type Node is record
      Left  : Treenode := null;
      Right : Treenode := null;
      Item  : Integer  := 0; 
   end record;
end Treenodes;
----------------------------------------------------------------
-- BinaryTrees
--
-- Ada 95 (GNAT)
--
-- Contributed by Jim Rogers
----------------------------------------------------------------

with Ada.Unchecked_Deallocation;

package body Treenodes is
   function Bottom_Up_Tree(Item : Integer; Depth : Integer)
      return Treenode is
   begin
      if Depth > 0 then
         return new Node'(Bottom_Up_Tree((2*Item) -1, Depth -1),
            Bottom_Up_Tree(2 * Item, Depth -1),
            Item);
      else
         return new Node'(null, null, Item);
      end if;
   end Bottom_Up_Tree;

   procedure Item_Check (This : in out Treenode; Sum : out Integer) is
      procedure Free is new Ada.Unchecked_Deallocation(Node, Treenode);
      Left_Sum, Right_Sum : Integer;
   begin
      if This.Left = null then
         Sum := This.Item;
      else
         Item_Check(This.Left, Left_Sum);
         Item_Check(This.Right, Right_Sum);
         Sum :=  This.Item + Left_Sum - Right_Sum;
      end if;
      Free(This);      
   end Item_Check;

end Treenodes;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Brian Drummond

with Treenodes; use Treenodes;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_Io; use Ada.Integer_Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;

procedure Binarytrees is
   -- Change "CPUs" to control number of tasks created
   CPUs : constant Positive := 4;
   BlockSize : Positive;
   Min_Depth : constant Positive := 4;
   N : Natural := 1;
   Stretch_Tree : TreeNode;
   Long_Lived_Tree : TreeNode;
   Max_Depth : Positive;
   Stretch_Depth : Positive;
   Iteration : Positive;
   Iterations : Positive;
   Sum : Integer;
   Check : Integer;
   Depth : Natural;

   task type check_this_depth is
      entry Start(Iteration, Size : Positive; To_Depth :in Natural);
      entry Complete(Result : out Integer);
   end check_this_depth;

   task body check_this_depth is
      Check : Integer;
      Sum : Integer;
      Depth : Natural;
      First : Positive;
      Last : Positive;
      Short_Lived_Tree_1 : TreeNode;
      Short_Lived_Tree_2 : TreeNode;

   begin
      loop
         select
            accept Start(Iteration, Size : Positive; To_Depth :in Natural) do
               First := Iteration;
               Last := Iteration + Size - 1;
               Depth := To_Depth;
            end Start;
            Check := 0;
            for I in First .. Last loop
               Short_Lived_Tree_1 := Bottom_Up_Tree(Item => I, Depth => Depth);
               Short_Lived_Tree_2 := Bottom_Up_Tree(Item =>-I, Depth => Depth);
               Item_Check(Short_Lived_Tree_1, Sum);
               Check := Check + Sum;
               Item_Check(Short_Lived_Tree_2, Sum);
               Check := Check + Sum;
            end loop;
            accept Complete(Result : out Integer) do
               Result := Check;
            end Complete;
         or
            Terminate;
         end select;
      end loop;
   end check_this_depth;

   subtype Task_Count is positive range 1 .. CPUs;	
   Tasks : array (Task_Count) of check_this_depth;

begin
   if Argument_Count > 0 then
      N := Positive'Value(Argument(1));
   end if;
   Max_Depth := Positive'Max(Min_Depth + 2, N);
   Stretch_Depth := Max_Depth + 1;
   Stretch_Tree := Bottom_Up_Tree(0, Stretch_Depth);
   Item_Check(Stretch_Tree, Check);
   Put("stretch tree of depth ");
   Put(Item => Stretch_Depth, Width => 1);
   Put(Ht & " check: ");
   Put(Item => Check, Width => 1);
   New_Line;
   
   Long_Lived_Tree := Bottom_Up_Tree(0, Max_Depth);
   
   Depth := Min_Depth;
   while Depth <= Max_Depth loop
      Iterations := 2**(Max_Depth - Depth + Min_Depth);
      Check := 0;

-- Setup tasking parameters for reasonable task granularity
-- Too large and we can't balance CPU loads
-- Too small and we waste time in task switches
-- Not very critical - anything more complex is probably a waste of effort
      
      BlockSize := 2**10;
      if Iterations < BlockSize * CPUs then
         BlockSize := 1;
      end if;
  
-- Check that Iterations is a multiple of Blocksize * CPUs
-- Error out otherwise (dealing with remainder is trivial but tedious)
      Pragma Assert(Iterations mod( BlockSize * CPUs) = 0, 
                            "Iteration count not supported!");

      -- for I in 1..Iterations loop  
      Iteration := 1;   
      while Iteration <= Iterations loop
         for j in Task_Count loop
            Tasks(j).Start(Iteration, Blocksize, Depth);
            Iteration := Iteration + BlockSize;
         end loop;
         for j in Task_Count loop
            Tasks(j).Complete(Sum);
            Check := Check + Sum;
         end loop;
      end loop;
      Put(Item => Iterations * 2, Width => 0);
      Put(Ht & " trees of depth ");
      Put(Item => Depth, Width => 0);
      Put(Ht & " check: ");
      Put(Item => Check, Width => 0);
      New_Line;
      Depth := Depth + 2;
   end loop;
   Put("long lived tree of depth ");
   Put(Item => Max_Depth, Width => 0);
   Put(Ht & " check: ");
   Item_Check(Long_Lived_Tree, Check);
   Put(Item => Check, Width => 0);
   New_Line;
end Binarytrees;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Brian Drummond

package Treenodes is
   type Treenode is private;
   function Bottom_Up_Tree(Item : Integer; Depth : Integer) return Treenode;
   procedure Item_Check(This : in out Treenode; Sum : out Integer);
private
   type Node;
   type Treenode is access Node;
   type Node is record
      Left  : Treenode := null;
      Right : Treenode := null;
      Item  : Integer  := 0; 
   end record;
end Treenodes;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Brian Drummond

with Ada.Unchecked_Deallocation;

package body Treenodes is
   function Bottom_Up_Tree(Item : Integer; Depth : Integer)
      return Treenode is
   begin
      if Depth > 0 then
         return new Node'(Bottom_Up_Tree((2*Item) -1, Depth -1),
            Bottom_Up_Tree(2 * Item, Depth -1),
            Item);
      else
         return new Node'(null, null, Item);
      end if;
   end Bottom_Up_Tree;

   procedure Item_Check (This : in out Treenode; Sum : out Integer) is
      procedure Free is new Ada.Unchecked_Deallocation(Node, Treenode);
      Left_Sum, Right_Sum : Integer;
   begin
      if This.Left = null then
         Sum := This.Item;
      else
         Item_Check(This.Left, Left_Sum);
         Item_Check(This.Right, Right_Sum);
         Sum :=  This.Item + Left_Sum - Right_Sum;
      end if;
      Free(This);      
   end Item_Check;

end Treenodes;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Based on Ada versions created by
--    Jim Rogers and Brian Drummons as well as the
--    C version by Francesco Abbate
--
--  Contributed by Brad Moore

with Trees;                  use Trees;
with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Integer_Text_IO;    use Ada.Integer_Text_IO;
with Ada.Command_Line;       use Ada.Command_Line;
with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;

procedure Binarytrees is

   function Get_Depth return Positive is
   begin
      if Argument_Count > 0 then
         return Positive'Value (Argument (1));
      else
         return 10;
      end if;
   end Get_Depth;

   Min_Depth     : constant := 4;
   Requested_Depth : constant Positive := Get_Depth;
   Max_Depth     : constant Positive := Positive'Max (Min_Depth + 2,
                                                      Requested_Depth);
   Depth_Iterations : constant Positive := (Max_Depth - Min_Depth) / 2 + 1;

   function Get_Worker_Count return Positive is
   begin
      if Argument_Count > 1 then
         return Positive'Value (Argument (2));
      else
         --  This seems to be the sweet spot assuming max depth of 20
         return 5;
      end if;
   end Get_Worker_Count;

   Worker_Count     : constant Positive := Get_Worker_Count;

   task type Depth_Worker
     (Start, Finish : Positive := Positive'Last) is
      pragma Storage_Size (16#100#);
   end Depth_Worker;

   Results : array (1 .. Depth_Iterations) of Integer;
   Iteration_Tracking : array (1 .. Depth_Iterations) of Positive;

   task body Depth_Worker
   is
      Depth         : Natural;
      Check         : Integer;
      Iterations    : Positive;
   begin

      for Depth_Iter in Start .. Finish loop

         Depth := Min_Depth + (Depth_Iter - 1) * 2;
         Iterations := 2 ** (Max_Depth - Depth + Min_Depth);
         Iteration_Tracking (Depth_Iter) := Iterations;

         Check      := 0;

         for I in 1 .. Iterations loop
            declare
               Short_Lived_Pool : Node_Pool;
               Short_Lived_Tree_1, Short_Lived_Tree_2 : Tree_Node;
            begin

               Short_Lived_Tree_1 :=
                 Create
                   (Short_Lived_Pool,
                    Item  => I,
                    Depth => Depth);

               Short_Lived_Tree_2 :=
                  Create
                    (Short_Lived_Pool,
                     Item  => -I,
                     Depth => Depth);

               Check := Check +
                 Item_Check (Short_Lived_Tree_1) +
                 Item_Check (Short_Lived_Tree_2);
            end;
         end loop;

         Results (Depth_Iter) := Check;
      end loop;

   end Depth_Worker;

   subtype Worker_Id is Positive range 1 .. Worker_Count;

   Start_Index         : Positive := 1;
   End_Index           : Positive := Depth_Iterations;

   Iterations_Per_Task : constant Positive :=
     Depth_Iterations / Worker_Count;

   Remainder           : Natural :=
     Depth_Iterations rem Worker_Count;

   function Create_Worker return Depth_Worker is
   begin
      if Remainder = 0 then
         End_Index := Start_Index + Iterations_Per_Task - 1;
      else
         End_Index := Start_Index + Iterations_Per_Task;
         Remainder := Remainder - 1;
      end if;

      return New_Worker : Depth_Worker
        (Start => Start_Index,
         Finish => End_Index)
      do
         Start_Index := End_Index + 1;
      end return;
   end Create_Worker;

   Long_Lived_Node_Pool : Node_Pool;

   Long_Lived_Tree      : Tree_Node;

   Check : Integer;

begin

   declare
      task Stretch_Depth_Task is
      end Stretch_Depth_Task;

      task body Stretch_Depth_Task is
         Stretch_Depth : constant Positive := Max_Depth + 1;

         Pool : Trees.Node_Pool;
         Stretch_Tree : constant Tree_Node :=
           Trees.Create (Pool  => Pool,
                         Item  => 0,
                         Depth => Stretch_Depth);
      begin
         Check        := Item_Check (Stretch_Tree);
         Put ("stretch tree of depth ");
         Put (Item => Stretch_Depth, Width => 1);
         Put (HT & " check: ");
         Put (Item => Check, Width => 1);
         New_Line;
      end Stretch_Depth_Task;

      task Create_Long_Lived_Tree_Task is
      end Create_Long_Lived_Tree_Task;

      task body Create_Long_Lived_Tree_Task is
      begin
         Long_Lived_Tree := Create (Long_Lived_Node_Pool, 0, Max_Depth);
      end Create_Long_Lived_Tree_Task;
   begin
      null;
   end;

   declare
      Workers : array (Worker_Id) of Depth_Worker
        := (others => Create_Worker);
      pragma Unreferenced (Workers);
   begin
      null;
   end;

   for I in Results'Range loop
      Put (Item => Iteration_Tracking (I) * 2, Width => 0);
      Put (HT & " trees of depth ");
      Put (Item => Min_Depth + 2 * (I - 1), Width => 0);
      Put (HT & " check: ");
      Put (Item => Results (I), Width => 0);
      New_Line;
   end loop;

   Put ("long lived tree of depth ");
   Put (Item => Max_Depth, Width => 0);
   Put (HT & " check: ");
   Check := Item_Check (Long_Lived_Tree);
   Put (Item => Check, Width => 0);
   New_Line;

end Binarytrees;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Based on Ada versions created by
--    Jim Rogers and Brian Drummond as well as
--    C version by Francesco Abbate
--
--  Contributed by Brad Moore

private with Ada.Finalization;
private with Apache_Runtime.Pools;

package Trees is

   type Tree_Node is private;
   function Item_Check (Item : Tree_Node) return Integer;

   type Node_Pool is limited private;

   function Create
     (Pool : Node_Pool;
      Item : Integer;
      Depth : Integer) return Tree_Node;

private

   use Apache_Runtime;

   type Node;
   type Tree_Node is access all Node;

   type Node is record
      Left  : Tree_Node;
      Right : Tree_Node;
      Value  : Integer;
   end record;

   type Node_Pool is
     new Ada.Finalization.Limited_Controlled with
      record
         Pool : aliased Pools.Pool_Type;
      end record;

   overriding procedure Initialize (Item : in out Node_Pool);
   overriding procedure Finalize   (Item : in out Node_Pool);

end Trees;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Based on Ada versions created by
--    Jim Rogers and Brian Drummond as well as the
--    C version by Francesco Abbate
--
--  Contributed by Brad Moore

with Ada.Unchecked_Conversion;
with Interfaces;
with System;

package body Trees is

   Pools_Status : constant Apache_Runtime.Apr_Status :=
     Apache_Runtime.Pools.Initialize;
   pragma Unreferenced (Pools_Status);

   function New_Node (Pool : Node_Pool) return Tree_Node;

   function Create
     (Pool : Node_Pool;
      Item : Integer;
      Depth : Integer) return Tree_Node
   is
      Result : constant Tree_Node := New_Node (Pool);
   begin
      if Depth > 0 then
         Result.all := (Left => Create (Pool, 2 * Item - 1, Depth - 1),
                        Right => Create (Pool, 2 * Item, Depth - 1),
                        Value => Item);
      else
         Result.all := (Left | Right => null, Value => Item);
      end if;

      return Result;

   end Create;

   overriding procedure Finalize   (Item : in out Node_Pool) is
   begin
      Pools.Destroy (Item.Pool);
   end Finalize;

   overriding procedure Initialize (Item : in out Node_Pool) is
      Status : constant Apr_Status :=
        Pools.Create
          (New_Pool => Item.Pool'Address,
           Parent   => System.Null_Address);
      pragma Unreferenced (Status);
   begin
      null;
   end Initialize;

   function Item_Check (Item : Tree_Node) return Integer is
   begin
      if Item.Left = null then
         return Item.Value;
      else
         return Item.Value + Item_Check (Item.Left) - Item_Check (Item.Right);
      end if;
   end Item_Check;

   function New_Node (Pool : Node_Pool) return Tree_Node
   is
      function Node_Convert is new Ada.Unchecked_Conversion
        (Source => System.Address,
         Target => Tree_Node);
   begin
      return Node_Convert
        (Pools.Allocate (Pool => Pool.Pool,
                         Size => Node'Size / Interfaces.Unsigned_8'Size));
   end New_Node;
end Trees;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Contributed by Brad Moore

package Apache_Runtime is
   pragma Pure;

   type Apr_Status is new Integer;

   type Apr_Size is new Integer;

end Apache_Runtime;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Contributed by Brad Moore

with System;

package Apache_Runtime.Pools is

   subtype Pool_Type is System.Address;
   subtype Pool_Access is System.Address;

   function Initialize return Apr_Status;

   function Create
     (New_Pool : Pool_Access;
      Parent : Pool_Type) return Apr_Status;

   procedure Destroy (Pool : Pool_Type);

   function Allocate (Pool : Pool_Type; Size : Apr_Size) return System.Address;

private

   pragma Import (C, Initialize, "apr_initialize");
   pragma Import (C, Destroy, "apr_pool_destroy");
   pragma Import (C, Allocate, "apr_palloc");

end Apache_Runtime.Pools;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Contributed by Brad Moore

package body Apache_Runtime.Pools is

   function Create_Ex
     (New_Pool : Pool_Access;
      Parent : Pool_Type;
      Reserved_1, Reserved_2 : System.Address) return Apr_Status;
   pragma Import (C, Create_Ex, "apr_pool_create_ex");

   ------------
   -- Create --
   ------------

   function Create
     (New_Pool : Pool_Access;
      Parent : Pool_Type)
      return Apr_Status
   is
   begin
      return Create_Ex
        (New_Pool,
         Parent,
         System.Null_Address,
         System.Null_Address);
   end Create;

end Apache_Runtime.Pools;
-----------------------------------------------------------------------
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-----------------------------------------------------------------------
-----------------------------------------------------------------------
-- Chameneos
-----------------------------------------------------------------------
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

procedure Chameneos is
   type Color is (Blue, Red, Yellow, Faded);
   
   Num_Meetings : Natural := 0;
   Max_Meetings : Natural;
   
   protected Meeting_Place is
      entry Engage(C : in Color; C_Other : out Color);
   private
      entry Waiting(C : in Color; C_Other : out Color);
      First_Call : Boolean := True;
      A_Color    : Color;
      B_Color    : Color;
   end Meeting_Place;
   
   protected body Meeting_Place is
      entry Engage(C : in Color; C_Other : out Color)
            when True is
      begin
         if First_Call then
            A_Color := C;
            First_Call := False;
            requeue Waiting;
         else
            Num_Meetings := Num_Meetings + 1;
            B_Color := C;
            C_Other := A_Color;
            First_Call := True;
         end if;
      end Engage;
      entry Waiting(C : in Color; C_Other : out Color)
            when First_Call is
      begin
         C_Other := B_Color;
      end Waiting;
   end Meeting_Place;
      
   task type Chameneos is
      entry Start(C : in Color);
      entry Get_Num_Met(N : out Natural);
   end Chameneos;
   
   task body Chameneos is
      My_Color : Color;
      Other_Color : Color;
      Creatures_Met : Natural := 0;
      
      function Complement return Color is
         New_Color : Color;
      begin
         if Num_Meetings >= Max_Meetings then
            return Faded;
         end if;
         
         if My_Color = Other_Color then
            return My_Color;
         else
            if My_Color = Blue then
               if Other_Color = Red then
                  New_Color := Yellow;
               else
                  New_Color := Red;
               end if;
            end if;
            if My_Color = Red then
               if Other_Color = Blue then
                  New_Color := Yellow;
               else
                  New_Color := Blue;
               end if;
            end if;
            if My_Color = Yellow then
               if Other_Color = Blue then
                  New_Color := Red;
               else
                  New_Color := Blue;
               end if;
            end if;
            return New_Color;
         end if;
      end Complement;
   begin
      accept Start(C : in Color) do
         My_Color := C;
      end Start;
      loop
         Meeting_Place.Engage(My_Color, Other_Color);
         Creatures_Met := Creatures_Met + 1;
         My_Color := Complement;
         exit when My_Color = Faded;
      end loop;
      accept Get_Num_Met(N : out Natural) do
         N := Creatures_Met;
      end Get_Num_Met;
   end Chameneos;
   
   Creatures : array(1..4) of Chameneos;
   Total_Meetings : Natural := 0;
   Creature_Meetings : Natural;
begin
   Max_Meetings := Natural'Value(Argument(1));
   Creatures(1).Start(Blue);
   Creatures(2).Start(Red);
   Creatures(3).Start(Yellow);
   Creatures(4).Start(Blue);
   for I in Creatures'range loop
      Creatures(I).Get_Num_Met(Creature_Meetings);
      Total_Meetings := Total_Meetings + Creature_Meetings;
   end loop;
   Put(Item => Total_Meetings, Width => 1);
   New_Line;
end Chameneos;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Francois Fabien (6 avril 2010)
--
-- Based on the original Ada version by
-- Claude Kaiser and Jean-Francois Pradat-Peyre (CEDRIC - CNAM Paris)
--
-- Chameneos are Ada tasks and the meeting place is a protected body
-- Fully portable :
--            No machine/OS dependency
--            No dependency of GNAT-compiler specific features
--
-- Expected build command:
-- gnatmake -gnatpn05 -O3 -march=native -f chameneosredux.adb
------------------------------------------------------------------------------
with Chameneos;        use Chameneos;
with Ada.Command_Line; use Ada.Command_Line;
with System;

procedure ChameneosRedux is
   pragma Priority (System.Max_Priority);
   Meeting_count : Natural := 600;
begin

   if Argument_Count > 0 then
      begin
         Meeting_count := Natural'Value (Argument (1));
      exception
         when others =>
            null;-- When bad argument, keep meetings := 600
      end;
   end if;

   Print_Colours;
   Run (Meeting_count, (Blue, Red, Yellow));
   Run
     (Meeting_count,
      (Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue));
end ChameneosRedux;
-------------------------------------------------------------------------------
-- Root package
-- Definitions and test procedure (run)
-------------------------------------------------------------------------------

package Chameneos is

   -- The creature Name
   subtype Id_Type is Positive;

   type Colour is (Blue, Red, Yellow);

   type Colour_Set is array (Id_Type range <>) of Colour;

   function Do_Complement (C1, C2 : Colour) return Colour;
   -- since this function is heavily used, make it inline to speed up
   pragma Inline (Do_Complement);

   -- Stuff required for the measurement
   type Measure_Type is record
      Meetings_Made : Natural := 0;
      Meetings_Same : Natural := 0;
   end record;

   type Result_Type is array (Id_Type range <>) of Measure_Type;

   --  Ancilliary procedure used for output
   procedure Print_Colours;

   -- The test procedure
   procedure Run (Meetings : Natural; Set : Colour_Set);

end Chameneos;
-------------------------------------------------------------------------------
with Ada.Text_IO;           use Ada.Text_IO;
with Ada.Exceptions;        use Ada.Exceptions;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Chameneos.Creatures;   use Chameneos.Creatures;

package body Chameneos is

   package Int_Io is new Ada.Text_IO.Integer_IO (Integer);

   function Do_Complement (C1, C2 : Colour) return Colour is
   begin
      case C1 is
         when Blue =>
            case C2 is
               when Blue =>
                  return Blue;
               when Red =>
                  return Yellow;
               when Yellow =>
                  return Red;
            end case;
         when Red =>
            case C2 is
               when Blue =>
                  return Yellow;
               when Red =>
                  return Red;
               when Yellow =>
                  return Blue;
            end case;
         when Yellow =>
            case C2 is
               when Blue =>
                  return Red;
               when Red =>
                  return Blue;
               when Yellow =>
                  return Yellow;
            end case;
      end case;
   end Do_Complement;

   function To_US (Source : String) return Unbounded_String renames
     To_Unbounded_String;

   Colour_Image : constant array (Colour) of Unbounded_String :=
     (Blue   => To_US ("blue"),
      Red    => To_US ("red"),
      Yellow => To_US ("yellow"));

   Numbers_Image : constant array (0 .. 9) of Unbounded_String :=
     (0 => To_US ("zero "),
      1 => To_US ("one "),
      2 => To_US ("two "),
      3 => To_US ("three "),
      4 => To_US ("four "),
      5 => To_US ("five "),
      6 => To_US ("six "),
      7 => To_US ("seven "),
      8 => To_US ("eight "),
      9 => To_US ("nine "));

   function Spelled (Value : Natural) return String is
      Result : Unbounded_String := Null_Unbounded_String;
      K      : Natural          := Value;
   begin
      loop
         Result := Numbers_Image (K rem 10) & Result;
         K      := K / 10;
         exit when K = 0;
      end loop;
      return To_String (Result);
   end Spelled;

   procedure Print_Colours is
   begin
      for C1 in Colour loop
         for C2 in Colour loop
            Put_Line
              (To_String (Colour_Image (C1)) &
               " + " &
               To_String (Colour_Image (C2)) &
               " -> " &
               To_String (Colour_Image (Do_Complement (C1, C2))));
         end loop;
      end loop;
      New_Line;
   end Print_Colours;

   -- The procedure that handles the test
   procedure Run (Meetings : Natural; Set : Colour_Set) is
      -- Chameneos are created here
      Creature_Set : array (Set'Range) of Creature;
      Measures       : Chameneos.Result_Type (Set'Range);
      Total_Meetings : Natural := 0;

   begin
      for I in Set'Range loop
         Put (To_String (Colour_Image (Set (I))) & " ");
      end loop;
      New_Line;

      -- Meeting place initialization
      Place.Init (Meetings);
      -- Rendez-vous to start the tasks
      for I in Set'Range loop
         Creature_Set (I).Start (I, Set (I));
      end loop;

      -- Rendez-vous : waiting for the test to complete
      for I in Set'Range loop
         Creature_Set (I).Report (I, Measures (I));
      end loop;

      for I in Set'Range loop
         Int_Io.Put (Measures (I).Meetings_Made, Width => 10);
         Put ("  " & Spelled (Measures (I).Meetings_Same));
         New_Line;
      end loop;

      for I in Set'Range loop
         Total_Meetings := Total_Meetings + Measures (I).Meetings_Made;
      end loop;
      Put (Spelled (Total_Meetings));
      New_Line (2);

   exception
      when E : others =>
         Ada.Text_IO.Put_Line
           ("Test failed cause :=" & Exception_Information (E));
   end Run;

end Chameneos;
------------------------------------------------------------------------------
-- The chameneos description
-------------------------------------------------------------------------------
package Chameneos.Creatures is

   --A chameneos is an Ada task
   task type Creature is
      entry Start (Id : in Id_Type; C : in Colour);
      entry Report (Id : in Id_Type; Measure : out Measure_Type);
   end Creature;
   -- The meeting place
   protected Place is
      procedure Init (Max_Count : in Natural);
      entry Meet
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour);

   private
      entry Waiting
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour);

      First_Call         : Boolean;
      A_Colour, B_Colour : Colour;
      A_Name, B_Name     : Id_Type;
      Meetings_Counter   : Natural;
   end Place;

end Chameneos.Creatures;
-------------------------------------------------------------------------------
package body Chameneos.Creatures is

   protected body Place is

      procedure Init (Max_Count : in Natural) is
      begin
         Meetings_Counter := Max_Count;
         First_Call       := True;
      end Init;

      entry Meet
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour) when True
      is
      begin
         if (Meetings_Counter = 0) then
            -- The test is finished
            Mall_Open := False;
            -- must give dummy values that will not be used anyway
            C_Other    := C;
            Name_Other := 1;
         else
            Mall_Open := True;
            if (First_Call) then
               A_Colour   := C;
               A_Name     := X;
               First_Call := False;
               requeue Waiting;
            else
               B_Colour         := C;
               B_Name           := X;
               C_Other          := A_Colour;
               Name_Other       := A_Name;
               First_Call       := True;
               Meetings_Counter := Meetings_Counter - 1;
            end if;
         end if;
      end Meet;

      entry Waiting
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour) when First_Call
      is
      begin
         Mall_Open  := True;
         C_Other    := B_Colour;
         Name_Other := B_Name;
      end Waiting;
   end Place;

   task body Creature is
      My_Id, Other_Id         : Id_Type;
      My_Colour, Other_Colour : Colour;
      Meetings_Made           : Natural := 0;
      Meetings_Same           : Natural := 0;
      Is_Mall_Open            : Boolean;
   begin
      accept Start (Id : in Id_Type; C : in Colour) do
         My_Id     := Id;
         My_Colour := C;
      end Start;

      loop
         Place.Meet (My_Id, My_Colour, Is_Mall_Open, Other_Id, Other_Colour);
         if not Is_Mall_Open then
            -- the test is finished
            exit;
         end if;
         My_Colour     := Do_Complement (My_Colour, Other_Colour);
         Meetings_Made := Meetings_Made + 1;
         if Other_Id = My_Id then
            Meetings_Same := Meetings_Same + 1;
         end if;

      end loop;
      -- Give the results and die.
      accept Report (Id : in Id_Type; Measure : out Measure_Type) do
         Measure.Meetings_Made := Meetings_Made;
         Measure.Meetings_Same := Meetings_Same;
      end Report;
   end Creature;

end Chameneos.Creatures;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pat Rogers
--
-- Based on the C++ version by Andrew Moon 
-- and the C version by Dmitry Vyukov
--
-- A task (thread) is created for each chameneous.
-- An atomic compare-and-swap operation is used
-- for shared state manipulation.  A protected 
-- type is used for completion notification.
-- A cache-aligned memory allocator is used.


-- Expected build command:
-- gnatmake -gnatp  -gnatn  -fstrict-aliasing -O3 -fomit-frame-pointer -march=native -ffunction-sections -fdata-sections -f chameneosredux.adb -o chameneosredux.gnat_run   -largs -Wl,--gc-sections



pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Chameneos.Games;       use Chameneos.Games;
with Ada.Command_Line;      use Ada.Command_Line;
with Chameneos.Processors;  use Chameneos.Processors;

procedure ChameneosRedux is

   use Chameneos;

   N : Meeting_Count;

   Game1_Creature_Colors : constant Color_List_Ref := new Color_List'(Blue, Red, Yellow);

   Game2_Creature_Colors : constant Color_List_Ref :=
      new Color_List'(Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue);

   Game1 : Game (Num_Creatures => Game1_Creature_Colors'Length);

   Game2 : Game (Num_Creatures => Game2_Creature_Colors'Length);

begin
   Print_Color_Complements;

   if Argument_Count < 1 then
      N := 6_000_000;
   else
      N := Meeting_Count'Value (Argument (1));
   end if;

   if Processor_Count < 4 then  -- run the games sequentially
      Game1.Start (Game1_Creature_Colors, N, Slot => 0);
      Game1.Await_Completion;

      Game2.Start (Game2_Creature_Colors, N, Slot => 0);
      Game2.Await_Completion;
   else -- run the games in parallel
      Game1.Start (Game1_Creature_Colors, N, Slot => 1);
      Game2.Start (Game2_Creature_Colors, N, Slot => 2);

      Game1.Await_Completion;
      Game2.Await_Completion;
   end if;

   Game1.Display;
   Game2.Display;
end ChameneosRedux;

-------------------------------------------------------------------------------

with Interfaces;                  use Interfaces;
with Cache_Aligned_Storage_Pools; use Cache_Aligned_Storage_Pools;

package Chameneos is

   Storage : Cache_Aligned_Storage_Pool;
   --  All allocators use this common pool, which is really just a wrapper for
   --  the system allocator, but with additional constraints on the addresses
   --  returned.

   type String_Access is access all String;
   for String_Access'Storage_Pool use Storage;

   type Colors is (Blue, Red, Yellow);

   Colors_Image : constant array (Colors) of String_Access :=
                    (Blue   => new String'("blue"),
                     Red    => new String'("red"),
                     Yellow => new String'("yellow"));

   type Colors_Complements is array (Colors, Colors) of Colors;

   Complementary_Color : constant Colors_Complements :=
                           (Blue   => (Blue   => Blue,
                                       Red    => Yellow,
                                       Yellow => Red),
                            Red    => (Red    => Red,
                                       Blue   => Yellow,
                                       Yellow => Blue),
                            Yellow => (Yellow => Yellow,
                                       Blue   => Red,
                                       Red    => Blue));

   --  Print the Complementary_Color map
   procedure Print_Color_Complements;

   --  Returns a string representing the non-negative integer Value, in which
   --  each digit of Value is spelled out as a distinct word
   function Spelled (Value : Natural) return String;


   type Color_List is array (Positive range <>) of Colors;

   type Color_List_Ref is access constant Color_List;
   for Color_List_Ref'Storage_Pool use Storage;


   --  The efficiency of this design is due to the underlying use of a single
   --  variable (per game) shared amongst all the creature threads. This
   --  variable is used both for the count of the number of meetings completed
   --  as well as an indication of the creatures present for meetings. Hence
   --  some of the bits are used for the meeting count and some for the
   --  creatures. The number of bits used for the creature mask, in combination
   --  with the total number of bits in the shared variable, determine how many
   --  creatures and how many total meetings are supported.

   --  The number of bits allocated within the shared variable for identifying
   --  creatures
   Creature_Mask_Bits : constant := 4;

   subtype Creature_Count is Unsigned_32 range 0 .. 2 ** Creature_Mask_Bits - 1;

   --  The number of bits allocated within the shared variable for tracking the
   --  total number of meetings completed
   Meetings_Bits : constant := Unsigned_32'Size - Creature_Mask_Bits;

   Max_Meetings : constant := 2 ** Meetings_Bits - 1;

   subtype Meeting_Count is Unsigned_32 range 0 .. Max_Meetings;

end Chameneos;

-------------------------------------------------------------------------------

with Chameneos.Meetings;
with Chameneos.Countdown;
with Chameneos.Processors;

with System.Task_Info;  use System.Task_Info;

package Chameneos.Creatures is

   type Creature (Starting_Color : Colors) is tagged limited private;
   --  Each creature has an initial color, but their current color is a function
   --  of the colors of the other creatures met.

   type Creature_Ref is access all Creature;
   for Creature_Ref'Storage_Pool use Chameneos.Storage;

   --  Tell the creature where all the creatures in the game are meeting, where
   --  to signal when the creature is finished, and which slot to execute in.
   procedure Start (This     : access Creature;
                    Location : Chameneos.Meetings.Venue;
                    Latch    : Chameneos.Countdown.Latch_Ref;
                    Slot     : Natural);

   --  The caller side of the rendezvous
   procedure Meet (This : in out Creature;  Other : in out Creature);

   --  The called side of the rendezvous
   procedure Wait_Until_Met (This : in out Creature);

   procedure Await_Completion (This : in out Creature);

   procedure Set_Id (This : in out Creature;  To : Creature_Count);

   function Id (This : Creature) return Creature_Count;

   function Current_Color (This : Creature) return Colors;

   function Initial_Color (This : Creature) return Colors;

   procedure Display (This : in out Creature);

   function Total_Met (This : Creature) return Natural;

   pragma Inline (Set_Id, Id, Current_Color, Initial_Color, Total_Met);

private

   use Chameneos.Processors;

   --  Objects of type Thread implement the active execution, i.e., the
   --  symmetric rendezvous requirement, for their corresponding creatures.
   --  Each thread instance has a discriminant designating the corresponding
   --  creature. No state is maintained within the threads themselves. Each
   --  thread instance executes in a given "slot" that specifies the cores it
   --  can run upon, via processor affinities. The specific slot is also given
   --  via discriminant.
   task type Thread (This : access Creature;  Slot : Natural) is
      pragma Task_Info (new Thread_Attributes'(CPU_Affinity => Affinity (Slot)));
   end Thread;

   type Thread_Ref is access all Thread;
   for Thread_Ref'Storage_Pool use Chameneos.Storage;

   type Creature (Starting_Color : Colors) is tagged limited
      record
         Met              : Boolean := False;
         --  Met is set by other threads so the pragma is essential
         pragma Volatile (Met);
         Count            : Natural := 0;
         Same_Count       : Natural := 0;
         Color            : Colors := Starting_Color;
         Id               : Creature_Count;
         Rendezvous_Point : Meetings.Venue;
         Completion       : Chameneos.Countdown.Latch_Ref;
      end record;

end Chameneos.Creatures;

-------------------------------------------------------------------------------

with Chameneos.Creatures;  use Chameneos.Creatures;
with Chameneos.Meetings;
with Chameneos.Countdown;

package Chameneos.Games is

   type Game (Num_Creatures : Creature_Count) is tagged limited private;

   --  Allocates the creature threads and all other required data.
   procedure Start
     (This            : in out Game;
      Creature_Colors : Color_List_Ref;
      Num_Meetings    : Meeting_Count;
      Slot            : Natural);

   --  Waits for all creatures (threads) to finish.
   procedure Await_Completion (This : Game);

   procedure Display (This : Game);

private

   use Chameneos;

   type Creatures_List is array (Creature_Count range <>) of Creature_Ref;

   type Game (Num_Creatures : Creature_Count) is tagged limited
      record
         --  where all the creatures in the game meet
         Rendezvous_Point : Meetings.Venue;
         --  all the creatures in the game
         Players : Creatures_List (1 .. Num_Creatures);
         --  the common mechanism used for signalling creature completion
         Latch : aliased Countdown.Latch (Num_Creatures);
      end record;

end Chameneos.Games;

-------------------------------------------------------------------------------

limited with Chameneos.Creatures;

package Chameneos.Meetings is

   type Place (Meetings_Expected : Meeting_Count) is tagged limited private;
   --  Where creatures come to meet other creatures, potentially change colors,
   --  and play the game. Creatures are required to meet until the required
   --  number of total meetings has occurred. This number of required meetings
   --  is specified by the discriminant Meetings_Expected.

   type Venue is access all Place;
   for Venue'Storage_Pool use Chameneos.Storage;

   --  Assign a location for the creature designated by Player, within This place,
   --  for the purpose of meeting any other creatures willing to meet.
   procedure Register
     (This   : in out Place;
      Player : access Chameneos.Creatures.Creature);

   --  Have creature Player iteratively meet other creatures with This place,
   --  updating the count of the total number of creature meetings as they
   --  occur, and updating individual creature states as well (including
   --  individual meeting counts and color changes).
   procedure Meet_Others
     (This   : in out Place;
      Player : access Chameneos.Creatures.Creature);

private

   type Creature_Reference_List is
     array (Creature_Count range 1 .. Creature_Count'Last) of
        access Chameneos.Creatures.Creature;

   subtype Valid_Creature_Id is
     Creature_Count range 1 .. Creature_Count'Last;

   No_Creature : constant Creature_Count := Valid_Creature_Id'First - 1;
   --  used in Meet_Others to determine whether any creatures are waiting

   type Place (Meetings_Expected : Meeting_Count) is tagged limited
      record
         Id_Generator : Valid_Creature_Id := Valid_Creature_Id'First;
         --  Used to assign unique id's to creature threads as they register.
         Shared_State : aliased Unsigned_32 := Shift_Left (Meetings_Expected, Creature_Mask_Bits);
         --  The essential aspect of this program's design is the use of this
         --  shared variable accessed by all the creature threads in a given
         --  game. This variable is used both for the count of the number of
         --  meetings completed as well as an indication of creatures waiting
         --  for meetings. Hence the initial value is the number of required
         --  meetings, shifted into the dedicated bits, with no creatures yet
         --  waiting.
         pragma Volatile (Shared_State);
         --  Shared_State is accessed and modified by all the threads within a
         --  given game, so the pragma is essential!
         Registered_Players : Creature_Reference_List;
      end record;

end Chameneos.Meetings;

-------------------------------------------------------------------------------

with System.Storage_Pools;
with System.Storage_Elements;

package Cache_Aligned_Storage_Pools is

   package SSE renames System.Storage_Elements;
   package SSP renames System.Storage_Pools;

   type Cache_Aligned_Storage_Pool is
     new SSP.Root_Storage_Pool with private;
   --  A Cache_Aligned_Storage_Pool is a wrapper for the underlying operating
   --  system storage allocator. Allocations using pool objects of this type
   --  will return addresses that are aligned with the cache line size specified
   --  below.

   Cache_Line_Size : constant := 64;
   --  The length of a cache line on this machine.  Change as necessary...

   --  Allocates a block of storage such that Storage_Address is aligned with
   --  Cache_Line_Size. Uses the system memory allocator to do the actual
   --  allocation but asks for more storage than Requested_Size so that an
   --  aligned address within the allocated block can be found.
   procedure Allocate
     (Pool            : in out Cache_Aligned_Storage_Pool;
      Storage_Address : out System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count);

   --  Uses the system memory routine to deallocate the entire block of storage
   --  in which Storage_Address is contained.
   procedure Deallocate
     (Pool            : in out Cache_Aligned_Storage_Pool;
      Storage_Address : System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count);

   --  Returns a meaningless number since the system memory allocation and
   --  deallocation routines are used.
   function Storage_Size (Pool : Cache_Aligned_Storage_Pool)
      return SSE.Storage_Count;

private

   procedure Allocate_Any
     (Pool            : in out Cache_Aligned_Storage_Pool'Class;
      Storage_Address : out System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count);

   procedure Deallocate_Any
     (Pool            : in out Cache_Aligned_Storage_Pool'Class;
      Storage_Address : System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count);

   type Cache_Aligned_Storage_Pool is
     new SSP.Root_Storage_Pool with null record;  -- just a wrapper...

end Cache_Aligned_Storage_Pools;

-------------------------------------------------------------------------------

package Chameneos.Countdown is

   --  "Latch" is a non-cyclic traditional barrier abstraction. As a barrier it
   --  provides a means of blocking callers to Wait until a specified number of
   --  calls to Signal have occurred. At that point all of the prior calls to
   --  Wait are allowed to execute and, therefore, their callers are no longer
   --  blocked. The number of required calls to Signal is specified on a
   --  per-object basis via discriminant when objects of the type are declared.
   --  Latch is "non-cyclic", i.e., it does not block another set of waiters
   --  after the first set is allowed to continue, because there is no
   --  requirement in this application for cyclic behavior.
   protected type Latch (Signallers : Creature_Count) is
      entry Wait;
      procedure Signal;
   private
      Count : Unsigned_32 := Signallers;
   end Latch;

   type Latch_Ref is access all Latch;
   for Latch_Ref'Storage_Pool use Chameneos.Storage;

end Chameneos.Countdown;

-------------------------------------------------------------------------------

with System.Task_Info;     use System.Task_Info;
pragma Warnings (Off);
with System.OS_Interface;  use System.OS_Interface;
pragma Warnings (On);

package Chameneos.Processors is
   pragma Elaborate_Body;

   Processor_Count : constant Positive := System.Task_Info.Number_Of_Processors;

   Max_Slots : constant := 33;

   --  Returns a bit mask indicating the cores on which a thread in Slot can
   --  execute. A game is assigned to a given slot, and as a result all the
   --  threads within that game will execute only on those cores, for the sake
   --  of locality (ie performance).
   function Affinity (Slot : Natural) return CPU_Set;

   --  Each slot has an affinity mask consisting of a pair of cores
   --  dedicated to that slot, except for slot 0 which is the global mask
   --  returned by the OS (which shows all processors available).
   --
   --  For example, imagine that we get a mask with the first 8 bits
   --  enabled, indicating that 8 processors (cores) are available.
   --  The resulting data structure would be as follows:
   --
   --                     bit#
   --   slot #         123456789...
   --     0            1111111100
   --     1            1100000000
   --     2            0011000000
   --     3            0000110000
   --     4            0000001100
   --     5            1100000000
   --     6            0011000000
   --    ...              ...

end Chameneos.Processors;

-------------------------------------------------------------------------------

with Interfaces;   use Interfaces;

package x86_Atomic_Swap_Utils is

   -- Perform an atomic compare and swap: if the current value of
   -- Destination.all is Comparand, then write New_Value into Destination.all.
   -- Returns the content of Destination.all before the operation.
   function Sync_Val_Compare_And_Swap
     (Destination : access Unsigned_32;
      Comparand   : Unsigned_32;
      New_Value   : Unsigned_32)
      return Unsigned_32;

   pragma Inline_Always (Sync_Val_Compare_And_Swap);

end x86_Atomic_Swap_Utils;

-------------------------------------------------------------------------------

with GNAT.IO; use GNAT.IO;
with Ada.Strings.Unbounded;

package body Chameneos is

   Numbers_Image : constant array (0 .. 9) of String_Access :=
                     (0 => new String'(" zero"),
                      1 => new String'(" one"),
                      2 => new String'(" two"),
                      3 => new String'(" three"),
                      4 => new String'(" four"),
                      5 => new String'(" five"),
                      6 => new String'(" six"),
                      7 => new String'(" seven"),
                      8 => new String'(" eight"),
                      9 => new String'(" nine"));

   -------------
   -- Spelled --
   -------------

   function Spelled (Value : Natural) return String is
      use Ada.Strings.Unbounded;
      Result : Unbounded_String;
      K      : Natural := Value;
   begin
      loop
         Insert (Result, 1, Numbers_Image (K rem 10).all);
         K := K / 10;
         exit when K = 0;
      end loop;
      return To_String (Result);
   end Spelled;

   -------------------------
   -- Print_Color_Changes --
   -------------------------

   procedure Print_Color_Complements is
   begin
      for Self in Colors loop
         for Other in Colors loop
            Put_Line (Colors_Image (Self).all & " + " &
                      Colors_Image (Other).all & " -> " &
                      Colors_Image (Complementary_Color (Self, Other)).all);
         end loop;
      end loop;
      New_Line;
   end Print_Color_Complements;

end Chameneos;

-------------------------------------------------------------------------------

with GNAT.IO;  use GNAT.IO;

package body Chameneos.Creatures is

   -----------
   -- Start --
   -----------

   procedure Start
     (This     : access Creature;
      Location : Chameneos.Meetings.Venue;
      Latch    : Chameneos.Countdown.Latch_Ref;
      Slot     : Natural)
   is
      Player_To_Be_Named_Later : Thread_Ref;
      pragma Unreferenced (Player_To_Be_Named_Later);
   begin
      This.Rendezvous_Point := Location;
      This.Completion := Latch;
      This.Rendezvous_Point.Register (This);
      Player_To_Be_Named_Later := new Thread (This, Slot);
        --  just launch the thread, no need to keep track of it
   end Start;

   ----------
   -- Meet --
   ----------

   procedure Meet (This : in out Creature; Other : in out Creature) is
      New_Color : Colors;
   begin
      if This.Id = Other.Id then
         This.Same_Count := This.Same_Count + 1;
         Other.Same_Count := Other.Same_Count + 1;
      end if;

      This.Count  := This.Count + 1;
      Other.Count := Other.Count + 1;

      New_Color := Complementary_Color (This.Color, Other.Color);
      This.Color := New_Color;
      Other.Color := New_Color;

      Other.Met := True;
   end Meet;

   --------------------
   -- Wait_Until_Met --
   --------------------

   procedure Wait_Until_Met (This : in out Creature) is
   begin
      if Processor_Count > 1 then
         declare
            Spin_Count : Integer := 0;
         begin
            while not This.Met loop
               Spin_Count := Spin_Count + 1;
               if Spin_Count > 20_000 then  -- arbitrary max
                  delay 0.0;  -- yield
                  Spin_Count := 0;
               end if;
            end loop;
         end;
      else
         while not This.Met loop
            delay 0.0; -- yield
         end loop;
      end if;
      This.Met := False;
   end Wait_Until_Met;

   ----------------------
   -- Await_Completion --
   ----------------------

   procedure Await_Completion (This : in out Creature) is
   begin
      This.Completion.Wait;
   end Await_Completion;

   ------------
   -- Set_Id --
   ------------

   procedure Set_Id (This : in out Creature;  To : Creature_Count) is
   begin
      This.Id := To;
   end Set_Id;

   --------
   -- Id --
   --------

   function Id (This : Creature) return Creature_Count is
   begin
      return This.Id;
   end Id;

   -------------------
   -- Current_Color --
   -------------------

   function Current_Color (This : Creature) return Colors is
   begin
      return This.Color;
   end Current_Color;

   -------------------
   -- Initial_Color --
   -------------------

   function Initial_Color (This : Creature) return Colors is
   begin
      return This.Starting_Color;
   end Initial_Color;

   -------------
   -- Display --
   -------------

   procedure Display (This : in out Creature) is
   begin
      Put (This.Count);
      Put_Line (Spelled (This.Same_Count));
   end Display;

   ---------------
   -- Total_Met --
   ---------------

   function Total_Met (This : Creature) return Natural is
   begin
      return This.Count;
   end Total_Met;

   ------------
   -- Thread --
   ------------

   task body Thread is
      use Chameneos.Meetings;
   begin
      Meet_Others (This.Rendezvous_Point.all, Player => This);
      This.Completion.Signal;
   end Thread;

end Chameneos.Creatures;

-------------------------------------------------------------------------------

with GNAT.IO;  use GNAT.IO;

package body Chameneos.Games is

   -----------
   -- Start --
   -----------

   procedure Start
     (This            : in out Game;
      Creature_Colors : Color_List_Ref;
      Num_Meetings    : Meeting_Count;
      Slot            : Natural)
   is
      Color_Index : Positive := Creature_Colors'First;
      --  We use a separate index, instead of the index used to iterate over
      --  This.Players, since the bounds need not be the same. The range of
      --  This.Players is 1 .. Num_Creatures, where that upper bound is set as a
      --  discriminant to the game when it is created. The actual value passed
      --  to this discriminant comes from the length of an array of colors,
      --  which is then passed to this procedure in Creature_Colors, so the
      --  count will be the same. There is no guarantee of that, of course, but
      --  in practice that will suffice.
   begin
      This.Rendezvous_Point := new Meetings.Place (Num_Meetings);
      for K in This.Players'Range loop
         This.Players (K) := new Creature (Creature_Colors (Color_Index));
         This.Players (K).Start
           (Location => This.Rendezvous_Point,
            Latch    => This.Latch'Unchecked_Access,
            Slot     => Slot);
         Color_Index := Color_Index + 1;
      end loop;
   end Start;

   ----------------------
   -- Await_Completion --
   ----------------------

   procedure Await_Completion (This : Game) is
   begin
      for K in This.Players'Range loop
         This.Players (K).Await_Completion;
      end loop;
   end Await_Completion;

   -------------
   -- Display --
   -------------

   procedure Display (This : Game) is
      Grand_Total : Natural := 0;
   begin
      for K in This.Players'Range loop
         Put( " " & Colors_Image (This.Players (K).Initial_Color).all);
      end loop;
      New_Line;

      for K in This.Players'Range loop
         This.Players (K).Display;
         Grand_Total := Grand_Total + This.Players (K).Total_Met;
      end loop;
      Put_Line (Spelled (Grand_Total));
      New_Line;
   end Display;

end Chameneos.Games;

-------------------------------------------------------------------------------

with Chameneos.Creatures;
with x86_Atomic_Swap_Utils;  use x86_Atomic_Swap_Utils;

package body Chameneos.Meetings is

   --------------
   -- Register --
   --------------

   procedure Register
     (This   : in out Place;
      Player : access Chameneos.Creatures.Creature)
   is
      Id : constant Creature_Count := This.Id_Generator;
   begin
      Player.Set_Id (Id);
      This.Registered_Players (Id) := Player;
      This.Id_Generator := This.Id_Generator + 1;
   end Register;


   --  the lower part of the shared variable State, used to represent those
   --  chameneos wating for a meeting in the mall
   Creature_Mask : constant := 2 ** Creature_Mask_Bits - 1;

   --  the additional meeting count value due to the creature mask
   Count_Offset : constant Unsigned_32 := Shift_Left (1, Creature_Mask_Bits);


   -----------------
   -- Meet_Others --
   -----------------

   procedure Meet_Others
     (This   : in out Place;
      Player : access Chameneos.Creatures.Creature)
   is
      Local_State       : Unsigned_32 := This.Shared_State;
      Waiting           : Unsigned_32;
      Target_State      : Unsigned_32;
      State_Before_Swap : Unsigned_32;
   begin
      loop
         --  get the Id of a creature waiting for a meeting, if any
         Waiting := Local_State and Creature_Mask;
         if Waiting /= No_Creature then
            --  at least one creature is in the mall, waiting for a rendezvous,
            --  so we set the target state to the current meeting count - 1 to
            --  reflect the meeting we're about to attempt
            Target_State := (Local_State and not Creature_Mask) - Count_Offset;
         elsif Local_State /= 0 then
            --  no creatures are waiting but there are meetings remaining so set
            --  the target state to reflect Player, who is willing to meet
            Target_State := Local_State or Player.Id;
         else  --  no creatures waiting and no further meetings to be held
            exit;
         end if;

         --  Attempt to update the shared game state. If the value of the shared
         --  state is that of the local copy when the swap is attempted, then
         --  the shared state will be updated, otherwise it is not changed.
         State_Before_Swap := Sync_Val_Compare_And_Swap
           (Destination => This.Shared_State'Access,
            Comparand   => Local_State,
            New_Value   => Target_State);

         if State_Before_Swap = Local_State then -- we successfully updated it
            if Waiting /= 0 then
               Player.Meet (This.Registered_Players (Waiting).all);
            else
               Player.Wait_Until_Met;
            end if;

            Local_State := Target_State;
         else  -- we did not update the shared state, so use the shared value
            Local_State := State_Before_Swap;
         end if;
      end loop;
   end Meet_Others;

end Chameneos.Meetings;

-------------------------------------------------------------------------------

package body Chameneos.Countdown is

   -----------
   -- Latch --
   -----------

   protected body Latch is

      ----------
      -- Wait --
      ----------

      entry Wait when Count = 0 is
      begin
         null;
      end Wait;

      ------------
      -- Signal --
      ------------

      procedure Signal is
      begin
         Count := Count - 1;
      end Signal;

   end Latch;

end Chameneos.Countdown;

-------------------------------------------------------------------------------

with System.Memory;
with Ada.Unchecked_Conversion;

package body Cache_Aligned_Storage_Pools is

   use System, System.Storage_Elements;

   --  we cannot use System.Address'Size as the modulus so we use the same thing
   --  that the compiler does (when declaring Address as a modular type in the
   --  full definition)
   type Unsigned_Address is mod System.Memory_Size;

   function As_Unsigned_Address is new Ada.Unchecked_Conversion
     (Source => Address,
      Target => Unsigned_Address);

   function As_Address is new Ada.Unchecked_Conversion
     (Target => Address,
      Source => Unsigned_Address);

   type Address_Pointer is access all Address;
   for Address_Pointer'Storage_Size use 0;

   function As_Address_Pointer is new Ada.Unchecked_Conversion
     (Source => Address,
      Target => Address_Pointer);

   --  size of an address in terms of storage units
   Size_Of_Address : constant Storage_Offset := Address'Size / System.Storage_Unit;

   Twice_Cache_Line_Size : constant := 2 * Cache_Line_Size;

   --------------
   -- Allocate --
   --------------

   procedure Allocate
     (Pool            : in out Cache_Aligned_Storage_Pool;
      Storage_Address : out System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count)
   is
      pragma Unreferenced (Pool);
      pragma Unreferenced (Alignment);

      Actual  : Address;
      Aligned : Address;
      Header  : Address;
      Temp    : Unsigned_Address;
   begin
      Actual := Memory.Alloc (Memory.size_t (Requested_Size + Twice_Cache_Line_Size));
      --  The call to Alloc returns an address whose alignment is compatible
      --  with the worst case alignment requirement for the machine; thus the
      --  Alignment argument can be safely ignored.

      if Actual = Null_Address then
         raise Storage_Error;
      end if;

      --  compute a cache-aligned address within the block allocated
      Temp := As_Unsigned_Address (Actual + Cache_Line_Size) and not (Cache_Line_Size - 1);
      Aligned := As_Address (Temp);
      --  Put the address of the whole allocated block just before the address
      --  given to the application so we can deallocate the whole block later
      Header := Aligned - Size_of_Address;
      As_Address_Pointer (Header).all := Actual;
      Storage_Address := Aligned;
   end Allocate;

   ----------------
   -- Deallocate --
   ----------------

   procedure Deallocate
     (Pool            : in out Cache_Aligned_Storage_Pool;
      Storage_Address : System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count)
   is
      pragma Unreferenced (Pool);
      pragma Unreferenced (Requested_Size);
      pragma Unreferenced (Alignment);

      Actual : Address;
      Header : Address;
   begin
      Header := Storage_Address - Size_of_Address;
      Actual := As_Address_Pointer (Header).all;
      Memory.Free (Actual);
   end Deallocate;

   ------------------
   -- Storage_Size --
   ------------------

   function Storage_Size
     (Pool  : Cache_Aligned_Storage_Pool)
      return  SSE.Storage_Count
   is
      pragma Warnings (Off, Pool);
   begin
      return SSE.Storage_Count'Last;
   end Storage_Size;

   ------------------
   -- Allocate_Any --
   ------------------

   procedure Allocate_Any
     (Pool            : in out Cache_Aligned_Storage_Pool'Class;
      Storage_Address : out System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count)
   is
   begin
      Allocate (Pool, Storage_Address, Requested_Size, Alignment);
   end Allocate_Any;

   --------------------
   -- Deallocate_Any --
   --------------------

   procedure Deallocate_Any
     (Pool            : in out Cache_Aligned_Storage_Pool'Class;
      Storage_Address : System.Address;
      Requested_Size  : SSE.Storage_Count;
      Alignment       : SSE.Storage_Count)
   is
   begin
      Deallocate (Pool, Storage_Address, Requested_Size, Alignment);
   end Deallocate_Any;

end Cache_Aligned_Storage_Pools;

-------------------------------------------------------------------------------

with Interfaces.C;

package body Chameneos.Processors is

   Cores_Per_Slot : constant := 2;

   Affinities : array (0 .. Max_Slots) of aliased CPU_Set;
   --  we use the first slot (ie 0) for the global affinity mask, internally,
   --  hence there are Max_Slots-1 total slots available to the application
   --  threads, and a total of ((Max_Slots-1) * Cores_Per_Slot) cores supported

   Slot_Modulus : Natural;

   --------------
   -- Affinity --
   --------------

   function Affinity (Slot : Natural) return cpu_set_t is
   begin
      if Slot = 0 then
         return Affinities (Slot);
      else
         return Affinities ((Slot mod Slot_Modulus) + 1);
      end if;
   end Affinity;

   -----------------------
   -- sched_getaffinity --
   -----------------------

   function Sched_Getaffinity
     (Pid : Pid_T;  Cpusetsize : Unsigned_32;  Mask : access CPU_Set)
      return Interfaces.C.int;
   pragma Import (C, sched_getaffinity);


   subtype Bit_Number is Integer range bit_field'Range;

   --------------
   --  Set_Bit --
   --------------

   procedure Set_Bit (Bit : Bit_Number;  Within : in out CPU_Set) is
   begin
      Within.bits (Bit) := True;
   end Set_Bit;

   -------------------------------
   -- Define_Affinities_By_Slot --
   -------------------------------

   procedure Define_Affinities_By_Slot is
      Num_Bits_Set     : Natural := 0;
      Global_Mask      : CPU_Set renames Affinities (0);
      Result           : Int;
      Global_Mask_Size : constant Unsigned_32 := Global_Mask'Size / System.Storage_Unit;
      Next_Affinity    : Natural;
      use type Interfaces.C.int;
   begin
      Result := sched_getaffinity (getpid, Global_Mask_Size, Global_Mask'Access);
      if Result /= 0 then
         raise Program_Error with "Could not get affinity";
      end if;

      for B in 1 .. CPU_SETSIZE loop
         if Global_Mask.Bits (B) then
            Next_Affinity := (Num_Bits_Set / Cores_Per_Slot) + 1;
            if Next_Affinity not in Affinities'Range then
               --  there are more processors enabled than we support, but
               --  that is OK since we only want a few
               exit;
            end if;
            Set_Bit (B, Affinities (Next_Affinity));
            Num_Bits_Set := Num_Bits_Set + 1;
         end if;
      end loop;

      if Num_Bits_Set > 2 then
         Slot_Modulus := Num_Bits_Set / 2;
      else
         Slot_Modulus := 1;
      end if;
   end Define_Affinities_By_Slot;


begin
   for K in Affinities'Range loop
      Affinities (K).bits := (others => False);
   end loop;
   Define_Affinities_By_Slot;
end Chameneos.Processors;

-------------------------------------------------------------------------------

with System.Machine_Code;  use System.Machine_Code;

package body x86_Atomic_Swap_Utils is

   -------------------------------
   -- Sync_Val_Compare_And_Swap --
   -------------------------------

   function Sync_Val_Compare_And_Swap
     (Destination : access Unsigned_32;
      Comparand   : Unsigned_32;
      New_Value   : Unsigned_32)
      return Unsigned_32
   is
      Prior_Value : Unsigned_32;
      pragma Suppress (All_Checks);
   begin
      --  %eax := Comparand
      --  if %eax = Destination.all then
      --     Destination.all := New_Value
      --  else
      --     %eax := Destination.all
      --  end if
      Asm("lock cmpxchg %1, %2;",
        Inputs  => (Unsigned_32'Asm_Input ("r", New_Value),        -- %1
                    Unsigned_32'Asm_Input ("m", Destination.all),  -- %2
                    Unsigned_32'Asm_Input ("a", Comparand)),
        Outputs => (Unsigned_32'Asm_Output ("=a", Prior_Value)),   -- %0
        Clobber => "memory, cc",
        Volatile => True);
      --  return %eax
      return Prior_Value;
   end Sync_Val_Compare_And_Swap;

end x86_Atomic_Swap_Utils;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
-- Contributed by Francois Fabien (24 avril 2011)
--
-- Based on the original Ada version by
-- Claude Kaiser and Jean-Francois Pradat-Peyre (CEDRIC - CNAM Paris)
--
-- Chameneos are Ada tasks and the meeting place is a protected body
-- Fully portable :
--            No machine/OS dependency
--            No dependency of GNAT-compiler specific features
--
-- Expected build command:
-- gnatmake -gnatpn05 -O3 -march=native -f chameneosredux.adb
------------------------------------------------------------------------------
pragma Restrictions (Simple_Barriers);
pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Chameneos;        use Chameneos;
with Ada.Command_Line; use Ada.Command_Line;
with System;

procedure ChameneosRedux is
   pragma Priority (System.Max_Priority);
   Meeting_count : Natural := 600;
begin

   if Argument_Count > 0 then
      begin
         Meeting_count := Natural'Value (Argument (1));
      exception
         when others =>
            null;-- When bad argument, keep meetings := 600
      end;
   end if;

   Print_Colours;
   Run (Meeting_count, (Blue, Red, Yellow));
   Run
     (Meeting_count,
      (Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue));
end ChameneosRedux;
-------------------------------------------------------------------------------
-- Root package
-- Definitions and test procedure (run)
-------------------------------------------------------------------------------

package Chameneos is
   -- The creature Name
   subtype Id_Type is Positive;
   type Colour is (Blue, Red, Yellow);
   type Colour_Set is array (Id_Type range <>) of Colour;

   function Do_Complement (C1, C2 : Colour) return Colour;
   -- since this function is heavily used, make it inline to speed up
   pragma Inline (Do_Complement);

   -- Stuff required for the measurement
   type Measure_Type is record
      Meetings_Made : Natural := 0;
      Meetings_Same : Natural := 0;
   end record;

   type Result_Type is array (Id_Type range <>) of Measure_Type;

   --  Utility for output
   procedure Print_Colours;
   -- The test procedure
   procedure Run (Meetings : Natural; Set : Colour_Set);
end Chameneos;
-------------------------------------------------------------------------------
with Ada.Text_IO;           use Ada.Text_IO;
with Ada.Exceptions;        use Ada.Exceptions;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Chameneos.Creatures;   use Chameneos.Creatures;

package body Chameneos is

   package Int_Io is new Ada.Text_IO.Integer_IO (Integer);

   function Do_Complement (C1, C2 : Colour) return Colour is
   begin
      case C1 is
         when Blue =>
            case C2 is
               when Blue =>
                  return Blue;
               when Red =>
                  return Yellow;
               when Yellow =>
                  return Red;
            end case;
         when Red =>
            case C2 is
               when Blue =>
                  return Yellow;
               when Red =>
                  return Red;
               when Yellow =>
                  return Blue;
            end case;
         when Yellow =>
            case C2 is
               when Blue =>
                  return Red;
               when Red =>
                  return Blue;
               when Yellow =>
                  return Yellow;
            end case;
      end case;
   end Do_Complement;

   function To_US (Source : String) return Unbounded_String renames
     To_Unbounded_String;

   Colour_Image : constant array (Colour) of Unbounded_String :=
     (Blue   => To_US ("blue"),
      Red    => To_US ("red"),
      Yellow => To_US ("yellow"));

   Numbers_Image : constant array (0 .. 9) of Unbounded_String :=
     (0 => To_US ("zero "),
      1 => To_US ("one "),
      2 => To_US ("two "),
      3 => To_US ("three "),
      4 => To_US ("four "),
      5 => To_US ("five "),
      6 => To_US ("six "),
      7 => To_US ("seven "),
      8 => To_US ("eight "),
      9 => To_US ("nine "));

   function Spelled (Value : Natural) return String is
      Result : Unbounded_String := Null_Unbounded_String;
      K      : Natural          := Value;
   begin
      loop
         Result := Numbers_Image (K rem 10) & Result;
         K      := K / 10;
         exit when K = 0;
      end loop;
      return To_String (Result);
   end Spelled;

   procedure Print_Colours is
   begin
      for C1 in Colour loop
         for C2 in Colour loop
            Put_Line
              (To_String (Colour_Image (C1)) &
               " + " &
               To_String (Colour_Image (C2)) &
               " -> " &
               To_String (Colour_Image (Do_Complement (C1, C2))));
         end loop;
      end loop;
      New_Line;
   end Print_Colours;

   -- The procedure that handles the test
   procedure Run (Meetings : Natural; Set : Colour_Set) is
      -- Chameneos are created here
      Creature_Set   : array (Set'Range) of Creature;
      Measures       : Chameneos.Result_Type (Set'Range);
      Total_Meetings : Natural := 0;

   begin
      for I in Set'Range loop
         Put (To_String (Colour_Image (Set (I))) & " ");
      end loop;
      New_Line;

      -- Meeting place initialization
      Place.Init (Meetings);
      -- Rendez-vous to start the tasks
      for I in Set'Range loop
         Creature_Set (I).Start (I, Set (I));
      end loop;

      -- Rendez-vous : waiting for the test to complete
      for I in Set'Range loop
         Creature_Set (I).Report (Measures (I));
      end loop;

      for I in Set'Range loop
         Int_Io.Put (Measures (I).Meetings_Made, Width => 10);
         Put ("  " & Spelled (Measures (I).Meetings_Same));
         New_Line;
      end loop;

      for I in Set'Range loop
         Total_Meetings := Total_Meetings + Measures (I).Meetings_Made;
      end loop;
      Put (Spelled (Total_Meetings));
      New_Line (2);

   exception
      when E : others =>
         Ada.Text_IO.Put_Line
           ("Test failed cause :=" & Exception_Information (E));
   end Run;

end Chameneos;
------------------------------------------------------------------------------
-- The chameneos description
-------------------------------------------------------------------------------
package Chameneos.Creatures is

   --A chameneos is an Ada task
   task type Creature is
      entry Start (Id : in Id_Type; C : in Colour);
      entry Report (Measure : out Measure_Type);
   end Creature;
   -- The meeting place
   protected Place is
      procedure Init (Max_Count : in Natural);
      entry Meet
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour);

   private
      entry Waiting
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour);

      Meetings_Counter   : Natural;
      First_Call         : Boolean;
      A_Colour, B_Colour : Colour;
      A_Name, B_Name     : Id_Type;
   end Place;

end Chameneos.Creatures;
-------------------------------------------------------------------------------
package body Chameneos.Creatures is

   protected body Place is

      procedure Init (Max_Count : in Natural) is
      begin
         Meetings_Counter := Max_Count;
         First_Call       := True;
      end Init;

      entry Meet
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour) when True
      is
      begin
         if (Meetings_Counter = 0) then
            -- The test is finished
            Mall_Open := False;
            -- must give dummy values that will not be used anyway
            C_Other    := C;
            Name_Other := 1;
         else
            Mall_Open := True;
            if (First_Call) then
               A_Colour   := C;
               A_Name     := X;
               First_Call := False;
               requeue Waiting;
            else
               B_Colour         := C;
               B_Name           := X;
               C_Other          := A_Colour;
               Name_Other       := A_Name;
               First_Call       := True;
               Meetings_Counter := Meetings_Counter - 1;
            end if;
         end if;
      end Meet;

      entry Waiting
        (X          : in Id_Type;
         C          : in Colour;
         Mall_Open  : out Boolean;
         Name_Other : out Id_Type;
         C_Other    : out Colour) when First_Call
      is
         pragma Unreferenced (X, C);
      begin
         Mall_Open  := True;
         C_Other    := B_Colour;
         Name_Other := B_Name;
      end Waiting;
   end Place;

   task body Creature is
      My_Id, Other_Id         : Id_Type;
      My_Colour, Other_Colour : Colour;
      Meetings_Made           : Natural := 0;
      Meetings_Same           : Natural := 0;
      Is_Mall_Open            : Boolean;
   begin
      accept Start (Id : in Id_Type; C : in Colour) do
         My_Id     := Id;
         My_Colour := C;
      end Start;
      loop
         Place.Meet (My_Id, My_Colour, Is_Mall_Open, Other_Id, Other_Colour);
         if not Is_Mall_Open then
            -- the test is finished
            exit;
         end if;
         My_Colour     := Do_Complement (My_Colour, Other_Colour);
         Meetings_Made := Meetings_Made + 1;
         if Other_Id = My_Id then
            Meetings_Same := Meetings_Same + 1;
         end if;
      end loop;
      -- Give the results and die.
      accept Report (Measure : out Measure_Type) do
         Measure.Meetings_Made := Meetings_Made;
         Measure.Meetings_Same := Meetings_Same;
      end Report;
   end Creature;

end Chameneos.Creatures;
-- $Id: except.gnat,v 1.1 2004-05-23 06:34:14 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Strings.Fixed, Ada.Command_Line;

procedure Except is
   High_Exception : exception;
   Low_Exception  : exception;
   Low            : Integer := 0;
   High           : Integer := 0;

   procedure Blowup (K : Integer) is
      pragma Inline (Blowup);
   begin
      case 1 = (K mod 2) is
         when False => raise High_Exception;
         when True  => raise Low_Exception;
      end case;
   end Blowup;

   procedure Low_Function (K : Integer) is
      pragma Inline (Low_Function);
   begin
      Blowup (K);
   exception
      when Low_Exception => Low := Low + 1;
   end Low_Function;

   procedure High_Function (K : Integer) is
      pragma Inline (High_Function);
   begin
      Low_Function (K);
   exception
      when High_Exception => High := High + 1;
   end High_Function;

   procedure Some_Function (K : Integer) is
      pragma Inline (Some_Function);
   begin
      High_Function (K);
   exception
      when others => Text_IO.Put_Line ("We shouldn't get here");
   end Some_Function;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for K in reverse 0 .. N - 1 loop
      Some_Function (K);
   end loop;
   Text_IO.Put_Line ("Exceptions: HI=" & L_Trim (Natural'Image (High)) &
            " / LO=" & L_Trim (Natural'Image (Low)));
end Except;
-----------------------------------------------------------------------
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- converted to Ada by Jim Rogers
-- compile: gcc -c -gnatwu -O2 -gnatn -funroll-loops -gnatp fannkuch.adb
-----------------------------------------------------------------------
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_Io; use Ada.Text_Io;

procedure Fannkuch is
   package Pos_Io is new Ada.Text_Io.Integer_Io(Positive);
   use Pos_IO;
   type Perm_Array is array(Natural range <>) of Natural;
   procedure Swap(A, B : in out Natural) is
      Temp : Natural := A;
   begin
      A := B;
      B := Temp;
   end Swap;
   
   function Fann(N : Positive) return Natural is
      M        : Natural := N - 1;
      Perm     : Perm_Array(0..M);
      Perm1    : Perm_Array(0..M);
      Count    : Perm_Array(0..M);
      Max_Flips_Count : Natural:= 0;
      R        : Natural := N;
      Check    : Natural := 0;
   begin
      for I in Perm1'range loop
         Perm1(I) := I;
      end loop;
      loop
         if Check < 30 then
            for I in Perm1'range loop
               Put(Item => Perm1(I) + 1, Width => 1);
            end loop;
            New_Line;
            Check := Check + 1;
         end if;
         while R /= 1 loop
            Count(R - 1) := R;
            R := R - 1;
         end loop;
         if not (Perm1(0) = 0 or Perm1(M) = M) then
            Perm := Perm1;
            declare
               Flips_Count : Natural := 0;
               K           : Natural;
            begin
               loop
                  K := Perm(0);
                  exit when K = 0;
                  for I in 0..((K + 1)/2 -1) loop
                     Swap(Perm(I), Perm(K - I));
                  end loop;
                  Flips_Count := Flips_Count + 1;
               end loop;
               if Flips_Count > Max_Flips_Count then
                  Max_Flips_Count := Flips_Count;
               end if;
            end;
         end if;
         loop
            if R = N then 
               return Max_Flips_Count;
            end if;
            declare
               Perm0 : Natural := Perm1(0);
               J : Natural;
               I : Natural := 0;
            begin
               while I < R loop
                  J := I + 1;
                  Perm1(I) := Perm1(J);
                  I := J;
               end loop;
               Perm1(r) := Perm0;
            end;
            Count(R) := Count(R) - 1;
            exit when Count(R) > 0;
            r := R + 1;
         end loop;
      end loop;
   end Fann;
   Num : Positive := 7;
   Result : Positive;
begin
   if Argument_Count > 0 then
      Num := Positive'Value(Argument(1));
   end if;
   Result := Fann(Num);
   Put("Pfannkuchen(" );
   Put(Item => Num, Width => 0);
   Put(") = ");
   Put(Item => Result, Width => 0);
   New_Line;
end Fannkuch;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Based on code by Dave Fladebo, Eckehard Berns and Heiner Marxen.
-- Based on the ATS version by Hongwei Xi,
-- and the Java version by The Anh Tran.
-- Contributed by Jonathan Parker.
--

with Ada.Command_Line;
with Ada.Text_Io; use Ada.Text_Io;

procedure Fannkuch is

   Multitasking_Version_Desired : constant Boolean := True;

   type Fann_Int is mod 2**64;

   N_image : constant String   := Ada.Command_Line.Argument (1);
   N       : constant Fann_Int := Fann_Int'Value (N_image);

   pragma Assert (N > 0, "Input argument N must be integer > 0.");

   Fann_First : constant Fann_Int := Fann_Int'First;
   Fann_Last  : constant Fann_Int := Fann_Int'First + (N - 1);

   subtype Perm_Index is Fann_Int range Fann_First .. Fann_Last;
   type Permutation is array(Perm_Index) of Fann_Int;

   subtype R_Range is Fann_Int range Fann_First .. Fann_Last-1;

   procedure Get_Count_of_Flips
     (Perm1      : in     Permutation;
      Flip_Count :    out Fann_Int)
   is 
      j, k, tmp : Fann_Int;
      P_1st     : Fann_Int    := Perm1(Fann_First);
      Perm      : Permutation := Perm1;
   begin
      Flip_Count := 0;

      while P_1st /= Fann_First loop  -- Flip until P_1st = Fann_First
         k := P_1st - 1;
         j := Fann_First + 1;
         while j < k loop
            tmp     := Perm(j);
            Perm(j) := Perm(k);
            j := j + 1;
            Perm(k) := tmp;
            k := k - 1;
         end loop;
         tmp         := Perm(P_1st);
         Perm(P_1st) := P_1st;
         P_1st       := tmp;
         Flip_Count  := Flip_Count + 1;
      end loop;
   end Get_Count_of_Flips;

   procedure Get_Another_Permutation
     (Perm       : in out Permutation;
      R_Position : in     Fann_Int)
   is
      tmp : Fann_Int := Perm(Fann_First);
      i   : Fann_Int := Fann_First;
   begin
      while i < R_Position loop
         Perm(i) := Perm(i+1);
         i := i + 1;
      end loop;
      Perm(R_Position) := tmp;
   end Get_Another_Permutation;

   function Max_No_of_Flips_Detected (R : in R_Range) return Fann_Int is
      R_strt, Flip_Count : Fann_Int;
      Perm, Count : Permutation := (others => Fann_Int'First);
      Max_Count : Fann_Int := 0;
   begin
      for m in Fann_First .. Fann_Last loop
         Perm(m) := m;
      end loop;
      Perm(R) := Fann_Last;
      Perm(Fann_Last) := R;

      for m in Fann_First .. Fann_Last loop
         Count(m) := m+1;
      end loop;

      R_strt := Fann_Last-1;
      while R_strt < Fann_Last loop

         Get_Another_Permutation (Perm, R_strt);

         Count(R_strt) := Count(R_strt) - 1;
         if Count(R_strt) > Fann_First then

            while R_strt > Fann_First+1 loop
               Count(R_strt-1) := R_strt;
               R_strt := R_strt - 1;
            end loop;

            if Perm(Fann_Last)  < Fann_Last and then
               Perm(Fann_First) > Fann_First
            then
               Get_Count_of_Flips (Perm, Flip_Count);
               if Flip_Count > Max_Count then  Max_Count := Flip_Count;  end if;
            end if;

         else
            R_strt := R_strt + 1;
         end if;

      end loop;

      return Max_Count;

   end Max_No_of_Flips_Detected;

   --  Uses original sequential method of enumerating permutations. Gives
   --  the right Max_Flips_Counted for N = 1 to 4, if No_of_Perms_to_Do = 30.

   procedure Print_Perms_and_Count_Flips 
     (No_of_Perms_to_Do : in     Fann_Int;
      Max_Flips_Counted :    out Fann_Int) 
   is
      Perm, Count : Permutation := (others => Fann_Int'First);
      F_1st : constant Fann_Int := Fann_Int'First;
      R : Fann_Int := Fann_Last + 1;
      Flip_Count : Fann_Int := 0;
   begin
      Max_Flips_Counted := 0;

      for m in Fann_First .. Fann_Last loop
         Perm(m) := m;
      end loop;

      Print_and_Count: for Lines in 1 .. No_of_Perms_to_Do loop

         for m in Fann_First .. Fann_Last loop
            declare
               Perm_Image : constant String := Fann_Int'Image (Perm(m)+1-F_1st);
            begin
               Put (Perm_Image(2..Perm_Image'Length));
            end;
         end loop;
         New_Line;

         while R > Fann_First+1 loop
            Count(R-1) := R;
            R := R-1;
         end loop;

         if Perm(Fann_Last) < Fann_Last and Perm(Fann_First) > Fann_First then
            Get_Count_of_Flips (Perm, Flip_Count);
            if Flip_Count > Max_Flips_Counted then 
               Max_Flips_Counted := Flip_Count; 
            end if;
         end if;

         Get_Next_Perm: loop
            exit Print_and_Count when R > Fann_Last;
            Get_Another_Permutation (Perm, R);
            Count(R) := Count(R) - 1;
            exit Get_Next_Perm when Count(R) > Fann_First;
            R := R + 1;
         end loop Get_Next_Perm;

      end loop Print_and_Count;

   end Print_Perms_and_Count_Flips;

   Store_of_Max_Flip_Counts : Permutation := (others => 0);
   Max_Flips, F, Initial_Count : Fann_Int := 0;

begin

   Print_Perms_and_Count_Flips 
     (No_of_Perms_to_Do => 30, 
      Max_Flips_Counted => Initial_Count);

   if N < 4 then -- use the above results, and terminate the procedure:
      Put ("Pfannkuchen("); Put (N_image); Put (") =");
      Put (Fann_Int'Image (Initial_Count));
      return;
   end if;

   if Multitasking_Version_Desired then

      declare  -- and launch 1 task for each R in R_Range:

         task type Flip_Counter is
            entry Start (R : in Fann_Int);
            entry Return_Result (Max_Flip_Count_for_R : out Fann_Int);
         end Flip_Counter;

         task body Flip_Counter is
            R_local, Count_for_R : Fann_Int;
         begin
            accept Start (R : in Fann_Int) do
               R_local := R;
            end Start;

            Count_for_R := Max_No_of_Flips_Detected (R_local);

            accept Return_Result (Max_Flip_Count_for_R : out Fann_Int) do
               Max_Flip_Count_for_R := Count_for_R;
            end Return_Result;
         end Flip_Counter;

         Counter : array(R_Range) of Flip_Counter; -- the tasks.

      begin 
         for R in R_Range loop
            Counter(R).Start (R);
         end loop;

         for R in R_Range loop
            Counter(R).Return_Result (F);
            Store_of_Max_Flip_Counts(R) := F;
         end loop;
      end;

   else   -- Sequential:
    
      for R in R_Range loop
         Store_of_Max_Flip_Counts(R) := Max_No_of_Flips_Detected (R);
      end loop;

   end if;

   Max_Flips := 0;
   for R in R_Range loop
      if Store_of_Max_Flip_Counts(R) > Max_Flips then
         Max_Flips := Store_of_Max_Flip_Counts(R);
      end if;
   end loop;

   Put ("Pfannkuchen("); Put (N_image); Put (") =");
   Put (Fann_Int'Image (Max_Flips));

end Fannkuch;

--
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Based on code by Dave Fladebo, Eckehard Berns, Heiner Marxen, Hongwei Xi,
-- and The Anh Tran, and on the Java version of fannkuchredux by Oleg Mazurov.
-- Contributed by Jonathan Parker, Oct 2010.
--

with Ada.Command_Line;
with Ada.Text_Io; use Ada.Text_Io;

procedure Fannkuchredux is

   Multitasking_Desired : constant Boolean := True;

   type Fann_Int is mod 2**64;

   N_image : constant String   := Ada.Command_Line.Argument (1);
   N       : constant Fann_Int := Fann_Int'Value (N_image);

   pragma Assert (N > 1,  "Input argument N must be integer > 1.");
   pragma Assert (N < 21, "Input argument N must be integer < 21.");
   --  21! is too large for a 64-bit Fann_Int.

   Fann_0 : constant Fann_Int := 0;
   Fann_First : constant Fann_Int := Fann_0;
   Fann_Last  : constant Fann_Int := Fann_0 + (N - 1);

   subtype Perm_Index is Fann_Int range Fann_First .. Fann_Last;
   type Permutation is array(Perm_Index) of Fann_Int;

   -- The N! permutations are indexed from 0 to N!-1.  The indices 
   -- and the factorials have type Perm_id_Range. 

   subtype Perm_id_Range is Fann_Int;
   subtype Enum_Index is Fann_Int range Fann_First .. Fann_Last+1;
   type Enumeration is array(Enum_Index) of Perm_id_Range; -- holds N!'s

   No_of_Tasks : constant := 12; 
   -- Using stnd setting of 12, Chunk_Size = (N! / No_of_Tasks) is even for N>3.

   type Task_id_Range is range 1 .. No_of_Tasks;

   type Integer_64 is range -2**63+1 .. 2**63-1; -- for checksums

   procedure Get_Count_of_Flips
     (Perm       : in    Permutation;
      Flip_Count :   out Fann_Int)
   is 
      Lo, Hi : Fann_Int;
      tmp    : Fann_Int;
      P_1st  : Fann_Int    := Perm(Fann_First);
      Perm1  : Permutation := Perm;
   begin
      Flip_Count := Fann_0;
      while P_1st /= Fann_First loop  -- Flip until P_1st = Fann_First
         Hi := P_1st - 1;
         Lo := Fann_First + 1;
         while Lo < Hi loop
            tmp       := Perm1(Lo);
            Perm1(Lo) := Perm1(Hi);
            Lo := Lo + 1;
            Perm1(Hi) := tmp;
            Hi := Hi - 1;
         end loop;
         tmp          := Perm1(P_1st);
         Perm1(P_1st) := P_1st;
         P_1st        := tmp;
         Flip_Count   := Flip_Count + 1;
      end loop;
   end Get_Count_of_Flips;

   procedure Get_First_Permutation 
     (Perm_id   : in     Perm_id_Range;
      Factorial : in     Enumeration;
      Perm      :    out Permutation;
      Count     :    out Permutation) 
   is
      p_id : Perm_id_Range := Perm_id;
      Perm1 : Permutation;
      d : Fann_Int;
   begin
      Count := (others => Fann_Int'First);

      for i in Perm'Range loop
         Perm(i) := i;
      end loop;

      for i in reverse Count'First+1 .. Count'Last loop
         d        := Fann_Int (p_id  /  Factorial(i));
         p_id     := p_id mod Factorial(i); 
         Count(i) := d;

         Perm1 := Perm;
         for j in 0 .. i loop
            if j+d <= i then
               Perm(j) :=  Perm1(j+d);
            else
               Perm(j) :=  Perm1(j+d-i-1);
            end if;
         end loop;
      end loop;

   end Get_First_Permutation;

   procedure Get_Next_Permutation 
     (Perm  : in out Permutation;
      Count : in out Permutation)
   is
      i : Fann_Int := 1;
      First : Fann_Int := Perm(1);
      Next_First : Fann_Int;
   begin
      Perm(1) := Perm(0);
      Perm(0) := First;

      Count(i) := Count(i) + 1;
      while  Count(i) > i  loop
         Count(i) := 0;
         i := i + 1;

         Perm(0)    := Perm(1);
         Next_First := Perm(1);
         for j in 1 .. i-1  loop
            Perm(j) := Perm(j+1);  
         end loop;
         Perm(i) := First;
         First   := Next_First;

         Count(i) := Count(i) + 1;
      end loop;

   end Get_Next_Permutation;

   procedure Get_Checksum_and_Flips 
     (Task_id   : in     Task_id_Range;
      Factorial : in     Enumeration;
      Max_Flips :    out Fann_Int;
      Checksum  :    out Integer_64)
   is
      Perm_id, Perm_id_Min, Perm_id_Max : Perm_id_Range;
      Flip_Count  : Fann_Int;
      Perm, Count : Permutation;
      Chunk_Size  : Perm_id_Range;
   begin

      Chunk_Size := Factorial(N) / No_of_Tasks;
      pragma Assert (Chunk_Size mod 2 = 0); -- so checksums work if No_of_Tasks>1.

      Perm_id_Min := Perm_id_Range (Task_id - Task_id_Range'First) * Chunk_Size;
      Perm_id_Max := Perm_id_Range'Min (Factorial(N), Perm_id_Min+Chunk_Size) - 1;
      --  for the First task:   Perm_id_Min = 0;  Perm_id_Max := Chunk_Size-1
      --  Perm_id ultimately runs from 0 .. Factorial(N)-1

      Get_First_Permutation (Perm_id_Min, Factorial, Perm, Count);
      --  Initialize Perm and Count

      Max_Flips := 1;
      Checksum  := 0;
      Perm_id   := Perm_id_Min;
      loop
         if  Perm(0) /= 0  then
            Get_Count_of_Flips (Perm, Flip_Count);
            Max_Flips := Fann_Int'Max (Max_Flips, Flip_Count);
            if Perm_id mod 2 = 0 then 
               Checksum := Checksum + Integer_64 (Flip_Count); 
            else 
               Checksum := Checksum - Integer_64 (Flip_Count); 
            end if;
         end if;

         exit when Perm_id = Perm_id_Max;  -- return
         Perm_id := Perm_id + 1;

         Get_Next_Permutation (Perm, Count);
      end loop;

   end Get_Checksum_and_Flips;

   task type Flip_Counter is
      pragma Storage_Size (2**14);
      entry Start 
        (Task_id   : in Task_id_Range;
         Factorial : in Enumeration);
      entry Return_Result 
        (Partial_Flip_Count : out Fann_Int;
         Partial_Checksum   : out Integer_64);
   end Flip_Counter;

   task body Flip_Counter is
      Task_id_Local : Task_id_Range;
      Max_Flips     : Fann_Int;
      Checksum      : Integer_64;
      F : Enumeration;
   begin
      accept Start 
        (Task_id   : in Task_id_Range;
         Factorial : in Enumeration)
      do
         Task_id_Local := Task_id;
         F := Factorial;
      end Start;

      Get_Checksum_and_Flips (Task_id_Local, F, Max_Flips, Checksum);

      accept Return_Result 
        (Partial_Flip_Count : out Fann_Int;
         Partial_Checksum   : out Integer_64)
      do
         Partial_Flip_Count := Max_Flips;
         Partial_Checksum   := Checksum;
      end Return_Result;
   end Flip_Counter;

   type Flip_Data   is array (Task_id_Range) of Fann_Int;
   type Chksum_Data is array (Task_id_Range) of Integer_64;
   Flip_Count_Storage : Flip_Data   := (others => 0);
   Checksum_Storage   : Chksum_Data := (others => 0);
   Checksum  : Integer_64 := 0;
   Max_Flips : Fann_Int   := 0;

   Factorial : Enumeration;

begin
   if not (N > 3 or (not Multitasking_Desired and No_of_Tasks = 1)) then
      Put_Line ("Set Multitasking_Desired = False and No_of_Tasks = 1 for N < 4");
      raise Program_Error;
   end if;

   Factorial(0) := 1;
   for i in Enum_Index range 1 .. Enum_Index'Last loop
      Factorial(i) := Factorial(i-1) * Perm_id_Range (i);
   end loop;

   if Multitasking_Desired then

      declare  -- and launch 1 task for each t in Task_id_Range:

         Counter : array(Task_id_Range) of Flip_Counter; -- the tasks.

      begin 

         for t in Task_id_Range loop
            Counter(t).Start (t, Factorial);
         end loop;

         for t in Task_id_Range loop
            Counter(t).Return_Result (Max_Flips, Checksum);
            Flip_Count_Storage(t) := Max_Flips;
            Checksum_Storage(t)   := Checksum;
         end loop;

      end;

   else  -- Sequential:
    
      for t in Task_id_Range loop
         Get_Checksum_and_Flips (t, Factorial, Max_Flips, Checksum);
         Flip_Count_Storage(t) := Max_Flips;
         Checksum_Storage(t)   := Checksum;
      end loop;

   end if;

   Max_Flips := 0;
   for t in Task_id_Range loop
      if Flip_Count_Storage(t) > Max_Flips then
         Max_Flips := Flip_Count_Storage(t);
      end if;
   end loop;

   Checksum := 0;
   for t in Task_id_Range loop
      Checksum := Checksum + Checksum_Storage(t); 
   end loop;

   declare
      C_Image : constant String := Integer_64'Image (Checksum);
   begin
      Put_Line (C_image(2..C_image'Last));
      Put ("Pfannkuchen("); Put (N_image); Put (") =");
      Put (Fann_Int'Image (Max_Flips));
   end;

end Fannkuchredux;
--
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Based on code by Dave Fladebo, Eckehard Berns, Heiner Marxen, Hongwei Xi,
-- and The Anh Tran, and on the Java version of fannkuchredux by Oleg Mazurov.
-- Contributed by Jonathan Parker and Georg Bauhaus, Nov 2010.
--

with Ada.Command_Line;
with Ada.Text_Io; use Ada.Text_Io;
with System;

procedure Fannkuchredux is

   Multitasking_Desired : constant Boolean := True;

   type Fann_Int is mod 2**System.Word_Size;

   pragma Assert (Ada.Command_Line.Argument_Count = 1, 
     "Exactly one input argument is required.");

   N_image : constant String   := Ada.Command_Line.Argument (1);
   N       : constant Fann_Int := Fann_Int'Value (N_image);

   pragma Assert (N > 1,  "Input argument N must be integer > 1.");

   Fann_0 : constant Fann_Int := 0;
   Fann_First : constant Fann_Int := Fann_0;
   Fann_Last  : constant Fann_Int := Fann_0 + (N - 1);

   subtype Perm_Index is Fann_Int range Fann_First .. Fann_Last;

   type Permutation is array(Perm_Index) of Fann_Int;

   -- The N! permutations are indexed from 0 to N!-1.  The indices 
   -- and the factorials have type Perm_id_Range. 

   type Perm_id_Range is mod 2**System.Word_Size;
   pragma Assert (N < 13 or System.Word_Size = 64);
   pragma Assert (N < 21, "Input argument N must be integer < 21.");

   subtype Enum_Index is Fann_Int range Fann_First .. Fann_Last+1;
   type Enumeration is array(Enum_Index) of Perm_id_Range; -- holds N!'s

   No_of_Tasks : constant := 12;
   -- Using stnd setting of 12, Chunk_Size = (N! / No_of_Tasks) is even for N>3.

   type Task_id_Range is range 1 .. No_of_Tasks;

   type Checksum_Int is range
      -2**(System.Word_Size-1)+1 .. 2**(System.Word_Size-1)-1; -- for checksums


   function Count_of_Flips
     (Perm : in Permutation)
      return Fann_Int
   is 
      Flip_Count : Fann_Int := 0;
      Lo, Hi : Fann_Int;
      tmp    : Fann_Int := 1;
      P_1st  : Fann_Int    := Perm(Perm'First);
      Perm1  : Permutation := Perm;
   begin
      loop                      -- Flip until P_1st = Fann_First
         exit when P_1st = Fann_First;
         Flip_Count := Flip_Count + 1;
         Lo := Fann_First + 1;
         Hi := P_1st - 1;
         while Lo < Hi loop
            tmp       := Perm1(Lo);
            Perm1(Lo) := Perm1(Hi);
            Lo := Lo + 1;
            Perm1(Hi) := tmp;
            Hi := Hi - 1;
         end loop;
         tmp          := Perm1(P_1st);
         Perm1(P_1st) := P_1st;
         P_1st        := tmp;
      end loop;
      return Flip_Count;
   end Count_of_Flips;

   procedure Get_First_Permutation 
     (Perm_id   : in     Perm_id_Range;
      Factorial : in     Enumeration;
      Perm      :    out Permutation;
      Count     :    out Permutation) 
   is
      d : Fann_Int;
      p_id : Perm_id_Range := Perm_id;
      Perm1 : Permutation;
   begin
      Count := (others => Fann_Int'First);
      Perm  := (others => Fann_Int'First);

      for i in Perm'Range loop
         Perm(i) := i;
      end loop;

      for i in reverse Fann_First+1 .. Fann_Last loop
         d        := Fann_Int (p_id  /  Factorial(i));
         p_id     := p_id mod Factorial(i); 
         Count(i) := d;

         Perm1 := Perm;
         for j in 0 .. i loop
            if j+d <= i then
               Perm(j) :=  Perm1(j+d);
            else
               Perm(j) :=  Perm1(j+d-i-1);
            end if;
         end loop;
      end loop;

   end Get_First_Permutation;

   procedure Get_Next_Permutation 
     (Perm  : in out Permutation;
      Count : in out Permutation)
   is
      Next_First : Fann_Int;
      i, j  : Fann_Int := 1;
      First : Fann_Int := Perm(1);
   begin
      Perm(1) := Perm(0);
      Perm(0) := First;
      Count(i) := Count(i) + 1;
    
      if Count(i) > i then
      loop
         Count(i) := 0;

         j := 1;
         i := i + 1;
         Next_First := Perm(1);
         Perm(0)    := Next_First;
         loop
            Perm(j) := Perm(j+1);
            j := j+1;
            exit when j = i;
         end loop;
         Perm(i)  := First;
         First    := Next_First;
         Count(i) := Count(i) + 1;
         exit when Count(i) <= i;
      end loop;
      end if;

   end Get_Next_Permutation;

   procedure Get_Checksum_and_Flips 
     (Task_id   : in     Task_id_Range;
      Factorial : in     Enumeration;
      Max_Flips :    out Fann_Int;
      Checksum  :    out Checksum_Int)
   is
      Perm_id, Perm_id_Min, Perm_id_Max : Perm_id_Range;
      Flip_Count  : Fann_Int;
      Perm, Count : Permutation;
      Chunk_Size  : Perm_id_Range;
   begin

      Chunk_Size := Factorial(N) / No_of_Tasks;
      pragma Assert (Chunk_Size mod 2 = 0); -- so checksums work if No_of_Tasks>1.

      Perm_id_Min := Perm_id_Range (Task_id - Task_id_Range'First) * Chunk_Size;
      Perm_id_Max := Perm_id_Range'Min (Factorial(N), Perm_id_Min+Chunk_Size) - 1;
      --  for the First task:   Perm_id_Min = 0;  Perm_id_Max := Chunk_Size-1
      --  Perm_id ultimately runs from 0 .. Factorial(N)-1

      Get_First_Permutation (Perm_id_Min, Factorial, Perm, Count);
      --  Initialize Perm and Count

      Max_Flips := 1;
      Checksum  := 0;
      Perm_id   := Perm_id_Min;
      loop

         if  Perm(0) > 0  then
            Flip_Count := Count_of_Flips (Perm);
            Max_Flips  := Fann_Int'Max (Max_Flips, Flip_Count);
            if Perm_id mod 2 = 0 then 
               Checksum := Checksum + Checksum_Int (Flip_Count); 
            else 
               Checksum := Checksum - Checksum_Int (Flip_Count); 
            end if;
         end if;

         exit when Perm_id >= Perm_id_Max;
         Perm_id := Perm_id + 1;
         Get_Next_Permutation (Perm, Count);

      end loop;

   end Get_Checksum_and_Flips;

   task type Flip_Counter is
      pragma Storage_Size (2**12);
      entry Start 
        (Task_id   : in Task_id_Range;
         Factorial : in Enumeration);
      entry Return_Result 
        (Partial_Flip_Count : out Fann_Int;
         Partial_Checksum   : out Checksum_Int);
   end Flip_Counter;


   task body Flip_Counter is
      Task_id_Local : Task_id_Range;
      Max_Flips     : Fann_Int;
      Checksum      : Checksum_Int;
      F : Enumeration;
   begin
      accept Start 
        (Task_id   : in Task_id_Range;
         Factorial : in Enumeration)
      do
         Task_id_Local := Task_id;
         F := Factorial;
      end Start;

      Get_Checksum_and_Flips (Task_id_Local, F, Max_Flips, Checksum);

      accept Return_Result 
        (Partial_Flip_Count : out Fann_Int;
         Partial_Checksum   : out Checksum_Int)
      do
         Partial_Flip_Count := Max_Flips;
         Partial_Checksum   := Checksum;
      end Return_Result;
   end Flip_Counter;

   type Flip_Data   is array (Task_id_Range) of Fann_Int;
   type Chksum_Data is array (Task_id_Range) of Checksum_Int;
   Flip_Count_Storage : Flip_Data   := (others => 0);
   Checksum_Storage   : Chksum_Data := (others => 0);
   Max_Flips : Fann_Int     := 0;
   Checksum  : Checksum_Int := 0;

   Factorial : Enumeration;

begin
   if not (N > 3 or (not Multitasking_Desired and No_of_Tasks = 1)) then
      Put_Line ("Set Multitasking_Desired = False and No_of_Tasks = 1 for N < 4");
      raise Program_Error;
   end if;

   Factorial(0) := 1;
   for i in Enum_Index range 1 .. Enum_Index'Last loop
      Factorial(i) := Factorial(i-1) * Perm_id_Range (i);
   end loop;

   if Multitasking_Desired then

      declare  -- and launch 1 task for each t in Task_id_Range:

         Counter : array(Task_id_Range) of Flip_Counter; -- the tasks.

      begin 

         for t in Task_id_Range loop
            Counter(t).Start (t, Factorial);
         end loop;

         for t in Task_id_Range loop
            Counter(t).Return_Result (Max_Flips, Checksum);
            Flip_Count_Storage(t) := Max_Flips;
            Checksum_Storage(t)   := Checksum;
         end loop;

      end;

   else  -- Sequential:
    
      for t in Task_id_Range loop
         Get_Checksum_and_Flips (t, Factorial, Max_Flips, Checksum);
         Flip_Count_Storage(t) := Max_Flips;
         Checksum_Storage(t)   := Checksum;
      end loop;

   end if;

   Max_Flips := 0;
   for t in Task_id_Range loop
      if Flip_Count_Storage(t) > Max_Flips then
         Max_Flips := Flip_Count_Storage(t);
      end if;
   end loop;

   Checksum := 0;
   for t in Task_id_Range loop
      Checksum := Checksum + Checksum_Storage(t); 
   end loop;

   declare
      C_Image : constant String := Checksum_Int'Image (Checksum);
   begin
      Put_Line (C_image(2..C_image'Last));
      Put ("Pfannkuchen("); Put (N_image); Put (") =");
      Put (Fann_Int'Image (Max_Flips));
   end;

end Fannkuchredux;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/04/07

package Fasta_Pck is

   type Real is new Long_Float;

   type Aminoacid is record
      C : Character;
      P : Real;
   end record;

   type Aminoacid_Set is array (Positive range <>) of Aminoacid;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set);

   function Select_Random (Gene_List : in Aminoacid_Set) return Character;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive);

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive);

end Fasta_Pck;

with Ada.Text_IO; use Ada.Text_IO;

package body Fasta_Pck is

   Line_Length : constant := 60;

   Last        : Natural := 42;

   function Gen_Random (Max : in Real) return Real;
   pragma Inline (Gen_Random);

   function Gen_Random (Max : in Real) return Real is
      IM : constant := 139_968;
      IA : constant :=   3_877;
      IC : constant :=  29_573;
   begin
      Last := (Last * IA + IC) mod IM;
      return (Max * Real (Last)) / Real (IM);
   end Gen_Random;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set) is
      C : Real := Gene_List (Gene_List'First).P;
   begin
      for K in Gene_List'First + 1 .. Gene_List'Last loop
         C := C + Gene_List (K).P;
         Gene_List (K).P := C;
      end loop;
   end Make_Cumulative;

   function Select_Random (Gene_List : in Aminoacid_Set) return Character is
      R         : Real := Gen_Random (1.0);
      I, Lo, Hi : Integer;
   begin
      if R < Gene_List (Gene_List'First).P then
         return Gene_List (Gene_List'First).C;
      end if;

      Lo := 0;
      Hi := Gene_List'Last;

      while Hi > Lo + 1 loop
         I := (Hi + Lo) / 2;
         if R < Gene_List (I).P then
            Hi := I;
         else
            Lo := I;
         end if;
      end loop;

      return Gene_List (Hi).C;
   end Select_Random;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive)
   is
      Todo : Integer := N;
      M    : Integer;
      Pick : String (1 .. Line_Length);
   begin
      Put_Line (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         M := Natural'Min (Todo, Line_Length);

         for K in 1 .. M loop
            Pick (K) := Select_Random (Gene_List);
         end loop;

         Put_Line (Pick (1 .. M));
         Todo := Todo - Line_Length;
      end loop;
   end Make_Random_Fasta;

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive) is
      Todo : Integer := N;
      K    : Positive := S'First;
      M    : Natural;
   begin
      Put_Line (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         M := Natural'Min (Todo, Line_Length);

         while M >= S'Length - K + S'First loop
            Put (S (K .. S'Last));
            M := M - (S'Length - K + S'First);
            K := S'First;
         end loop;

         Put_Line (S (K .. K + M - S'First));
         K := K + M - S'First + 1;

         Todo := Todo - Line_Length;
      end loop;
   end Make_Repeat_Fasta;

end Fasta_Pck;

with Ada.Command_Line; use Ada.Command_Line;
with Fasta_Pck;        use Fasta_Pck;

procedure Fasta is
   Homosapiens : Aminoacid_Set :=
                   (('a', 0.3029549426680), ('c', 0.1979883004921),
                    ('g', 0.1975473066391), ('t', 0.3015094502008));
   Iub         : Aminoacid_Set :=
                   (('a', 0.27), ('c', 0.12), ('g', 0.12), ('t', 0.27),
                    ('B', 0.02), ('D', 0.02), ('H', 0.02), ('K', 0.02),
                    ('M', 0.02), ('N', 0.02), ('R', 0.02), ('S', 0.02),
                    ('V', 0.02), ('W', 0.02), ('Y', 0.02));
   Alu         : constant String :=
                    "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" &
                    "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" &
                    "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" &
                    "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" &
                    "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" &
                    "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" &
                    "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

   N           : constant Positive := Positive'Value (Argument (1));

begin
   Make_Cumulative (Iub);
   Make_Cumulative (Homosapiens);

   Make_Repeat_Fasta ("ONE", "Homo sapiens alu", alu, N * 2);
   Make_Random_Fasta ("TWO", "IUB ambiguity codes", Iub, N * 3);
   Make_Random_Fasta
     ("THREE", "Homo sapiens frequency", Homosapiens, N * 5);
end Fasta;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Based on code by Pascal Obry, Gautier de Montmollin, Andrew Moon
-- Jason Blevins, and Petr Prokhorenkov
-- Contributed by Jonathan Parker and Georg Bauhaus (Nov 2010)


with Ada.Command_Line; use Ada.Command_Line;
with Ada.Streams.Stream_IO;

procedure Fasta is

   type Real is digits 15;

   type Gene_id_Type is range -2**15 .. 2**15-1;

   type Aminoacid is record
      C : Character;  -- IUB code
      P : Real;       -- probability
   end record;

   type Aminoacid_Set is array (Gene_id_Type range <>) of Aminoacid;

   Homo_Sapiens : constant Aminoacid_Set(0 .. 3) :=
    (('a', 0.3029549426680), ('c', 0.1979883004921),
     ('g', 0.1975473066391), ('t', 0.3015094502008));

   Genes : constant Aminoacid_Set(0 .. 14) :=
    (('a', 0.27), ('c', 0.12), ('g', 0.12), ('t', 0.27),
     ('B', 0.02), ('D', 0.02), ('H', 0.02), ('K', 0.02),
     ('M', 0.02), ('N', 0.02), ('R', 0.02), ('S', 0.02),
     ('V', 0.02), ('W', 0.02), ('Y', 0.02));

   ALU : constant String :=
     "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG" &
     "GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA" &
     "GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA" &
     "AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT" &
     "CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC" &
     "CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG" &
     "CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

   ALU_Length : constant Positive := ALU'Length;

   Lookup_Table_Size : constant := 4096;
   Lookup_Scale : constant Real := Real (Lookup_Table_Size - 1);

   type Lookup_Table is
      array (Gene_id_Type range 0..Lookup_Table_Size-1) of Gene_id_Type;

   type Random_State is mod 2**32;
   Max   : constant Real := 1.0;
   Seed  : constant := 42;
   State : Random_State := Seed;

   Line_Length : constant Positive := 60;
   End_of_Line : constant String := (1 => ASCII.LF);

   package Streamed_Line_IO is

      procedure Put (Item : String);

      procedure Close;  --  close output

   end Streamed_Line_IO;


   package body Streamed_Line_IO is

      use Ada.Streams;

      Stdout : Stream_IO.File_Type;

      procedure Put (Item : String) is
         subtype Index is Stream_Element_Offset range 1 .. Item'Length;
         subtype XBytes is Stream_Element_Array (Index);
         Item_Bytes: XBytes;
         pragma Import (Ada, Item_Bytes);
         for Item_Bytes'Address use Item'Address;
         pragma Assert (Item'Size = Item_Bytes'Size);
      begin
         Stream_IO.Write (Stdout, Item_Bytes);
      end Put;

      procedure Close is
      begin
         Stream_IO.Close (Stdout);
      end Close;

   begin
      Stream_IO.Open (Stdout,
                      Mode => Stream_IO.Out_File,
                      Name => "/dev/stdout");
   end Streamed_Line_IO;


   procedure Gen_Random
     (Next_Result :    out Real;
      State       : in out Random_State)
   is
      IM : constant := 139_968;
      IA : constant :=   3_877;
      IC : constant :=  29_573;
   begin
      State := (State * IA + IC) mod IM;
      Next_Result := Max *(Real (State)) * (Lookup_Scale / Real (IM));
   end Gen_Random;


   procedure New_Line is begin
      Streamed_Line_IO.Put (End_of_Line);
   end New_Line;

   procedure Repeat
     (Title : in String;
      N     : in Natural)
   is
      Buffer : String(1 .. ALU_Length + Line_Length);
      nn, pos, bytes : Integer;
   begin
      nn := N;
      pos := 1;

      Buffer(1 .. ALU_Length) := ALU(1 .. ALU_Length);
      Buffer(ALU_Length+1 .. Buffer'Last) := ALU(1 .. Buffer'Last-ALU_Length);

      Streamed_Line_IO.Put (Title); New_Line;

      while nn > 1 loop
         Bytes := Positive'Min (Line_Length, Nn);

         Streamed_Line_IO.Put (Buffer(pos .. pos+bytes-1)); New_Line;

         pos := pos + bytes;
         if pos > ALU_Length then
            pos := pos - ALU_Length;
         end if;
         nn := nn - bytes;
      end loop;
   end Repeat;


   procedure Randomize
     (Genes : in Aminoacid_Set;
      Title : in String;
      N     : in Integer)
   is
      Line_Buffer : String (1 .. Line_Length + End_of_Line'Length);
      Gene_Lookup : Lookup_Table;
      Cumulative_Prob : array (Gene_id_Type range 0..15) of Real;
      j : Positive;
      u : Gene_id_Type;
      r : Real;
      Local_State : Random_State;

      procedure Init_Lookup_Table (Genes : in Aminoacid_Set) is
         Sum_of_Ps : Real := 0.0;
      begin
         for i in Genes'Range loop
            Sum_of_Ps := Sum_of_Ps + Genes(i).p;
            Cumulative_Prob (i) := Sum_of_Ps * Lookup_Scale;
         end loop;

         Cumulative_Prob(Genes'Last) := Lookup_Scale;

         declare
            g : Gene_id_Type := Genes'First;
            Threshold : Real := Real(Gene_Lookup'First) - 1.0;
         begin
            for i in Gene_Lookup'Range loop
               while Cumulative_Prob(g) < Threshold loop
                  g := g + 1;
               end loop;
               Threshold := Threshold + 1.0;
               Gene_Lookup(i) := g;
            end loop;
         end;
      end Init_Lookup_Table;

      subtype Line_End_Positions is Positive
        range Line_Buffer'Last - End_of_Line'Length + 1 .. Line_Buffer'Last;
   begin
      Streamed_Line_IO.Put (Title); New_Line;

      Init_Lookup_Table (Genes);

      Line_Buffer(Line_End_Positions) := End_of_Line;

      Local_State := State;
      j := 1;
      for i in 1 .. N loop
         Gen_Random(r, Local_State);
         u := Gene_Lookup(Gene_id_Type(Real'Truncation(r)));
         while Cumulative_Prob(u) < r loop
            u := u + 1;
         end loop;

         Line_Buffer(j) := Genes(u).C;

         if j = Line_Length then
            Streamed_Line_IO.Put (Line_Buffer);
            j := 1;
         else
            j := j + 1;
         end if;
      end loop;
      if j > 1 then
         Streamed_Line_IO.Put (Line_Buffer(1 .. j-1) & End_of_Line);
      end if;

      State := Local_State;
   end Randomize;

   N : constant Positive := Positive'Value (Argument (1));

begin

  Repeat (">ONE Homo sapiens alu", N*2);
  Randomize (Genes, ">TWO IUB ambiguity codes", N*3);
  Randomize (Homo_Sapiens, ">THREE Homo sapiens frequency", N*5);

  Streamed_Line_IO.Close;

end Fasta;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
--
-- contributed by Pascal Obry on 2005/04/07
-- modified by Gautier de Montmollin,
--                     Georg Bauhaus, Jonathan Parker,
--                 and comp.lang.ada in Summer 2009

package Fasta_Pck is

   type Real is new Long_Float;

   type Aminoacid is record
      C : Character;
      P : Real;
   end record;

   type Aminoacid_Set is array (Positive range <>) of Aminoacid;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set);

   function Select_Random (Gene_List : in Aminoacid_Set) return Character;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive);

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive);

private
   pragma Inline (Select_Random);
end Fasta_Pck;

with Ada.Streams.Stream_IO;  use Ada.Streams;
with Unchecked_Conversion;

package body Fasta_Pck is

   Line_Length : constant := 60;

   type Uns_32 is mod 2**32;

   Last        : Uns_32 := 42;

   function Gen_Random (Max : in Real) return Real;
   pragma Inline (Gen_Random);

   function Gen_Random (Max : in Real) return Real is
      IM : constant := 139_968;
      IA : constant :=   3_877;
      IC : constant :=  29_573;
   begin
      Last := (Last * IA + IC) mod IM;
      return (Max * Real (Last)) * (1.0 / Real (IM));
   end Gen_Random;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set) is
      C : Real := Gene_List (Gene_List'First).P;
   begin
      for K in Gene_List'First + 1 .. Gene_List'Last loop
         C := C + Gene_List (K).P;
         Gene_List (K).P := C;
      end loop;
   end Make_Cumulative;

   function Select_Random (Gene_List : in Aminoacid_Set) return Character is
      R         : constant Real := Gen_Random (1.0);
      I, Lo, Hi : Integer;
   begin
      if R < Gene_List (Gene_List'First).P then
         return Gene_List (Gene_List'First).C;
      end if;

      Lo := 0;
      Hi := Gene_List'Last;

      while Hi > Lo + 1 loop
         I := (Hi + Lo) / 2;
         if R < Gene_List (I).P then
            Hi := I;
         else
            Lo := I;
         end if;
      end loop;

      return Gene_List (Hi).C;
   end Select_Random;


   Stdout : Stream_IO.File_Type;

   procedure Print (Item : String) is
      subtype Index is Stream_Element_Offset range
        Stream_Element_Offset(Item'First)
        .. Stream_Element_Offset(Item'Last + 1);
      subtype XString is String (Item'First .. Item'Last + 1);
      subtype XBytes is Stream_Element_Array (Index);
      function To_Bytes is new Unchecked_Conversion
        (Source => XString,
         Target => XBytes);
   begin
      Stream_IO.Write (Stdout, To_Bytes (Item & ASCII.LF));
   end Print;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive)
   is
      Todo : Integer := N;
      M    : Integer;
      Pick : String (1 .. Line_Length);
   begin
      Print (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         M := Natural'Min (Todo, Line_Length);

         for K in 1 .. M loop
            Pick (K) := Select_Random (Gene_List);
         end loop;

         Print (Pick (1 .. M));
         Todo := Todo - Line_Length;
      end loop;
   end Make_Random_Fasta;

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive) is
      Todo : Integer := N;
      K    : Positive := S'First;
      S_App: constant String := S & S(S'First .. S'First + Line_Length);
   begin
      Print (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         Print (S_App (K .. K + Integer'Min(Todo, Line_Length) - 1));
         K := K + Line_Length;
         if K > S'Last then -- we are on the extra characters
           K:= K - S'Length;
         end if;
         Todo := Todo - Line_Length;
      end loop;

   end Make_Repeat_Fasta;

begin
   Stream_IO.Open (Stdout,
                   Mode => Stream_IO.Out_File,
                   Name => "/dev/stdout");
end Fasta_Pck;

with Ada.Command_Line; use Ada.Command_Line;
with Fasta_Pck;        use Fasta_Pck;

procedure Fasta is
   Homosapiens : Aminoacid_Set :=
                   (('a', 0.3029549426680), ('c', 0.1979883004921),
                    ('g', 0.1975473066391), ('t', 0.3015094502008));
   Iub         : Aminoacid_Set :=
                   (('a', 0.27), ('c', 0.12), ('g', 0.12), ('t', 0.27),
                    ('B', 0.02), ('D', 0.02), ('H', 0.02), ('K', 0.02),
                    ('M', 0.02), ('N', 0.02), ('R', 0.02), ('S', 0.02),
                    ('V', 0.02), ('W', 0.02), ('Y', 0.02));
   Alu         : constant String :=
                    "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" &
                    "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" &
                    "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" &
                    "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" &
                    "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" &
                    "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" &
                    "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

   N           : constant Positive := Positive'Value (Argument (1));

begin
   Make_Cumulative (Iub);
   Make_Cumulative (Homosapiens);

   Make_Repeat_Fasta ("ONE", "Homo sapiens alu", alu, N * 2);
   Make_Random_Fasta ("TWO", "IUB ambiguity codes", Iub, N * 3);
   Make_Random_Fasta
     ("THREE", "Homo sapiens frequency", Homosapiens, N * 5);
end Fasta;
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22

with Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;
use  Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;

with Pck_Fibo;

procedure Fibo is
   N : Natural;
begin
   N := Natural'Value (Argument (1));
   Put (Item => Pck_Fibo.Fib (N), Width => 0);
   New_Line;
end Fibo;
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://dada.perl.it/shootout/
-- Contributed by Pascal Obry on 2005/03/22

package Pck_Fibo is

   function Fib (N : in Natural) return Natural;

end Pck_Fibo;
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://shootout.alioth.debian.org/
-- Contributed by Pascal Obry on 2005/03/22

package body Pck_Fibo is

   function Fib (N : in Natural) return Natural is
   begin
      if N <= 1 then
         return 1;
      else
         return Fib (N - 2) + Fib (N - 1);
      end if;
   end Fib;

end Pck_Fibo;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/18

with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Command_Line;       use Ada.Command_Line;
with Ada.Long_Float_Text_IO; use Ada.Long_Float_Text_IO;

procedure Harmonic is
   Partial_Sum : Long_Float := 0.0;
   N           : Natural;
begin
   N := Integer'Value (Argument (1));

   for I in 1 .. N loop
      Partial_Sum := Partial_Sum + (1.0 / Long_Float (I));
   end loop;

   Put (Item => Partial_Sum, Aft => 9, Exp => 0);
   New_Line;
end Harmonic;
-- $Id: heapsort.gnat,v 1.2 2005-03-30 21:06:00 obry-guest Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.
-- Modified by Pascal Obry on 2005/03/30

package Random_Long_Float is
   function Gen_Random (Supr : Long_Float) return Long_Float;
   pragma Inline (Gen_Random);
end Random_Long_Float;

package body Random_Long_Float is
   IM          : constant Positive := 139968;
   IA          : constant Integer  := 3877;
   IC          : constant Integer  := 29573;
   Last        : Integer := 42;

   function Gen_Random (Supr : Long_Float) return Long_Float is
   begin
      Last := (Last * IA + IC) mod IM;
      return Supr * Long_Float (Last) / Long_Float (IM);
   end Gen_Random;
end Random_Long_Float;

package Heapsort_Pck is

   type Long_Float_Array is array (Positive range <>) of Long_Float;
   type Long_Float_Array_Ptr is access Long_Float_Array;

   procedure Heapsort (A : in out Long_Float_Array);
end Heapsort_Pck;

package body Heapsort_Pck is

   procedure Heapsort (A : in out Long_Float_Array) is
      First         : constant Positive := A'First;
      IR            : Integer;
      One           : constant Integer := 1;
      Minus_One     : constant Integer := -1;
      First_Minus_1 : constant Integer := First + Minus_One;
      First_Plus_1  : constant Integer := First + One;
      RRA           : Long_Float;
      L             : Integer := One + (A'Length / 2);
      K1, K2        : Integer;
   begin
      if A'Length <= 0 then
         return;
      end if;
      IR := A'Last;
      loop
         if L > One then
            L := L - One;
            RRA := A (First_Minus_1 + L);
         else
            RRA := A (IR);
            A (IR) := A (First);
            if IR <= First_Plus_1 then
               A (First) := RRA;
               exit;
            else
               IR := IR + Minus_One;
            end if;
         end if;
         K1 := First_Minus_1 + L;
         K2 := K1 + L;
         while K2 <= IR loop
            if K2 < IR then
               if A (K2) < A (K2 + One) then
                  K2 := K2 + One;
               end if;
            end if;
            if RRA < A (K2) then
               A (K1) := A (K2);
               K1 := K2;
               K2 := K1 + (K1 - First_Minus_1);
            else
               K2 := IR + One;
            end if;
         end loop;
         A (K1) := RRA;
      end loop;
   end Heapsort;

end Heapsort_Pck;

with Ada.Command_Line, Text_IO;
with Heapsort_Pck; use Heapsort_Pck;
with Random_Long_Float;

procedure Heapsort is
   package Rio is new Text_IO.Float_IO (Num => Long_Float);

   N : Positive;
   X : Long_Float_Array_Ptr;
begin
   N := Positive'Value (Ada.Command_Line.Argument (1));
   X := new Long_Float_Array (1 .. N);
   for Iter in X'Range loop
      X (Iter) := Random_Long_Float.Gen_Random (Supr => 1.0);
   end loop;

   Heapsort (A => X.all);
   Rio.Put (X (X'Last), Fore => 0, Aft => 10, Exp => 0);
   Text_IO.New_Line;
end Heapsort;
-- $Id: hello.gnat,v 1.1 2004-05-23 07:03:09 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Ada.Text_IO;
procedure Hello is
begin
   Ada.Text_IO.Put_Line ("hello world");
end Hello;
--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Contributed by Martin Krischik
--  Modified by Georg Bauhaus and Jonathan Parker

pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Ada.Characters.Latin_1;
with Ada.Integer_Text_IO;
with Ada.Float_Text_IO;
with Ada.Text_IO;
with Ada.Exceptions;

with String_Fragments;
with Data_Input;
with GNAT.Heap_Sort_G;
with GNAT.HTable;

procedure KNucleotide is

   subtype Fragment_Lengths is Integer range 1 .. 18;

   --  Data read as single String:

   Buffer : constant String := Data_Input.Read;

   --  Calculate and write data - either a percentage for all fragments found
   --  or - when Nucleotide_Fragment is given - the count for that fragment.

   generic
      with package Fragments is new String_Fragments(<>);
   package Work is

      procedure Write
        (Nucleotide_Length   : in Fragment_Lengths;
         Nucleotide_Fragment : in Fragments.Fragment := Fragments.Null_Fragment);

      task Writer is
         --
         --  Performs `Write` calls
         --
         pragma Storage_Size (2**24);

         entry Set (Nucleotide_Length   : in Fragment_Lengths;
                    Nucleotide_Fragment : in Fragments.Fragment := Fragments.Null_Fragment);
      end Writer;

   end Work;


   type Order is array (Fragment_Lengths) of Boolean;

   protected Printer is
      --
      --  Serializes access to output
      --
      entry Seize (Fragment_Lengths);
      procedure Release (L : Fragment_Lengths);

   private
      Done : Order :=
        (1 | 2 | 3 | 4 | 6 | 12 | 18 => False,
         others => True);
   end Printer;

   protected body Printer is

      --  Use families' entry indexes to find that output of preceding
      --  `Write`s has already been produced thus ordering the tasks's results.

      entry Seize (for L in Fragment_Lengths)
      when Done (1 .. Fragment_Lengths'Pred(L)) = (1 .. Fragment_Lengths'Pred(L) => True) is
      begin
         null;
      end Seize;

      procedure Release (L : Fragment_Lengths) is
      begin
         Done (L) := True;
      end Release;

   end Printer;

   package body Work is

      ---------------------
      -- procedure Write --
      ---------------------

      --  Procedure KNucleotide's tasks call Write in order to calculate and
      --  write data - either a percentage for all fragments found or - when
      --  Nucleotide_Fragment is given - the count for that fragment.
      --
      procedure Write
        (Nucleotide_Length   : in Fragment_Lengths;
         Nucleotide_Fragment : in Fragments.Fragment := Fragments.Null_Fragment)
      is
         use Fragments;

         --  Package is an interface to GNAT's simple hash table: GNAT.HTable.
         --  The package calculates nucleotide Fragment_Lengths and keeps the
         --  result inside a hash table as requested by the shootout rules.

         package Calculator is

            --  Elements used to store inside hash table:

            type Element_Type is private;
            type Element_Access is access Element_Type;
            for Element_Access'Storage_Size use 16#60_00_01#;


--  Calculate frequency of occurrence of the nucleotides:

            procedure Get_Frequencies (Length : Fragment_Lengths);

            --  Get the count for the given nucleotide fragment:

            function Number_Counted (Nucleotide_Fragment : Fragment) return Natural;

            --  Start to iterate over all elements of hash table:

            function Get_First return Element_Access;

            --  Continue itereation over the hash table:

            function Get_Next return Element_Access;

            --  Key and value when computed:

            function Count_Of (Element : not null Element_Access) return Natural;
            function Fragment_Of (Element : not null Element_Access) return Fragment;

            --  Get total count over all elements - as well as the count of
            --  elements:

            procedure Get_Totals (Total : out Natural; Count : out Natural);

         private
            pragma Inline (Count_of, Fragment_Of);

            type Element_Type is record
               Count : Natural        := 0;
               Key   : Fragment       := Fragments.Null_Fragment;
               Next  : Element_Access := null;
            end record;
         end Calculator;

         package body Calculator is

            Log_Table_Size : constant Natural := Natural'Min (Fragment'Last*2+4, 17);
            Table_Size     : constant Natural := 2 ** Log_Table_Size;

            subtype Hash_Type is Natural range 0 .. Table_Size - 1;

            function Hash (Key : Fragment) return Hash_Type;
            procedure Set_Next (E : Element_Access; Next : Element_Access);
            function Next (E : Element_Access) return Element_Access;
            function Get_Key (E : not null Element_Access) return Fragment;

            pragma Inline (Hash, Set_Next, Next, Get_Key);

            package Table is new GNAT.HTable.Static_HTable
              (Header_Num => Hash_Type,
               Element    => Element_Type,
               Elmt_Ptr   => Element_Access,
               Null_Ptr   => null,
               Key        => Fragment,
               Hash       => Hash,
               Equal      => Fragments."=",
               Set_Next   => Set_Next,
               Next       => Next,
               Get_Key    => Get_Key);


            function Hash (Key : Fragment) return Hash_Type is
               pragma Assert (Hash_Type'First = 0);
               pragma Assert (Hash_Type'Last  = 2**Log_Table_Size - 1);
               type Uns_32 is mod 2**32;
               H : Uns_32 := Character'Pos (Key (Key'First));
            begin
               for J in Key'First + 1 .. Key'Last loop
                  H := Character'Pos (Key (J)) + H * 2**3 + H;
               end loop;
               H := (H / 2**Log_Table_Size) xor H;
               return Hash_Type'Base (H mod 2**Log_Table_Size);
            end Hash;


            procedure Get_Frequencies (Length : Fragment_Lengths) is
            begin
               for I in  1 .. Buffer'Last - Length + 1 loop
                  declare
                     Key : String renames Buffer(I .. I + Length - 1);
                     Element : constant Element_Access := Table.Get (Key);
                  begin
                     if Element /= null then
                        Element.all.Count := Natural'Succ (Element.all.Count);
                     else
                        Table.Set (new Element_Type'(Count => 1,
                                                     Key => Key,
                                                     Next => null));
                     end if;
                  end;
               end loop;
               return;
            end Get_Frequencies;


            function Count_Of (Element : not null Element_Access) return Natural is
            begin
               return Element.all.Count;
            end Count_Of;


            function Number_Counted (Nucleotide_Fragment : Fragment) return Natural is
               The_Element : constant Element_Access := Table.Get (Nucleotide_Fragment);
            begin
               if The_Element /= null then
                  return The_Element.all.Count;
               else
                  return 0;
               end if;
            end Number_Counted;


            function Get_First return Element_Access is
            begin
               return Table.Get_First;
            end Get_First;


            function Get_Key (E : not null Element_Access) return Fragment is
            begin
               return E.all.Key;
            end Get_Key;


            function Get_Next return Element_Access is
            begin
               return Table.Get_Next;
            end Get_Next;


            procedure Get_Totals (Total : out Natural; Count : out Natural) is
               The_Element : Element_Access := Table.Get_First;
            begin
               Total := 0;
               Count := 0;
               while The_Element /= null loop
                  Total       := Total + The_Element.all.Count;
                  Count       := Count + 1;
                  The_Element := Table.Get_Next;
               end loop;
            end Get_Totals;


            function Fragment_Of (Element : not null Element_Access) return Fragment is
            begin
               return Element.all.Key;
            end Fragment_Of;

            function Next (E : Element_Access) return Element_Access is
            begin
               return E.all.Next;
            end Next;

            procedure Set_Next (E : Element_Access; Next : Element_Access) is
            begin
               E.all.Next := Next;
            end Set_Next;

         end Calculator;

      begin --  Write

         Calculator.Get_Frequencies (Nucleotide_Length);

         if Nucleotide_Fragment = Fragments.Null_Fragment then
            Calculate_Total : declare
               Num_Table_Entries : Natural;
               Sum_Of_Counts     : Natural;
            begin
               Calculator.Get_Totals
                 (Total => Sum_Of_Counts,
                  Count => Num_Table_Entries);

               Get_Sort_Put : declare
                  Data : array (0 .. Num_Table_Entries) of Calculator.Element_Access;

                  --  heap sort subprograms
                  procedure Move (From : Natural; To : Natural);
                  function Less_Then (Op1, Op2 : Natural) return Boolean;

                  pragma Inline (Move, Less_Then);

                  function Less_Then (Op1, Op2 : Natural) return Boolean is
                  begin
                     return
                       Calculator.Count_Of (Data (Op1))
                       >
                       Calculator.Count_Of (Data (Op2));
                  end Less_Then;

                  procedure Move (From : Natural; To : Natural) is
                  begin
                     Data (To) := Data (From);
                  end Move;

                  package Heap_Sort is new GNAT.Heap_Sort_G
                    (Move => Move,
                     Lt   => Less_Then);

               begin  -- Get_Sort_Put
                  Data (0) := null;
                  Data (1) := Calculator.Get_First;

                  for I in  2 .. Data'Last loop
                     Data (I) := Calculator.Get_Next;
                  end loop;

                  Heap_Sort.Sort (Data'Last);

                  Printer.Seize (Nucleotide_Length);
                  for I in  1 .. Data'Last loop
                     Ada.Text_IO.Put (Calculator.Fragment_Of (Data (I)) & ' ');
                     Ada.Float_Text_IO.Put
                       (Item => (100.0
                                   * Float (Calculator.Count_Of (Data (I)))
                                   / Float (Sum_Of_Counts)),
                        Fore => 1,
                        Aft  => 3,
                        Exp  => 0);
                     Ada.Text_IO.New_Line;
                  end loop;
                  Ada.Text_IO.New_Line;
                  Printer.Release (Nucleotide_Length);
               end Get_Sort_Put;
            end Calculate_Total;
         else
            Printer.Seize (Nucleotide_Length);
            Ada.Integer_Text_IO.Put
              (Item => Calculator.Number_Counted (Nucleotide_Fragment),
               Width => 1);
            Ada.Text_IO.Put (Ada.Characters.Latin_1.HT);
            Ada.Text_IO.Put_Line (Nucleotide_Fragment);
            Printer.Release (Nucleotide_Length);
         end if;
      end Write;

      task body Writer is
         Current_Length   : Fragment_Lengths;
         Current_Fragment : Fragments.Fragment;

         use Fragments;
      begin
         loop
            --
            --  perform a `Write` with parameters `Set` or terminate
            --
            select
               accept Set (Nucleotide_Length   : in Fragment_Lengths;
                           Nucleotide_Fragment : in Fragment := Null_Fragment)
               do
                  Current_Length   := Nucleotide_Length;
                  Current_Fragment := Nucleotide_Fragment;
               end Set;
               Write (Current_Length, Current_Fragment);
            or
               terminate;
            end select;
         end loop;
      exception
         when E : others =>
            Ada.Text_IO.Put_Line(Ada.Text_IO.Current_Error,
              Ada.Exceptions.Exception_Information(E));
      end Writer;

   end Work;


   package Fragments_1 is new String_Fragments (1);
   package Fragments_2 is new String_Fragments (2);
   package Fragments_3 is new String_Fragments (3);
   package Fragments_4 is new String_Fragments (4);
   package Fragments_6 is new String_Fragments (6);
   package Fragments_12 is new String_Fragments (12);
   package Fragments_18 is new String_Fragments (18);

   --  List of fragments to be analyzed for this test:

   Fragment_3  : constant Fragments_3.Fragment := Fragments_3.To_Fragment ("GGT");
   Fragment_4  : constant Fragments_4.Fragment := Fragments_4.To_Fragment ("GGTA");
   Fragment_6  : constant Fragments_6.Fragment := Fragments_6.To_Fragment ("GGTATT");
   Fragment_12 : constant Fragments_12.Fragment := Fragments_12.To_Fragment ("GGTATTTTAATT");
   Fragment_18 : constant Fragments_18.Fragment := Fragments_18.To_Fragment ("GGTATTTTAATTTATAGT");

   package Work_On_1 is new Work (Fragments_1);
   package Work_On_2 is new Work (Fragments_2);
   package Work_On_3 is new Work (Fragments_3);
   package Work_On_4 is new Work (Fragments_4);
   package Work_On_6 is new Work (Fragments_6);
   package Work_On_12 is new Work (Fragments_12);
   package Work_On_18 is new Work (Fragments_18);

begin
   Work_On_1.Writer.Set (1);
   Work_On_12.Writer.Set (Fragment_12'Length, Fragment_12);
   Work_On_18.Writer.Set (Fragment_18'Length, Fragment_18);
   Work_On_6.Writer.Set (Fragment_6'Length, Fragment_6);
   Work_On_2.Writer.Set (2);
   Work_On_4.Writer.Set (Fragment_4'Length, Fragment_4);
   Work_On_3.Writer.Set (Fragment_3'Length, Fragment_3);
end KNucleotide;



generic
   Max_String_Length : Positive;
package String_Fragments is

   subtype Fragment is String (1 .. Max_String_Length);

   function To_Fragment (Source : String) return Fragment;
   function Null_Fragment return Fragment;
   function "=" (Left, Right: Fragment) return Boolean;

end String_Fragments;


with Ada.Unchecked_Conversion;

package body String_Fragments is

   Bytes_Per_Word : constant := 4;
   type Uns is mod 2**(8 * Bytes_Per_Word);
   for Uns'Size use 8 * Bytes_Per_Word;
   subtype Str is String (1 .. Bytes_Per_Word);

   function Null_Fragment return Fragment is
   begin
      return Fragment'(1 .. Max_String_Length => '*');
   end Null_Fragment;


   function To_Uns is new Ada.Unchecked_Conversion (Str, Uns);

   function "=" (Left, Right: Fragment) return Boolean is
      Strt : Integer := 1;
      Fnsh : Integer := Bytes_Per_Word;
      Last : constant Integer := Left'Last;
   begin
      if Last /= Right'Last then
         return False;
      end if;

      loop
         exit when Fnsh > Last;
         if To_Uns (Left(Strt..Fnsh)) /= To_Uns (Right(Strt..Fnsh)) then
            return False;
         end if;
         Strt := Strt + Bytes_Per_Word;
         Fnsh := Fnsh + Bytes_Per_Word;
      end loop;

      for I in Strt .. Last loop
         if Left(I) /= Right(I) then
            return False;
         end if;
      end loop;
      return True;
   end "=";


   function To_Fragment (Source : String) return Fragment is
      Result : Fragment;
   begin
      if Source'Length /= Max_String_Length then
         raise Constraint_Error;
      end if;
      Result (1 .. Source'Length) := Source;
      return Result;
   end To_Fragment;

end String_Fragments;


----------------
-- data input --
----------------

package Data_Input is

   --  Read data from Standard_Input and return section THREE as String:

   function Read return String;

end Data_Input;

with Ada.Strings.Maps.Constants;
with Ada.IO_Exceptions;
with Ada.Strings.Unbounded;
with Line_IO;
with Ada.Unchecked_Deallocation;

package body Data_Input is

   use Ada.Strings;
   UnixLF : constant String := String'(1 => ASCII.LF);
   package LIO is new Line_IO (UnixLF);

   Data_Buffer : Unbounded.Unbounded_String := Unbounded.Null_Unbounded_String;

   Section_Marker : constant Character := '>';
   Section        : constant String    := Section_Marker & "THREE";

   --  Read next data section - until EOF oder a line beginning with > is found.

   type String_Access is access String;
   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);

   procedure Read_Section is
      Buffer     : String_Access;
      Read_First : Natural;
      Read_Last  : Natural;
   begin
      Buffer := new String (1 .. 1024 * 1024 * 16);
      Get_Data : loop
         Read_First := Buffer'First;
         Read_Last  := Buffer'First - 1;
         -- fill Buffer and append to Data_Buffer when filled
         loop
            declare
               Line : String renames LIO.Get_Line;
            begin
               Read_Last := Read_First + Line'Length - 1;
               if Read_Last >= Buffer'Last then
                  Unbounded.Append
                    (Data_Buffer, New_Item => Buffer(1 .. Read_First - 1));
                  Unbounded.Append (Data_Buffer, New_Item => Line);
                  exit;
               end if;
               Buffer (Read_First .. Read_Last) := Line;
            end;
            exit Get_Data when Buffer (Read_First) = Section_Marker;
            Read_First := Read_Last + 1;
         end loop;
      end loop Get_Data;
      Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));
      Free (Buffer);
   exception
      when Ada.IO_Exceptions.End_Error =>
         Unbounded.Append (Data_Buffer, Buffer (1 .. Read_Last));
         Free (Buffer);
   end Read_Section;


   --  Skip data on Standard_Input until ">THREE" is found

   procedure Skip_To_Section is
   begin
      loop
         declare
            Line : constant String := LIO.Get_Line;
         begin
            exit when Line(1) = Section(1)
              and then Line(Section'Range) = Section;
         end;
      end loop;
   end Skip_To_Section;


   function Read return String is
   begin
      Skip_To_Section;
      Read_Section;

      Unbounded.Translate
        (Source => Data_Buffer,
         Mapping => Maps.Constants.Upper_Case_Map);

      return Unbounded.To_String (Data_Buffer);
   end Read;

end Data_Input;

---------------------------
--  Stream I/O of lines --
---------------------------
generic
   Separator_Sequence : in String;  --  ends a line
package Line_IO is

   pragma Elaborate_Body;

   procedure Put_Line (Item : String) is null;
   -- not used in this program

   function Get_Line return String;

end Line_IO;


with Ada.Streams.Stream_IO;

package body Line_IO is

   use Ada.Streams;

   Stdin : Stream_IO.File_Type;

   -- Types etc., status variables, and the buffer.

   BUFSIZ: constant := 8_192;
   pragma Assert(Character'Size = Stream_Element'Size);

   SL : constant Natural := Separator_Sequence'Length;

   subtype Extended_Buffer_Index is Positive range 1 .. BUFSIZ + SL;
   subtype Buffer_Index is Extended_Buffer_Index
     range Extended_Buffer_Index'First .. Extended_Buffer_Index'Last - SL;
   subtype Extended_Bytes_Index is Stream_Element_Offset
     range 1 .. Stream_Element_Offset(Extended_Buffer_Index'Last);
   subtype Bytes_Index is Extended_Bytes_Index
     range Extended_Bytes_Index'First
     .. (Extended_Bytes_Index'Last - Stream_Element_Offset(SL));

   subtype Buffer_Data is String(Extended_Buffer_Index);
   subtype Buffer_Bytes is Stream_Element_Array(Extended_Bytes_Index);

   Buffer : Buffer_Data;
   Bytes  : Buffer_Bytes;
   for Bytes'Address use Buffer'Address;
   pragma Import (Ada, Bytes);

   -- start of next substring and last valid character in buffer
   Position : Natural range 0 .. Extended_Buffer_Index'Last;
   Last     : Natural range 0 .. Buffer_Index'Last;
   End_Of_Input : Boolean;

   function Get_Line return String is

      procedure Reload is
         --  fill Buffer with bytes available
         Last_Filled : Stream_Element_Offset;
      begin
         if Last < Buffer_Index'Last then
            raise Stream_IO.End_Error;
         end if;
         Stream_IO.Read(Stdin,
           Item => Bytes(Bytes_Index),
           Last => Last_Filled);
         Last := Natural(Last_Filled);
         Position := 1;
         Buffer(Last + 1 .. Last + SL) := Separator_Sequence;
      end Reload;


      function Separator_Position return Natural is
         --   index of next Separator_Sequence (may be sentinel)
         pragma Inline(Separator_Position);
         K : Extended_Buffer_Index := Position;
      begin
         while Buffer(K) /= Separator_Sequence(1) loop
            K := K + 1;
         end loop;
         return K;
      end Separator_Position;


      Next_Separator : Natural range 0 .. Extended_Buffer_Index'Last;
   begin  -- Get_Line

      if End_Of_Input then
         raise Stream_IO.End_Error;
      end if;

      Next_Separator := Separator_Position;

      if Next_Separator > Last then
         declare
            Result : constant String := Buffer(Position .. Last);
            subtype XString is String (1 .. Last - Position + 1);
         begin
            begin
               Reload;
               return XString(Result) & Get_Line;
            exception
               when Stream_IO.End_Error =>
                  End_Of_Input := True;
                  return XString(Result);
            end;
         end;
      else
         declare
            Result : String renames Buffer(Position .. Next_Separator - 1);
            subtype XString is String (1 .. Next_Separator - Position);
         begin
            Position := Next_Separator + SL;
            return XString (Result);
         end;
      end if;

      raise Program_Error;
   end Get_Line;


begin
   Stream_IO.Open (Stdin,
     Mode => Stream_IO.In_File,
     Name => "/dev/stdin");

   Buffer(Buffer_Index'Last + 1 .. Buffer'Last) := Separator_Sequence;
   Position := Buffer_Index'Last + 1;
   Last := Buffer_Index'Last;
   End_Of_Input := False;
end Line_IO;
-- $Id: lists.gnat,v 1.2 2005-05-13 16:24:18 igouy-guest Exp $
-- http://dada.perl.it/shootout/ 
-- by James S. Rogers
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_Io; use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with Ada.Command_Line; use Ada.Command_Line;

procedure Listoperations is
   pragma suppress(All_Checks);
   package Listops is
      Empty_List_Error : exception;
      type List is private;
      function Length(Item : in List) return Natural;
      function Is_Empty(Item : in List) return Boolean;
      type List_Element is private;
      type Element_Access is access List_Element;
      function First(Item : in List) return List_Element;
      function Last(Item : in List) return List_Element;
      procedure Push_Tail(Item : in out List; Element : in Integer);
      procedure Pop_Tail(Item : in out List; Element : out Integer);
      procedure Push_Head(Item : in out List; Element : in Integer);
      procedure Pop_Head(Item : in out List; Element : out Integer);
      function "="(Left, Right : in List) return Boolean;
      function New_List return List;
      function Sequence(From, To : Integer) return List;
      function Copy(Source : List) return List;
      procedure List_Reverse(Source : in out List);
      procedure Empty_List(Source : in out List);
      procedure Print(Msg : in String; Item : in List);
      function Test_Lists return Integer;
   private
      type List_Element is record
         Value : Integer := 0;
         Previous : Element_Access := null;
         Next     : Element_Access := null;
      end record;
      type List is record
         Length : Natural := 0;
         Head   : Element_Access := null;
         Tail   : Element_Access := null;
      end record;
   end Listops;

   package body Listops is
      function Length(Item : in List) return Natural is
      begin
         return Item.Length;
      end Length;
      function Is_Empty(Item : in List) return Boolean is
      begin
         return Item.Length = 0;
      end Is_Empty;
      function First(Item : List) return List_Element is
      begin
         if Is_Empty(Item) then
            raise Empty_List_Error;
         end if;
         return Item.Head.All;
      end First;
      function Last(Item : List) return List_Element is
      begin
         if Is_Empty(Item) then
            raise Empty_List_Error;
         end if;
         return Item.Tail.All;
      end Last;
      procedure Push_Tail(Item : in out List; Element : in Integer) is
         Tail : Element_Access := Item.Tail;
         Temp : Element_Access := new List_Element;
      begin
         Temp.Value := Element;
         Item.Length := Item.Length + 1;
         Item.Tail := Temp;
         if Tail /= null then
            Temp.Previous := Tail;
            Tail.Next := Temp;
         else
            Item.Head := Temp;
         end if;
      end Push_Tail;
      procedure Pop_Tail(Item : in out List; Element : out Integer) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
         Temp : Element_Access := Item.Tail;
      begin
         if Item.Length >= 1 then
            Item.Length := Item.Length - 1;
            Element := Item.Tail.Value;
            Item.Tail := Item.Tail.Previous;
            if Item.Tail /= null then
               Item.Tail.Next := null;
            else
               Item.Head := null;
            end if;
            if Temp /= null then
               Free(Temp);
            end if;
         end if;
      end Pop_Tail;
      procedure Push_Head(Item : in out List; Element : in Integer) is
         Head : Element_Access := Item.Head;
         Temp : Element_Access := new List_Element;
      begin
         Temp.Value := Element;
         Item.Length := Item.Length + 1;
         Temp.Next := Head;
         Item.Head := Temp;
         if Head /= null then
            Head.Previous := Temp;
         else
            Item.Tail := Temp;
         end if;
      end Push_Head;
      procedure Pop_Head(Item : in out List; Element : out Integer) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
            Head : Element_Access := Item.Head;
         begin
            if Head /= null then
               Element := Head.Value;
               Item.Head := Item.Head.Next;
               Item.Length := Item.Length - 1;
               if Item.Head = null then
                  Item.Tail := null;
               else
                  Item.Head.Previous := null;
               end if;
               Free(Head);
            end if;
         end Pop_Head;
      function "="(Left, Right : List) return Boolean is
         Left_Ptr : Element_Access := Left.Head;
         Right_Ptr : Element_Access := Right.Head;
         Result : Boolean := True;
      begin
         if Left.Length = Right.Length then
            while Left_Ptr /= null loop
               if Left_Ptr.Value /= Right_Ptr.Value then
                  Result := False;
                  exit;
               end if;
               Left_Ptr := Left_Ptr.Next;
               Right_Ptr := Right_Ptr.Next;
            end loop;
         else
            Result := False;
         end if;
         return Result;
      end "=";
      function New_List return List is
         Result : List;
      begin
         return Result;
      end New_List;
      function Sequence(From, To : Integer) return List is
         Result : List;
         Temp : Integer;
         Low : Integer := From;
         High : Integer := To;
      begin
         if From > To then
            Temp := From;
            Low := To;
            High := Temp;
         end if;
         for Val in Low..High loop
            Push_Tail(Result, Val);
         end loop;
         return Result;
      end Sequence;
      function Copy(Source : List) return List is
         Result : List;
         Source_Ptr : Element_Access := Source.Head;
      begin
         while Source_Ptr /= null loop
            Push_Tail(Item => Result, Element => Source_Ptr.Value);
            Source_Ptr := Source_Ptr.Next;
         end loop;
         return Result;
      end Copy;
      procedure List_Reverse(Source : in out List) is
         Head : Element_Access := Source.Head;
         Temp : Element_Access;
      begin
         Temp := Source.Head;
         Source.Head := Source.Tail;
         Source.Tail := Temp;
         if Head = null then
            raise Empty_List_Error;
         end if;
         loop
            Temp := Head.Next;
            Head.Next := Head.Previous;
            Head.Previous := Temp;
            Head := Temp;
            exit when Head = null;
         end loop;
      end List_Reverse;
      procedure Empty_List(Source : in out List) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
         Source_Ptr : Element_Access := Source.Head;
         Temp : Element_Access;
      begin
         while Source_Ptr /= null loop
            Temp := Source_Ptr;
            Source_Ptr := Source_Ptr.Next;
            Free(Temp);
         end loop;
         Source := New_List;
      end Empty_List;
      procedure Print(Msg : in String; Item : in List) is
         Source_Ptr : Element_Access := Item.Head;
      begin
         Put_Line(Msg);
         Put_Line("Length:" & Integer'Image(Length(Item)));
         while Source_Ptr /= null loop
            if Source_Ptr.Previous /= null then
               Put(Item => Source_Ptr.Previous.Value, Width => 6);
            end if;
            Put(Item => Source_Ptr.Value, Width => 6);
            if Source_Ptr.Next /= null then
               Put(Item => Source_Ptr.Next.Value, Width => 6);
            end if;
            New_Line;
            Source_Ptr := Source_Ptr.Next;
         end loop;
      end Print;
      function Test_Lists return Integer is
         Size : constant Integer := 10_000;
         Li1, Li2, Li3 : List; -- all are created as empty lists
         Temp_Element : Integer;
         Len : Integer;
      begin
         -- Create a list of integers from 1 to Size
         Li1 := Sequence(1, Size);
         -- Copy the list to Li2
         Li2 := Copy(Li1);
         -- Compare Li1 and Li2 for equality
         if Li1 /= Li2 then
            Put_Line("Li1 and Li2 are not equal!");
            return -1;
         end if;
         while not Is_Empty(Li2) loop
            Pop_Head(Li2, Temp_Element);
            Push_Tail(Li3, Temp_Element);
         end loop;
         -- Li2 must be empty now
         if not Is_Empty(Li2) then
            Put_Line("Li2 should be empty now!");
            return -1;
         end if;
         -- Append each item from Li3 to Li2
         -- reversing the list
         while not Is_Empty(Li3) loop
            Pop_Tail(Li3, Temp_Element);
            Push_Tail(Li2, Temp_Element);
         end loop;
         -- Li3 must be empty now
         if not Is_Empty(Li3) then
            Put_Line("Li3 should be empty now!");
            return -1;
         end if;
         -- reverse Li1 in place
         List_Reverse(Li1);
         -- check that Li1's first item is still Size
         if First(Li1).Value /= Size then
            Put_Line("First Li1 value wrong. Wanted" & Integer'Image(Size) &
               " got" & Integer'Image(First(Li1).Value));
            return -1;
         end if;
         -- Ensure Li1 last value is now 1
         if Last(Li1).Value /= 1 then
            Put_Line("Last Li1 value wrong, wanted 1, got" &
               Integer'Image(Last(Li1).Value));
            return -1;
         end if;
         -- Check that Li2's first value is now Size
         if First(Li2).Value /= Size then
            Put_Line("First Li2 value wrong, wanted" &
               Integer'Image(Size) & " got" &
               Integer'Image(First(Li2).Value));
            return -1;
         end if;
         -- Check that Li2's last item is now 1
         if Last(Li2).Value /= 1 then
            Put_Line("Last Li2 value wrong, wanted 1");
            return -1;
         end if;
         -- Check that Li1's size is still Size
         if Length(Li1) /= Size then
            Put_Line("Li1 size wrong, wanted" &
               Integer'Image(Size) & " got" &
               Integer'Image(Length(Li1)));
            return -1;
         end if;
         -- compare Li1 and Li2 for equality
         if Li1 /= Li2 then
            Put_Line("Li1 and Li2 are not equal.");
            return -1;
         end if;
         Len := Length(Li1);
         Empty_List(Li1);
         Empty_List(Li2);
         Empty_List(Li3);
         return Len;
      end Test_Lists;
   end Listops;
   Max : Positive;
   Result : Natural;
begin
   begin
      Max := Positive'Value(Argument(1));
   exception
      when others =>
         Max := 16;
   end;
   for Iter in 1..Max loop
      Result := Listops.Test_Lists;
   end loop;
   Ada.Integer_Text_IO.Put(Item => Result, Width => 0);
   Ada.Text_IO.New_Line;
end Listoperations;


-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/21
-- Modified Experimental version suggested by Pascal Obry

with GNAT.IO;          use GNAT.IO;
with Ada.Command_Line; use Ada.Command_Line;
with Interfaces;       use Interfaces;

procedure Mandelbrot is
   type Real is digits 15;
   Iter                   : constant := 50;
   Limit                  : constant := 4.0;
   Width, Height          : Positive;
   Bit_Num                : Natural    := 0;
   Byte_Acc               : Unsigned_8 := 0;
   Zr, Zi, Cr, Ci, Tr, Ti, Zr2, Zi2 : Real;
begin
   Width := Positive'Value (Argument (1));

   Height := Width;

   Put_Line ("P4");
   Put_Line (Argument (1) & " " & Argument (1));

   for Y in 0 .. Height - 1 loop
      for X in 0 .. Width - 1 loop
         Zr := 0.0;
         Zi := 0.0;
         Cr := 2.0 * Real (X) / Real (Width) - 1.5;
         Ci := 2.0 * Real (Y) / Real (Height) - 1.0;

         for I in 1 .. Iter + 1 loop
            Zr2 := Zr ** 2;
            Zi2 := Zi ** 2;
            Tr  := Zr2 - Zi2 + Cr;
            Ti  := 2.0 * Zr * Zi + Ci;
            Zr  := Tr;
            Zi  := Ti;

            exit when Zr2 + Zi2 > Limit;
         end loop;
         
         if Zr2 + Zi2 > Limit then
            Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#00#;
         else
            Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#01#;
         end if;

         Bit_Num := Bit_Num + 1;

         if Bit_Num = 8 then
            Put (Character'Val (Byte_Acc));
            Byte_Acc := 0;
            Bit_Num  := 0;
         elsif X = Width - 1 then
            Byte_Acc := Shift_Left (Byte_Acc, 8 - (Width mod 8));
            Put (Character'Val (Byte_Acc));
            Byte_Acc := 0;
            Bit_Num  := 0;
         end if;
      end loop;
   end loop;
end Mandelbrot;

--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org
--
--  Contributed by Jim Rogers
--  Modified by Pascal Obry, Gautier de Montmollin, Georg Bauhaus, Jonathan Parker

pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Ada.Command_Line;      use Ada.Command_Line;

with Interfaces;            use Interfaces;
with Ada.Streams.Stream_IO; use Ada.Streams;

procedure Mandelbrot is

   type Real is digits 15;
   type M8 is mod 8;
   type PCount is range 0 .. 2**20 - 1;

   Iter        : constant := 50;
   Limit       : constant := 4.0;
   Size        : constant Positive := Positive'Value (Argument (1));
   Two_on_Size : constant Real := 2.0 / Real (Size);

   subtype Output_Index is Stream_Element_Offset range 1 .. Stream_Element_Offset'Last;
   subtype Output_Queue is Stream_Element_Array;
   type Output is access Output_Queue;

   task type X_Step is
      entry Compute_Z (Y1, Y2 : PCount);
      entry Get_Output (Result : out Output);
   end X_Step;

   procedure Allocate_Output_Queue (Y1, Y2 : PCount; Result : out Output);
   pragma Precondition
     (Output_Index'First = 1);
   pragma Postcondition
     (Result'First = Output_Index'First and
      Result'Last = Output_Index'Max
        (0, Stream_Element_Offset (Integer (Y2 - Y1) * (Size / 8 + Boolean'Pos (Size mod 8 > 0)))));

   procedure Compute (Y1, Y2 : PCount; Result : Output)
   is
      subtype Instruction_Stream_Index is Integer range 1 .. 2;
      pragma Assert (Instruction_Stream_Index'First = 1);

      Bit_Num  : M8         := 0;
      Byte_Acc : Unsigned_8 := 0;
      Byte_Acc_Storage : array (Instruction_Stream_Index) of Unsigned_8;
      Last     : Stream_Element_Offset := Result'First - 1;
   begin
      for Y in Y1 .. Y2 - 1 loop
         for X in 0 .. Size / Instruction_Stream_Index'Last - 1 loop
            declare
               Cr_1 : constant Real := Two_on_Size * (Real (2*X)) - 1.5;
               Ci_1 : constant Real := Two_on_Size * (Real (Y)) - 1.0;
               Zr_1 : Real := Cr_1;
               Zi_1 : Real := Ci_1;
               ZZi_1 : Real := Zi_1 * Zi_1;
               ZZr_1 : Real := Zr_1 * Zr_1;
               Z_1_Exceeded_Limit : Boolean := False;
               Tmp_1 : Real;

               Cr_2 : constant Real := Two_on_Size * (Real (2*X + 1)) - 1.5;
               Ci_2 : constant Real := Two_on_Size * (Real (Y)) - 1.0;
               Zr_2 : Real := Cr_2;
               Zi_2 : Real := Ci_2;
               ZZi_2 : Real := Zi_2 * Zi_2;
               ZZr_2 : Real := Zr_2 * Zr_2;
               Z_2_Exceeded_Limit : Boolean := False;
               Tmp_2 : Real;
            begin
               for I in 1 .. Iter loop

                  Tmp_1 := Zr_1 * Zi_1;
                  Tmp_2 := Zr_2 * Zi_2;
                  Zr_1 := Cr_1 - ZZi_1;
                  Zr_2 := Cr_2 - ZZi_2;
                  Zi_1 := Ci_1 + Tmp_1 + Tmp_1;
                  Zi_2 := Ci_2 + Tmp_2 + Tmp_2;
                  Zr_1 := Zr_1 + ZZr_1;
                  Zr_2 := Zr_2 + ZZr_2;

                  if not Z_1_Exceeded_Limit then
                     if ZZi_1 + ZZr_1 > Limit then
                        Z_1_Exceeded_Limit := True;
                     end if;
                  end if;
                  if not Z_1_Exceeded_Limit then
                     ZZr_1 := Zr_1 * Zr_1;
                     ZZi_1 := Zi_1 * Zi_1;
                  end if;

                  if not Z_2_Exceeded_Limit then
                     if ZZi_2 + ZZr_2 > Limit then
                        Z_2_Exceeded_Limit := True;
                     end if;
                  end if;
                  if not Z_2_Exceeded_Limit then
                     ZZr_2 := Zr_2 * Zr_2;
                     ZZi_2 := Zi_2 * Zi_2;
                  end if;

                  exit when Z_2_Exceeded_Limit and Z_1_Exceeded_Limit;
               end loop;

               if Z_1_Exceeded_Limit then
                  Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#00#;
               else
                  Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#01#;
               end if;
               Byte_Acc_Storage (1) := Byte_Acc;

               if Z_2_Exceeded_Limit then
                  Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#00#;
               else
                  Byte_Acc := Shift_Left (Byte_Acc, 1) or 16#01#;
               end if;
               Byte_Acc_Storage (2) := Byte_Acc;
            end;

            for j in Byte_Acc_Storage'Range loop

               Bit_Num := Bit_Num + 1;

               if Bit_Num = 0 then
                  Last := Last + 1;
                  Result (Last) := Stream_Element (Byte_Acc_Storage (j));
                  Byte_Acc := 0;
               end if;

            end loop;
         end loop;

         case M8 (Size mod 8) is
            when 0 =>
               null;
            when 1 | 3 | 5 | 7 =>
               pragma Assert (False);  -- odd Size not covered
               null;
            when 2 | 4 | 6 =>
               Byte_Acc_Storage (2) := Shift_Left (Byte_Acc, 8 - (Size mod 8));
               Last := Last + 1;
               Result (Last) := Stream_Element (Byte_Acc_Storage (2));
               Byte_Acc := 0;
               Bit_Num  := 0;
         end case;
      end loop;
   end Compute;

   task body X_Step is
      Y1, Y2 : PCount;
      Data   : Output;
   begin
      accept Compute_Z (Y1, Y2 : PCount) do
         X_Step.Y1 := Y1;
         X_Step.Y2 := Y2;
      end Compute_Z;

      Allocate_Output_Queue (Y1, Y2, Result => Data);
      Compute (Y1, Y2, Result => Data);

      accept Get_Output (Result : out Output) do
         Result := Data;
      end Get_Output;
   end X_Step;

   procedure Allocate_Output_Queue (Y1, Y2 : PCount; Result : out Output) is
      Limit : constant Natural := Natural'Max
        (0,
         Integer (Y2 - Y1) * (Size / 8 + Boolean'Pos (Size mod 8 > 0)));
   begin
      Result := new Output_Queue (1 .. Output_Index'Base (Limit));
   end Allocate_Output_Queue;

begin
   pragma Assert (Size mod 2 = 0, "Size must be even at present");

   declare
      subtype Worker_Index is Natural range 0 .. 32;
      Chunk_Size : constant Positive :=
        (Size + Worker_Index'Last) / Worker_Index'Last;
      Worker     : array (Worker_Index) of X_Step;
      pragma       Assert (Worker'Length * Chunk_Size >= Size);
      pragma       Assert (Worker'First = 0);
   begin
      for P in Worker'Range loop
         Worker (P).Compute_Z
           (Y1 => PCount (P * Chunk_Size),
            Y2 => PCount (Positive'Min ((P + 1) * Chunk_Size, Size)));
      end loop;

      declare
         Stdout : Stream_IO.File_Type;
         Header : constant String := "P4" & ASCII.LF &
           Argument (1) & " " & Argument (1) & ASCII.LF;
         Buffer : Output;

         Header_Bytes : Stream_Element_Array (1 .. Header'Length);
         pragma Import (Ada, Header_Bytes);
         for Header_Bytes'Address use Header'Address;
      begin
         Stream_IO.Open (Stdout, Stream_IO.Out_File, "/dev/stdout");
         Stream_IO.Write (Stdout, Header_Bytes);
         for P in Worker'Range loop
            Worker (P).Get_Output (Result => Buffer);
            Stream_IO.Write (Stdout, Buffer.all);
         end loop;
      end;
   end;

end Mandelbrot;

-- $Id: matrix.gnat,v 1.2 2005-03-13 23:29:08 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry.

with Text_IO, Ada.Strings.Fixed, Ada.Command_Line;

procedure Matrix is

   pragma Suppress (All_Checks);

   use Ada;

   Size : constant Natural := 30;

   type Int is new Integer;
   type Int_Matrix is array (1 .. Size, 1 .. Size) of Int;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
       Ada.Strings.Left ) return String renames Ada.Strings.Fixed.Trim;

   procedure Mk_Matrix (M : out Int_Matrix) is
      Count : Int := 1;
   begin
      for I in M'Range (1) loop
         for J in M'Range (2) loop
            M (I, J) := Count;
            Count := Count + 1;
         end loop;
      end loop;
   end Mk_Matrix;

   procedure M_Mult (M1, M2 : Int_Matrix; MM : in out Int_Matrix) is
      Sum : Int;
   begin
      for I in M1'Range (1) loop
         for J in M2'Range (2) loop
            Sum := 0;
            for KK in M1'Range (2) loop
               Sum := Sum + M1 (I, KK) * M2 (KK, J);
            end loop;
            MM (I, J) := Sum;
         end loop;
      end loop;
   end M_Mult;

   M1, M2, MM : Int_Matrix;
   N          : Positive := 1;

begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;

   Mk_Matrix (M1);
   Mk_Matrix (M2);

   for Iter in 1 .. N loop
      M_Mult (M1, M2, MM);
   end loop;

   Text_IO.Put_Line
     (L_Trim (Int'Image (MM (1, 1))) & Int'Image (MM (3, 4)) &
        Int'Image (MM (4, 3)) & Int'Image (MM (5, 5)));
end Matrix;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/17

with Ada.Integer_Text_Io; use Ada.Integer_Text_Io;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;

procedure Message is
   type Link;
   type Link_Access is access Link;
   task type Link (Next_Link : Link_Access; Num_Iter : Positive) is
      pragma Storage_Size (100000);
      entry Receive (I : in Integer);
   end Link;

   task body Link is
      Val     : Integer := 0;
      New_Val : Integer;
   begin
      for iter in 1 .. Num_Iter loop
         accept Receive (I : in Integer) do
            New_Val := I;
         end Receive;

         if Next_Link = null then
            Val := Val + New_Val + 1;
         else
            Val := New_Val + 1;
            Next_Link.Receive (Val);
         end if;
      end loop;

      if Next_Link = null then
         Put (Item => Val, Width => 0);
         New_Line;
      end if;
   end Link;

   Num_Tasks : Positive := 500;
   Num_Iter  : Positive := 200;
   New_Task  : Link_Access;
   Last_Task : Link_Access := null;
begin
   if Argument_Count > 0 then
      Num_Iter := Positive'Value (Argument (1));
   end if;

   for Item in 1 .. Num_Tasks loop
      New_Task  := new Link (Last_Task, Num_Iter);
      Last_Task := New_Task;
   end loop;

   for iter in 1 .. Num_Iter loop
      New_Task.Receive (0);
   end loop;
end Message;

-- $Id: methcall.gnat,v 1.1 2004-05-23 07:14:27 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Command_Line, Ada.Characters.Handling;

procedure MethCall is
   package Toggles is
      type A_Rec is                          --  'tagged' implies hidden field,
         tagged record                       --   and can append new fields
            Value       : Boolean := True;
         end record;

      procedure Activate (A : in out A_Rec);

      type B_Rec is new A_Rec with                 --  Add more fields to A_Rec
         record
            Flip_Period : Positive := 1;
            Count       : Natural := 0;
         end record;

      procedure Activate (B : in out B_Rec);
      pragma Inline (Activate);
   end Toggles;

   package body Toggles is
      procedure Activate (A : in out A_Rec) is
      begin
         A.Value := not A.Value;
      end Activate;

      procedure Activate (B : in out B_Rec) is
      begin
         B.Count := B.Count + 1;
         if B.Count = B.Flip_Period then
            B.Count := 0;
            B.Value := not B.Value;
         end if;
      end Activate;
   end Toggles;

   X        : Toggles.A_Rec := (Value => True);
   Y        : Toggles.B_Rec := (Value => True, Count => 0, Flip_Period => 3);
   Val      : Boolean;
   N        : Positive := 1;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      Toggles.Activate (X);
      Val := X.Value;
   end loop;
   Text_IO.Put_Line (Ada.Characters.Handling.To_Lower (Boolean'Image (Val)));
   for Iter in 1 .. N loop
      Toggles.Activate (Y);
      Val := Y.Value;
   end loop;
   Text_IO.Put_Line (Ada.Characters.Handling.To_Lower (Boolean'Image (Val)));
end MethCall;
-- $Id: moments.gnat,v 1.8 2005-03-30 20:31:48 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23
-- Modified by Pascal Obry on 2005/03/30

generic
   type Item_Type is private;
   with function "<=" (X, Y : Item_Type) return Boolean;
   type Sequence is array (Integer range <>) of Item_Type;
procedure Quick_Sort (S : in out Sequence; Lwb, Upb : in Integer);

procedure Quick_Sort (S : in out Sequence; Lwb, Upb : in Integer) is
   Pivot : Item_Type := S (Upb);
   Front : Integer := Lwb;
   Back  : Integer := Upb;
   Temp  : Item_Type;
begin
   if Lwb < Upb then
      while  (Front <= Back)  loop
         while not  (Pivot <= S (Front)) loop
            Front := Front + 1;
         end loop;
         while not  (S (Back) <= Pivot) loop
            Back := Back - 1;
         end loop;
         if Front <= Back then
            Temp := S (Front);
            S (Front) := S (Back);
            S (Back) := Temp;
            Front := Front + 1;
            Back  := Back - 1;
         end if;
      end loop;
      Quick_Sort (S, Lwb, Back);
      Quick_Sort (S, Front, Upb);
   end if;
end Quick_Sort;

-- $Id: moments.gnat,v 1.8 2005-03-30 20:31:48 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23
-- Modified by Pascal Obry on 2005/03/30

with System, Ada.Numerics.Generic_Elementary_Functions;
with Ada.Text_IO; use Ada.Text_IO;
with Quick_Sort;
with GNAT.Dynamic_Tables;

procedure Moments is

   type Real is new Long_Float;

   package AF is new
     Ada.Numerics.Generic_Elementary_Functions (Float_Type => Real);
   package RIO is new Ada.Text_IO.Float_IO (Num => Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 6;
      Exp  : Field := 0) renames RIO.Put;

   package Real_Table is
      new GNAT.Dynamic_Tables (Real, Integer, 1, 4_096, 200);

   procedure Sort is new Quick_Sort (Real, "<=", Real_Table.Table_Type);

   Table                    : Real_Table.Instance;

   Dev, D_2, Mean, Median   : Real;
   Standard_Deviation       : Real;
   Sum, Avg_Abs_Deviation   : Real    := 0.0;
   Variance, Skew, Kurtosis : Real    := 0.0;
   M                        : Natural := 0;
   Value                    : Real;

begin
   Real_Table.Init (Table);

   begin
      loop
         RIO.Get (Item => Value);
         M := M + 1;
         Real_Table.Append (Table, Value);
         Sum := Sum + Value;
      end loop;
   exception
      when others => null;
   end;

   Mean := Sum / Real (M);

   for K in 1 .. M loop
      Dev               := Table.Table (K) - Mean;
      Avg_Abs_Deviation := Avg_Abs_Deviation + abs Dev;
      D_2               := Dev * Dev;
      Variance          := Variance + D_2;
      Skew              := Skew + (D_2 * Dev);
      Kurtosis          := Kurtosis + (D_2 * D_2);
   end loop;

   Avg_Abs_Deviation  := Avg_Abs_Deviation / Real (M);
   Variance           := Variance / Real (M - 1);
   Standard_Deviation := AF.Sqrt (Variance);

   if Variance < 10.0 * Real'Model_Epsilon then
      Put_Line ("> Reduced accuracy results: 0 = ((Variance/10 + 1) - 1)");
   else
      Skew     := Skew / (Real (M) * Variance * Standard_Deviation);
      Kurtosis := -3.0 + Kurtosis / (Real (M) * Variance * Variance);
   end if;

   Sort (Table.Table.all, 1, M);

   if 1 = (M mod 2) then
      Median := Table.Table ((M + 1) / 2);
   else
      Median := (Table.Table (M / 2) + Table.Table (1 + M / 2)) / 2.0;
   end if;

   Put_Line ("n:                 " & Integer'Image (M));
   Put ("median:             "); Put (Median);              New_Line;
   Put ("mean:               "); Put (Mean);                New_Line;
   Put ("average_deviation:  "); Put (Avg_Abs_Deviation);   New_Line;
   Put ("standard_deviation: "); Put (Standard_Deviation);  New_Line;
   Put ("variance:           "); Put (Variance);            New_Line;
   Put ("skew:               "); Put (Skew);                New_Line;
   Put ("kurtosis:           "); Put (Kurtosis);            New_Line;
end Moments;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Numerics; use Ada.Numerics;
with Ada.Numerics.Generic_Elementary_Functions;

package Nbody_Pck is

   type Real is Digits 15;

   package Math is new Ada.Numerics.Generic_Elementary_Functions (Real);

   Solar_Mass    : constant Real := 4.0 * Pi * Pi;
   Days_Per_Year : constant Real := 365.24;

   type Data is record
      X, Y, Z    : Real;
      Vx, Vy, Vz : Real;
      Mass       : Real;
   end record;

   type Body_Name is (Sun, Jupiter, Saturn, Uranus, Neptune);

   Bodies : array (Body_Name) of Data :=
              (Jupiter => (X    => 4.84143144246472090e+00,
                           Y    => -1.16032004402742839e+00,
                           Z    => -1.03622044471123109e-01,
                           Vx   => 1.66007664274403694e-03 * Days_Per_Year,
                           Vy   => 7.69901118419740425e-03 * Days_Per_Year,
                           Vz   => -6.90460016972063023e-05 * Days_Per_Year,
                           Mass => 9.54791938424326609e-04 * Solar_Mass),

               Saturn  => (X    => 8.34336671824457987e+00,
                           Y    => 4.12479856412430479e+00,
                           Z    => -4.03523417114321381e-01,
                           Vx   => -2.76742510726862411e-03 * Days_Per_Year,
                           Vy   => 4.99852801234917238e-03 * Days_Per_Year,
                           Vz   => 2.30417297573763929e-05 * Days_Per_Year,
                           Mass => 2.85885980666130812e-04 * Solar_Mass),

               Uranus  => (X    => 1.28943695621391310e+01,
                           y    => -1.51111514016986312e+01,
                           Z    => -2.23307578892655734e-01,
                           Vx   => 2.96460137564761618e-03 * Days_Per_Year,
                           Vy   => 2.37847173959480950e-03 * Days_Per_Year,
                           Vz   => -2.96589568540237556e-05 * Days_Per_Year,
                           Mass => 4.36624404335156298e-05 * Solar_Mass),

               Neptune => (X    => 1.53796971148509165e+01,
                           Y    => -2.59193146099879641e+01,
                           Z    => 1.79258772950371181e-01,
                           Vx   => 2.68067772490389322e-03 * Days_Per_Year,
                           Vy   => 1.62824170038242295e-03 * Days_Per_Year,
                           Vz   => -9.51592254519715870e-05 * Days_Per_Year,
                           Mass => 5.15138902046611451e-05 * Solar_Mass),

               Sun     => (X    => 0.0,
                           Y    => 0.0,
                           Z    => 0.0,
                           Vx   => 0.0,
                           Vy   => 0.0,
                           Vz   => 0.0,
                           Mass => Solar_Mass));

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real);

   function Energy return Real;

   procedure Advance (Dt : in Real);

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

package body Nbody_Pck is

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real) is
   begin
      Planet.Vx := -Px / Solar_Mass;
      Planet.Vy := -Py / Solar_Mass;
      Planet.Vz := -Pz / Solar_Mass;
   end Offset_Momentum;

   function Energy return Real is
      Dx, Dy, Dz, Distance : Real;
      E                    : Real := 0.0;
   begin
      for I in Bodies'Range loop
        E := E + 0.5 * Bodies (I).Mass
          * (Bodies (I).Vx * Bodies (I).Vx
               + Bodies (I).Vy * Bodies (I).Vy
               + Bodies (I).Vz * Bodies (I).Vz);

        if I /= Body_Name'Last then
           for J in Body_Name'Succ (I) .. Body_Name'Last loop
              Dx := Bodies (I).X - Bodies (J).X;
              Dy := Bodies (I).Y - Bodies (J).Y;
              Dz := Bodies (I).Z - Bodies (J).Z;

              Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
              E := E - (Bodies (I).Mass * Bodies (J).Mass) / Distance;
           end loop;
        end if;
      end loop;
      return E;
   end Energy;

   procedure Advance (Dt : in Real) is
      Dx, Dy, Dz, Distance, Mag : Real;
   begin
      for I in Body_Name'Range loop
         if I /= Body_Name'Last then
            for J in Body_Name'Succ (I) .. Body_Name'Last loop
               Dx := Bodies (I).X - Bodies (J).X;
               Dy := Bodies (I).Y - Bodies (J).Y;
               Dz := Bodies (I).Z - Bodies (J).Z;

               Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
               Mag := Dt / (Distance ** 3);

               Bodies (I).Vx := Bodies (I).Vx - Dx * Bodies (J).Mass * Mag;
               Bodies (I).Vy := Bodies (I).Vy - Dy * Bodies (J).Mass * Mag;
               Bodies (I).Vz := Bodies (I).Vz - Dz * Bodies (J).Mass * Mag;

               Bodies (J).Vx := Bodies (J).Vx + Dx * Bodies (I).Mass * Mag;
               Bodies (J).Vy := Bodies (J).Vy + Dy * Bodies (I).Mass * Mag;
               Bodies (J).Vz := Bodies (J).Vz + Dz * Bodies (I).Mass * Mag;
            end loop;
         end if;
      end loop;

      for I in Body_Name'Range loop
         Bodies (I).X := Bodies (I).X + Dt * Bodies (I).Vx;
         Bodies (I).Y := Bodies (I).Y + Dt * Bodies (I).Vy;
         Bodies (I).Z := Bodies (I).Z + Dt * Bodies (I).Vz;
      end loop;
   end Advance;

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_IO;      use Ada.Text_IO;
with Nbody_Pck;        use Nbody_Pck;

procedure Nbody is

   package RIO is new Float_Io (Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 9;
      Exp  : Field := 0) renames RIO.Put;

   N : constant Integer := Integer'Value (Argument (1));

   Px, Py, Pz : Real := 0.0;

begin
   for I in Body_Name'Range loop
      Px := Px + Bodies (I).Vx * Bodies (I).Mass;
      Py := Py + Bodies (I).Vy * Bodies (I).Mass;
      Pz := Pz + Bodies (I).Vz * Bodies (I).Mass;
   end loop;

   Offset_Momentum (Bodies (Sun), Px, Py, Pz);

   Put (Energy);
   New_Line;

   for K in 1 .. N loop
      Advance (0.01);
   end loop;

   Put (Energy);
   New_Line;
end Nbody;
--
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
-- 
-- Contributed by Pascal Obry (2005/03/21)
-- Modified by Jonathan Parker 
--
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_IO;      use Ada.Text_IO;
with Nbody_Pck;        use Nbody_Pck;

procedure Nbody is

   N : constant Integer := Integer'Value (Argument (1));

   Bodies : Planets :=
     (Sun     => 
        (X    => 0.0,
         Y    => 0.0,
         Z    => 0.0,
         Vx   => 0.0,
         Vy   => 0.0,
         Vz   => 0.0,
         Mass => Solar_Mass),
      Jupiter => 
        (X    =>  4.84143144246472090e+00,
         Y    => -1.16032004402742839e+00,
         Z    => -1.03622044471123109e-01,
         Vx   =>  1.66007664274403694e-03 * Days_Per_Year,
         Vy   =>  7.69901118419740425e-03 * Days_Per_Year,
         Vz   => -6.90460016972063023e-05 * Days_Per_Year,
         Mass =>  9.54791938424326609e-04 * Solar_Mass),
      Saturn  => 
        (X    =>  8.34336671824457987e+00,
         Y    =>  4.12479856412430479e+00,
         Z    => -4.03523417114321381e-01,
         Vx   => -2.76742510726862411e-03 * Days_Per_Year,
         Vy   =>  4.99852801234917238e-03 * Days_Per_Year,
         Vz   =>  2.30417297573763929e-05 * Days_Per_Year,
         Mass =>  2.85885980666130812e-04 * Solar_Mass),
      Uranus  => 
        (X    =>  1.28943695621391310e+01,
         y    => -1.51111514016986312e+01,
         Z    => -2.23307578892655734e-01,
         Vx   =>  2.96460137564761618e-03 * Days_Per_Year,
         Vy   =>  2.37847173959480950e-03 * Days_Per_Year,
         Vz   => -2.96589568540237556e-05 * Days_Per_Year,
         Mass =>  4.36624404335156298e-05 * Solar_Mass),
      Neptune => 
        (X    =>  1.53796971148509165e+01,
         Y    => -2.59193146099879641e+01,
         Z    =>  1.79258772950371181e-01,
         Vx   =>  2.68067772490389322e-03 * Days_Per_Year,
         Vy   =>  1.62824170038242295e-03 * Days_Per_Year,
         Vz   => -9.51592254519715870e-05 * Days_Per_Year,
         Mass =>  5.15138902046611451e-05 * Solar_Mass));

   package RIO is new Float_IO (Real);

   procedure Put
     (Item : in Real; 
      Fore : in Field := 0; 
      Aft  : in Field := 9;
      Exp  : in Field := 0) 
   renames RIO.Put;

   Px, Py, Pz : Real := 0.0;

begin

   for I in Bodies'Range loop
      Px := Px + Bodies (I).Vx * Bodies (I).Mass;
      Py := Py + Bodies (I).Vy * Bodies (I).Mass;
      Pz := Pz + Bodies (I).Vz * Bodies (I).Mass;
   end loop;

   Offset_Momentum (Bodies (Sun), Px, Py, Pz);

   Put (Energy (Bodies));
   New_Line;

   for K in 1 .. N loop
      Advance (Bodies, 0.01);
   end loop;

   Put (Energy (Bodies));
   New_Line;

 --testing:
 --for I in Body_id loop
 --  put(Bodies(I).X); put(" "); 
 --end loop;

end Nbody;

with Ada.Numerics; use Ada.Numerics;
with Ada.Numerics.Generic_Elementary_Functions;

package Nbody_Pck is

   type Real is digits 15;

   package Math is new Ada.Numerics.Generic_Elementary_Functions (Real);

   Solar_Mass    : constant Real := 4.0 * Pi * Pi;
   Days_Per_Year : constant Real := 365.24;

   type Data is
      record
         X, Y, Z : Real;
         Vx, Vy, Vz : Real;
         Mass : Real;
      end record;

   type Uns is mod 2**64;

   subtype Body_id is Uns range 0 .. 4;

   Sun     : constant := Body_id'First + 0;
   Jupiter : constant := Body_id'First + 1;
   Saturn  : constant := Body_id'First + 2;
   Neptune : constant := Body_id'First + 3;
   Uranus  : constant := Body_id'First + 4;

   type Planets is array (Body_id) of Data;

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real);

   function Energy (Bodies : in Planets) return Real;

   procedure Advance (Bodies : in out Planets; Dt : in Real);

end Nbody_Pck;

package body Nbody_Pck is

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real) is
   begin
      Planet.Vx := -Px / Solar_Mass;
      Planet.Vy := -Py / Solar_Mass;
      Planet.Vz := -Pz / Solar_Mass;
   end Offset_Momentum;

   function Energy (Bodies : in Planets) return Real is
      Dx, Dy, Dz, Distance : Real;
      E                    : Real := 0.0;
   begin
      for I in Bodies'Range loop
         E := E + 0.5 * Bodies (I).Mass
              * (Bodies (I).Vx * Bodies (I).Vx
               + Bodies (I).Vy * Bodies (I).Vy
               + Bodies (I).Vz * Bodies (I).Vz);

         for J in Bodies'Range loop
            if J > I then
               Dx := Bodies (I).X - Bodies (J).X;
               Dy := Bodies (I).Y - Bodies (J).Y;
               Dz := Bodies (I).Z - Bodies (J).Z;
               Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
               E := E - (Bodies (I).Mass * Bodies (J).Mass) / Distance;
            end if;
         end loop;
      end loop;
      return E;
   end Energy;

   procedure Advance (Bodies : in out Planets; Dt : in Real) is
      Dx, Dy, Dz, Mag : Real;
      Delta_r_sqr : Real;
   begin
      for I in Bodies'Range loop
         for J in Bodies'Range loop
            if J < I then
               Dx := (Bodies (I).X - Bodies (J).X);
               Dy := (Bodies (I).Y - Bodies (J).Y);
               Dz := (Bodies (I).Z - Bodies (J).Z);

               Delta_r_sqr := Dx*Dx + Dy*Dy + Dz*Dz;
               Mag         := Dt / (Delta_r_sqr * Math.Sqrt (Delta_r_sqr));

               Bodies (I).Vx := Bodies (I).Vx - Dx  * Bodies (J).Mass * Mag;
               Bodies (I).Vy := Bodies (I).Vy - Dy  * Bodies (J).Mass * Mag;
               Bodies (I).Vz := Bodies (I).Vz - Dz  * Bodies (J).Mass * Mag;
               Bodies (J).Vx := Bodies (J).Vx + Mag * Bodies (I).Mass * Dx;
               Bodies (J).Vy := Bodies (J).Vy + Mag * Bodies (I).Mass * Dy;
               Bodies (J).Vz := Bodies (J).Vz + Mag * Bodies (I).Mass * Dz;
            end if;
         end loop;
      end loop;

      for I in Bodies'Range loop
         Bodies (I).X := Bodies (I).X + Dt * Bodies (I).Vx;
         Bodies (I).Y := Bodies (I).Y + Dt * Bodies (I).Vy;
         Bodies (I).Z := Bodies (I).Z + Dt * Bodies (I).Vz;
      end loop;
   end Advance;

end Nbody_Pck;

-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21
-- Modified by Brian Drummond on 2011/03/24

with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_IO;      use Ada.Text_IO;
with Nbody_Pck;        use Nbody_Pck;

procedure Nbody is

   package RIO is new Float_Io (Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 9;
      Exp  : Field := 0) renames RIO.Put;

   N : constant Integer := Integer'Value (Argument (1));

   Px, Py, Pz : Real := 0.0;

begin
   for I in Body_Name'Range loop
      Add_Momentum (I, Px, Py, Pz);
   end loop;

   Offset_Momentum (Sun, Px, Py, Pz);

   Put (Energy);
   New_Line;

   for K in 1 .. N loop
      Advance(0.01);
   end loop;

   Put (Energy);
   New_Line;
end Nbody;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21
-- Modified by Brian Drummond on 2011/03/24

with Ada.Numerics; use Ada.Numerics;
with Ada.Numerics.Generic_Elementary_Functions;

package Nbody_Pck is

   type Real is Digits 15;

   package Math is new Ada.Numerics.Generic_Elementary_Functions (Real);

   Solar_Mass    : constant Real := 4.0 * Pi * Pi;
   Days_Per_Year : constant Real := 365.24;

   type Body_Name is (Sun, Jupiter, Saturn, Uranus, Neptune);
   type Axes      is (X, Y, Z);

   procedure Offset_Momentum
     (Planet     : in Body_Name;
      Px, Py, Pz : in Real);

   procedure Add_Momentum
     (Planet     : in Body_Name;
      Px, Py, Pz : in out Real);

   function Energy return Real;

   procedure Advance(Dt : in Real);

private

   Position : array (Body_Name,Axes) of Real :=
              (Jupiter => (X    => 4.84143144246472090e+00,
                           Y    => -1.16032004402742839e+00,
                           Z    => -1.03622044471123109e-01),
               Saturn  => (X    => 8.34336671824457987e+00,
                           Y    => 4.12479856412430479e+00,
                           Z    => -4.03523417114321381e-01),
               Uranus  => (X    => 1.28943695621391310e+01,
                           y    => -1.51111514016986312e+01,
                           Z    => -2.23307578892655734e-01),
               Neptune => (X    => 1.53796971148509165e+01,
                           Y    => -2.59193146099879641e+01,
                           Z    => 1.79258772950371181e-01),
               Sun     => (X    => 0.0,
                           Y    => 0.0,
                           Z    => 0.0));

   Velocity : array (Body_Name,Axes) of Real :=
              (Jupiter => (X    => 1.66007664274403694e-03 * Days_Per_Year,
                           Y    => 7.69901118419740425e-03 * Days_Per_Year,
                           Z    => -6.90460016972063023e-05 * Days_Per_Year),
               Saturn  => (X    => -2.76742510726862411e-03 * Days_Per_Year,
                           Y    => 4.99852801234917238e-03 * Days_Per_Year,
                           Z    => 2.30417297573763929e-05 * Days_Per_Year),
               Uranus  => (X    => 2.96460137564761618e-03 * Days_Per_Year,
                           Y    => 2.37847173959480950e-03 * Days_Per_Year,
                           Z    => -2.96589568540237556e-05 * Days_Per_Year),
               Neptune => (X    => 2.68067772490389322e-03 * Days_Per_Year,
                           Y    => 1.62824170038242295e-03 * Days_Per_Year,
                           Z    => -9.51592254519715870e-05 * Days_Per_Year),
               Sun     => (X    => 0.0,
                           Y    => 0.0,
                           Z    => 0.0));

   Mass: constant array (Body_Name) of Real :=
              (Jupiter => 9.54791938424326609e-04 * Solar_Mass,
               Saturn  => 2.85885980666130812e-04 * Solar_Mass,
               Uranus  => 4.36624404335156298e-05 * Solar_Mass,
               Neptune => 5.15138902046611451e-05 * Solar_Mass,
               Sun     => Solar_Mass);

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21
-- Modified by Brian Drummond on 2011/03/24

package body Nbody_Pck is

   procedure Offset_Momentum
     (Planet     : in Body_Name;
      Px, Py, Pz : in Real) is
   begin
      Velocity (Planet, X) := -Px / Solar_Mass;
      Velocity (Planet, Y) := -Py / Solar_Mass;
      Velocity (Planet, Z) := -Pz / Solar_Mass;
   end Offset_Momentum;

   procedure Add_Momentum
     (Planet     : in Body_Name;
      Px, Py, Pz : in out Real) is
   begin
      Px := Px + Velocity (Planet, X) * Mass (Planet);
      Py := Py + Velocity (Planet, Y) * Mass (Planet);
      Pz := Pz + Velocity (Planet, Z) * Mass (Planet);
   end Add_Momentum;

   function Energy return Real is
      Dx, Dy, Dz, Distance : Real;
      E                    : Real := 0.0;
   begin
      for I in Body_Name loop
        E := E + 0.5 * Mass (I)
              * (Velocity (I, X) * Velocity (I, X)
               + Velocity (I, Y) * Velocity (I, Y)
               + Velocity (I, Z) * Velocity (I, Z));

        if I /= Body_Name'Last then
           for J in Body_Name'Succ (I) .. Body_Name'Last loop
              Dx := Position (I, X) - Position (J, X);
              Dy := Position (I, Y) - Position (J, Y);
              Dz := Position (I, Z) - Position (J, Z);

              Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
              E := E - (Mass (I) * Mass (J)) / Distance;
           end loop;
        end if;
      end loop;
      return E;
   end Energy;

   procedure Advance(Dt : in Real) is
      Dx, Dy, Dz, Dist_Sq, Mag : Real;
      Mass_I: Real;
      subtype I_Name is Body_Name range Body_Name'first .. Body_Name'pred(Body_Name'last);

   begin
      for I in I_Name loop
         Mass_I := Mass (I);   
         for J in Body_Name loop
            if J > I then
               Dx := Position (I, X) - Position (J, X);
               Dy := Position (I, Y) - Position (J, Y);
               Dz := Position (I, Z) - Position (J, Z);

               Dist_sq := Dx*Dx + Dy*Dy + Dz*Dz;
               Mag     := Dt / (Dist_sq * Math.Sqrt (Dist_sq));

               Velocity (I, X) := Velocity (I, X) - Dx * Mass (J) * Mag;
               Velocity (I, Y) := Velocity (I, Y) - Dy * Mass (J) * Mag;
               Velocity (I, Z) := Velocity (I, Z) - Dz * Mass (J) * Mag;

               Velocity (J, X) := Velocity (J, X) + Dx * Mass_I * Mag;
               Velocity (J, Y) := Velocity (J, Y) + Dy * Mass_I * Mag;
               Velocity (J, Z) := Velocity (J, Z) + Dz * Mass_I * Mag;

            end if;
         end loop;
      end loop;

      for I in Body_Name loop
         Position (I, X) := Position (I, X) + Dt * Velocity (I, X);
         Position (I, Y) := Position (I, Y) + Dt * Velocity (I, Y);
         Position (I, Z) := Position (I, Z) + Dt * Velocity (I, Z);
      end loop;
   end Advance;

end Nbody_Pck;
-- $Id: nestedloop.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;

procedure NestedLoop is
   Count, M : Natural := 0;
   N        : Positive := 1;
begin

   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   M := N - 1;
   for A in 0 .. M loop
      for B in 0 .. M loop
         for C in 0 .. M loop
            for D in 0 .. M loop
               for E in 0 .. M loop
                  for F in 0 .. M loop
                     Count := Count + 1;
                  end loop;
               end loop;
            end loop;
         end loop;
      end loop;
   end loop;
   Ada.Integer_Text_IO.Put (Item => Count, Width => 0);
   Ada.Text_IO.New_Line;
end NestedLoop;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

procedure Nsieve is

   function Count (M : in Natural) return Natural is
      type Boolean_Array is array (2 .. M) of Boolean;
      C : Natural := 0;
      S : Boolean_Array := (others => True);
      I : Positive;
   begin
      for K in S'Range loop
         if S (K) then
            C := C + 1;
            I := K * 2;
            while I <= M loop
               S (I) := False;
               I := I + K;
            end loop;
         end if;
      end loop;
      return C;
   end Count;

   procedure Run (N : in Natural) is
      M : Natural;
   begin
      M := 2 ** N * 10_000;
      Put ("Primes up to ");
      Put (Item => M, Width => 8);
      Put (" ");
      Put (Item => Count (M), Width => 8);
      New_Line;
   end Run;

   N : constant Natural := Natural'Value (Argument (1));
begin
   Run (N);
   Run (N - 1);
   Run (N - 2);
   
end Nsieve;
-- The Great Computer Language Shootout 
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/19 

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

procedure NsieveBits is

   function Count (M : in Natural) return Natural is
      type Boolean_Array is array (2 .. M) of Boolean;
      pragma Pack (Boolean_Array);
      C : Natural := 0;
      S : Boolean_Array := (others => True);
      I : Positive;
   begin
      for K in S'Range loop
         if S (K) then
            C := C + 1;
            I := K * 2;
            while I <= M loop
               S (I) := False;
               I := I + K;
            end loop;
         end if;
      end loop;
      return C;
   end Count;

   procedure Run (N : in Natural) is
      M : Natural;
   begin
      M := 2 ** N * 10_000;
      Put ("Primes up to ");
      Put (Item => M, Width => 8);
      Put (" "); 
      Put (Item => Count (M), Width => 8);
      New_Line;
   end Run;

   N : constant Natural := Natural'Value (Argument (1));
begin
   Run (N);
   Run (N - 1);
   Run (N - 2);
end NsieveBits;
-- $Id: objinst.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

-- Annotated Ada Reference Manual ISO/IEC 8652:1995: http://www.ada-auth.org/

with Ada.Command_Line, Ada.Characters.Handling, Text_IO, Ada.Tags;

procedure ObjInst is    --  3.451
   pragma Suppress (Discriminant_Check);
   pragma Suppress (Access_Check);
   package CH renames Ada.Characters.Handling;
   use type Ada.Tags.Tag;

   package Toggles is
      type A_Rec is
         tagged record                 --  'tagged' allows fields to be added
            Value       : Boolean := True;
         end record;

      type B_Rec is new A_Rec with
         record
            Flip_Period : Positive := 1;
            Count       : Natural := 0;
         end record;

      type A_Recs_Family_Ptr is access all A_Rec'Class;

      function Activate (X : A_Recs_Family_Ptr) return A_Recs_Family_Ptr;
      pragma Inline (Activate);
   end Toggles;

   package body Toggles is
      function Activate (X : A_Recs_Family_Ptr) return A_Recs_Family_Ptr is
         pragma Suppress (Range_Check);
         pragma Suppress (Tag_Check);
      begin                   --  X is a ptr: no "in out" parms in a function
         if X.all'Tag = A_Rec'Tag then                         --  A_Rec case
            X.all.Value := not X.all.Value;
         else
            declare                       --  Make visible the 2 B_Rec fields
               pragma Suppress (Tag_Check);
               B        : B_Rec renames B_Rec (X.all);
            begin
               B.Count := B.Count + 1;
               if B.Count = B.Flip_Period then
                  B.Count := 0;
                  B.Value := not B.Value;
               end if;
            end;
         end if;
         return X;
      end Activate;
   end Toggles;

   A        : aliased Toggles.A_Rec;      --  "aliased", since X'Access is used
   B        : aliased Toggles.B_Rec;      --  "access all" above for aliased
   N        : Positive := 1;
   Res      : Boolean;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   A := Toggles.A_Rec'(Value => True);
   for K in 1 .. 5 loop
      Res := Toggles.Activate (A'Access).Value;
      Text_IO.Put_Line (CH.To_Lower (Boolean'Image (Res)));
   end loop;
   for Iter in 1 .. N loop
      A := Toggles.A_Rec'(Value => True);
   end loop;
   Text_IO.New_Line;
   B := Toggles.B_Rec'(Value => True, Flip_Period => 3, Count => 0);
   for K in 1 .. 8 loop
      Res := Toggles.Activate (B'Access).Value;
      Text_IO.Put_Line (CH.To_Lower (Boolean'Image (Res)));
   end loop;
   for Iter in 1 .. N loop
      B := Toggles.B_Rec'(Value => True, Flip_Period => 3, Count => 0);
   end loop;
end ObjInst;
-----------------------------------------------------------------------
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
-- contributed by Jim Rogers
-- modified by Gautier de Montmollin
-----------------------------------------------------------------------
with Ada.Numerics.Generic_Elementary_Functions;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;


procedure Partialsums is
   type Real is digits 12;
   package Real_Funcs is new Ada.Numerics.Generic_Elementary_Functions(Real);
   use Real_Funcs;
   package Real_Io is new Ada.Text_Io.Float_Io(Real);
   use Real_Io;

   Two_Thirds : constant := 2.0/3.0;

   N   : Integer;
   A1, A2, A3, A4, A5, A6, A7, A8, A9 : Real := 0.0;
   Alt : Real := -1.0;

begin

   N := Integer'Value(Argument(1));

   for K in 1..N loop
      declare
         Rk : Real := Real(K);
         K2 : Real := Rk**2;
         K3 : Real := K2*Rk;
         Sk : Real := Sin(Rk);
         Ck : Real := Cos(Rk);
      begin
         Alt := -Alt;
         A1 := A1 + Two_Thirds ** (K - 1);
         A2 := A2 + 1.0 / Sqrt(Rk);
         A3 := A3 + 1.0 / (Rk * (Rk + 1.0));
         A4 := A4 + 1.0 / (K3 * Sk * Sk);
         A5 := A5 + 1.0 / (K3 * Ck * Ck);
         A6 := A6 + 1.0 / Rk;
         A7 := A7 + 1.0 / K2;
         A8 := A8 + Alt / Rk;
         A9 := A9 + Alt / (2.0 * Rk - 1.0);
      end;
   end loop;

   Real_Io.Put(Item => A1, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "(2/3)^k");

   Real_Io.Put(Item => A2, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "k^-0.5");

   Real_Io.Put(Item => A3, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "1/k(k+1)");

   Real_Io.Put(Item => A4, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Flint Hills");

   Real_Io.Put(Item => A5, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Cookson Hills");

   Real_Io.Put(Item => A6, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Harmonic");

   Real_Io.Put(Item => A7, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Riemann Zeta");

   Real_Io.Put(Item => A8, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Alternating Harmonic");

   Real_Io.Put(Item => A9, Fore => 1, Aft => 9, Exp => 0);
   Put_Line(Ascii.Ht & "Gregory");
end Partialsums;

--  The Computer Language Shootout
--  http://shootout.alioth.debian.org
--  Calculate digits of pi using the
--  Unbounded Spigot Algorithms
--
--  From Pascal code by Vincent Snijders
--  gmp headers by Karl-Michael Schindler
--  Translated by (New) P2Ada v. 17-June-2006

with Ada.Text_IO;                       use Ada.Text_IO;
with Ada.Integer_Text_IO;               use Ada.Integer_Text_IO;
with Ada.Command_Line;                  use Ada.Command_Line;
with Ada.Calendar;                      use Ada.Calendar;

with Interfaces.C;

procedure pidigits is

  pragma Suppress(All_Checks);

  package GMP_mini is
    type mp_limb_t is new Interfaces.C.unsigned;
    type mp_ptr is access mp_limb_t;

    type mpz_t is record
      mp_alloc, mp_size : Interfaces.C.int;
      mp_d    : mp_ptr;
    end record;

    procedure mpz_init (Dest: out mpz_t);
    pragma Import(C, mpz_init, "__gmpz_init");

    procedure mpz_init_set_ui (Dest: out mpz_t; Src: in Interfaces.C.unsigned_long);
    pragma Import(C, mpz_init_set_ui, "__gmpz_init_set_ui");

    procedure mpz_mul_ui (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.unsigned_long);
    pragma Import(C, mpz_mul_ui, "__gmpz_mul_ui");

    procedure mpz_mul_si (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.int);
    pragma Import(C, mpz_mul_si, "__gmpz_mul_si");

    procedure mpz_add (Dest: out mpz_t; Src1, Src2: in mpz_t);
    pragma Import(C, mpz_add, "__gmpz_add");

    procedure mpz_tdiv_q (Dest: out mpz_t; Src1, Src2: in mpz_t);
    pragma Import(C, mpz_tdiv_q, "__gmpz_tdiv_q");

    function  mpz_get_ui (Src: in mpz_t) return Interfaces.C.unsigned_long;
    pragma Import(C, mpz_get_ui, "__gmpz_get_ui");

    pragma Linker_Options("-lgmp");

  end GMP_Mini;

  procedure Print_pi_digits(num_digits: Integer) is
    use GMP_mini;

    q,r,s,t: mpz_t; --  Transformation matrix components

    u,v,w: mpz_t;   --  Temporary variables

    k,digit: Interfaces.C.int;
    c,i: Integer;
    line: String(1 ..10);

    function Extract(x: Interfaces.C.Unsigned_long) return Interfaces.C.int is
    begin
      mpz_mul_ui(u, q, x);
      mpz_add(u, u, r);
      mpz_mul_ui(v, s, x);
      mpz_add(v, v, t);
      mpz_tdiv_q(w, u, v);
      return Interfaces.C.int(mpz_get_ui(w));
    end Extract;

    use Interfaces.C;

    function IsSafe return Boolean is
    begin
      return digit = Extract(4);
    end IsSafe;

    procedure Produce is
    begin
      mpz_mul_si(r, r, 10);
      mpz_mul_si(v, t, -10 * digit);
      mpz_add(r, r, v);
      mpz_mul_si(q, q, 10);
    end Produce;

    procedure Consume is
    begin
      k:= k + 1;
      mpz_mul_si(r, r, 2*k+1);
      mpz_mul_si(u, q, 4*k+2);
      mpz_add(r, r, u);
      mpz_mul_si(t, t, 2*k+1);
      mpz_mul_si(v, s, 4*k+2);
      mpz_add(t, t, v);
      mpz_mul_si(s, s, k);
      mpz_mul_si(q, q, k);
    end Consume;

  begin
    k := 0;
    i := 0;
    c := 0;
    mpz_init_set_ui(q, 1);
    mpz_init_set_ui(r, 0);
    mpz_init_set_ui(s, 0);
    mpz_init_set_ui(t, 1);
    mpz_init(u);
    mpz_init(v);
    mpz_init(w);
    while i < num_digits loop
      digit := Extract(3);
      while not IsSafe loop
        Consume;
        digit:= Extract(3);
      end loop;
      Produce;
      c:= c + 1;
      line(c) := Character'Val(Character'Pos('0')+digit);
      i:= i + 1;
      if c = 10 then
        Put(line & ASCII.HT & ':');
        Put(i,0); New_Line;
        c := 0;
      end if;
    end loop;
    if  c/=0 then
      Put(line(1..c));
      for i in c+1..10 loop
        Put(' ');
      end loop;
      Put(ASCII.HT & ':');
      Put(i,0);
      New_Line;
    end if;
  end Print_pi_digits;

  n: Integer;

  t0,t1: Time;
  timing: constant Boolean:= False;

begin
  n:= 2_500;
  if Argument_Count=1 then
    n:= Integer'Value(Argument(1));
  end if;
  if timing then
    t0:= Clock;
  end if;
  Print_pi_digits(n);
  if timing then
    t1:= Clock;
    Put("Time in seconds: " & Duration'Image(t1-t0) & " [press return]");
    Skip_Line;
  end if;
end pidigits;
--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org
--  Calculate digits of pi using the Unbounded Spigot Algorithm (step-by-step)
--
--  contributed by Paolo Bonzini & Sean Bartlett
--  modified by Michael Mellor

with Ada.Text_IO;                       use Ada.Text_IO;
with Ada.Integer_Text_IO;               use Ada.Integer_Text_IO;
with Ada.Command_Line;                  use Ada.Command_Line;
with Ada.Calendar;                      use Ada.Calendar;

with GMP_mini_bindings;                 use GMP_mini_bindings;
with Interfaces.C;

procedure pidigits is

  procedure Print_pi_digits(num_digits: Integer) is

    use Interfaces.C;

    numer, accum, denom, tmp1, tmp2: mpz_t;

    function Extract_digit return Interfaces.C.int is
    begin
      if mpz_cmp(numer, accum) > 0 then
        return -1;
      end if;

      -- Compute (numer * 3 + accum) / denom
      mpz_mul_2exp(tmp1, numer, 1);
      mpz_add(tmp1, tmp1, numer);
      mpz_add(tmp1, tmp1, accum);
      mpz_fdiv_qr(tmp1, tmp2, tmp1, denom);

      -- Now, if (numer * 4 + accum) % denom...
      mpz_add(tmp2, tmp2, numer);

      -- ... is normalized, then the two divisions have the same result.
      if mpz_cmp(tmp2, denom) >= 0 then
        return -1;
      end if;

      return Interfaces.C.int(mpz_get_ui(tmp1));
    end Extract_digit;

    k: Interfaces.C.unsigned;

    procedure Next_term is
      y2: constant Interfaces.C.unsigned:= k*2 + 1;
    begin
      mpz_mul_2exp(tmp1, numer, 1);
      mpz_add(accum, accum, tmp1);
      mpz_mul_ui(accum, accum, y2);
      mpz_mul_ui(numer, numer, k);
      mpz_mul_ui(denom, denom, y2);
    end Next_term;

    d: Interfaces.C.int;

    procedure Eliminate_digit is
    begin
      mpz_submul_ui(accum, denom, Interfaces.C.unsigned(d));
      mpz_mul_ui(accum, accum, 10);
      mpz_mul_ui(numer, numer, 10);
    end Eliminate_digit;

    i, c: Integer:= 0;
    line: String(1 ..10);

  begin
    k := 0;
    mpz_init(tmp1);
    mpz_init(tmp2);
    mpz_init_set_ui(numer, 1);
    mpz_init_set_ui(accum, 0);
    mpz_init_set_ui(denom, 1);
    --
    loop
      loop
        k:= k + 1;
        Next_term;
        d:= Extract_digit;
        exit when d /= -1;
      end loop;
      c:= c + 1;
      line(c) := Character'Val(Character'Pos('0')+d);
      i:= i + 1;
      if c = 10 then
        Put(line & ASCII.HT & ':');
        Put(i,0); New_Line;
        c:= 0;
      end if;
      exit when i >= num_digits;
      Eliminate_digit;
    end loop;

    if c/=0 then
      Put(line(1..c));
      for i in c+1..10 loop
        Put(' ');
      end loop;
      Put(ASCII.HT & ':');
      Put(i,0);
      New_Line;
    end if;
  end Print_pi_digits;

  n: Integer;

  t0,t1: Time;
  timing: constant Boolean:= False;

begin
  n:= 2_500;
  if Argument_Count=1 then
    n:= Integer'Value(Argument(1));
  end if;
  if timing then
    t0:= Clock;
  end if;
  Print_pi_digits(n);
  if timing then
    t1:= Clock;
    Put("Time in seconds: " & Duration'Image(t1-t0) & " [press return]");
    Skip_Line;
  end if;
end pidigits;
with Interfaces.C;

package GMP_mini_bindings is

  pragma Linker_Options("-lgmp");

  -- types

  type mp_limb_t is new Interfaces.C.unsigned;
  type mp_ptr is access mp_limb_t;

  type mpz_t is record
    mp_alloc, mp_size : Interfaces.C.int;
    mp_d    : mp_ptr;
  end record;

  -- initialization and input from integer

  procedure mpz_init (Dest: out mpz_t);
  pragma Import(C, mpz_init, "__gmpz_init");

  procedure mpz_init_set_ui (Dest: out mpz_t; Src: in Interfaces.C.unsigned);
  pragma Import(C, mpz_init_set_ui, "__gmpz_init_set_ui");

  -- comparisons

  function mpz_cmp (Op1, Op2 : mpz_t) return Interfaces.C.int;
  pragma Import (C, mpz_cmp, "__gmpz_cmp");

  -- +, -, *, /

  procedure mpz_add (Dest: out mpz_t; Src1, Src2: in mpz_t);
  pragma Import(C, mpz_add, "__gmpz_add");

  procedure mpz_submul_ui (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.unsigned);
  pragma Import(C, mpz_submul_ui, "__gmpz_submul_ui");

  procedure mpz_mul_ui (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.unsigned);
  pragma Import(C, mpz_mul_ui, "__gmpz_mul_ui");

  procedure mpz_mul_si (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.int);
  pragma Import(C, mpz_mul_si, "__gmpz_mul_si");

  procedure mpz_mul_2exp (Dest: out mpz_t; Src: in mpz_t; Exponent: in Interfaces.C.unsigned);
  pragma Import(C, mpz_mul_2exp, "__gmpz_mul_2exp");

  procedure mpz_tdiv_q (Dest: out mpz_t; Src1, Src2: in mpz_t);
  pragma Import(C, mpz_tdiv_q, "__gmpz_tdiv_q");

  procedure mpz_fdiv_qr (Q, R: out mpz_t; Num, Den: in mpz_t);
  pragma Import(C, mpz_fdiv_qr, "__gmpz_fdiv_qr");

  -- output to integer

  function  mpz_get_ui (Src: in mpz_t) return Interfaces.C.unsigned;
  pragma Import(C, mpz_get_ui, "__gmpz_get_ui");

end GMP_mini_bindings;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/18

with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Command_Line;    use Ada.Command_Line;

procedure Process is

   type Link;
   type Link_Access is access Link;

   task type Link (Next_Link : Link_Access)is
      pragma Storage_Size (100_000);
      entry Receive (I : in Integer);
   end Link;

   task body Link is
      Val : Integer;
   begin
      accept Receive (I : in Integer) do
         Val := I;
      end Receive;

      if Next_Link = Null then
         Put(Item => Val + 1, Width => 0);
         New_Line;
      else
         Next_Link.Receive (Val + 1);
      end if;
   end Link;

   Num_Tasks : Positive := 251;
   New_Task  : Link_Access;
   Last_Task : Link_Access := null;

begin
   if Argument_Count > 0 then
      Num_Tasks := Positive'Value (Argument (1));
   end if;

   for Item in 1..Num_Tasks loop
      New_Task := new Link (Last_Task);
      Last_Task := New_Task;
   end loop;

   New_Task.Receive (0);
end Process;
-- $Id: prodcons.gnat,v 1.2 2005-05-13 16:24:18 igouy-guest Exp $
-- http://dada.perl.it/shootout/ 
-- Ada 95 code by C.C.

with Ada.Strings.Fixed, Ada.Command_Line, Text_IO;

procedure ProdCons is

   type Data_Type is new Integer;
   End_Of_Data    : constant Data_Type := Data_Type'First;

   protected Queue is
      entry Put (Data : Data_Type);
      entry Get (Data_Out : out Data_Type);
   private
      Count          : Natural := 0;
      Buffer         : Data_Type;
   end Queue;

   protected body Queue is
      entry Put (Data : Data_Type)
         when Count = 0 is
      begin
         Buffer := Data;
         Count := Count + 1;
      end Put;

      entry Get (Data_Out : out Data_Type)
         when Count /= 0 is
      begin
         Data_Out := Buffer;
         Count := Count - 1;
      end Get;
   end Queue;

   Produced, Consumed : Natural := 0;

   task type Producer_Task (N : Natural);
   task type Consumer_Task (N : Natural);

   task body Producer_Task is
   begin
      for Data_K in 1 .. Data_Type (N) loop
         Queue.Put (Data => Data_K);
         Produced := Produced + 1;
      end loop;
      Queue.Put (Data => End_Of_Data);
   end Producer_Task;

   task body Consumer_Task is
      Data        : Data_Type;
   begin
      loop
         Queue.Get (Data_Out => Data);
         exit when Data = End_Of_Data;
         Consumed := Consumed + 1;
      end loop;
   end Consumer_Task;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   declare
      Producer    : Producer_Task (N => N);
      Consumer    : Consumer_Task (N => N);
   begin
      null;
   end;
   Text_IO.Put_Line (L_Trim (Natural'Image (Produced)) &
            Natural'Image (Consumed));
end ProdCons;

-- $Id: random.gnat,v 1.2 2005-03-25 07:59:08 bfulgham Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23

with System, Ada.Command_Line, Ada.Text_IO;

procedure Random is
   type Real is new Long_Float;
   package Rio is new Ada.Text_IO.Float_IO (Num => Real);

   package Random_Real is
      function Gen_Random (Supr : Real) return Real;
      pragma Inline (Gen_Random);
   end Random_Real;

   package body Random_Real is
      IM          : constant Positive := 139968;
      IA          : constant Integer := 3877;
      IC          : constant Integer := 29573;
      Last        : Integer := 42;

      function Gen_Random (Supr : Real) return Real is
         pragma Suppress (Overflow_Check);
         pragma Suppress (Range_Check);
      begin
         Last := (Last * IA + IC) mod IM;
         return Supr * Real (Last) / Real (IM);
      end Gen_Random;
         --  Assume no overflow for "Natural ((IM - 1) * IA + IC)"
   end Random_Real;

   Result   : Real;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      Result := Random_Real.Gen_Random (Supr => 100.0);
   end loop;
   Rio.Put (Result, Fore => 0, Aft => 9, Exp => 0);
   Ada.Text_IO.New_Line;
end Random;
-----------------------------------------------------------------------
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org
-- contributed by Jim Rogers and Gautier de Montmollin
-----------------------------------------------------------------------

with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;

procedure Recursive is
   type Real is digits 15;
   package Real_Io is new Ada.Text_Io.Float_Io(Real);
   use Real_Io;
   package Int_Io is new Ada.Text_Io.Integer_Io(Long_Integer);
   use Int_Io;

   N : Long_Integer;

   function Ack (M, N : Long_Integer) return Long_Integer is
   begin
      if M = 0 then
         return N + 1;
      end if;
      if N = 0 then
         return Ack(M - 1, 1);
      end if;
      return Ack(M - 1, Ack(M, N - 1));
   end Ack;
   function Fib(N : Long_Integer) return Long_Integer is
   begin
      if N < 2 then
         return 1;
      else
         return Fib(N - 2) + Fib(N - 1);
      end if;
   end Fib;
   function Tak(X, Y, Z : Long_Integer) return Long_Integer is
   begin
      if Y < X then
         return Tak(Tak(X -1, Y, Z), Tak(Y-1, Z, X), Tak(Z - 1, X, Y));
      else
         return Z;
      end if;
   end Tak;
   function Fib(N : Real) return Real is
   begin
      if N < 2.0 then
         return 1.0;
      else
         return Fib(N - 2.0) + Fib(N - 1.0);
      end if;
   end Fib;
   function Tak(X, Y, Z : Real) return Real is
   begin
      if Y < X then
         return Tak(Tak(X - 1.0, Y, X), Tak(Y - 1.0, Z, X), Tak(Z - 1.0, X, Y));
      else
         return Z;
      end if;
   end Tak;

begin
   N := Long_Integer'Value(Argument(1));

   Put("Ack(3,"); Put(Item => N, Width => 1); Put("): ");
   Put(Item => Ack(3, N), Width => 1); New_Line;

   Put("Fib("); Put(Item => Real(N)+27.0, Fore => 1, Aft => 1, Exp => 0);
   Put("): "); Put(Item => Fib(Real(N) + 27.0), Fore => 1, Aft => 1, Exp => 0);
   New_Line;

   N := N - 1;
   Put("Tak("); Put(Item => N*3, Width => 1); Put(",");
   Put(Item => N*2, Width => 1); Put(","); Put(Item => N, Width => 1);
   Put("): "); Put(Item => Tak(N*3, N*2, N), Width => 1); New_Line;

   Put("Fib(3): "); Put(Item => Fib(3), Width => 0); New_Line;
   Put("Tak(3.0,2.0,1.0): "); Put(Item => Tak(3.0,2.0,1.0), Aft => 1, Exp => 0, Fore => 1);
   New_Line;

end Recursive;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Georg Bauhaus
--
-- This version uses the GNAT Spitbol Pattern matching libraries
-- rather than the more commonly used Unix-style regex libraries

with Gnat.Spitbol.Patterns; use Gnat.Spitbol.Patterns;
use Gnat.Spitbol;

package DNA is

   subtype Variant_Index is Positive range 1..9;
   Variant_Labels : constant array (Variant_Index) of Vstring := (
      V("agggtaaa|tttaccct"),
      V("[cgt]gggtaaa|tttaccc[acg]"),
      V("a[act]ggtaaa|tttacc[agt]t"),
      V("ag[act]gtaaa|tttac[agt]ct"),
      V("agg[act]taaa|ttta[agt]cct"),
      V("aggg[acg]aaa|ttt[cgt]ccct"),
      V("agggt[cgt]aa|tt[acg]accct"),
      V("agggta[cgt]a|t[acg]taccct"),
      V("agggtaa[cgt]|[acg]ttaccct"));

   Variant_Patterns : constant array(Variant_Index) of Pattern := (
      "agggtaaa" or "tttaccct",
      (Any("cgt") & "gggtaaa") or ("tttaccc" & Any("acg")),
      ("a" & Any("act") & "ggtaaa") or ("tttacc" & Any("agt") & "t"),
      ("ag" & Any("act") & "gtaaa") or ("tttac" & Any("agt") & "ct"),
      ("agg" & Any("act") & "taaa") or ("ttta" & Any("agt") & "cct"),
      ("aggg" & Any("acg") & "aaa") or ("ttt" & Any("cgt") & "ccct"),
      ("agggt" & Any("cgt") & "aa") or ("tt" & Any("acg") & "accct"),
      ("agggta" & Any("cgt") & "a") or ("t" & Any("acg") & "taccct"),
      ("agggtaa" & Any("cgt")) or (Any("acg") & "ttaccct"));

   type Iub is
      record
         Code         : Pattern;
         Alternatives : VString;
   end record;
   subtype Codes_Index is Natural range 1..11;
   type Codes_Array is array (Codes_Index) of Iub;
   Codes : constant Codes_Array := (
      (Any("B"), V("(c|g|t)")),
      (Any("D"), V("(a|g|t)")),
      (Any("H"), V("(a|c|t)")),
      (Any("K"), V("(g|t)")),
      (Any("M"), V("(a|c)")),
      (Any("N"), V("(a|c|g|t)")),
      (Any("R"), V("(a|g)")),
      (Any("S"), V("(c|g)")),
      (Any("V"), V("(a|c|g)")),
      (Any("W"), V("(a|t)")),
      (Any("Y"), V("(c|t)")));

   type Lines is array(Positive range <>) of Vstring;

end DNA;

-- ----------------
-- main subprogram
-- ----------------
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;
with Gnat.Spitbol.Patterns; use Gnat.Spitbol.Patterns;
use Gnat.Spitbol;

with DNA.Matching;
with DNA.Replacing;
use DNA;

procedure Regexdna is

   function Length(Item : in DNA.Lines) return Natural is
      Sum : Natural := 0;
   begin
      for I in Item'range loop
         Sum := Sum + Size(Item(I));
      end loop;
      return Sum;
   end Length;


   Initial_Length : Natural := 0;
   Code_Length : Natural;
   Line : String(1..80);
   Var_Line : Vstring_Var;
   Line_Length : Natural;
   Sequence : aliased Vstring_Var;
   Fasta_Description : constant Pattern := Pos(0) & ">" & Rest;
   Num_Lines : Natural;
   Split_Length : constant := 80;
begin

   -- Read FASTA Sequence
   -- Record length and remove the unwanted elements

   while not End_Of_File loop
      Get_Line(Item => Line, Last => Line_Length);
      Var_Line := V(Line(1..Line_Length));
      Initial_Length := Initial_Length + Size(Var_Line) + 1;
      Match(Subject => Var_Line,
         Pat => Fasta_Description, Replace => "");
      Append(Source => Sequence, New_Item => Var_Line);
   end loop;
   Code_Length := Length(Sequence);


   Matching_Part:
   declare
      Worker : array (Variant_Index) of Matching.Service(Sequence'Access);
      Count : Natural;
   begin
      -- assign tasks
      for Variant in Variant_Index loop
         Worker(Variant).Match_Variant(Variant);
      end loop;

      -- print results so far
      for Variant in Variant_Index Loop
         Matching.Stats.Get(Variant)(Result => Count);
         Put(To_String(Variant_Labels(Variant)) & " ");
         Put(Item => Count, Width => 1);
         New_Line;
      end loop;

   end Matching_Part;


   -- regex substitution

   Num_Lines := Length(Sequence) / Split_Length;
   if Length(Sequence) mod Split_Length > 1 then
      Num_Lines := Num_Lines + 1;
   end if;

   Replacing_Part:
   declare
      type Sequence_Lines_Access is access DNA.Lines;
      Sequence_Lines_Pointer : constant Sequence_Lines_Access :=
        new DNA.Lines(1..Num_Lines);
      Sequence_Lines : DNA.Lines renames Sequence_Lines_Pointer.all;

      Worker : array (Codes_Index) of Replacing.Service(Sequence_Lines_Pointer);
      Low, Sub_Len : Natural;
   begin
      -- Distribute Sequence to Sequence_Lines
      Low := 1;
      Sub_Len := Split_Length;
      for I in Sequence_Lines'range loop
         Sequence_Lines(I) := Substr(Str => Sequence ,
            Start => Low, Len => Sub_Len );
         Low := Low + Sub_Len;
         if Low + Sub_Len > Length(Sequence) then
            Sub_Len := Length(Sequence) - Low + 1;
         end if;
      end loop;

      -- replace
      for L in Worker'Range loop
         Worker(L).Replace (First_Line => L);
      end loop;

      -- wait for results and report
      Replacing.Stats.Collect;
      New_Line;
      Put(Item => Initial_Length, Width => 1);
      New_Line;
      Put(Item => Code_Length, Width => 1);
      New_Line;
      Put(Item => Length(Sequence_Lines), Width => 1);
      New_Line;
   end Replacing_Part;

end Regexdna;

-- ----------------
-- match
-- ----------------
package DNA.Matching is

   task type Service(Sequence : access VString_Var) is
      -- perform matching one pattern concurrently

      entry Match_Variant(Variant : Variant_Index);
   end Service;


   type Occurrences is array (Variant_Index) of Natural;

   No_Count : constant Natural := Natural'Last;

   protected Stats is
      -- collect counts from tasks, waiting to be printed

      procedure Report(Variant : Variant_Index; Count : Natural);
      entry Get(Variant_Index)(Result : out Natural);
   private
      Data : Occurrences := (Variant_Index => No_Count);
   end Stats;

end DNA.Matching;


package body DNA.Matching is

   task body Service is
      Count : Natural := 0;
      function Inc_Count return Boolean is
      begin
         Count := Count + 1;
         return False;
      end Inc_Count;
      Variant : Variant_Index;
   begin
      accept Match_Variant(Variant : Variant_Index) do
         Service.Variant := Variant;
      end Match_Variant;

      Count := 0;
      Match(Subject => Sequence.all,
            Pat => Variant_Patterns(Variant) & (+Inc_Count'Unrestricted_Access));
      Stats.Report(Variant, Count);
   end Service;


   protected body Stats is
      procedure Report(Variant : Variant_Index; Count : Natural) is
      begin
         Data(Variant) := Count;
      end Report;

      entry Get(for Variant in Variant_Index)(Result : out Natural)
      when Data(Variant) /= No_Count is
      begin
         Result := Data(Variant);
      end Get;
   end Stats;

end DNA.Matching;


-- ----------------
-- match-replace
-- ----------------
package DNA.Replacing is

   task type Service(Sequence_Lines : access DNA.Lines)  is
      --
      --  replace in one bunch of lines
      --
      entry Replace(First_Line : Codes_Index);
   end Service;

   type Task_Status is array (Codes_Index) of Boolean;

   protected Stats is
      procedure Done(Who : Codes_Index);
      entry Collect;
      --  wait for all to have called `Done`
   private
      Finished : Task_Status := (Codes_Index => False);
   end Stats;

end DNA.Replacing;


package body DNA.Replacing is

   task body Service is

      Offset : Positive range Codes_Index'Range;
      Step : constant Positive := Codes_Index'Last;
      --  the task's loop skips `Step` lines in `Sequence_Lines`

      Limit : Natural;
      I : Positive;
   begin
      accept Replace(First_Line : Codes_Index) do
         Offset := First_Line;
      end Replace;

      Limit := Sequence_Lines'Last + Offset - Step;
      I := Offset;

      -- Perform the regex substitution.  Likely facing
      --
      -- (1a) the GREAT BIG subtstitution problem
      --      (cf. D.W.E. Blatt, 1980)
      -- (1b) replacements in Unbounded_String which
      --      the pattern matching implementation is using
      while I <= Limit loop
         for C in Codes_Index loop
            while
               Match(Subject => Sequence_Lines(I),
                     Pat => Codes(C).Code,
                     Replace => Codes(C).Alternatives)
            loop
               null;
            end loop;
         end loop;
         I := I + Step;
      end loop;

      Stats.Done(Offset);

   end Service;


   protected body Stats is
      procedure Done(Who : Codes_Index) is
      begin
         Finished (Who) := True;
      end Done;

      entry Collect
      when Finished = (Finished'Range => True) is
      begin
         null;
      end Collect;
   end Stats;

end DNA.Replacing;

-- spec of GNAT Pattern library package with Stack_Size setting
with Ada.Strings.Maps; use Ada.Strings.Maps;
with Ada.Text_IO;      use Ada.Text_IO;
package GNAT.Spitbol.Patterns is
   pragma Elaborate_Body;
   type Pattern is private;
   type Boolean_Func is access function return Boolean;
   type Natural_Func is access function return Natural;
   type VString_Func is access function return VString;
   subtype PString is String;
   subtype PChar is Character;
   subtype VString_Var is VString;
   subtype Pattern_Var is Pattern;
   function "&"  (L : Pattern; R : Pattern) return Pattern;
   function "&"  (L : PString; R : Pattern) return Pattern;
   function "&"  (L : Pattern; R : PString) return Pattern;
   function "&"  (L : PChar;   R : Pattern) return Pattern;
   function "&"  (L : Pattern; R : PChar)   return Pattern;
   function "or" (L : Pattern; R : Pattern) return Pattern;
   function "or" (L : PString; R : Pattern) return Pattern;
   function "or" (L : Pattern; R : PString) return Pattern;
   function "or" (L : PString; R : PString) return Pattern;
   function "or" (L : PChar;   R : Pattern) return Pattern;
   function "or" (L : Pattern; R : PChar)   return Pattern;
   function "or" (L : PChar;   R : PChar)   return Pattern;
   function "or" (L : PString; R : PChar)   return Pattern;
   function "or" (L : PChar;   R : PString) return Pattern;
   function "*" (P : Pattern; Var : VString_Var)  return Pattern;
   function "*" (P : PString; Var : VString_Var)  return Pattern;
   function "*" (P : PChar;   Var : VString_Var)  return Pattern;
   function "**" (P : Pattern; Var : VString_Var) return Pattern;
   function "**" (P : PString; Var : VString_Var) return Pattern;
   function "**" (P : PChar;   Var : VString_Var) return Pattern;
   function "+" (Str : VString_Var)  return Pattern;
   function "+" (Str : VString_Func) return Pattern;
   function "+" (P : Pattern_Var)    return Pattern;
   function "+" (P : Boolean_Func)   return Pattern;
   function Arb                                             return Pattern;
   function Arbno  (P : Pattern)                            return Pattern;
   function Arbno  (P : PString)                            return Pattern;
   function Arbno  (P : PChar)                              return Pattern;
   function Any    (Str : String)                           return Pattern;
   function Any    (Str : VString)                          return Pattern;
   function Any    (Str : Character)                        return Pattern;
   function Any    (Str : Character_Set)                    return Pattern;
   function Any    (Str : not null access VString)          return Pattern;
   function Any    (Str : VString_Func)                     return Pattern;
   function Bal                                             return Pattern;
   function Break  (Str : String)                           return Pattern;
   function Break  (Str : VString)                          return Pattern;
   function Break  (Str : Character)                        return Pattern;
   function Break  (Str : Character_Set)                    return Pattern;
   function Break  (Str : not null access VString)          return Pattern;
   function Break  (Str : VString_Func)                     return Pattern;
   function BreakX (Str : String)                           return Pattern;
   function BreakX (Str : VString)                          return Pattern;
   function BreakX (Str : Character)                        return Pattern;
   function BreakX (Str : Character_Set)                    return Pattern;
   function BreakX (Str : not null access VString)          return Pattern;
   function BreakX (Str : VString_Func)                     return Pattern;
   function Cancel                                          return Pattern;
   function Fail                                            return Pattern;
   function Fence                                           return Pattern;
   function Fence  (P : Pattern)                            return Pattern;
   function Len    (Count : Natural)                        return Pattern;
   function Len    (Count : not null access Natural)        return Pattern;
   function Len    (Count : Natural_Func)                   return Pattern;
   function NotAny (Str : String)                           return Pattern;
   function NotAny (Str : VString)                          return Pattern;
   function NotAny (Str : Character)                        return Pattern;
   function NotAny (Str : Character_Set)                    return Pattern;
   function NotAny (Str : not null access VString)          return Pattern;
   function NotAny (Str : VString_Func)                     return Pattern;
   function NSpan  (Str : String)                           return Pattern;
   function NSpan  (Str : VString)                          return Pattern;
   function NSpan  (Str : Character)                        return Pattern;
   function NSpan  (Str : Character_Set)                    return Pattern;
   function NSpan  (Str : not null access VString)          return Pattern;
   function NSpan  (Str : VString_Func)                     return Pattern;
   function Pos    (Count : Natural)                        return Pattern;
   function Pos    (Count : not null access Natural)        return Pattern;
   function Pos    (Count : Natural_Func)                   return Pattern;
   function Rest                                            return Pattern;
   function Rpos   (Count : Natural)                        return Pattern;
   function Rpos   (Count : not null access Natural)        return Pattern;
   function Rpos   (Count : Natural_Func)                   return Pattern;
   function Rtab   (Count : Natural)                        return Pattern;
   function Rtab   (Count : not null access Natural)        return Pattern;
   function Rtab   (Count : Natural_Func)                   return Pattern;
   function Setcur (Var : not null access Natural)          return Pattern;
   function Span   (Str : String)                           return Pattern;
   function Span   (Str : VString)                          return Pattern;
   function Span   (Str : Character)                        return Pattern;
   function Span   (Str : Character_Set)                    return Pattern;
   function Span   (Str : not null access VString)          return Pattern;
   function Span   (Str : VString_Func)                     return Pattern;
   function Succeed                                         return Pattern;
   function Tab    (Count : Natural)                        return Pattern;
   function Tab    (Count : not null access Natural)        return Pattern;
   function Tab    (Count : Natural_Func)                   return Pattern;
   Anchored_Mode : Boolean := False;
   Pattern_Stack_Overflow : exception;
   Stack_Size : constant Positive := 20;
   function Match
     (Subject : VString;
      Pat     : Pattern) return Boolean;
   function Match
     (Subject : VString;
      Pat     : PString) return Boolean;
   function Match
     (Subject : String;
      Pat     : Pattern) return Boolean;
   function Match
     (Subject : String;
      Pat     : PString) return Boolean;
   function Match
     (Subject : VString_Var;
      Pat     : Pattern;
      Replace : VString) return Boolean;
   function Match
     (Subject : VString_Var;
      Pat     : PString;
      Replace : VString) return Boolean;
   function Match
     (Subject : VString_Var;
      Pat     : Pattern;
      Replace : String) return Boolean;
   function Match
     (Subject : VString_Var;
      Pat     : PString;
      Replace : String) return Boolean;
   procedure Match
     (Subject : VString;
      Pat     : Pattern);
   procedure Match
     (Subject : VString;
      Pat     : PString);
   procedure Match
     (Subject : String;
      Pat     : Pattern);
   procedure Match
     (Subject : String;
      Pat     : PString);
   procedure Match
     (Subject : in out VString;
      Pat     : Pattern;
      Replace : VString);
   procedure Match
     (Subject : in out VString;
      Pat     : PString;
      Replace : VString);
   procedure Match
     (Subject : in out VString;
      Pat     : Pattern;
      Replace : String);
   procedure Match
     (Subject : in out VString;
      Pat     : PString;
      Replace : String);
   type Match_Result is private;
   subtype Match_Result_Var is Match_Result;
   function Match
     (Subject : VString_Var;
      Pat     : Pattern;
      Result  : Match_Result_Var) return Boolean;
   procedure Match
     (Subject : in out VString;
      Pat     : Pattern;
      Result  : out Match_Result);
   procedure Replace
     (Result  : in out Match_Result;
      Replace : VString);
   Debug_Mode : Boolean := False;
   function "*"  (P : Pattern; Fil : File_Access)           return Pattern;
   function "*"  (P : PString; Fil : File_Access)           return Pattern;
   function "*"  (P : PChar;   Fil : File_Access)           return Pattern;
   function "**" (P : Pattern; Fil : File_Access)           return Pattern;
   function "**" (P : PString; Fil : File_Access)           return Pattern;
   function "**" (P : PChar;   Fil : File_Access)           return Pattern;
   Terminal : constant File_Access := Standard_Error;
   Output   : constant File_Access := Standard_Output;
   function Image (P : Pattern) return String;
   function Image (P : Pattern) return VString;
   procedure Dump (P : Pattern);
private
   type PE;
   type PE_Ptr is access all PE;
   type Pattern is new Controlled with record
      Stk : Natural := 0;
      P : PE_Ptr := null;
   end record;
   pragma Finalize_Storage_Only (Pattern);
   procedure Adjust (Object : in out Pattern);
   procedure Finalize (Object : in out Pattern);
   type VString_Ptr is access all VString;
   type Match_Result is record
      Var : VString_Ptr;
      Start : Natural := 1;
      Stop : Natural := 0;
   end record;
   pragma Volatile (Match_Result);
end GNAT.Spitbol.Patterns;
-- $Id: regexmatch.gnat-2.gnat,v 1.2 2005-05-15 06:34:27 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/04/01

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Text_IO;         use Ada.Text_IO;
with GNAT.Regpat;         use GNAT.Regpat;

procedure Regexmatch.Gnat-2 is

   N        : constant Positive := Positive'Value (Argument (1));

   Max_Line : constant := 100;

   Pattern : constant String :=
               "(^|^\D*[^\(\d])"         -- start conditions
             & "((\(\d\d\d\))|(\d\d\d))" -- area code
             & "[ ]"                     -- area code followed by one space
             & "(\d\d\d)"                -- match 3: prefix of 3 digits
             & "[ -]"                    -- separator is either space or dash
             & "(\d\d\d\d)"              -- match 4: last 4 digits
             & "(\D|$)";                 -- must be followed by a non-digit

   type String_Access is access String;

   Lines : array (1 .. Max_Line) of String_Access;
   L     : Natural := 0;

   Buffer : String (1 .. 1_024);
   Last   : Natural;

   Matcher : Pattern_Matcher := Compile (Pattern);
   Matches : Match_Array (1 .. 10);

   Result  : String := ": (...) ...-....";
   Count   : Natural := 0;

   subtype Area_Code is Positive range 4 .. 6;
   subtype Prefix is Positive range 9 .. 11;
   subtype Number is Positive range 13 .. 16;

begin
   begin
      loop
         Get_Line (Buffer, Last);
         L := L + 1;
         Lines (L) := new String'(Buffer (1 .. Last));
      end loop;
   exception
      when others => null;
   end;

   for Iter in 1 .. N loop
      for K in 1 .. L loop
         Match (Matcher, Lines (K).all, Matches);

         if Iter = N then
            if Matches (1) /= No_Match then
               if Lines (K) (Matches (2).First) = '(' then
                  Result (Area_Code) :=
                    Lines (K) (Matches (2).First + 1 .. Matches (2).Last - 1);
               else
                  Result (Area_Code) :=
                    Lines (K) (Matches (2).First .. Matches (2).Last);
               end if;

               Result (Prefix) :=
                 Lines (K) (Matches (5).First .. Matches (5).Last);
               Result (Number) :=
                 Lines (K) (Matches (6).First .. Matches (6).Last);

               Count := Count + 1;
               Put (Count, Width => 0);
               Put_Line (Result);
            end if;
         end if;
      end loop;
   end loop;
end Regexmatch.Gnat-2;
-- $Id: revcomp.gnat,v 1.2 2005-04-04 09:59:22 obry-guest Exp $
-- http://dada.perl.it/shootout/
-- Contributed by Pascal Obry on 2005/03/19
-- Optimized by Bill Findlay on 2005/04/04

with Ada.Text_IO;                use Ada.Text_IO;
with Ada.Unchecked_Deallocation;

procedure Revcomp is

   Complement : constant array (Character) of Character :=
                  ('A' => 'T', 'C' => 'G', 'G' => 'C', 'T' => 'A', 'U' => 'A',
                   'M' => 'K', 'R' => 'Y', 'W' => 'W', 'S' => 'S', 'Y' => 'R',
                   'K' => 'M', 'V' => 'B', 'H' => 'D', 'D' => 'H', 'B' => 'V',
                   'N' => 'N',
                   'a' => 'T', 'c' => 'G', 'g' => 'C', 't' => 'A', 'u' => 'A',
                   'm' => 'K', 'r' => 'Y', 'w' => 'W', 's' => 'S', 'y' => 'R',
                   'k' => 'M', 'v' => 'B', 'h' => 'D', 'd' => 'H', 'b' => 'V',
                   'n' => 'N',
                   others => '?');

   Max_Length : constant := 60;

   type String_Access is access String;

   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);

   procedure Get_Fasta (Seq : in out String_Access; Length : out Natural) is
      Ptr  : String_Access;
      J, K : Natural := 0;
      C    : Character;
      EOL  : Boolean;
   begin
      Length := 0;

      loop
         Look_Ahead (C, EOL);
         exit when C /= '>' and C /= ';' ;
         Get_Line (Seq (1 .. Seq'Length), J);
         if Seq (1) = '>' then
            Put_Line (Seq (1 .. J));
         end if;
      end loop;

      loop
         if Length + Max_Length > Seq'Length then
            Ptr := Seq;
            Seq := new String (1 .. 2 * Seq'Length);
            Seq (1 .. Length) := Ptr (1 .. Length);
            Free (Ptr);
         end if;

         Get_Line (Seq (Length + 1 .. Length + Max_Length), J);
         K := J - Length;
         Length := J;

         if K = Max_Length then
            Skip_Line;
         end if;

         Look_Ahead (C, EOL);

         if K < Max_Length or else C = '>' or else C = ';' then
            return;
         end if;
      end loop;
   exception
      when End_Error =>
         return;
   end Get_Fasta;

   procedure Reverse_Fasta (Fasta : in out String) is
      C    : Character;
      L, R : Natural;
   begin
      for I in 0 .. Fasta'Length loop
         L := Fasta'First + I;
         R := Fasta'Last - I;
         exit when L > R;
         C := Fasta (L);
         Fasta (L) := Complement (Fasta (R));
         Fasta (R) := Complement (C);
      end loop;
   end Reverse_Fasta;

   procedure Put_Reversed_Fasta (Fasta : in out String) is
      L : Natural := Fasta'Last;
   begin
      while L >= Max_Length loop
         Reverse_Fasta (Fasta (L - Max_Length + 1 .. L));
         Put_Line (Fasta (L - Max_Length + 1 .. L));
         L := L - Max_Length;
      end loop;
      if L > 0 then
         Reverse_Fasta (Fasta (1 .. L));
         Put_Line (Fasta (1 .. L));
      end if;
   end Put_Reversed_Fasta;

   Seq    : String_Access := new String (1 .. 1_024);
   Length : Natural;

begin
   loop
      Get_Fasta (Seq, Length);
      exit when Length = 0;
      Put_Reversed_Fasta (Seq (1 .. Length));
   end loop;
end Revcomp;
--
--  The Computer Language Benchmarks Game
--  http://shootout.alioth.debian.org/
--
--  Contributed by Pascal Obry on 2005/03/19
--  Modified by Bill Findlay  on 2005/04/04
--  Modified by Jonathan Parker and Georg Bauhaus


with Choice_Of_Line_Feed;
with Text_Input; use Text_Input;
with Streamed_Line_IO; 

procedure Revcomp is

   Multitasking_Version_Desired : constant Boolean := True;

   End_Of_Line : constant String := Choice_Of_Line_Feed.Separator;

   Complement : constant array (Character) of Character :=
     ('A' => 'T', 'C' => 'G', 'G' => 'C', 'T' => 'A', 'U' => 'A',
      'M' => 'K', 'R' => 'Y', 'W' => 'W', 'S' => 'S', 'Y' => 'R',
      'K' => 'M', 'V' => 'B', 'H' => 'D', 'D' => 'H', 'B' => 'V',
      'N' => 'N',
      'a' => 'T', 'c' => 'G', 'g' => 'C', 't' => 'A', 'u' => 'A',
      'm' => 'K', 'r' => 'Y', 'w' => 'W', 's' => 'S', 'y' => 'R',
      'k' => 'M', 'v' => 'B', 'h' => 'D', 'd' => 'H', 'b' => 'V',
      'n' => 'N',
      others => '?');

   Max_Line_Length : constant := 60;

   procedure Reverse_Fasta 
     (Fasta_Line   : in     String_Access;
      Fasta_Start  : in     Natural;
      Fasta_Finish : in     Natural;
      Bundle       : in out String) 
   is
      L : Natural := Bundle'First; -- Leftmost char
      R : Natural := Fasta_Finish; -- Rightmost char
   begin
      loop
         exit when R < Fasta_Start;
         Bundle(L) := Complement(Fasta_Line(R));
         R := R - 1;
         L := L + 1;
      end loop;
   end Reverse_Fasta;

   pragma Inline (Reverse_Fasta);

   procedure Put_Reversed_Fasta 
     (Fasta_Section     : in String_Access;
      Fasta_Data_Length : in Natural) 
   is
      Lines_per_Bundle : constant := 4000;
      Line_Feed_Len    : constant := Choice_Of_Line_Feed.Separator'Length;
      Line_Bundle : String(1 .. Lines_per_Bundle*(Max_Line_Length + Line_Feed_Len));
      L        : Natural := Fasta_Data_Length;
      B_start  : Natural := Line_Bundle'First;
      B_finish : Natural := B_start + Max_Line_Length - 1;
   begin

      --  Append line feed string (End_Of_Line) to 4000 Line_Bundle lines:

      while L >= Lines_per_Bundle * Max_Line_Length loop
         B_start := Line_Bundle'First;
         for j in 1 .. Lines_per_Bundle loop
            B_finish := B_start + Max_Line_Length - 1;
            Reverse_Fasta 
              (Fasta_Line   => Fasta_Section, 
               Fasta_Start  => L - Max_Line_Length + 1,
               Fasta_Finish => L,
               Bundle       => Line_Bundle(B_start .. B_finish));
            Line_Bundle(B_finish + 1 .. B_finish + Line_Feed_Len) := End_Of_Line;
            B_start := B_finish + Line_Feed_Len + 1; 
            L       := L - Max_Line_Length;
         end loop;
         Streamed_Line_IO.Put (Line_Bundle);
      end loop;

      while L >= Max_Line_Length loop
         Reverse_Fasta 
           (Fasta_Line   => Fasta_Section, 
            Fasta_Start  => L - Max_Line_Length + 1,
            Fasta_Finish => L,
            Bundle       => Line_Bundle(1 .. Max_Line_Length));
         Streamed_Line_IO.Put_Line (Line_Bundle (1..Max_Line_Length));
         L := L - Max_Line_Length;
      end loop;

      if L > 0 then
         Reverse_Fasta 
           (Fasta_Line   => Fasta_Section, 
            Fasta_Start  => 1,
            Fasta_Finish => L,
            Bundle       => Line_Bundle(1 .. L));
         Streamed_Line_IO.Put_Line (Line_Bundle (1 .. L));
      end if;

   end Put_Reversed_Fasta;

   procedure Read_Reverse_Write_a_Section_p
     (Job_Is_Complete : out Boolean)
   is
      Section_o_Fasta : String_Access := new String (1 .. 2**20 * 128);
      Header          : String(1..Max_Line_Length) := (others => '?');
      Section_Length  : Natural := 0;
      Header_Length   : Natural := 0;
   begin
      Job_Is_Complete := False;

      Text_Input.Read_Section
        (Data_Buffer     => Section_o_Fasta,
         Data_Length     => Section_Length,
         Next_Header     => Header,
         Header_Length   => Header_Length,
         Max_Line_Length => 100); -- use anything >= actual limit of 60.

      if Header_Length < 1 then   -- null Header marks final section.
         Job_Is_Complete := True;
      end if;

      if Section_Length > 0 then       
         Put_Reversed_Fasta (Section_o_Fasta, Section_Length);
      end if;
      if Header_Length > 0 then
         Streamed_Line_IO.Put_Line (Header(1..Header_Length));
      end if;
      Text_Input.Free (Section_o_Fasta);

   end Read_Reverse_Write_a_Section_p;

   task type Read_Reverse_Write_a_Section is
      entry Start_Reading;
      entry Done_Reading_A_Section (Reached_End_Of_File : out Boolean);
      entry Done_Writing;
      pragma Storage_Size (2**20);
   end Read_Reverse_Write_a_Section;

   task body Read_Reverse_Write_a_Section is
      Section_o_Fasta : String_Access := new String (1 .. 2**20 * 128);
      Header          : String(1..Max_Line_Length) := (others => '?');
      Section_Length  : Natural := 0;
      Header_Length   : Natural := 0;
      Hit_End_Of_File : Boolean := False;
   begin
      loop
      select
         accept Start_Reading;
   
         Text_Input.Read_Section
           (Data_Buffer     => Section_o_Fasta,
            Data_Length     => Section_Length,
            Next_Header     => Header,
            Header_Length   => Header_Length,
            Max_Line_Length => 100); -- use anything >= actual limit of 60.
   
         if Header_Length < 1 then   -- null Header marks final section.
            Hit_End_Of_File := True;
         end if;

         accept Done_Reading_A_Section (Reached_End_Of_File : out Boolean) do
            Reached_End_Of_File := Hit_End_Of_File;
         end Done_Reading_A_Section;
   
         if Section_Length > 0 then       
            Put_Reversed_Fasta (Section_o_Fasta, Section_Length);
         end if;
         if Header_Length > 0 then
            Streamed_Line_IO.Put_Line (Header(1..Header_Length));
         end if;

         accept Done_Writing;
      or
         terminate;
      end select;
      end loop;
      Text_Input.Free (Section_o_Fasta);
   end Read_Reverse_Write_a_Section;

   Job_Is_Complete : Boolean;

begin

   if Multitasking_Version_Desired then -- do computation concurrently with IO:

      declare
         type Task_Id_Type is mod 2;
         Do_a_Section : array (Task_Id_Type) of Read_Reverse_Write_a_Section;
         i : Task_Id_Type := Task_Id_Type'First;
         Reached_End_Of_File : Boolean := False;
      begin

         Read_Reverse_Write_a_Section_p (Job_Is_Complete);
         --  All this does is handle the 1st line of the file (the Header).

           Do_a_Section(i).Start_Reading;
           --  Start 1st task reading 1st section.

          loop
           
             Do_a_Section(i).Done_Reading_A_Section (Reached_End_Of_File);
             -- Block here until task i says its done reading the section.
    
             -- Task i is done reading so tell task i+1 to start reading:
             if not Reached_End_Of_File then
                Do_a_Section(i+1).Start_Reading; 
             end if;
    
             Do_a_Section(i).Done_Writing;
             -- Block here until task i says its done writing. (If task i+1 were
             -- to write while task i writes, then their output is interleaved.)

             exit when Reached_End_Of_File;
             i := i + 1;

          end loop;

       end;

   else -- Use a Procedure rather than Tasks:

      loop
         Read_Reverse_Write_a_Section_p (Job_Is_Complete);
         exit when Job_Is_Complete;
      end loop;

   end if; -- Multitasking_Version_Desired

   Streamed_Line_IO.Close;

end Revcomp;


package Choice_Of_Line_Feed is
   Separator : constant String(1..1) := String'(1 => ASCII.LF); --Unix
 --Separator : constant String(1..2) := String'(ASCII.CR, ASCII.LF); --Windows
 --Separator : constant String(1..1) := String'(1 => ASCII.CR); --MacOS
end Choice_Of_Line_Feed;


-- Create package Streamed_Line_IO at the library level:
with Line_IO;
with Choice_Of_Line_Feed;
package Streamed_Line_IO is new Line_IO
  (Separator_Sequence => Choice_Of_Line_Feed.Separator);


with Streamed_Line_IO;
with Ada.Unchecked_Deallocation;

package Text_Input is

   -- Use Stream_IO to Read data from Standard_Input

   type String_Access is access String;

   procedure Read_Section
     (Data_Buffer     : in out String_Access;
      Data_Length     :    out Natural;
      Next_Header     :    out String;
      Header_Length   :    out Natural;
      Max_Line_Length : in     Natural := 1024);

   Section_Marker : constant Character := '>';

   -- Read_Section reads until EOF or Section_Marker is found at start
   -- of a line. Can accept any line of length <= Max_Line_Length.

   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);

end Text_Input;

with Ada.IO_Exceptions;

package body Text_Input is

   procedure Read_Section
     (Data_Buffer     : in out String_Access;
      Data_Length     :    out Natural;
      Next_Header     :    out String;
      Header_Length   :    out Natural;
      Max_Line_Length : in     Natural := 1024)
   is
      Ptr : String_Access;
   begin
      Data_Length   := 0;
      Header_Length := 0;

      Fill_Data_Buffer:
      loop
         if Data_Length + Max_Line_Length > Data_Buffer'Length then
            Ptr := Data_Buffer;
            Data_Buffer := new String (1 .. 2 * Data_Buffer'Length);
            Data_Buffer (1 .. Data_Length) := Ptr (1 .. Data_Length);
            Free (Ptr);
         end if;

         Get_Next_Line:
         declare
            Line : constant String := Streamed_Line_IO.Get_Line;
            Present_Line_Length : constant Natural := Line'Length;
            Strt : Natural;
         begin

            if Present_Line_Length < 1 then
               Header_Length := 0;
               exit Fill_Data_Buffer;
            end if;

            if Present_Line_Length > Max_Line_Length then
               raise Program_Error;
            end if;

            if Line(Line'First) = Section_Marker then
               Strt := Next_Header'First;
               Next_Header(Strt .. Strt + Present_Line_Length - 1) := Line;
               Header_Length := Present_Line_Length;
               exit Fill_Data_Buffer;
            else
               Data_Buffer(Data_Length+1 .. Data_Length+Present_Line_Length):=Line;
               Data_Length := Data_Length + Present_Line_Length;
            end if;

         end Get_Next_Line;

      end loop Fill_Data_Buffer;

   exception
      when Ada.IO_Exceptions.End_Error =>
        return;
   end Read_Section;

end Text_Input;

---------------------------
--  Stream I/O of lines --
---------------------------

generic
   Separator_Sequence : in String;  --  ends a line
package Line_IO is

   pragma Elaborate_Body;

   procedure Put_Line (Item : String);

   procedure Put (Item : String);

   function Get_Line return String;

   procedure Close;  --  close output

end Line_IO;


with Ada.Streams.Stream_IO;
with Unchecked_Conversion;

package body Line_IO is

   use Ada.Streams;

   Stdin  : Stream_IO.File_Type;
   Stdout : Stream_IO.File_Type;

   -- ----------------
   -- writing
   -- ----------------
   --  Put_Line calls Stream_IO.Write twice, once for the string, then for the
   --  line separator (terminator).  The second call needs the separator as a
   --  Stream_Element_Array.

   Separator_Bytes : Stream_Element_Array(1 .. Separator_Sequence'Length);
   for Separator_Bytes'Address use Separator_Sequence'Address;
   pragma Import (Ada, Separator_Bytes);

   procedure Put_Line (Item : String) is
      subtype Index is Stream_Element_Offset range 1 .. Item'Length;
      subtype XBytes is Stream_Element_Array (Index);
      Item_Bytes: XBytes;
      pragma Import (Ada, Item_Bytes);
      for Item_Bytes'Address use Item'Address;
      pragma Assert (Item'Size = Item_Bytes'Size);
   begin
      Stream_IO.Write (Stdout, Item_Bytes);
      Stream_IO.Write (Stdout, Separator_Bytes);
   end Put_Line;

   procedure Put (Item : String) is
      subtype Index is Stream_Element_Offset range 1 .. Item'Length;
      subtype XBytes is Stream_Element_Array (Index);
      Item_Bytes: XBytes;
      pragma Import (Ada, Item_Bytes);
      for Item_Bytes'Address use Item'Address;
      pragma Assert (Item'Size = Item_Bytes'Size);
   begin
      Stream_IO.Write (Stdout, Item_Bytes);
   end Put;

   -- Types etc., status variables, and the buffer.

   BUFSIZ: constant := 8_192 * 8;
   pragma Assert(Character'Size = Stream_Element'Size);

   SL : constant Natural   := Separator_Sequence'Length;

   subtype Extended_Buffer_Index is Positive range 1 .. BUFSIZ + SL;
   subtype Buffer_Index is Extended_Buffer_Index
     range Extended_Buffer_Index'First .. Extended_Buffer_Index'Last - SL;
   subtype Extended_Bytes_Index is Stream_Element_Offset
     range 1 .. Stream_Element_Offset(Extended_Buffer_Index'Last);
   subtype Bytes_Index is Extended_Bytes_Index
     range Extended_Bytes_Index'First
     .. (Extended_Bytes_Index'Last - Stream_Element_Offset(SL));

   subtype Buffer_Data is String(Extended_Buffer_Index);
   subtype Buffer_Bytes is Stream_Element_Array(Extended_Bytes_Index);

   Buffer : Buffer_Data;
   Bytes  : Buffer_Bytes;
   for Bytes'Address use Buffer'Address;
   pragma Import (Ada, Bytes);

   -- start of next substring and last valid character in buffer
   Position : Natural range 0 .. Extended_Buffer_Index'Last;
   Last     : Natural range 0 .. Buffer_Index'Last;
   End_Of_Input : Boolean;

   function Get_Line return String is

      procedure Reload is
         --  fill Buffer with bytes available
         Last_Filled : Stream_Element_Offset;
      begin
         if Last < Buffer_Index'Last then
            raise Stream_IO.End_Error;
         end if;
         Stream_IO.Read(Stdin,
           Item => Bytes(Bytes_Index),
           Last => Last_Filled);
         Last := Natural(Last_Filled);
         Position := 1;
         Buffer(Last + 1 .. Last + SL) := Separator_Sequence;
      end Reload;

      function Separator_Position return Natural is
         --   index of next Separator_Sequence (may be sentinel)
         K : Extended_Buffer_Index := Position;
      begin
         loop
            if Buffer(K) = Separator_Sequence(1) then
               exit;
            elsif Buffer(K+1) = Separator_Sequence(1) then
               K := K + 1; exit;
            else
               K := K + 2;
            end if;
         end loop;
        return K;
      end Separator_Position;

      Next_Separator : Natural range 0 .. Extended_Buffer_Index'Last;
   begin  -- Get_Line

      if End_Of_Input then
         raise Stream_IO.End_Error;
      end if;

      Next_Separator := Separator_Position;

      if Next_Separator > Last then
         declare
            Result : constant String := Buffer(Position .. Last);
            subtype XString is String (1 .. Last - Position + 1);
         begin
            begin
               Reload;
               return XString(Result) & Get_Line;
            exception
               when Stream_IO.End_Error =>
                  End_Of_Input := True;
                  return XString(Result);
            end;
         end;
      else
         declare
            Result : String renames Buffer(Position .. Next_Separator - 1);
            subtype XString is String (1 .. Next_Separator - Position);
         begin
            Position := Next_Separator + SL;
            return XString (Result);
         end;
      end if;

      raise Program_Error;
   end Get_Line;

   procedure Close is
   begin
      Stream_IO.Close (Stdout);
   end Close;

begin
   Stream_IO.Open (Stdout,
      Mode => Stream_IO.Out_File,
      Name => "/dev/stdout");
   Stream_IO.Open (Stdin,
      Mode => Stream_IO.In_File,
      Name => "/dev/stdin");

   Buffer(Buffer_Index'Last + 1 .. Buffer'Last) := Separator_Sequence;
   Position := Buffer_Index'Last + 1;
   Last     := Buffer_Index'Last;
   End_Of_Input := False;
end Line_IO;
-----------------------------------------------------------------------
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- contributed by Jim Rogers
-- gnatmake -gnat05 -O3 -gnatVn -gnatp
-----------------------------------------------------------------------
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Characters.Handling; use Ada.Characters.Handling;
with Ada.Unchecked_Deallocation;

procedure Revcomp is
   type First_Index_Type is range 1..16;
   type Second_Index_Type is range 1..2;
   type Correspondence_Array is array(First_Index_type, Second_Index_type)
                                of Character;

   type Tuple;
   type Tuple_Access is access Tuple;
   type Tuple is record
      Value : Character := 'X';
      Next  : Tuple_Access := null;
   end record;
   Stack : Tuple_Access := null;

   procedure Push(Item : Character) is
      Temp : Tuple_Access := New Tuple'(Item, Stack);
   begin
      Stack := Temp;
   end Push;

   procedure Pop(Item : out Character) is
      procedure Free is new Ada.Unchecked_Deallocation(Tuple, Tuple_Access);
      Temp : Tuple_Access;
   begin
      if Stack /= null then
         Temp := Stack;
         Item := Stack.Value;
         Stack := Stack.Next;
         Free(Temp);
      end if;
   end Pop;

   procedure Print_Stack(Length : Natural) is
      Count : natural := 0;
      Value : Character;
   begin
      While Stack /= null loop
         Count := Count + 1;
         Pop(Value);
         Put(Value);
         if Count >= Length then
            New_Line;
            Count := 0;
         end if;
      end loop;
      if Count > 0 then
         New_Line;
      end if;
   end Print_Stack;

   function Complement(Item : Character) return Character is

      Correspondence : Correspondence_Array := (('A', 'T'),
                                                ('C', 'G'),
                                                ('G', 'C'),
                                                ('T', 'A'),
                                                ('U', 'A'),
                                                ('M', 'K'),
                                                ('R', 'Y'),
                                                ('W', 'W'),
                                                ('S', 'S'),
                                                ('Y', 'R'),
                                                ('K', 'M'),
                                                ('V', 'B'),
                                                ('H', 'D'),
                                                ('D', 'H'),
                                                ('B', 'V'),
                                                ('N', 'N'));
      Temp : Character := To_Upper(Item);
      Result : Character;
   begin
      for I in First_Index_Type'range loop
         if Correspondence(I, 1) = Temp then
            Result := Correspondence(I,2);
            exit;
         end if;
      end loop;
      return Result;
   end Complement;

   Input_String : String(1..120);
   Input_Length : Natural;
   Max_Output_Length : Natural := 0;

begin
   while not End_Of_File(Standard_Input) loop
      Get_Line(Item => Input_String, Last => Input_Length);
      if Input_String(1) = '>' or Input_String(1) = ';' then
         --------------------------------------------------
         -- Print reverse complement in memory, if any
         --------------------------------------------------
         if Max_Output_Length > 0 then
            Print_Stack(Max_Output_Length);
         end if;
         -------------------------------------------------
         -- Print sequence info
         -------------------------------------------------
         Put_Line(Input_String(1..Input_Length));
         Max_Output_Length := 0;
      else
         if Max_Output_Length = 0 then
            Max_Output_Length := Input_Length;
         end if;
         -------------------------------------------------
         -- Push complemented characters on stack
         -------------------------------------------------
         for I in 1..Input_Length loop
            Push(Complement(Input_String(I)));
         end loop;
      end if;
   end loop;
   ----------------------------------------------------
   -- Print reverse complement of last sequence
   ----------------------------------------------------
   if Stack /= null then
      Print_Stack(Max_Output_Length);
   end if;
end Revcomp;
-- $Id: reversefile.gnat,v 1.2 2004-08-16 08:00:24 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- by James S. Rogers
-- 
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_Io; use Ada.Text_Io;

procedure Reversefile is
  Contents : Unbounded_String := Null_Unbounded_String;
  Next_Char : Character;
begin
  while not End_Of_File loop
    Get(Next_Char);
    Contents := Contents & Next_Char;
  end loop;
  for Iter in reverse 1..Length(Contents) loop
    Put(Item => Element(Source => Contents, Index => Iter));
  end loop;
end Reversefile;
-- $Id: sieve.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Command_Line;

procedure Sieve is
   High        : constant := 8192;
   Is_Prime    : array (2 .. High) of Boolean;
   Count, K, N : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      declare
         pragma Suppress (Overflow_Check);
         pragma Suppress (Index_Check);
         pragma Suppress (Range_Check);
      begin
         Count := 0;
         Is_Prime := (others => True);
         for J in Is_Prime'Range loop
            if Is_Prime (J) then
               K := J + J;
               while K <= Is_Prime'Last loop
                  Is_Prime (K) := False;        --  K is not a prime since a
                  K := K + J;                   --  multiple of prime J
               end loop;
               Count := Count + 1;
            end if;
         end loop;
      end;
   end loop;
   Text_IO.Put_Line ("Count:" & Natural'Image (Count));
end Sieve;
-----------------------------------------
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
-- 
-- Contributed by Jim Rogers
-----------------------------------------
package Spectral_Utils is
   type Matrix is array(Natural range <>) of Long_Float;
   
   function Eval_A(I, J : Integer) return Long_Float;
   procedure Eval_A_Times(U : Matrix; Au : out Matrix);
   procedure Eval_At_Times(U : Matrix; Au : out Matrix);
   procedure Eval_Ata_Times_U(U : Matrix; Atau : out Matrix);
end Spectral_Utils;

-----------------------------------------
-- The Great Computer Language Shootout
--
-- Contributed by Jim Rogers
-----------------------------------------
package body Spectral_Utils is

   function Eval_A (I, J : Integer) return Long_Float is
   begin
      return 1.0 / Long_Float((I + J) * (I + J + 1) /2 + I + 1);
   end Eval_A;
   
   procedure Eval_A_Times (U : Matrix; Au : out Matrix) is
   begin
      for I in Au'range loop
         Au(I) := 0.0;
         for J in U'range loop
            Au(I) := Au(I) + Eval_A(I, J) * U(J);
         end loop;
      end loop;
   end Eval_A_Times;
   
   procedure Eval_At_Times (U : Matrix; Au : out Matrix) is
   begin
      for I in Au'range loop
         Au(I) := 0.0;
         for J in U'range loop
            Au(I) := Au(I) + Eval_A(J, I) * U(J);
         end loop;
      end loop;
   end Eval_At_Times;
   
   procedure Eval_Ata_Times_U (U : Matrix; Atau : out Matrix) is
      V : Matrix(0..U'Length - 1);
   begin
      Eval_A_Times(U, V);
      Eval_At_Times(V, Atau);
   end Eval_Ata_Times_U;
   
end Spectral_Utils;

-----------------------------------------------------------
-- The Great Computer Language Shootout
--
-- Contributed by Jim Rogers
-----------------------------------------------------------

with Ada.Text_Io;
with Ada.Numerics.Generic_Elementary_Functions ;
with Ada.Command_Line; use Ada.Command_Line;
with Spectral_Utils; use Spectral_Utils;

procedure SpectralNorm is
   package Long_Io is new Ada.Text_Io.Float_Io(Long_Float);
   package Long_Funcs is new Ada.Numerics.Generic_Elementary_Functions(Long_Float);
   use Long_Funcs;
   N : Natural := 100;
   Vbv, vv : Long_Float := 0.0;
begin
   if Argument_Count = 1 then
      N := Natural'Value(Argument(1));
   end if;
   
   declare
      U : Matrix(0..N-1) := (Others => 1.0);
      V : Matrix(0..N-1) := (Others => 0.0);
   begin
      for I in 1..10 loop
         Eval_Ata_Times_U(U, V);
         Eval_Ata_Times_U(V, U);
      end loop;
      for I in V'range loop
         Vbv := Vbv + U(I) * V(I);
         Vv := Vv + V(I)*V(I);
      end loop;
   end;
   Long_Io.Put(Item => Sqrt(Vbv/Vv), Fore => 1, Aft => 9, Exp => 0);
   Ada.Text_Io.New_Line;
end SpectralNorm;






-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
--
-- Contributed by Jim Rogers
-- Modified by Jonathan Parker (Oct 2009)

pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Ada.Text_Io;
with Ada.Numerics.Generic_Elementary_Functions;
with Ada.Command_Line; use Ada.Command_Line;
with Spectral_Utils;

procedure SpectralNorm is

   type Real is digits 15;

   No_of_Cores_to_Use : constant := 4;

   package Real_IO is new Ada.Text_Io.Float_Io(Real);
   package Real_Funcs is new Ada.Numerics.Generic_Elementary_Functions(Real);
   use Real_Funcs;

   N : Natural := 100;
   Vbv, Vv : Real := 0.0;
begin
   if Argument_Count = 1 then
      N := Natural'Value (Argument(1));
   end if;

   declare
      package Spectral_Utilities is new Spectral_Utils
        (Real, No_of_Tasks => No_of_Cores_to_Use, Matrix_Size => N);
      use Spectral_Utilities;

      U : Matrix := (Others => 1.0);
      V : Matrix := (Others => 0.0);
   begin
      for I in 1 .. 10 loop
         Eval_Ata_Times_U(U, V);
         Eval_Ata_Times_U(V, U);
      end loop;
      for I in V'Range loop
         Vbv := Vbv + U(I) * V(I);
         Vv  := Vv  + V(I) * V(I);
      end loop;
   end;
   Real_IO.Put(Item => Sqrt(Vbv/Vv), Fore => 1, Aft => 9, Exp => 0);
   Ada.Text_Io.New_Line;
end SpectralNorm;

generic

   type Real is digits <>;
   No_Of_Tasks : Positive;
   Matrix_Size : Positive;

package Spectral_Utils is

   type Matrix is array(Natural range 0 .. Matrix_Size-1) of Real;

   --  Evaluate matrix A at indices I, J.
 
   function Eval_A(I, J : Natural) return Real;

   --  Get   A_transpose_A_times_U = A_transpose * A * U. 
 
   procedure Eval_Ata_Times_U
     (U                     : in Matrix; 
      A_transpose_A_times_U : out Matrix);

   --  Get   AU = A * U.  Calculate only AU(Start .. Finish).
 
   procedure Eval_A_Times 
     (U      : in  Matrix; 
      Start  : in  Natural; 
      Finish : in  Natural; 
      AU     : out Matrix);

   --  Get   AU = A_transpose * U.   Calculate only AU(Start .. Finish).
 
   procedure Eval_At_Times
     (U      : in  Matrix; 
      Start  : in  Natural; 
      Finish : in  Natural; 
      AU     : out Matrix);

   pragma Inline (Eval_A_Times, Eval_At_Times);
   pragma Inline (Eval_A, Eval_Ata_Times_U);

end Spectral_Utils;

package body Spectral_Utils is

   function Eval_A (I, J : in Natural) return Real is
      Denom : constant Real := Real (((I + J) * (I + J + 1)) / 2 + I + 1);
   begin
      return 1.0 / Denom;
   end Eval_A;

   type A_Element_Pair is array (0 .. 1) of Real;

   -- Evaluate matrix A twice - at (I,J) and (I,J+1):

   function Eval_A_Twice (I, J : in Integer) return A_Element_Pair is
      Denom_0 : constant Real := Real ((I + J    )*(I + J + 1)/2 + I + 1);
      Denom_1 : constant Real := Real ((I + J + 1)*(I + J + 2)/2 + I + 1);
   begin
      return (1.0 / Denom_0, 1.0 / Denom_1);
   end Eval_A_Twice;

   -- Evaluate A_transpose (indices I and J swapped):

   function Eval_A_tr_Twice (I, J : in Integer) return A_Element_Pair is 
      Denom_0 : constant Real := Real ((I + J    )*(I + J + 1)/2 + J + 1);
      Denom_1 : constant Real := Real ((I + J + 1)*(I + J + 2)/2 + J + 2);
   begin
      return (1.0 / Denom_0, 1.0 / Denom_1);
   end Eval_A_tr_Twice;

   procedure Eval_A_Times
     (U      : in  Matrix; 
      Start  : in  Natural; 
      Finish : in  Natural; 
      Au     : out Matrix) 
   is
      Sum : Real;
      J_Index : Natural;
      A_Elements : A_Element_Pair;
   begin
      for I in Start .. Finish loop
         Sum := 0.0;
         for J in Natural range 0 .. U'Length/2 - 1 loop
            J_Index    := U'First + 2*J;
            A_Elements := Eval_A_Twice (I, J_Index);
            Sum := Sum + A_Elements(0)*U(J_Index) + A_Elements(1)*U(J_Index+1);
         end loop;
         if U'Length mod 2 = 1 then
            Sum := Sum + Eval_A(I, U'Last) * U(U'Last); -- J_Index := U'Last;
         end if;
         Au(I) := Sum;
      end loop;
   end Eval_A_Times;


   procedure Eval_At_Times
     (U      : in  Matrix; 
      Start  : in  Natural; 
      Finish : in  Natural; 
      Au     : out Matrix) 
   is
      Sum : Real;
      J_Index : Natural;
      A_Elements : A_Element_Pair;
   begin
      for I in Start .. Finish loop
         Sum := 0.0;
         for J in Natural range 0 .. U'Length/2 - 1 loop
            J_Index    := U'First + 2*J;
            A_Elements := Eval_A_tr_Twice (I, J_Index);
            Sum := Sum + A_Elements(0)*U(J_Index) + A_Elements(1)*U(J_Index+1);
         end loop;
         if U'Length mod 2 = 1 then
            Sum := Sum + Eval_A (U'Last, I) * U(U'Last); -- J_Index := U'Last;
         end if;
         Au(I) := Sum;
      end loop;
   end Eval_At_Times;


   -- Calculate A * U

   task type Matrix_A_times_U is
      pragma Storage_Size (2**20);
      entry Multiply (U : in Matrix; Start : in Natural; Finish : in Natural);
      entry Result (Start : out Natural; Finish : out Natural; R : out Matrix);
   end Matrix_A_times_U;

   task body Matrix_A_times_U is
      I1, I2 : Natural;
      AU, U_local : Matrix;
   begin
     loop
     select
        accept Multiply (U : in Matrix; Start : in Natural; Finish : in Natural) do
           I1 := Start;
           I2 := Finish;
           U_local := U;
        end Multiply;
  
        Eval_A_Times (U_local, I1, I2, AU); -- updates AU(I1..I2)
  
        accept Result (Start : out Natural; Finish : out Natural; R : out Matrix) do
           Start  := I1;
           Finish := I2;
           R(Start .. Finish) := AU(Start .. Finish);
        end Result;
     or
        terminate;
     end select;
     end loop;
   end Matrix_A_times_U;


   -- Calculate A_transpose * V

   task type Matrix_A_tr_times_V is
      pragma Storage_Size (2**20);
      entry Multiply (V : in Matrix; Start : in Natural; Finish : in Natural);
      entry Result (Start : out Natural; Finish : out Natural; R : out Matrix);
   end Matrix_A_tr_times_V;

   task body Matrix_A_tr_times_V is
      I1, I2 : Natural;
      AV, V_local : Matrix;
   begin
     loop
     select
        accept Multiply (V : in Matrix; Start : in Natural; Finish : in Natural) do
           I1 := Start;
           I2 := Finish;
           V_local := V;
        end Multiply;
  
        Eval_At_Times (V_local, I1, I2, AV);  -- AV = A_transpose * V_local
  
        accept Result (Start : out Natural; Finish : out Natural; R : out Matrix) do
           Start  := I1;
           Finish := I2;
           R(Start .. Finish) := AV(Start .. Finish);
        end Result;
     or
        terminate;
     end select;
     end loop;
   end Matrix_A_tr_times_V;


   -- Create (No_Of_Tasks-1) tasks. The final task is the environmental task, 
   -- which does its fair share of the work in procedure Eval_Ata_Times_U.

   subtype Task_Range is Positive range 1 .. No_Of_Tasks-1;

   Partial_Matrix_A_times_U    : array (Task_Range) of Matrix_A_times_U; 
   Partial_Matrix_A_tr_times_V : array (Task_Range) of Matrix_A_tr_times_V; 


   procedure Eval_Ata_Times_U 
     (U                     : in  Matrix; 
      A_transpose_A_times_U : out Matrix) 
   is
      V, Partial_Product : Matrix;
   
      Segment_Length : constant Integer := U'Length / No_Of_Tasks + 1;
      -- Gives the 1st few tasks a slightly greater share of the work.
 
      I1, I2, J1, J2 : Natural;
   begin
      I1 := V'First;
      I2 := V'First + Segment_Length - 1;
      I2 := Integer'Min (I2, V'Last); 

      -- Start running the tasks in Task_Range:

      for k in Task_Range loop
         Partial_Matrix_A_times_U(k).Multiply (U, I1, I2);
         I1 := I2 + 1;
         I2 := I2 + Segment_Length;
         I2 := Integer'Min (I2, V'Last);
      end loop;

      Eval_A_Times (U, I1, V'Last, V); -- Env task updates V(I1 .. V'Last).

      -- Rendezvous with tasks to get partial results. Write results to V:

      for k in Task_Range loop
         Partial_Matrix_A_times_U(k).Result (J1, J2, Partial_Product);
         V(J1 .. J2) := Partial_Product(J1 .. J2);
      end loop;

      -- The result, stored in V, is A*U. Next get A_transpose * (A*U).

      I1 := V'First;
      I2 := V'First + Segment_Length - 1;
      I2 := Integer'Min (I2, V'Last); 

      for k in Task_Range loop
         Partial_Matrix_A_tr_times_V(k).Multiply (V, I1, I2);
         I1 := I2 + 1;
         I2 := I2 + Segment_Length;
         I2 := Integer'Min (I2, V'Last);
      end loop;

      Eval_At_Times (V, I1, V'Last, A_transpose_A_times_U); 
      -- Env. task updates A_transpose_A_times_U (I1 .. V'Last).

      for k in Task_Range loop
         Partial_Matrix_A_tr_times_V(k).Result (J1, J2, Partial_Product);
         A_transpose_A_times_U(J1 .. J2) := Partial_Product(J1 .. J2);
      end loop;

   end Eval_Ata_Times_U;

end Spectral_Utils;


-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with Dictionnary_Mgr;

procedure Spellcheck is
begin
   Dictionnary_Mgr.Load ("Usr.Dict.Words");
   Dictionnary_Mgr.Word_Analysis;
end Spellcheck;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with GNAT.Spitbol;

package Dictionnary_Mgr is

   package Dictionnary is new GNAT.Spitbol.Table (Boolean, False, Boolean'Image);

   Map : Dictionnary.Table (40_000);

   -- ------------------------------------------------
   procedure Load (File_Name : String);
   -- ------------------------------------------------
   procedure Word_analysis;

end Dictionnary_Mgr;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with Ada.Streams, Ada.Streams.Stream_IO, Ada.Text_IO, GNAT.Spitbol;
use  Ada.Streams, Ada.Streams.Stream_IO;

package body Dictionnary_Mgr is

   Tmp_Word : String (1 ..128);
   Index    : Natural range 0 .. Tmp_Word'Last := 0;

   -- ------------------------------------------------
   procedure Load (File_Name : String) is
      Dictionnary_File : File_Type;
      Buffer           : Stream_Element_Array (1 .. 4_096);
      Last             : Stream_Element_Offset;

      -- ------------------------------------------------
      procedure Process (Buffer : Stream_Element_Array) is
      begin
           for I in Buffer'Range loop
            if Character'Val(Buffer (I)) = ASCII.LF then
               if Index > 1 then
                  Dictionnary.Set (Map, Tmp_Word (1 .. Index),True);
               end if;
               Index := 0;
            else
               Index := Index + 1;
               Tmp_Word(Index) := Character'Val(Buffer (I));

            end if;
         end loop;
      end Process;

   begin
      Open (Dictionnary_File, In_File, File_Name);

      loop
         Read (Dictionnary_File, Buffer, Last);
         Process (Buffer (1 .. Last));
         exit when Last < Buffer'Length;
      end loop ;

      Close (Dictionnary_File);
   end Load;

   -- ------------------------------------------------
   procedure Word_analysis is
      Word : String (1 .. 128);
      Last : Natural;
      use Ada.Text_IO;
   begin

      loop
         Get_Line (Word, Last);
         if not Dictionnary.Present (Map, Word (1 .. Last)) then
            Put_Line (Standard_Output, Word (1 .. Last));
         end if;
      end loop;

   exception
      when Ada.Text_IO.End_Error =>
         null;
   end Word_analysis;

end Dictionnary_Mgr;
-- $Id: strcat.gnat-2.gnat,v 1.1 2004-11-23 08:08:46 bfulgham Exp $
-- http://shootout.alioth.debian.org/
-- contributed by James S. Rogers
-- modified 2004/11/21 by Kat-Zygfryd: trimmed the output
-- This is a more 'True ADA' version of the task, but is somewhat less
--    efficient than the other version.

with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_Io; use Ada.Text_Io;
 
procedure Strcat is
    N: Integer;
    Hello : String := "hello" & Ascii.Lf;
    Buffer : Unbounded_String := Null_Unbounded_String;
begin
    N := Integer'Value(Argument(1));
    for Num in 1..N loop
       Append(Source => Buffer, New_Item => Hello);
    end loop;
    declare
       S: String := Natural'Image( Length(Buffer) );
    begin
       Put_Line( S(2..S'Length) );
    end;
end Strcat;
-- $Id: sumcol.gnat,v 1.4 2005-03-30 11:01:07 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- by James S. Rogers
-- Simplified by Pascal Obry on 2005/03/17
-- Faster version by Bill Findlay on 2005/03/23

with Ada.Text_IO, Ada.Strings.Fixed;
use  Ada.Text_IO, Ada.Strings.Fixed;

procedure SumCol is
  Line : String (1 .. 128);
  Sum  : Integer := 0;
  Len  : Natural;
begin
  loop
    Get_Line (Item => Line, Last => Len);
    Sum := Sum + Integer'Value (Line (1 .. Len));
   end loop;
exception
   when End_Error =>
      Put_Line (Trim (Integer'Image(Sum), Ada.Strings.Both));
end SumCol;
-- $Id: takfp.gnat,v 1.6 2005-03-30 17:53:38 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Vasiliy Fofanov and Pascal Obry on 2005/03/22
-- Fixed by Pascal Obry on 2005/03/30

package Takfp_Pck is
   function Tak (X, Y, Z : Float) return Float;
end Takfp_Pck;

package body Takfp_Pck is

   function Tak (X, Y, Z : Float) return Float is
   begin
      if Y >= X then
         return Z;
      else
         return Tak
           (Tak (X - 1.0, Y, Z), Tak (Y - 1.0, Z, X), Tak (Z - 1.0, X, Y));
      end if;
   end Tak;

end Takfp_Pck;

-- $Id: takfp.gnat,v 1.6 2005-03-30 17:53:38 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Vasiliy Fofanov and Pascal Obry on 2005/03/22
-- Fixed by Pascal Obry on 2005/03/30

with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Command_Line;  use Ada.Command_Line;
with Takfp_Pck;         use Takfp_Pck;

procedure Takfp is
   N : Float;
begin
   N := Float'Value (Argument (1));
   Put (Tak (N * 3.0, N * 2.0, N * 1.0), 0, 1, 0);
   New_Line;
end Takfp;
-- $Id: tcpecho.gnat,v 1.1 2005-03-31 14:08:44 obry-guest Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/03/31

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Streams;         use Ada.Streams;
with GNAT.Sockets;        use GNAT.Sockets;

procedure TCPEcho is

   N            : constant Positive := Positive'Value (Argument (1));
   M            : constant := 6_400;
   Reply_Size   : constant := 64;
   Request_Size : constant := 64;

   Reply   : constant Stream_Element_Array := (1 .. Reply_Size => 88);
   Request : constant Stream_Element_Array := (1 .. Request_Size => 23);

   Address : Sock_Addr_Type;

   task Client is
      entry Start;
   end Client;

   task body Client is
      Socket : Socket_Type;
      Buffer : Stream_Element_Array (1 .. Reply_Size);
      Last   : Stream_Element_Offset;
      Count  : Natural := 0;
      Bytes  : Natural := 0;
   begin
      accept Start;

      Create_Socket (Socket);
      Connect_Socket (Socket, Address);

      for K in 1 .. M * N loop
         Send_Socket (Socket, Request, Last);

         Bytes := 0;
         while Bytes /= Reply_Size loop
            Receive_Socket (Socket, Buffer, Last);
            Bytes := Bytes + Natural (Last);
         end loop;

         Count := Count + Bytes;
      end loop;

      Close_Socket (Socket);

      Put ("replies: "); Put (N * M, Width => 0);
      Put (ASCII.HT & "bytes: "); Put (Count, Width => 0);
   end Client;

   Server_Socket : Socket_Type;
   Socket        : Socket_Type;
   Buffer        : Stream_Element_Array (1 .. Request_Size);
   Last          : Stream_Element_Offset;

begin
   Address.Addr := Addresses (Get_Host_By_Name ("localhost"), 1);
   Address.Port := 2987;

   Create_Socket (Server_Socket);
   Bind_Socket (Server_Socket, Address);
   Listen_Socket (Server_Socket);

   Client.Start;

   Accept_Socket (Server_Socket, Socket, Address);

   for K in 1 .. M * N loop
      Receive_Socket (Socket, Buffer, Last);
      Send_Socket (Socket, Reply, Last);
   end loop;
end TCPEcho;
-- $Id: tcprequest.gnat,v 1.1 2005-03-31 14:11:36 obry-guest Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/03/31

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Streams;         use Ada.Streams;
with GNAT.Sockets;        use GNAT.Sockets;

procedure TCPRequest is

   N            : constant Positive := Positive'Value (Argument (1));
   M            : constant := 100;
   Reply_Size   : constant := 4_096;
   Request_Size : constant := 64;

   Reply   : constant Stream_Element_Array := (1 .. Reply_Size => 88);
   Request : constant Stream_Element_Array := (1 .. Request_Size => 23);

   Address : Sock_Addr_Type;

   task Client is
      entry Start;
   end Client;

   task body Client is
      Socket : Socket_Type;
      Buffer : Stream_Element_Array (1 .. Reply_Size);
      Last   : Stream_Element_Offset;
      Count  : Natural := 0;
      Bytes  : Natural := 0;
   begin
      accept Start;

      Create_Socket (Socket);
      Connect_Socket (Socket, Address);

      for K in 1 .. M * N loop
         Send_Socket (Socket, Request, Last);

         Bytes := 0;
         while Bytes /= Reply_Size loop
            Receive_Socket (Socket, Buffer, Last);
            Bytes := Bytes + Natural (Last);
         end loop;

         Count := Count + Bytes;
      end loop;

      Close_Socket (Socket);

      Put ("replies: "); Put (N * M, Width => 0);
      Put (ASCII.HT & "bytes: "); Put (Count, Width => 0);
   end Client;

   Server_Socket : Socket_Type;
   Socket        : Socket_Type;
   Buffer        : Stream_Element_Array (1 .. Request_Size);
   Last          : Stream_Element_Offset;

begin
   Address.Addr := Addresses (Get_Host_By_Name ("localhost"), 1);
   Address.Port := 2987;

   Create_Socket (Server_Socket);
   Bind_Socket (Server_Socket, Address);
   Listen_Socket (Server_Socket);

   Client.Start;

   Accept_Socket (Server_Socket, Socket, Address);

   for K in 1 .. M * N loop
      Receive_Socket (Socket, Buffer, Last);
      Send_Socket (Socket, Reply, Last);
   end loop;
end TCPRequest;
-- $Id: tcpstream.gnat,v 1.1 2005-03-31 14:10:02 obry-guest Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/03/31

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Streams;         use Ada.Streams;
with GNAT.Sockets;        use GNAT.Sockets;

procedure TCPStream is

   N            : constant Positive := Positive'Value (Argument (1));
   M            : constant := 1;
   Reply_Size   : constant := 409_600;
   Request_Size : constant := 64;

   Reply   : constant Stream_Element_Array := (1 .. Reply_Size => 88);
   Request : constant Stream_Element_Array := (1 .. Request_Size => 23);

   Address : Sock_Addr_Type;

   task Client is
      entry Start;
   end Client;

   task body Client is
      Socket : Socket_Type;
      Buffer : Stream_Element_Array (1 .. Reply_Size);
      Last   : Stream_Element_Offset;
      Count  : Natural := 0;
      Bytes  : Natural := 0;
   begin
      accept Start;

      Create_Socket (Socket);
      Connect_Socket (Socket, Address);

      for K in 1 .. M * N loop
         Send_Socket (Socket, Request, Last);

         Bytes := 0;
         while Bytes /= Reply_Size loop
            Receive_Socket (Socket, Buffer, Last);
            Bytes := Bytes + Natural (Last);
         end loop;

         Count := Count + Bytes;
      end loop;

      Close_Socket (Socket);

      Put ("replies: "); Put (N * M, Width => 0);
      Put (ASCII.HT & "bytes: "); Put (Count, Width => 0);
   end Client;

   Server_Socket : Socket_Type;
   Socket        : Socket_Type;
   Buffer        : Stream_Element_Array (1 .. Request_Size);
   Last          : Stream_Element_Offset;

begin
   Address.Addr := Addresses (Get_Host_By_Name ("localhost"), 1);
   Address.Port := 2987;

   Create_Socket (Server_Socket);
   Bind_Socket (Server_Socket, Address);
   Listen_Socket (Server_Socket);

   Client.Start;

   Accept_Socket (Server_Socket, Socket, Address);

   for K in 1 .. M * N loop
      Receive_Socket (Socket, Buffer, Last);
      Send_Socket (Socket, Reply, Last);
   end loop;
end TCPStream;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
-- contributed by Jim Rogers

with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

procedure ThreadRing is
   
   protected Flag is
      procedure Set(Num : Positive);
      entry Wait(Last : out Positive);
   private
      Done : Boolean := False;
      Id : Positive;
   end Flag;
   protected body Flag is
      procedure Set(Num : Positive) is
      begin
         Done := True;
         Id := Num;
      end Set;
      entry Wait(Last : out Positive) when Done is
      begin
         Last := Id;
      end Wait;
   end Flag;

   type Node;
   type Node_Access is access Node;
   
   Ring : array(1..503) of Node_Access;
   
   task type Node(Id : Positive) is
      entry Start(Next : Node_Access);
      entry Put(Item : in Natural);
      entry Stop;
   end Node;
   
   task body Node is
      Val : Natural;
      Next_Node : Node_Access;
   begin
      accept Start(Next : Node_Access) do
         Next_Node := Next;
      end Start;
      
      loop
         select
            accept Put(Item : in Natural) do
               Val := Item;
            end Put;
         or
            accept Stop;
            exit;
         end select;
         if Val > 0 then
            Val := Val - 1;
            Next_Node.Put(Val);
         else
            Flag.Set(Id);
         end if;
      end loop;
   end Node;
   
   Num_Passes : Natural;
   Last_Node : Positive;
begin
   Num_Passes := Natural'Value(Argument(1));
   for I in Ring'range loop
      Ring(I) := new Node(I);
   end loop;
   Ring(Ring'Last).Start(Ring(1));
   for I in Ring'First..Ring'Last - 1 loop
      Ring(I).Start(Ring(I + 1));
   end loop;
   Ring(1).Put(Num_Passes);
   Flag.Wait(Last_Node);
   Put(Item => Last_Node, Width => 1);
   New_Line;
   for I in Ring'range loop
      Ring(I).Stop;
   end loop;
   
end ThreadRing;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
-- Contributed by Jacob Sparre Andersen (with help from Alex Mason)
--
-- Compile with:
--    gnatmake -gnat05 -gnatE -gnato -gnatv -gnati1 -gnatf -m -O3 -funroll-loops -funwind-tables -gnatn -fomit-frame-pointer -march=native thread_ring

with Ada.Text_IO;
with Ada.Command_line;

procedure ThreadRing is
   Ring_Size : constant := 503;
   type Ring_Index is mod Ring_Size;

   package Ring_Text_IO is new Ada.Text_IO.Modular_IO (Ring_Index);

   protected type Store is
      entry Put  (Item : in     Integer);
      entry Take (Item :    out Integer);
   private
      Value : Integer;
      Full  : Boolean := False;
   end Store;

   protected body Store is
      entry Put (Item : in     Integer) when not Full is
      begin
         Value := Item;
         Full := True;
      end Put;

      entry Take (Item :    out Integer) when Full is
      begin
         Item := Value;
         Full := False;
      end Take;
   end Store;

   type Store_Ring is array (Ring_Index) of Store;
   Stores : Store_Ring;

   task type Node is
      entry Initialize (Identifier  : in     Ring_Index);
   end Node;

   task body Node is
      ID    : Ring_Index;
      Token : Integer;
   begin
      accept Initialize (Identifier  : in     Ring_Index) do
         ID := Identifier;
      end Initialize;

      loop
         Stores (ID).Take (Token);

         if Token = 0 then
            Ring_Text_IO.Put (ID, Width => 0);
            Ada.Text_IO.New_Line;
         end if;

         Stores (ID + 1).Put (Token - 1);

         exit when Token < 0;
      end loop;
   end Node;

   type Node_Ring is array (Ring_Index) of Node;
   Nodes : Node_Ring;
begin
   for ID in Nodes'Range loop
      Nodes (ID).Initialize (Identifier => ID);
   end loop;

   Stores (1).Put (Integer'Value (Ada.Command_Line.Argument (1)));
end ThreadRing;
-- The Computer Language Benchmarks Game
-- http://shootout.alioth.debian.org/
-- Contributed by Francois Fabien on April 24, 2011.
--  (modified from Jacob Sparre Andersen).
-- Compile with:
--    gnatmake -gnatEpVn -O3 threadring.adb
--
pragma Restrictions (No_Abort_Statements);
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);

with Ada.Text_IO, Ada.Command_Line;

procedure Threadring is
   Ring_Size : constant := 503;
   type Ring_Index is mod Ring_Size;

   package Ring_Text_IO is new Ada.Text_IO.Modular_IO (Ring_Index);

   task type Node is
      entry Initialize (Identifier : in Ring_Index);
      entry Take (Token : in Integer);
   end Node;

   type Node_Ring is array (Ring_Index) of Node;
   Nodes : Node_Ring;

   task body Node is
      ID          : Ring_Index;
      Local_Token : Integer;
   begin
      accept Initialize (Identifier : in Ring_Index) do
         ID := Identifier;
      end Initialize;

      loop
         accept Take (Token : in Integer) do
            Local_Token := Token;
         end Take;
         Local_Token := Local_Token - 1;
         Nodes (ID + 1).Take (Local_Token);
         exit when Local_Token < 0;
      end loop;

      if Local_Token = -1 then
         Ring_Text_IO.Put (ID, Width => 0);
         Ada.Text_IO.New_Line;
      end if;
   end Node;

begin
   for ID in Nodes'Range loop
      Nodes (ID).Initialize (Identifier => ID);
   end loop;
   Nodes (1).Take (Natural'Value (Ada.Command_Line.Argument (1)));
end Threadring;
-- $Id: wc.gnat,v 1.4 2005-03-30 13:56:16 obry-guest Exp $
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Marius Amado Alves
-- Fixed by Pascal Obry on 2005/03/30
--
-- gnatmake -O3 cw.adb

with Ada.Characters.Handling;  use Ada.Characters.Handling;
with Ada.Characters.Latin_1;   use Ada.Characters.Latin_1;
with Ada.Command_Line;         use Ada.Command_Line;
with Ada.Streams;              use Ada.Streams;
with Ada.Streams.Stream_IO;    use Ada.Streams.Stream_IO;
with Ada.Strings.Fixed;
with Ada.Text_IO;              use Ada.Text_IO;
with Ada.Text_IO.Text_Streams; use Ada.Text_IO.Text_Streams;

procedure wc is

   Input_Stream : constant Text_Streams.Stream_Access :=
     Stream (Current_Input);
   EOL          : constant Stream_Element := Character'Pos (LF);
   Is_Separator : constant array (Stream_Element) of Boolean :=
     (0 .. 32 | 127 .. 159 => True, others => False);

   In_Word : Boolean := False;
   Buffer  : Stream_Element_Array (1 .. 4_096);
   N       : Stream_Element_Offset;

   Lines   : Natural := 0;
   Words   : Natural := 0;
   Total   : Natural := 0;

   procedure Begin_Word is
   begin
      Words := Words + 1;
      In_Word := True;
   end Begin_Word;

   procedure End_Word is
   begin
      In_Word := False;
   end End_Word;

   procedure End_Line is
   begin
      Lines := Lines + 1;
      End_Word;
   end End_Line;

   procedure Count_Words (S : in Stream_Element_Array) is
   begin
      Total := Total + S'Length;
      for I in S'Range loop
         if S (I) = EOL then
            End_Line;
         else
            if Is_Separator (S (I)) then
               if In_Word then
                  End_Word;
               end if;
            else
               if not In_Word then
                  Begin_Word;
               end if;
            end if;
         end if;
      end loop;
   end Count_Words;

   pragma Inline (Begin_Word, End_Word, End_Line, Count_Words);

begin
   loop
      Read (Root_Stream_Type'Class (Input_Stream.all), Buffer, N);
      Count_Words (Buffer (1 .. N));
      exit when N < Buffer'Length;
   end loop;

   declare
      Result : constant String :=
        Natural'Image (Lines) & Natural'Image (Words) & Natural'Image (Total);
   begin
      Ada.Text_IO.Put_Line (Result (Result'First + 1 .. Result'Last));
   end;
end wc;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Marius Amado Alves
--
-- gnatmake -O3 -gnatp word_frequency.adb

with Ada.Streams;
with Ada.Streams.Stream_IO;
with Ada.Text_IO;
with Ada.Text_IO.Text_Streams;

procedure WordFreq is

    use Ada.Streams;

    Buffer : Stream_Element_Array (1 .. 4096);
    Input_Stream : Ada.Text_IO.Text_Streams.Stream_Access
      := Ada.Text_IO.Text_Streams.Stream (Ada.Text_IO.Current_Input);
    N : Stream_Element_Offset;
    Is_Separator : array (Stream_Element) of Boolean :=
      (Character'Pos ('A') .. Character'Pos ('Z') |
       Character'Pos ('a') .. Character'Pos ('z') => False,
       others => True);

    -- N-ary tree of word counts
    -- used to increment the counts in one pass of the input file
    -- branches on the letter
    -- carries the count
    -- very fast
    -- but very space consuming

    subtype Letter is Stream_Element range
       Character'Pos ('a') .. Character'Pos ('z');
    type Word is array (Positive range <>) of Letter;
    type Tree;
    type Tree_Ptr is access Tree;
    type Node is
       record
          Count : Natural := 0;
          Subtree : Tree_Ptr := null;
       end record;
    type Tree is array (Letter) of Node;

    procedure Inc (X : in out Integer) is begin X := X + 1; end;
    procedure Dec (X : in out Integer) is begin X := X - 1; end;
    pragma Inline (Inc, Dec);

    procedure Inc_Word (Parent : Tree_Ptr; Descendents : Word) is
    begin
       if Descendents'Length > 0 then
          declare
             Child_Index : Positive := Descendents'First;
             Child : Letter renames Descendents (Child_Index);
          begin
             if Descendents'Length = 1 then
                Inc (Parent (Child).Count);
             else
                if Parent (Child).Subtree = null then
                   Parent (Child).Subtree := new Tree;
                end if;
                Inc_Word
                  (Parent (Child).Subtree,
                   Descendents (Child_Index + 1 .. Descendents'Last));
             end if;
          end;
       end if;
    end;

    -- Binary tree of word counts
    -- used for sorting the result by the count (frequency)
    -- branches on the word count
    -- carries the word form

    type Form_Ptr is access Word;
    type Binary_Tree;
    type Binary_Tree_Ptr is access Binary_Tree;
    type Binary_Tree is
       record
          Form : Form_Ptr;
          Count : Natural;
          Left, Right : Binary_Tree_Ptr;
       end record;

    procedure Add_Node (Parent : in out Binary_Tree_Ptr; 
                        Form : Form_Ptr; Count : Natural) is
    begin
       if Parent = null then
          Parent := new Binary_Tree;
          Parent.Form := Form;
          Parent.Count := Count;
       else
          if Count < Parent.Count then
             Add_Node (Parent.Left, Form, Count);
          else
             Add_Node (Parent.Right, Form, Count);
          end if;
       end if;
    end;

    -- end of binary tree primitives

    Root : Tree_Ptr := new Tree;
    Btree : Binary_Tree_Ptr := null;
    Current_Word : Word (1 .. 1000);
    Current_Word_Length : Natural range 0 .. Current_Word'Last := 0;
    In_Word : Boolean := False;

    procedure Append_To_Word (E : Letter) is
    begin
       Inc (Current_Word_Length);
       Current_Word (Current_Word_Length) := E;
       In_Word := True;
    end;

    procedure End_Word is
    begin
       if Current_Word_Length > 0 then
          Inc_Word (Root, Current_Word (1 .. Current_Word_Length));
       end if;
       Current_Word_Length := 0;
       In_Word := False;
    end;

    To_Lower : array (Stream_Element) of Letter;

    procedure Initialise_To_Lower_Map is
       D : Integer := Character'Pos ('a') - Character'Pos ('A');
    begin
       for I in Character'Pos ('a') .. Character'Pos ('z') loop
          To_Lower (Stream_Element (I)) := Letter (I);
          To_Lower (Stream_Element (I - D)) := Letter (I);
       end loop;
    end;

    procedure Process (S : Stream_Element_Array) is
    begin
       for I in S'Range loop
          if Is_Separator (S (I)) then
             if In_Word then End_Word; end if;
          else
             Append_To_Word (To_Lower (S (I)));
          end if;
       end loop;
    end;

    pragma Inline (Append_To_Word, End_Word, Process);

    procedure Populate_Btree (Ntree : Tree_Ptr) is
    begin
       Inc (Current_Word_Length);
       for I in Letter'Range loop
          Current_Word (Current_Word_Length) := I;
          if Ntree (I).Count > 0 then
             Add_Node
                (Btree,
                 Form => new Word'(Current_Word (1 .. Current_Word_Length)),
                 Count => Ntree (I).Count);
          end if;
          if Ntree (I).Subtree /= null then
             Populate_Btree (Ntree (I).Subtree);
          end if;
       end loop;
       Dec (Current_Word_Length);
    end;

    procedure Populate_Btree is
    begin
       Current_Word_Length := 0;
       Populate_Btree (Root);
    end;

    function To_String (X : Form_Ptr) return String is
       S : String (X'Range);
    begin
       for I in X'Range loop
          S (I) := Character'Val (X (I));
       end loop;
       return S;
    end;

    subtype String7 is String (1 .. 7);

    function Img7 (X : Natural) return String7 is
       S : String := Natural'Image (X);
    begin
       return String' (1 .. 8 - S'Length => ' ') & S (2 .. S'Last);
    end;

    pragma Inline (To_String, Img7);

    procedure Dump_Btree (X : Binary_Tree_Ptr := Btree) is
    begin
       if X /= null then
          Dump_Btree (X.Right);
          Ada.Text_IO.Put_Line
            (Img7 (X.Count) & " " & To_String (X.Form));
          Dump_Btree (X.Left);
       end if;
    end;

begin
    Initialise_To_Lower_Map;
    loop
       Read (Root_Stream_Type'Class (Input_Stream.all), Buffer, N);
       Process (Buffer (1 .. N));
       exit when N < Buffer'Length;
    end loop;
    if In_Word then End_Word; end if;
    Populate_Btree;
    Dump_Btree;
end;
